<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pwn.college(1)</title>
    <link href="/posts/9b840b21.html"/>
    <url>/posts/9b840b21.html</url>
    
    <content type="html"><![CDATA[<h1 id="program-interaction"><a class="markdownIt-Anchor" href="#program-interaction"></a> Program Interaction</h1><h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2><blockquote><p>环境变量的设置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> yqxjyb=isdvinxiir<br>./challenge/embryoio_level4<br></code></pre></td></tr></table></figure><h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2><blockquote><p>一开始没搞懂，后来知道是重定向到文件的stdin，而不是0</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> yorlicln &gt; /tmp/tlvzpz<br>./challenge/embryoio_level5 &lt; /tmp/tlvzpz<br></code></pre></td></tr></table></figure><h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2><blockquote><p>主要是不知道环境变量的设置问题</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提示</span><br>- the challenge checks <span class="hljs-keyword">for</span> a specific parent process : bash<br>- the challenge will check that the environment is empty (except LC_CTYPE, <span class="hljs-built_in">which</span> is impossible to get rid of <span class="hljs-keyword">in</span> some cases)<br><span class="hljs-comment"># 这就是要求运行时环境变量为空，而env -i 中env用于运行命令时设置环境变量的命令，-i表示在执行命令时忽略当前环境中的所有环境变量</span><br><br><span class="hljs-comment"># 做法</span><br><span class="hljs-built_in">env</span> -i /challenge/embryoio_level7<br></code></pre></td></tr></table></figure><h2 id="level-11"><a class="markdownIt-Anchor" href="#level-11"></a> level 11</h2><blockquote><p>使用bash运行tmp.sh程序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ugdygr=ybezdhyzoq<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/challenge/embryoio_level11 ugdygr&#x27;</span> &gt; tmp.sh<br>bash tmp.sh<br></code></pre></td></tr></table></figure><h2 id="level-15"><a class="markdownIt-Anchor" href="#level-15"></a> level 15</h2><blockquote><p>使用ipython来执行特定的语句</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipython<br>import subprocess<br>subprocess.Popen(<span class="hljs-string">&quot;/challenge/embryoio_level15&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="program-misuse"><a class="markdownIt-Anchor" href="#program-misuse"></a> Program Misuse</h1><h2 id="level-11-2"><a class="markdownIt-Anchor" href="#level-11-2"></a> level 11</h2><ul><li><code>od -w100 -c /flag | sed ‘s# ##g’</code><ul><li>这里的 <code>-w100</code> ****指每行显示100个字节，<code>-c</code> 以字符形式显示sed工具可以进行文本替换，<code>s</code> 表示替换，<code>#</code> 是分隔符，<code>##</code> 表示要替换的内容为空字符串，<code>g</code> 表示全局替换，即一行中的所有匹配都替换。</li><li>这里注意管道符的作用，它将前面的输出作为后面的输出，进行更改之后再向shell中输出</li></ul></li></ul><h2 id="level-12"><a class="markdownIt-Anchor" href="#level-12"></a> level 12</h2><ul><li><p><code>hexdump -C /flag | awk -F &quot;|&quot; '&#123;print $2&#125;' | xargs | sed &quot;s# ##g&quot;</code></p><ul><li><code>awk -F &quot;|&quot; '&#123;print $2&#125;'</code> ，awk用于处理上一个语句的输出，使用 <code>“|”</code> 作为字段分隔符，并打印第二个字段，这里就是按照 | 把每行分成了3份。这里就是把两个 | 中的语句提取出来打印</li><li><code>xargs</code> 构建并执行来自标准输入的命令行，就是从标准输入中得到数据。这里就是获取<code>awk</code> 的数据，将其作为参数传递给下一个命令 —&gt; <a href="https://www.notion.so/Linux-5f53968518a54ccbb605d10a1b177e3a?pvs=21">注意它与管道符的区别</a></li><li><code>sed &quot;s# ##g&quot;</code> 全局替换空格为无，这里首先使用 <code>xargs</code> 把内容输入到 <code>sed</code> 中，之后再进行处理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-12:/challenge$ hexdump -C /flag <br>00000000  70 77 6e 2e 63 6f 6c 6c  65 67 65 7b 63 44 64 55  |pwn.college&#123;cDdU|<br>00000010  48 34 43 66 4d 76 4a 6a  45 44 5a 6f 55 32 79 56  |H4CfMvJjEDZoU2yV|<br>00000020  61 41 5a 6d 6c 37 57 2e  30 46 4e 31 45 44 4c 30  |aAZml7W.0FN1EDL0|<br>00000030  63 44 4d 7a 51 7a 57 7d  0a                       |cDMzQzW&#125;.|<br>00000039<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> <br>pwn.college&#123;cDdU<br>H4CfMvJjEDZoU2yV<br>aAZml7W.0FN1EDL0<br>cDMzQzW&#125;.<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs | sed <span class="hljs-string">&quot;s# ##g&quot;</span><br>pwn.college&#123;cDdUH4CfMvJjEDZoU2yVaAZml7W.0FN1EDL0cDMzQzW&#125;.<br></code></pre></td></tr></table></figure></li></ul><h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2><ul><li><p><code>echo $(xxd -p /flag) | xxd -r -p</code> —&gt; <code>xxd -p /flag | xxd -r -p</code></p><ul><li>使用<code>xxd -p /flag</code>生成连续的十六进制输出。<code>xxd</code>是一个将二进制文件转换为十六进制表示的工具，<code>-p</code>选项使其生成连续的十六进制输出</li><li>使用<code>echo</code>将输出传递给下一个命令。这里<code>echo $&#123; &#125;</code>da会先处理 <code>&#123; &#125;</code>，并将其结果输出出来 。</li><li>使用<code>xxd -r -p</code>将十六进制转换为ASCII。<code>xxd -r -p</code>会将十六进制字符串转换回原始的二进制数据。这里的二进制数据实际上只包含了ASCII字符的字节，那么转化后就会得到ascii字符</li><li>之后进行实验，不适用 <code>echo</code> 也可以</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-13:/challenge$ xxd /flag<br>00000000: 7077 6e2e 636f 6c6c 6567 657b 7761 6f39  pwn.college&#123;wao9<br>00000010: 4d74 386a 6d36 7342 6c30 7644 4338 7672  Mt8jm6sBl0vDC8vr<br>00000020: 6374 4a49 4a6f 332e 3056 4e31 4544 4c30  ctJIJo3.0VN1EDL0<br>00000030: 6344 4d7a 517a 577d 0a                   cDMzQzW&#125;.<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338<br>767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag)<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338 767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag) | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="level-19"><a class="markdownIt-Anchor" href="#level-19"></a> level 19</h2><ul><li><code>zip tmp.zip /flag; unzip -p tmp.zip</code><ul><li><code>zip tmp.zip /flag</code> 将 <code>/flag</code> 压缩到 <code>tmp.zip</code> 文件中</li><li><code>unzip -p tmp.zip</code> 解压缩并标准输出</li></ul></li></ul><h2 id="level-20"><a class="markdownIt-Anchor" href="#level-20"></a> level 20</h2><ul><li><code>tar xf /flag -I '/bin/sh -c &quot;cat 1&gt;&amp;2&quot;'</code></li><li>或者 <code>tar cf  flag.tar /flag; tar -Oxf /flag.tar</code></li></ul><h1 id="linux补充"><a class="markdownIt-Anchor" href="#linux补充"></a> Linux补充</h1><h2 id="网站"><a class="markdownIt-Anchor" href="#网站"></a> 网站</h2><ul><li><a href="https://gtfobins.github.io/">GTFOBins</a> -&gt; GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.</li></ul><h2 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> sed</h2><blockquote><p>用于替换语句</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed <span class="hljs-string">&#x27;s/old_pattern/new_text/g&#x27;</span><br><span class="hljs-comment"># 将old替换为new，/g表示为全局</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>白盒AES</title>
    <link href="/posts/7dd931db.html"/>
    <url>/posts/7dd931db.html</url>
    
    <content type="html"><![CDATA[<h1 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析</h1><h1 id="例题分析"><a class="markdownIt-Anchor" href="#例题分析"></a> 例题分析</h1><h2 id="2023巅峰极客"><a class="markdownIt-Anchor" href="#2023巅峰极客"></a> 2023巅峰极客</h2><p>| m1_read</p><h2 id="2023强网杯"><a class="markdownIt-Anchor" href="#2023强网杯"></a> 2023强网杯</h2><p>| dotdot</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android简单逆向</title>
    <link href="/posts/71cb8802.html"/>
    <url>/posts/71cb8802.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>跟随视频进行学习</p><p>参考教程</p><p><a href="https://space.bilibili.com/27577421/channel/collectiondetail?sid=1105137">安卓反调试frida检测Neo</a></p><p><a href="https://blog.csdn.net/m0_54352040/article/details/115734161">【精选】Frida 使用教程和错误汇总_frida 教程-CSDN博客</a></p><p><a href="https://www.52pojie.cn/thread-1128884-1-1.html">frida入门总结 - 『移动安全区』 - 吾爱破解</a></p></blockquote><h1 id="android相关"><a class="markdownIt-Anchor" href="#android相关"></a> Android相关</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MDcyNjA3Mg==&amp;mid=2247484102&amp;idx=1&amp;sn=a82b69ca30ad86ce94e1df778a23e63f&amp;chksm=ea640e91dd138787d25fce2d4b356a213b856f35fd46db3a779f36702fd3ab937a7af7976b23&amp;mpshare=1&amp;scene=23&amp;srcid=0113tIPSLLYqhvffrFmR87oj&amp;sharer_shareinfo=8f360e91069202b191849c480dd5bc49&amp;sharer_shareinfo_first=8f360e91069202b191849c480dd5bc49#rd">frida学习</a></p><h2 id="源码查看"><a class="markdownIt-Anchor" href="#源码查看"></a> 源码查看</h2><ul><li><a href="http://androidxref.com/">http://androidxref.com/</a></li></ul><h2 id="手机信息查看"><a class="markdownIt-Anchor" href="#手机信息查看"></a> 手机信息查看</h2><ul><li>手机信息 -&gt; 决定使用什么版本的server<ul><li>adb shell中 <code>cat /proc/cpuinfo</code> 查看手机架构</li><li>adb shell中 <code>getprop ro.product.cpu.abi</code> 查看cpu处理器位数</li></ul></li></ul><h2 id="查看包名"><a class="markdownIt-Anchor" href="#查看包名"></a> 查看包名</h2><ul><li><p>adb shell</p><ol><li><p><code>dumpsys activity top | grep TASK</code></p></li><li><p><code>am monitor</code></p></li><li><p><code>pm path 包名</code> 寻找包名所在文件的目录</p></li></ol></li><li><p>打开apk, 寻找<code>资源文件-&gt;AndroidManifest.xml-&gt;package=&quot;包名&quot;</code></p></li></ul><h2 id="查看apk的安装目录"><a class="markdownIt-Anchor" href="#查看apk的安装目录"></a> 查看apk的安装目录</h2><ul><li><code>pm path cn.pojie52.cm01(包名)</code></li><li><code>cat /proc/pid/maps | grep /data</code><ul><li>查看包含 /data 的虚拟内存区域的详细信息，即查看包含/data名称的进程的相关信息，这里就是找到对应虚拟内存区域中的所有文件</li></ul></li></ul><h2 id="查看进程信息"><a class="markdownIt-Anchor" href="#查看进程信息"></a> 查看进程信息</h2><ul><li><code>ps -ef | grep (包的信息)</code></li></ul><h2 id="frida-运行"><a class="markdownIt-Anchor" href="#frida-运行"></a> frida 运行</h2><ul><li>在电脑端查看Android的frida是否运行<ul><li><code>frida-ps -U | grep frida</code> 或者 <code>frida-ps -R</code>，<code>-U</code>为usb</li><li><code>frida-ps -U | findstr frida</code> -&gt; windows cmd使用</li></ul></li><li>在电脑端查看正在运行的 frida 程序<ul><li><code>frida-ps -U | findstr frida</code></li></ul></li><li>在手机查看 frida 的监听端口<ul><li><code>netstat -tunlp</code></li></ul></li></ul><h1 id="ida-调试-apk"><a class="markdownIt-Anchor" href="#ida-调试-apk"></a> IDA 调试 apk</h1><h2 id="ida找不到so的情况"><a class="markdownIt-Anchor" href="#ida找不到so的情况"></a> ida找不到so的情况</h2><ul><li>因为APK设置了该属性<code>android:extractNativeLibs=&quot;false&quot;</code>，所有在apk的安装目录中不显示so文件，这个时候可以直接将 <strong>base.apk</strong> 作为so文件进行处理</li></ul><h2 id="attach模式"><a class="markdownIt-Anchor" href="#attach模式"></a> attach模式</h2><ol><li>注意端口转发 <code>adb forward tcp:23946 tcp:23946</code></li><li>找到base.apk的基址-&gt;这里可以直接从IDA的线程目录中获取，。例如<br /><code>/data/app/~~UbqwoOpDOTfYTfwZ1Ty9pA==/cn.pojie52.cm01-Fu70kSLImy0Ji7ekdGzWFQ==/base.apk00000076282C600000000002CB5FA000</code></li><li>修改静态分析的基址，方便我们查找函数的偏移</li></ol><h2 id="spawn模式"><a class="markdownIt-Anchor" href="#spawn模式"></a> spawn模式</h2><h2 id="安卓高版本android10及以上与低版本的差异"><a class="markdownIt-Anchor" href="#安卓高版本android10及以上与低版本的差异"></a> 安卓高版本（android10及以上）与低版本的差异</h2><ul><li>高版本因为libc.so的路径改变了，所以显示不出所有的线程。<code>IDA_LIBC_PATH=/apex/com.android.runtime/lib64/bionic/libc.so ./android_server64</code> 启动服务可以完整显示</li></ul><h1 id="frida"><a class="markdownIt-Anchor" href="#frida"></a> frida</h1><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><h3 id="attach模式-2"><a class="markdownIt-Anchor" href="#attach模式-2"></a> attach模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">frida -UF<br>frida -U -n 设置(进程名 frida-ps -U)<br>frida -U -N com.android.settings<br></code></pre></td></tr></table></figure><h3 id="spawn模式-2"><a class="markdownIt-Anchor" href="#spawn模式-2"></a> spawn模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">frida -U -f com.android.settings --no-pause(后面--no……高版本不写)<br></code></pre></td></tr></table></figure><h3 id="frida-server"><a class="markdownIt-Anchor" href="#frida-server"></a> frida-server</h3><ul><li>frida-server的使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/local/tmp<br>chmod 777 *<br>./frida-server-16.0.8-android-arm64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">防止反调试，切换端口监听(默认端口为27042)</span><br>./frida-server-16.0.8-android-arm64 -l 0.0.0.0:1314<br></code></pre></td></tr></table></figure><h2 id="frida-hook"><a class="markdownIt-Anchor" href="#frida-hook"></a> frida hook</h2><h3 id="动态注册"><a class="markdownIt-Anchor" href="#动态注册"></a> 动态注册</h3><h4 id="详情"><a class="markdownIt-Anchor" href="#详情"></a> 详情</h4><p><a href="https://blog.csdn.net/lyz_zyx/article/details/88690930">Android中JNI&amp;NDK入门(三) 之 动态注册Native函数</a></p><h4 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readStdString</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> isTiny = (str.<span class="hljs-title function_">readU8</span>() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (isTiny) &#123;<br>        <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">readUtf8String</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span> * <span class="hljs-title class_">Process</span>.<span class="hljs-property">pointerSize</span>).<span class="hljs-title function_">readPointer</span>().<span class="hljs-title function_">readUtf8String</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callPrettyMethod</span>(<span class="hljs-params">ArtMethodptr</span>) &#123;<br>    <span class="hljs-comment">// _ZN3art9ArtMethod12PrettyMethodEPS0_b</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">PrettyMethod</span>_addr =  <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, <span class="hljs-string">&quot;_ZN3art9ArtMethod12PrettyMethodEPS0_b&quot;</span>);<br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">PrettyMethodfunc</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(<span class="hljs-title class_">PrettyMethod</span>_addr, [<span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>], [<span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;int&quot;</span>]);<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">PrettyMethodfunc</span>(<span class="hljs-title class_">ArtMethodptr</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">var</span> stdstring = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">3</span> * <span class="hljs-title class_">Process</span>.<span class="hljs-property">pointerSize</span>);<br>    <span class="hljs-title function_">ptr</span>(stdstring).<span class="hljs-title function_">writePointer</span>(result[<span class="hljs-number">0</span>]);<br>    <span class="hljs-title function_">ptr</span>(stdstring).<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span> * <span class="hljs-title class_">Process</span>.<span class="hljs-property">pointerSize</span>).<span class="hljs-title function_">writePointer</span>(result[<span class="hljs-number">1</span>]);<br>    <span class="hljs-title function_">ptr</span>(stdstring).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span> * <span class="hljs-title class_">Process</span>.<span class="hljs-property">pointerSize</span>).<span class="hljs-title function_">writePointer</span>(result[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-title function_">readStdString</span>(stdstring)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook_RegisterNativeMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">RegisterNativeMethod</span>_addr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, <span class="hljs-string">&quot;_ZN3art16RuntimeCallbacks20RegisterNativeMethodEPNS_9ArtMethodEPKvPPv&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;RegisterNativeMethod_addr=&quot;</span>,<span class="hljs-title class_">RegisterNativeMethod</span>_addr)<br>    <span class="hljs-comment">// art::RuntimeCallbacks::RegisterNativeMethod(art::ArtMethod*, void const*, void**)</span><br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">RegisterNativeMethod</span>_addr, &#123;<br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">artmethod</span> = args[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">var</span> methodname = <span class="hljs-title function_">callPrettyMethod</span>(<span class="hljs-title function_">ptr</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">artmethod</span>));<br>            <span class="hljs-keyword">var</span> address = args[<span class="hljs-number">2</span>];<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dex_method_index_</span> = <span class="hljs-title function_">ptr</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">artmethod</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">12</span>).<span class="hljs-title function_">readU32</span>();<br>            <span class="hljs-keyword">var</span> current_module = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">getModuleByAddress</span>(address)<br>            <span class="hljs-keyword">var</span> modulename = current_module.<span class="hljs-property">name</span><br>            <span class="hljs-keyword">var</span> base = current_module.<span class="hljs-property">base</span><br>            <span class="hljs-keyword">var</span> offset = address.<span class="hljs-title function_">sub</span>(base)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;go into RegisterNativeMethod ---&quot;</span> + <span class="hljs-string">&quot;artmethodptr:&quot;</span> + <span class="hljs-title function_">ptr</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">artmethod</span>) + <span class="hljs-string">&quot;---methodidx:&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dex_method_index_</span> + <span class="hljs-string">&quot;--addr:&quot;</span> + address + <span class="hljs-string">&quot;----name:&quot;</span> + methodname + <span class="hljs-string">&quot;---modulename:&quot;</span> + modulename + <span class="hljs-string">&quot;---offset:&quot;</span> + offset);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;, <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">retval</span>) &#123;<br>        &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(hook_RegisterNativeMethod)<br><span class="hljs-comment">// frida -U -f com.wolf.ndktest -l hook_RegisterNativeMethod.js --no-pause -o out.log</span><br><span class="hljs-comment">// frida -U -f com.wolf.ndktest -l hook_RegisterNativeMethod.js  -o out.log</span><br></code></pre></td></tr></table></figure><h3 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> hook</h3><h4 id="java-hook"><a class="markdownIt-Anchor" href="#java-hook"></a> java hook</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;java.lang.String&quot;</span>).<span class="hljs-property">equals</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)&#123;<br>        <span class="hljs-keyword">var</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">equals</span>(str)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;str = &quot;</span>+str);<br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(hook)<br></code></pre></td></tr></table></figure><h4 id="native-hook"><a class="markdownIt-Anchor" href="#native-hook"></a> native hook</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 1. 拿到目标so的基址--base=0x77bbc412f0</span><br>    <span class="hljs-comment">// https://frida.re/docs/javascript-api/</span><br>    <span class="hljs-keyword">var</span> base = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;libwolf.so&quot;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;base = &quot;</span>, base)<br>    <span class="hljs-comment">// 2. 由于该so是arm架构，所以偏移要加1</span><br>    <span class="hljs-keyword">var</span> bc = base.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x14074</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">0x1</span>)<br>    <span class="hljs-comment">// 3. 获取函数的输入参数，输出返回值</span><br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(bc, &#123; <br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;enter bc&quot;</span>)<br>        &#125;,<br>        <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">retval</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level bc&quot;</span>)<br>        &#125;<br>    &#125;)<br><span class="hljs-title function_">setImmediate</span>(hook)<br><span class="hljs-comment">// frida -UF -l hook.js -o out2.log</span><br></code></pre></td></tr></table></figure><h4 id="inline-hook"><a class="markdownIt-Anchor" href="#inline-hook"></a> inline hook</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> inline_B34 = base.<span class="hljs-title function_">add</span>(<span class="hljs-number">0xB34</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">0x0</span>)<br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(inline_B34,&#123;<br>        <span class="hljs-attr">onEnter</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;<br>        <span class="hljs-comment">// 这里通过this.context.寄存器得到寄存器的值</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;called enter inline_B34  = &quot;</span> +<span class="hljs-title function_">hexdump</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">x0</span>))<br>        &#125;,<br>        <span class="hljs-attr">onLeave</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>心得体会</title>
    <link href="/posts/cf26faba.html"/>
    <url>/posts/cf26faba.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8eaae180fc530a0e8398cc35a2f803389521ad79e60fe1718db5b6587bc049ec">b61ac2957fe6e5696172d47e7b49d1ddbbc6337abdf627161c76f9507780f653d1a054b52b984b0a9be7cb35b6554b7c631ea1d34498e1b5c077c6c73bd69540e7493aaef9f4bdbac83242efbe7dd809a9967772cc9b7e9ed69d017236cf9019a5d69bb0c0c0c92c9ede89a04f3b3b7a586624c03a6cd5bd78eee6fe26abcedbf3151d4d2a087c42e4837e94026c5cff3de16c0bb66720d242c49e7429ec92ea6b0fae7f3712c69fd2b9f30ffbcabf6b163edbe0b064394c910b655f6f4d889e589ccc64206897879695abade2a0dd1464ee3d8a652e9c9e8f13501c6129e0b6a6e198a368d10d8453ad031d929d4caec0ef6ed24bdee269137c66a836a7e14e3fa0e50330237260d4f1b9aa4b3a3ba2d7dcc28fb479bd232439dddb9e9819ea6b1b0ddcd2b5b1e4323518e2ffc3956f493d31439f5b89dc24c494939f2489b177bc278b1cf9d011ebd7083ce299ff538343ae9b7be2ad2a0c99bd97867891699393ae686858005b83e66f335a51242df4337cd76413c32de066418b389894dec5d0d82e1a388743cb4e21e29b76e8d0e496e3a29249c8eaddda85d8648bc8f36881deeb7f52455af68ff99bad5651900f92bb7084d6049a8d769413a0eb5dca8e39aba51a69e984d05c44ab7b368236e7a885e3d857455b7085a1932751e016022ccd893cfd5659108867e5afe60598aef70a0d530ef5f71dbf90ad1d4c2dea2701a0a66adf714aa8860f1954b82e34935fcbba63418558d5401b013e0d61132b1ea67876e5fe62173f8b2a1be442501089a8a366165e5f7f14a83fadc27dab8bfa81c5fe7ae7618584f779d018a518f886e2b11c5c795eb9f269fe48277b33c81d24d76d851366e1959b7ea2ddf950665e55af017a563c54f010c9e265855ab56473e172bd5f12c257e42aa4e8a539d26e9cc22b52b9945a2eba7e19f9bc9b426fb3b3120d6ea71518e329f9cda397e4c3c7c7a08ce0964885070b499a913f7325e32a52111d36443ff1019b9810e4decd3a4364cead18e0f83b5be16b954bbcbbbfe083190b522beaeaf3583147120317114e7e506cc17d6d2f1771d041e0dd04c7e9aa709d757769b5d653ebc6d8bcdf860b4acfd9a4c5f6a72bf2f2a1045270983bd7f1bea4799849cb7b97b83f8c817f810f483dc7076bd13652478cb5c29ba5e1c06a68e38a0649a9aede794a51ca1eaadfb7babafae7148581982d8b8310fd4e9ede179e57ea77419683799d7b2852129e3d7f93196c3aefa5d2ec4ccaea857a6bb0e8ce9053512500806a3e422a5b82a640bf94c5ff7a71119d5687aa8ab78b2252e5763e38699cd0cd9c8215634acdedbb4b64add39792ed3c9f2c743361498ae2940b4bdd08cec3bc8bfc89b2fc87bb4bfb4fcfcfd8923d56b540aacd617d6f33246a9726924a468e70dc69c94f47073f974ed31e1eb7684f381f54f9ee7f54fea49c91914fc04a1f7942bcac6baa627dfccc7154982bdcd8a4e677b445915d89bbbc034edc41c9ddfba7703c6f0f834bf4d4387c65e60946ddfe4dae5cdf68922da5b12729764178428de0e74415620a9ab526d84b31ed351220cfc67ed4172772cd6efb5ba508120c2ea53ddc755945a59753c5789c509327d975da7c5a44c35c7c53c3e8506da8713facc652dccab05c81df3a1458e8f6423bf6d18f6b9b372506b7fe650bf2bf32eb9417ad885a05746a44e48c7ff06ab1027d8956f617f6823d962d880d4cdceae3ea3e058c9952be7efb7993de5f492a4fa3ca820a40c30ea293a23a7e48f21f2d28ebaef751d6225327a65c84f0fe19847e3db33bb82af7fb069d33a9c59823c5acc0fa1e50112beb9fe6cdce3f210df2e0be743c5df4f1b415d84b74e985ba2908a6c92af3b79898e07ca0a2eda905600d2f98b54628afd33b72987858509f39389b72996137166e35736263c739275cd26b09b74f6b678ecf04b014d6fa32f8a7f8bf9fe3f3f5a97bfe2fe00941ef8e03222306a53fa65ad983f783154409f1f153d5e504d4731598b2d4c40248c3d11af8ad763f54646d0f68dfb6c0c9a5a41250eab678b901d11403fb1409ecaf5bc76a1699bdf0caf6a168b07020fd7d95f01e414665175b6b861aa3794d44a572b395e64e5ac2fb1faaed35396642673a2ae45d56dc2716ad1e8293bddb3a7c5bc85eb0566d2c4db38443f7fddc83916b7c9681767a49c3853ff04992e707931473d0359cfc2587e0912fd9eb0dce6a750fc4bae8acf760a1ff494ef02880e285</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Static Analysis 实验</title>
    <link href="/posts/f88cd8e5.html"/>
    <url>/posts/f88cd8e5.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - …………</code><ol><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="a1"><a class="markdownIt-Anchor" href="#a1"></a> A1</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code><ul><li>这是一个抽象的数据流分析类，是<strong>具体的数据流分析与求解器之间的接口</strong>。一个具体的数据流分析(如活跃变量分析)需要实现它的接口，而求解器(如迭代求解器)需要通过它的接口来求解数据流。</li><li>它是一个 <code>interface</code> , 其中包含 <code>newBoundaryFact</code>,<code>newInitialFact</code>,<code>meetInto</code>,<code>transferNode</code>的实现声名</li><li>包含 <code>&lt;Node&gt;</code>类型, 它表示 CFG 的 BB</li><li>包含 <code>&lt;Fact&gt;</code>类型, 它表示数据流分析中用来描述程序状态的元素, 即有关程序代码的信息或属性。它与Node联系在一起，表示一个{name: information}，即这里的 “facts” 是指分析确定的信息，如在程序某个点活跃的变量集。</li></ul></li><li><code>pascal.taie.analysis.dataflow.analysis.LiveVariableAnalysis</code><ul><li>这个类通过实现 <code>DataflowAnalysis</code> 的接口来定义具体的活跃变量分析。</li><li>LiveVariableAnalysis 继承抽象类 AbstractDataflowAnalysis, AbstractDataflowAnalysis 继承接口 DataflowAnalysis</li></ul></li><li><code>pascal.taie.analysis.dataflow.fact.SetFact&lt;Var&gt;</code><ul><li>这个泛型类用于把 data-flow fact 组织成一个集合。</li></ul></li><li><code>pascal.taie.analysis.dataflow.fact.DataflowResult</code><ul><li>该类对象用于维护数据流分析的 CFG 中的 fact。可以通过它的 API 获取、设置 CFG 节点(BB?)的 <code>IN facts</code> 和 <code>OUT facts</code>, 这也表示fact存储有关 BB 的信息</li></ul></li><li><code>pascal.taie.analysis.graph.cfg.CFG</code><ul><li>这个类用于表示程序中方法的控制流图(control-flow graphs)。</li><li>它是可迭代的，也就是说你可以通过一个 <em>for</em> 循环遍历其中的所有节点。这就意味着它维护了某些方法可以遍历所有的节点(CFG继承的接口Graph中方法 <code>Set&lt;N&gt; getNodes()</code> 可以遍历所有节点)</li></ul></li><li><code>pascal.taie.analysis.dataflow.solver.Solver</code><ul><li>这是数据流分析求解器的基类，包含了求解器的抽象功能。它定义了数据流分析的基本流程和步骤，沿着CFG来对数据进行分析处理，它的具体分析逻辑和迭代算法由它的子类实现提供。</li></ul></li><li><code>pascal.taie.analysis.dataflow.solver.IterativeSolver</code><ul><li>这个类扩展了 <code>Solver</code> 的功能并实现了迭代求解算法。</li></ul></li></ul><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><code>pascal.taie.ir.exp.Exp</code><ul><li>这是 Tai-e 的 IR 中的一个关键接口，用于表示程序中中间语言(IR)的所有表达式。</li></ul></li><li><code>pascal.taie.ir.stmt.Stmt</code><ul><li>这是 Tai-e 的 IR 中的另一个关键接口，它用于表示程序中的所有语句。对于一个典型的程序设计语言来说，<strong>每个表达式都属于某条特定的语句</strong>。这里statement泛指所有的语句，其中至多只可能定义一个变量、而可能使用零或多个变量。</li></ul></li><li>这里注意区分表达式和语句的区别<ul><li>表达式(exp)通常用来计算值，它们可能由常量、变量、操作符（如加减乘除）以及函数调用组合而成。比如算数表达式 <code>a + b</code>, 方法调用 <code>foo()</code></li><li>语句(stmt)是执行的单位，它们执行操作可能会改变程序的状态。包括赋值，控制流决策，循环等，比如赋值语句 <code>x = a + b</code> 包含了赋值操作，和算术表达式 <code>a + b</code></li><li>因此，表达式是构成语句的元素，而语句则用表达式来执行程序中的操作。在数据流分析中，理解一个语句如何使用和定义表达式是至关重要的，因为它影响了变量在程序执行过程中的生命周期和作用域。</li></ul></li></ul><h3 id="流程理解"><a class="markdownIt-Anchor" href="#流程理解"></a> 流程理解</h3><ul><li>对于整个流程，就是使用 <code>DataflowAnalysis</code> 与 <code>Solver</code> 进行交互。<ul><li><code>DataflowAnalysis</code> 对数据流进行处理, 使用子类 LiveVariableAnalysis 对基类的功能进行扩展, 实现了分析流中的初始化, Transfer Function 与 Control Flow 的实现。</li><li><code>Solver</code> 实现了迭代解释器, 它通过子类 lterativeSolver 对基类功能进行实现。之后通过 cfg 表示当前的控制流, 然后使用由 DataflowAnalysis 定义的 analysis 来对 cfg 进行操作。<ul><li>这里 <code>cfg</code> 是对于 Node 进行各项操作, 比如判断是否 Exit, 遍历寻找所有 BB。</li><li>而 <code>analysis</code> 则是包含了所有对于数据流的操作，比如 meetInto, transferNode。</li></ul></li></ul></li></ul><blockquote><p><a href="https://github.com/pascal-lab/Tai-e-assignments/commit/2b21a6dd84d81a56cdffb0c91b575d655d5b1da0">参考代码</a></p></blockquote><h2 id="疑问"><a class="markdownIt-Anchor" href="#疑问"></a> 疑问</h2><ol><li><p>在 <code>Assign.java</code> 中，soot(Tai-e)转化为三地址码时，对于语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b;<br>c = a;<br><span class="hljs-comment">// 这里转化为三地址码，增加了临时变量temp$0</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">temp$0 = a;</span><br><span class="hljs-comment">    d = temp$0 + b;</span><br><span class="hljs-comment">    b = d;</span><br><span class="hljs-comment">    c = a;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>在询问chatgpt时，它给出的答案是这里引入 <code>temp$0</code>并不是为了防止 <code>a</code>被修改，而是为了确保在计算 <code>d</code>的过程中，<code>a</code>的原始值保持不变。这可能是为了在计算过程中确保 <code>a</code>的值不会被无意间或意外地修改，以便获得正确的结果。</li><li>这里我感觉它说的有道理，为了防止潜在的对a进行更改的可能而引入临时变量进行存储(<s>感觉是囿于静态分析sound–&gt;may analysis的性质，可能更改我就提出阻止策略</s>, 但是又感觉不对，静态分析是在IR基础上进行的，这里是生成IR的过程)</li></ul></li></ol><h1 id="a2"><a class="markdownIt-Anchor" href="#a2"></a> A2</h1><h2 id="理解-2"><a class="markdownIt-Anchor" href="#理解-2"></a> 理解</h2><ul><li>这次搞明白代码的实现逻辑，同时跟着指南进行就很清晰地实现代码部分</li><li>在这里 <code>ConstantPropagation</code> 实现的就是数据流的处理, 例如 <code>meetinto</code>, <code>Transfer Function</code>; 而 <code>Solver</code> 和 <code>WorkListSolver</code> 就是实现迭代算法的具体流程。这两个就相当于前面的是函数实现，后面就是利用函数来实现一个流程<ul><li>这里需要注意, <code>meetinto</code> 处理的就是 两个 BB 之间数据的流动交汇情况, 这里指对于多个分支对同一个变量的赋值交汇在同一点的处理; 而 <code>TransferNode</code> 则是对于 BB 内部数据的处理，可以近似看作对于 Statement 的处理。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Static Analysis</title>
    <link href="/posts/4002e7c0.html"/>
    <url>/posts/4002e7c0.html</url>
    
    <content type="html"><![CDATA[<p>This is my curriculum understanding.</p><blockquote><p>Reference:</p><p><a href="https://blog.csdn.net/zhang971105/category_10471447.html">静态分析学习笔记</a></p><p><a href="https://ranger-nju.gitbook.io/static-program-analysis-book/">上课笔记</a></p></blockquote><h1 id="intermediate-representation"><a class="markdownIt-Anchor" href="#intermediate-representation"></a> Intermediate Representation</h1><h2 id="rice定理"><a class="markdownIt-Anchor" href="#rice定理"></a> Rice定理</h2><ul><li>对于使用 <strong>递归可枚举（Recursively Enumerable）</strong> 的语言描述的程序，其任何 <strong>非平凡（Non-trivial）</strong> 的性质都是无法完美确定的。<ul><li>关于递归可枚举，其含义是存在某个计算函数（可以是图灵机），能够将这种语言中的所有合法字符串枚举出来。这个概念有些抽象，不必深究，暂时只需要知道，目前我们所能想到的所有的编程语言都是递归可枚举语言。</li><li>对于编程语言可以这样理解：关于递归可枚举，其含义是存在某个编译器或解释器，能够将这种语言中的所有合法源代码（程序）识别并执行。这个概念有些抽象，不必深究，暂时只需要知道，目前我们所能想到的所有的编程语言都是递归可枚举语言。</li></ul></li></ul><h2 id="compilers-and-static-analyzers"><a class="markdownIt-Anchor" href="#compilers-and-static-analyzers"></a> Compilers and Static Analyzers</h2><p>编译器将源代码(<code>Source code</code>)转换为机器代码(<code>Machine Code</code>)。其中的流程框架如下</p><ul><li>此处也可以去延伸了解一下<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">乔姆斯基体系</a>，包含了0型文法(对应递归可枚举语言，图灵机)、1型文法(对应上下文敏感语言)、2型文法(对应上下文无关语言)和3型文法(正则文法，有限状态机)</li></ul><h3 id="scanner"><a class="markdownIt-Anchor" href="#scanner"></a> Scanner</h3><ul><li><strong>词法分析器</strong>(<code>Scanner扫描器</code>)，结合正则表达式，通过词法分析（<code>Lexical Analysis</code>）将 source code 翻译为 token。<ul><li>这里就是根据语句的不同组成成分进行划分，例如划分出关键词，标识符等(由正则表达式进行匹配)，之后进提取形成一个标记(Token)串</li></ul></li></ul><h3 id="parser"><a class="markdownIt-Anchor" href="#parser"></a> Parser</h3><ul><li><strong>语法分析器</strong>(<code>Parser解析器</code>)，结合上下文无关文法(<code>Context-Free Grammar</code>)，通过语法分析(<code>Syntax Analysis</code>)，将 token 解析为抽象语法树(<code>Abstract Syntax Tree</code>, AST)。<ul><li>解析器内部应该是实现了一个有限状态机，用来识别和分析每个语法格式的正确性—这里解析器实现了token和语法规则的匹配(具体可以联系主谓宾的匹配，存在这种组合既可以通过，而不必考虑这句话的含义是否正确)</li><li>解析为抽象语法树----递归下贱解析器等</li></ul></li></ul><h3 id="type-checker"><a class="markdownIt-Anchor" href="#type-checker"></a> Type Checker</h3><ul><li><strong>语义分析器</strong>(<code>Type Checker类型检查器</code>)，结合属性文法(<code>Attribute Grammar</code>)，通过语义分析(<code>Semantic Analysis</code>)，将 AST 解析为 decorated AST。<ul><li>这里语义分析主要就是对于变量声明和类型检查(例如INT与String进行相加)，作用域分析，类型推断(rust的推断功能)，错误检查等，然后生成一个抽象语法树</li><li>抽象语法树相比于语法树，包含了更多关于源代码语义的信息。普通的语法树主要表示了源代码的结构，但不包含关于标识符、数据类型、作用域等语义信息。</li></ul></li></ul><h3 id="translator"><a class="markdownIt-Anchor" href="#translator"></a> Translator</h3><ul><li><strong>翻译器</strong>(<code>Translator</code>)，会将抽象语法树翻译成中间表示（Intermediate Representation, IR），IR 的出现解耦了编译器的机器相关（Machine Dependent）部分和机器无关（Machine Independent）部分，上述几个层次在不同架构的机器上面是可以几乎不加改动地复用的。Translator，将 decorated AST 翻译为生成<code>三地址码这样的中间表示形式</code>(<code>Intermediate Representation</code>, IR)，并<strong>基于 IR 做静态分析</strong>(例如代码优化这样的工作----下面提及的机器无关方面)。<ul><li><strong>编译器的结构</strong>：编译器通常包括两个主要部分：机器相关部分和机器无关部分。机器相关部分负责将源代码翻译成特定计算机体系结构的机器代码，而机器无关部分负责执行编程语言无关的分析和优化。机器相关部分需要根据不同的目标体系结构进行适应和修改，这可能是复杂且繁琐的工作。</li><li><strong>中间表示（IR）的作用</strong>：引入中间表示的目的是为了将机器相关和机器无关部分解耦。IR 是一种抽象的、与计算机体系结构无关的表示，它在编译器的不同阶段中用作数据结构，将源代码的语义信息转化成一种通用形式。这种中间表示有助于减少编译器的复杂性，使编译器的机器无关部分不需要依赖于特定的硬件体系结构。</li><li><strong>机器相关和机器无关的复用</strong>：由于IR是与硬件体系结构无关的通用表示，机器相关部分只需关注如何将IR翻译成目标机器的机器代码，而无需关心源代码的编程语言细节。这使得机器相关部分在不同的计算机体系结构上能够以几乎不加修改地复用。同时，机器无关部分也不需要知道目标机器的具体细节，因为它操作的是IR而不是直接的机器代码。</li><li>简单理解，在拥有翻译器之前<ul><li><code>机器相关</code>就是负责将中间表示(IR)翻译成目标机器的机器代码，处理与底层硬件相关的细节，以便将源代码转化为可在特定机器上执行的代码。</li><li><code>机器无关</code> 就是负责对中间表示(IR)进行分析和优化。这个部分独立于目标机器的体系结构，它执行编程语言无关的操作，如常量传播、死代码消除、循环优化等。机器无关部分的目标是提高源代码的性能、可读性和可维护性。</li></ul></li></ul></li></ul><h3 id="code-generator"><a class="markdownIt-Anchor" href="#code-generator"></a> Code Generator</h3><ul><li><strong>机器码生成器（Code Generator）</strong> 会将 IR 转化成物理 CPU 能够直接执行的比特序列，这个过程是<strong>机器相关的</strong>。</li></ul><h3 id="summarize"><a class="markdownIt-Anchor" href="#summarize"></a> summarize</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202311060905306.png" alt="image-20231106090527264" /></p><ul><li>这里的<code>e.g</code>为被剔除的语句</li></ul><h2 id="ir-three-address-code3ac"><a class="markdownIt-Anchor" href="#ir-three-address-code3ac"></a> IR: Three-Address Code(3AC)</h2><ul><li>3AC的要求:<ul><li>在一个指令的<code>右边至多</code>只有一个操作符</li><li>每个3AC指令<code>可以至多</code>包含三种地址：变量名(如a、b、c)，常量(如数字3)，编译器生成的临时变量(如t1)</li></ul></li><li>这里使用的是java–&gt;IR Jimple–&gt;有类型的三地址码(typed 3AC)</li><li>这里需要注意一下的是，无论是三地址码还是汇编，其指令类型不取决于具体的语言，而取决于运行这个语言的机器的指令集体系结构(Instruction Set Architecture，ISA)</li></ul><h2 id="static-single-assignment"><a class="markdownIt-Anchor" href="#static-single-assignment"></a> Static Single Assignment</h2><p>所谓静态单赋值（SSA），就是让每次对变量x赋值都重新使用一个新的变量xi，并在后续使用中选择最新的变量。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">  <span class="hljs-number">3</span>AC         <span class="hljs-string">|         SSA</span><br>p = a + b     <span class="hljs-string">|     p1 = a + b</span><br>q = p - c     <span class="hljs-string">|     q1 = p1 - c</span><br>p = q * d     <span class="hljs-string">|     p2 = q1 * d</span><br>q = p + q     <span class="hljs-string">|     q2 = p2 + q1</span><br></code></pre></td></tr></table></figure><h3 id="why-use-ssa"><a class="markdownIt-Anchor" href="#why-use-ssa"></a> why use SSA</h3><ul><li>控制流信息间接地集成到了独特变量名中<ul><li>如果有些对控制流不敏感的简化分析，就可以借助于 SSA</li></ul></li><li>定义与使用是显式的<ul><li>更有效率的数据存取与传播，有些优化在基于 SSA 时效果更好(例如条件常量传播，全局变量编号等)</li></ul></li></ul><h3 id="why-not-use-ssa"><a class="markdownIt-Anchor" href="#why-not-use-ssa"></a> why not use SSA</h3><ul><li>SSA 会引入过多的变量和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> 函数–&gt;面对 SSA 中不同控制流汇入到一个块中,导致多变量备选的问题，使用此合并操作符，根据控制流来确定使用哪个变量</li></ul></li><li>在转换成机器代码时会引入低效率的问题</li></ul><h2 id="basic-blocks-control-flow-graphs"><a class="markdownIt-Anchor" href="#basic-blocks-control-flow-graphs"></a> Basic Blocks &amp; Control Flow Graphs</h2><p>​控制流分析(<code>Control Flow Analysis</code>)通常指的是构建控制流图(<code>Control Flow Graph</code>, CFG)，并以 CFG 作为基础结构进行静态分析的过程。CFG 的一个结点可以是一条单独的 3AC，但是更常见的是一个基本块（Basic Block）。所谓基本块，就是满足以下性质的连续 3AC：</p><ul><li>只能从块的第一条指令进入。</li><li>只能从块的最后一条指令离开</li></ul><h1 id="data-flow-analysis-applications"><a class="markdownIt-Anchor" href="#data-flow-analysis-applications"></a> Data Flow Analysis - Applications</h1><h2 id="data-flow-analysis"><a class="markdownIt-Anchor" href="#data-flow-analysis"></a> Data Flow Analysis</h2><ul><li><p>分析的行为是数据的“流动”，分析的方式是 <strong>安全近似(Safe-Approximation)</strong></p><ul><li>根据安全性需求选择过近似(Over-Approximation)还是欠近似(Under-Approximation)</li></ul></li><li><p><strong>数据流动的场景</strong>有两个：</p><ul><li>在CFG的点(Node)内流动，即程序基块(Basic Block)内部的数据流；</li><li>在CFG的边(Edge)上流动，即由基块间控制流触发的数据流。</li></ul></li><li><p>数据流值</p><ul><li>也称为<strong>抽象数据状态(ADS)</strong>，为程序 P 中所有的数据的抽象值的整体</li><li>称每一个 IR 语句 <em>s</em> 执行之前, <em>pre(s)</em> 执行之后的<strong>数据流值</strong>为 <em>s</em> 的 <strong>输入状态</strong>—&gt;IN[S]</li><li>称每一个 IR 语句 <em>s</em> 执行之后, <em>suc(s)</em> 执行之前的数据流值为 <em>s</em> 的 <strong>输出状态</strong>—&gt;OUT[S]</li></ul></li><li><p>程序点可以用控制流中相邻语句的<strong>顺序二元组</strong>表示。</p><ul><li>每个程序点都对应了一个数据流值(<strong>这个数据流值表征了在这个程序点能够观察到的所有可能的程序状态</strong>)–&gt;这里和后面提及的 bit vector 相联系，这个点可以看到所有可能的程序状态</li><li>每一个不同的(集合具有互异性)数据流值都会有一个或者多个程序点与之对应。</li></ul></li><li><p>数据流分析就是要寻找一种解决方案，对于程序 <em>P</em> 中的所有语句 <em>s</em> ，这种解决方案能够满足 IN[s] 和 O<strong>U</strong>T[s] 所需要满足的 <strong>安全近似导向型约束(Safe-Approximation-Oriented Constraints, SAOC)</strong>，SAOC主要有两种：</p><ul><li>基于语句语意(Sematics of Statements)的约束，即由状态转移方程产生的约束</li><li>基于控制流(Flow of Control)的约束，可能性分析/必然性分析</li></ul></li></ul><h2 id="reaching-definition-analysis"><a class="markdownIt-Anchor" href="#reaching-definition-analysis"></a> Reaching Definition Analysis</h2><h3 id="basic-concept"><a class="markdownIt-Anchor" href="#basic-concept"></a> Basic concept</h3><p>​如果在程序中点p到点q构成一条路径，在点p处的<strong>定义d</strong>在这条路径中不会被杀死，则称<strong>定义d</strong>可以从点p <strong>reach</strong> 点 q。换句话说，就是：<code>p处定义的变量 v 从点 p 可以 reach 点 q，当且仅当，v在整个路径中不会获得新的定义</code>。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310210027371.png" alt="image-20231021002745300" /></p><p>​Reaching Definitions可以用来检测可能存在的、使用了未定义变量的情况。例如，在CFG入口为每个变量引入一个虚拟定义，如果这个虚拟定义能从入口reach一个使用了该变量的点p，那么这个变量就有可能未定义便被使用。(因为“未定义”reach了使用变量的p)</p><h3 id="comprehend"><a class="markdownIt-Anchor" href="#comprehend"></a> Comprehend</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211945453.png" alt="image-20231021194510364" /></p><ul><li>如图所示，关注的目标是<code>程序中定义的变量</code>，<strong>即数据流值是一个程序中所有的定义</strong>。可以使用bit编码表示在某程序点的多个Reaching Definitions，从左数第几个字节就是第几个definition<ul><li>Di如果为0表示Di无法reach该程序点</li><li>Di如果为1表示Di可以reach该程序点。</li></ul></li><li>这里D即Definition，可以表示为   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>D</mi><mo>:</mo><mi>v</mi><mo>=</mo><mi>x</mi><mtext> </mtext><mi>o</mi><mi>p</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">\ D: v = x \  op \ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><ul><li>其中一个D可以视为一行三地址码<ol><li>生成了一个定义D</li><li>在保持其他传入程序不受影响的同时，杀死了程序中其他对变量v的定义</li><li>语句 <code>D: v = x op y</code> 生成了关于变量 <code>v</code> 的一个新定义 <code>D</code> ，并且覆盖了程序中其他地方对于变量 <code>v</code> 的定义，不过并不会影响后续其他的定义再来覆盖这里的定义。赋值语句只是定义的一种形式而已，定义也可以有别的形式，比如说引用参数。</li></ol></li></ul></li><li>由此可以得到对于<strong>Node(Basic Block)的传递函数</strong>和对于<strong>Edge(Control-flow Hangling)的控制流函数</strong></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211453613.png" alt="image-20231021145323589" /></p><ul><li>Transfer Function(到达定值的转移方程)<ul><li>从入口状态删除 kill 掉的定值，并加入新生成的定值</li><li>D：v = x op y，gen v, kill 其它所有的 v</li><li>注意，是所有其他地方，不仅仅是之前的control flow，因为程序control flow可能存在环，我们不能确定运行时真正的执行先后顺序。即使kill掉了无环执行流的下游的定义也没有关系，后面再重新定义即可。</li></ul></li><li>Control Flow(到达定值的数据流处理)<ul><li>任何一个前驱的变量定值都表明，该变量得到了定义</li><li>其中U表示union，结合前文使用bit字节表示的D，可以知道，IN[B]的输入等于OUT[P1]并OUT[P2]，意味着只要存在一条路径可以reach，那么就算作可以reach</li></ul></li></ul><h3 id="algorithm"><a class="markdownIt-Anchor" href="#algorithm"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211454978.png" alt="image-20231021145410941" /></p><ul><li>这便是Reaching Definitions的算法表示形式，其中入口和每个OUT都初始化为空集即00000(bit vector)的形式，是因为1并0或1都是1，会导致算法无法继续进行。算法的<strong>停止条件</strong>是：经过一次完整的迭代后，迭代前后所有的OUT都不再发生改变。<ul><li>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</li><li>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，所需要修改各 BB 的 IN 和 OUT。</li><li>先处理 IN，然后再根据转移完成更新 OUT。</li><li>在 gen U (IN - kill)中，kill 与 gen 相关的 bit 不会因为 IN 的改变而发生改变，而其它 bit 又是通过对前驱 OUT 取并得到的，因此其它 bit 不会发生 0 -&gt; 1 的情况。所以，OUT 是不断增长的，而且有上界，因此算法最后必然会停止。</li><li>因为 OUT 没有变化，不会导致任何的 IN 发生变化，因此 OUT 不变可以作为终止条件。我们称之为程序到达了不动点（Fixed Point）</li></ul></li></ul><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png" alt="image-20231022095908077" /></p><h3 id="疑问"><a class="markdownIt-Anchor" href="#疑问"></a> 疑问</h3><ul><li><p>这里的 bit vector 为什么是和每一个 statement 相联系，而不是和对于变量的定义所联系，比如为什么不把所有对于 x 的定义作为一个 bit？</p><ul><li>这里针对的是所有的定义，对于每一个定义给予一个 bit 位。我的理解是，这样对于每一个定义(也可以说是statement)是为了存储更多的信息，就比如第一次B2之后的程序点上，杀死了D2，但是保留了D4，存储了D4的信息，即使y的状态更明确了。但是如果是通多变量名来分配 bit，那样在这种时候，y的信息就会舍弃了D2处。</li></ul></li><li><p>这里最后的结束条件表示了什么，这里 bit vector到底反映了个什么状态？</p><ul><li>这里对于某个程序点，为1表示能reach到这个程序点，即存在一开始被定义的变量v，存在一条路径使得到达程序点前没有被再次定义。</li></ul></li><li><p><s>结果这两个问题和再看视频，我这里应该理解为 为每一个 definition 给予一个 bit，这我感觉是 definition是抽象出来的结果，它每一个都是不同的，而例子中不同的 definition 都是为同一个变量的判断，应该是具体的方面，抽象的静态分析不关心具体的数值。</s></p><ul><li>这里就是这样设计的，我需要考虑的问题应该是为什么会有覆盖(kill)的存在？<ul><li>从头捋一遍，kill就是设置为0，即其余的定义不能reach到这一点，也就是说任何一条路径都有重复定义，因为这一个transfer function 就是守门员，它下一个程序点必定会受到这个func的影响。(这里相同的变量已经定义了，主要的目的是为了删除之前的相关定义，而删除后面的感觉是为了方便操作，因为后面会重新定义，所以删除不影响)</li></ul></li></ul></li></ul><h2 id="live-variables-analysis"><a class="markdownIt-Anchor" href="#live-variables-analysis"></a> Live Variables Analysis</h2><h3 id="basic-concept-2"><a class="markdownIt-Anchor" href="#basic-concept-2"></a> Basic concept</h3><ul><li>变量 v 在程序点 p 上的值是否会在某条从 p 出发的路径中使用</li><li>变量 v 在 p 上活跃，当且仅存在一条从 p 开始的路径，该路径的末端使用了 v，且路径上没有对 v 进行覆盖(redefine)。</li><li>隐藏了这样一个含义：<code>在被使用前, v 没有被重新定义过, 即没有被 kill 过, 则证明 v 在 p 处是活跃的</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211523664.png" alt="" /></p><h3 id="comprehend-2"><a class="markdownIt-Anchor" href="#comprehend-2"></a> Comprehend</h3><ul><li><p>可以假设以下，如果从后往前搜索，只要在某程序点处找到一个变量vi的使用，就证明在此之前任意可达此点的、定义了vi的程序点处，vi都是live的(<strong>这里疑惑为什么只保证了被使用，而没有保证没有重新定义就确定它满足条件</strong>)；而如果使用前向传播的算法，每到一个程序点都要正向搜索一遍后方的路径查看是否被使用，才能确认变量在此处是否live，虽然也能进行分析，但是效率较低</p></li><li><p>这里关注的是<code>程序中的的所有变量</code>，即<strong>数据流值是一个程序中所有变量</strong>。在程序点 p 处，变量为1，当且仅当变量在 p 点存活。</p></li><li><p>Transfer Function &amp; Control Flow</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png" alt="image-20231022092800008" /></p><ul><li><p>分析：</p><ul><li><p>一个基本块内，若 v = exp, 则就是 def v。若 exp = exp op v，那么就是 use v。一个变量要么是 use，要么是 def，根据 def 和 use 的先后顺序来决定。考虑基本块 B 及其后继 S。若 S 中，变量 v 被使用，那么我们就把 v 放到 S 的 IN 中(IN[S] = {v})，交给 B 来分析。因此对于活跃变量分析，其控制流处理是 <code>OUT[B] = U IN[S]</code>，就是 <code>B 的输出是所有后继 S 的输入的总和</code>。</p></li><li><p>在一个块中，若变量 v 被使用，那么我们需要添加到我们的 IN 里(IN[B] = {v})。而如果 v 被定义，那么在其之下的语句中，v 都是一个非活跃变量，因为没有语句再需要使用它。因此对于Transfer Function，IN 是从 OUT 中删去重新定值的变量，然后并上使用过的变量。需要注意，如果同一个块中，变量 v 的 def 先于 use ，那么实际上效果和没有 use 是一样的。</p></li></ul></li></ul><h3 id="algorithm-2"><a class="markdownIt-Anchor" href="#algorithm-2"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310212020469.png" alt="image-20231021202056427" /></p><ul><li><p>我们不知道块中有哪些活跃变量，而且我们的目标是知道在一个块开始时哪些变量活跃，因此把 IN 初始化为空。</p></li><li><p>初始化的判断技巧：may analysis 是空，must analysis 是 top。</p></li></ul><h3 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959784.png" alt="image-20231022095945740" /></p><h3 id="疑问-2"><a class="markdownIt-Anchor" href="#疑问-2"></a> 疑问</h3><ul><li>为什么使用 backwards ?<ul><li>使用 forwards 来确定变量在某一个程序点是否存活，那每到一个程序点，都需要查看之后的路径有没有在重定义之前使用该变量的情况，需要查看的情况众多</li><li>使用 backwards 来确定，在 BB 中存在对于一个变量的使用而在同一个 BB 中没有重新定义，那么这个 BB 之前最近的一个 程序点 P(我们分析的那个 program point)，它这里一定是满足活跃变量的，即 IN[B] = {v}</li></ul></li></ul><h2 id="available-expressions-analysis"><a class="markdownIt-Anchor" href="#available-expressions-analysis"></a> Available Expressions Analysis</h2><h3 id="basic-concept-3"><a class="markdownIt-Anchor" href="#basic-concept-3"></a> Basic concept</h3><ul><li><p>程序点 p 处的表达式 <code>x op y  </code>是 available(可用) 需满足2个条件：</p><ol><li><p>从 <strong>entry</strong> 到 p 点的所有路径必须经过(使用)x op y</p></li><li><p>最后一次使用 x op y 之后，没有重定义操作数 x、y</p><p>(如果重定义了x 或 y，如x = a op2 b，则原来的表达式x op y中的x或y就会被替代)</p></li></ol></li><li><p>这个定义说明，在p处如果表达式available，就可以将其替换为最后一次运算的结果，或者可以检测全局通用表达式，感觉这里可以直接优化，首先计算表达式的结果，之后直接替换即可，相当于 <code>#define PI x + y, 这里x与y为常量</code>。</p></li></ul><h3 id="comprehend-3"><a class="markdownIt-Anchor" href="#comprehend-3"></a> Comprehend</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310212025007.png" alt="image-20231021202525968" /></p><ul><li>这里关注的就是<strong>程序中的表达式</strong>，那么每个程序点处的抽象程序状态，也就是数据流值，则为 <em>E</em> 的一个子集(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo>…</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E=\{e_{1},e_{2}……,e_{n}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>)，即数据流值可以是{0,1,0……，1}之类的(这是子集)。</li><li>Transfer Function &amp; Control Flow</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220921179.png" alt="image-20231022092148128" /></p><ul><li>我们要求无论从哪条路径到达 B，表达式都应该已经计算，才能将其视为可用表达式，因此这是一个 must analysis。</li><li>注意到图中，两条不同的路径可能会导致表达式的结果最终不一致。但是我们只关心它的值能不能够再被重复利用，因此可以认为表达式可用。</li><li>v = x op y，则 gen x op y。当 x = a op b，则任何包含 x 的表达式都被 kill 掉。若 gen 和 kill 同时存在，<code>那么以最后一个操作为准</code>。</li><li>转移方程很好理解，和到达定值差不多。但是，由于我们是 must analysis，因此控制流处理是<code>取交集</code>，而非到达定值那样取并集。</li></ul><h3 id="algorithm-3"><a class="markdownIt-Anchor" href="#algorithm-3"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220923234.png" alt="image-20231022092329180" /></p><h3 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221000927.png" alt="image-20231022100017882" /></p><h2 id="summarize-2"><a class="markdownIt-Anchor" href="#summarize-2"></a> Summarize</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220933086.png" alt="image-20231022093321043" /></p><h1 id="data-flow-analysis-foundations"><a class="markdownIt-Anchor" href="#data-flow-analysis-foundations"></a> Data Flow Analysis - Foundations</h1><h2 id="partial-order"><a class="markdownIt-Anchor" href="#partial-order"></a> Partial Order</h2><p>所谓偏序集合(poset)，就是一个由集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和偏序关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> 所组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mo>⊑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(P, \sqsubseteq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 对。这个对满足以下三个条件：</p><ul><li>Reflexivity 自反性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi mathvariant="normal">x</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi mathvariant="normal">x</mi><mo>⊑</mo><mi mathvariant="normal">x</mi></mrow><annotation encoding="application/x-tex">\forall\mathrm{x}\in P,\mathrm{x}\sqsubseteq\mathrm{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">x</span></span></span></span></span></li><li>Antisymmetry 反对称性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>∧</mo><mi>y</mi><mo>⊑</mo><mi>x</mi><mo>⟹</mo><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\forall x,y\in P,x\sqsubseteq y\land y\sqsubseteq x\Longrightarrow x=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li>Transitivity 传递性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>∧</mo><mi>y</mi><mo>⊑</mo><mi>z</mi><mo>⟹</mo><mi mathvariant="normal">x</mi><mo>⊑</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z\in P,x\sqsubseteq y\land y\sqsubseteq z\Longrightarrow\mathrm{x}\sqsubseteq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>例子：小于等于关系就是一个偏序关系，但小于关系不是偏序关系，它是全序关系。</li></ul><p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而<code>偏序关系不保证所有元素都能进行比较</code></p><h2 id="upper-and-lower-bounds"><a class="markdownIt-Anchor" href="#upper-and-lower-bounds"></a> Upper and Lower Bounds</h2><ul><li><p>对于偏序集中的某子集 S 来说：</p><ul><li><p>若存在元素 u 使得 S 的任意元素 x 有 x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> u，那么我们说 u 是 S 的上界(Upper bound)。</p></li><li><p>同理，若存在元素 l 使得 S 的任意元素 x 有 l <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> x，那么我们说 l 是 S 的下界(Lower bound)。</p></li></ul></li><li><p>然后我们衍生出最小上界和最大下界的概念：</p><ul><li><p>在 S 的所有上界中，我们记最小上界(Least upper bound, lub)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\sqcup S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">⊔</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 满足所有上界 u 对 lub 有: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo><mi>S</mi><mo>⊑</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">\sqcup S \sqsubseteq u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord">⊔</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span></p></li><li><p>类似地我们也能定义出最大下界(Greatest lower bound, glb)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊓</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\sqcap S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">⊓</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 满足所有下届 l 对 glb 有: $l \sqsubseteq \sqcup S $</p></li></ul></li><li><p>当 S 的元素个数只有两个{a, b}时，我们还可以有另一种记法：</p><ul><li><p>最小上界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊔</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \sqcup b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, a <code>join</code> b</p></li><li><p>最大下界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊓</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \sqcap b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, a <code>meet</code> b</p></li></ul></li></ul><p>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的。(可假设存在多个，然后用自反性证明它们是同一个)</p><h2 id="lattice"><a class="markdownIt-Anchor" href="#lattice"></a> Lattice</h2><h3 id="lattice-2"><a class="markdownIt-Anchor" href="#lattice-2"></a> Lattice</h3><p>​给定一个偏序集，如果任意元素 a, b 都有 lub 和 glb，那么这么偏序集就叫做 <strong>格（lattice）</strong>。也就是说一个lattice的任意两个元素组成的元素对都有lub和glb。</p><ul><li>属于 lattice 的：小于等于关系，子集关系</li><li>不属于 lattice 的：子串关系</li></ul><h3 id="semilattice"><a class="markdownIt-Anchor" href="#semilattice"></a> Semilattice</h3><p>​给定偏序集，对于任意元素 a，b 只有 lub，则称此偏序集为一个 <code>join semilattice</code>，若是任意元素 a，b 只有 glb，则称此偏序集为一个 <code>meet semilattice</code></p><h3 id="complete-lattice"><a class="markdownIt-Anchor" href="#complete-lattice"></a> Complete Lattice</h3><p>​给定一个偏序集，<code>任意子集S</code> 都存在 lub 和 glb，那么我们说这个 lattice 为<strong>全格(complete lattice)</strong></p><ul><li>属于全格的：子集关系</li><li>不属于全格的：小于等于关系，因为全体正整数没有一个边界</li></ul><p>​每一个全格都存在着 **最大元素 **<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span> (top)和 <strong>最小元素</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span> (bottom)，他们分别是整个集合的 lub 和 glb。</p><p>​如果一个 lattice 是有穷的，那么它一定是一个全格。然而，一个全格不一定是有穷的，例如[0, 1]之间的实数是无穷的，但是期间的小于等于关系可以使其成为全格。</p><h3 id="product-lattice"><a class="markdownIt-Anchor" href="#product-lattice"></a> Product Lattice</h3><p>​另外还有 <strong>Product Lattice</strong>，多个 lattice 的<strong>笛卡尔积</strong>也能形成一个新的 lattice。</p><ul><li>product lattice 也是一个 lattice</li><li>如果 product lattice L是全格的积，那么 L 也是全格。</li></ul><h2 id="data-flow-analysis-framework-via-lattice"><a class="markdownIt-Anchor" href="#data-flow-analysis-framework-via-lattice"></a> Data Flow Analysis Framework via Lattice</h2><p>一个数据流分析框架(D, L, F)由以下元素组成：</p><ul><li>D: 数据流的方向，前向还是后向</li><li>L: 包含了数据值 V 和 meet, join 符号的格</li><li>F: V -&gt; V 的转移方程族</li></ul><p>从而，数据流分析可以被视为在 lattice 的值上迭代地应用转移方程和 meet/join 操作符。</p><h2 id="monotonicity-and-fixed-point-theorem"><a class="markdownIt-Anchor" href="#monotonicity-and-fixed-point-theorem"></a> Monotonicity and Fixed Point Theorem</h2><ul><li><p>对于问题----迭代算法在什么条件下可以停机？我们在这里引入不动点定理：</p><ul><li><strong>Monotonicity 单调性</strong>: 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>⇒</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \sqsubseteq y \Rightarrow f(x)\sqsubseteq f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，则说函数f: L -&gt; L 是<strong>单调的</strong>。</li><li><strong>FIxed Point Theorem 不动点定理</strong>: 给定一个全格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mo>⊑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L,\sqsubseteq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span>，如果<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">f: L \rightarrow L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是单调的</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是有穷的(也就是f单调有界+L全格)</li></ul></li></ul></li><li><p>那么</p><ul><li><p>迭代<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^k(\bot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span></span></span></span>可以得到最小不动点(least fixed point)。</p></li><li><p>迭代<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊤</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^k(\top)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊤</span><span class="mclose">)</span></span></span></span>可以得到最大不动点(greatest fixed point)。</p></li></ul></li><li><p>证明：</p><ul><li>根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>和f的定义，我们可以得到：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bot \sqsubseteq f(\bot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">⊥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span></span></span></span>。由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq …\sqsubseteq f^k(\bot)\sqsubseteq f^{k+1}(\bot) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，且</mtext></mrow><annotation encoding="application/x-tex">，且</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">且</span></span></span></span>f^k(\bot) = f^{k+1}(\bot)$。</li><li>假设我们有另一个任意不动点 x，由于 f 是单调的，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>f</mi><mrow><mi>F</mi><mi>i</mi><mi>x</mi></mrow></msup><mo>=</mo><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(\bot) \sqsubseteq f(x), f^2(\bot) \sqsubseteq f^2(x),...,f^{Fix} = f^k(\bot)\sqsubseteq f^k(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>可知的确<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>F</mi><mi>i</mi><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f^{Fix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span>是最小不动点。</li></ul></li></ul><p>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</p><h2 id="relate-iterative-algorithm-to-fixed-point-theorem"><a class="markdownIt-Anchor" href="#relate-iterative-algorithm-to-fixed-point-theorem"></a> Relate Iterative Algorithm to Fixed Point Theorem</h2><p>以上我们只是定性的描述了是否能得到最优不动点，但是迭代算法怎样才能算是符合了不动点定理的要求呢？接下来介绍关联的方法。</p><p>首先，回想 fact 的形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msubsup><mi>v</mi><mn>1</mn><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>v</mi><mn>2</mn><mn>1</mn></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi>v</mi><mi>k</mi><mn>1</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1^1,v_2^1,...,v_k^1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.2831079999999999em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，可以将其视为一个有限 lattice，它的积也是有限 lattice，因此 fact 对应到 finite lattice 是可以的。然后，我们的迭代函数 F 包括了转移函数 f 和 join/meet 函数，证明 F 是单调的，那么也就能得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">F: L\rightarrow L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是单调的。</p><ul><li><p>这里分两部分。</p><ul><li><p>转移函数，即 OUT = gen U (IN - kill)，显然是单调的。</p></li><li><p>那么 join/meet 函数，我们要证明其单调，就是要证明：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><mi>L</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z\in L, x\sqsubseteq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>。</p><ol><li>由定义，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>由传递性，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的 lub</li><li>又 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的 lub</li><li>因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>，证毕。</li></ol></li></ul></li></ul><p>于是我们就完成了迭代算法到不动点定理的对应。</p><ul><li><p>现在我们要回答本文开头的第三个问题了，什么时候算法停机？</p><ul><li>这个问题就很简单了，因为每个 lattice 都有其高度。假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>h</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i = h \times k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></li></ul></li><li><p>最后我们再列出这三个问题与其回答：</p><ul><li><p>算法是否确保一定能停止/达到不动点？**能！**会不会总是有一个解答？<strong>可以！</strong></p></li><li><p>如果能到达不动点，那么是不是只有一个不动点？**可以有很多。**如果有多个不动点，我们的结果是最优的吗？<strong>是的！</strong></p></li><li><p>什么时候我们会能得到不动点？<strong>最坏情况下，是 lattice 的高度与 CFG 的节点数的乘积。</strong></p></li></ul></li></ul><h2 id="maymust-analysis-a-lattice-view"><a class="markdownIt-Anchor" href="#maymust-analysis-a-lattice-view"></a> May/Must Analysis, A Lattice View</h2><h3 id="may"><a class="markdownIt-Anchor" href="#may"></a> MAY</h3><ul><li><p>对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p></li><li><p>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换。上界代表 safe but useless 的情况，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义。</p></li><li><p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走(相对于truth点而言)，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221522165.png" alt="" /></p><h3 id="must"><a class="markdownIt-Anchor" href="#must"></a> MUST</h3><ul><li><p>在可用表达式分析中，下界代表无可用表达式，上界代表所有表达式都可用。</p></li><li><p>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即使确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221525983.png" alt="" /></p><h2 id="distributivity-and-mop"><a class="markdownIt-Anchor" href="#distributivity-and-mop"></a> Distributivity and MOP</h2><p>​与我们之前使用的算法不同，我们以前使用的算法是在运行过程中沿着数据流反复迭代的，而MOP是找出从开头到结尾所有路径，分别进行传递函数计算，最后将算完的所有路径进行 $\sqcup / \sqcap $ (即不是根据节点与其前驱/后继节点的关系来迭代计算数据流，而是直接查找所有路径，根据所有路径的计算结果再取上/下界。这个结果是最理想的结果。)，公式如下：</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221646821.png" alt="image-20231022164631766" /></p><p>​由于某些路径可能实际无法到达，因此MOP不是特别精确；而在正常的程序中路径过多，几乎无法全部枚举，因此MOP也不太实际。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221648079.png" alt="image-20231022164859036" /></p><p>​可以看到，迭代算法是 s3 对前驱取 join 后进行进行 f3 的转移，而 MOP 算法是对到达 s3 之后，s4 之前的路径结果取 join。</p><ul><li><p>那么迭代算法和 MOP 哪个更精确呢？我们可以证明，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⊔</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⊔</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)\sqcup F(y)\sqsubseteq F(x\sqcup y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>：</p></li><li><p>这表明 MOP 是更为精确的。但这并没有结束。而如果 F 是可分配的，那么确实可以让偏序符号改为等于号。恰好，gen/kill problem 下，F 确实可分配因此我们能确定，迭代算法的精度与 MOP 相等。</p></li></ul><h2 id="constant-propagation-worklist-algorithm"><a class="markdownIt-Anchor" href="#constant-propagation-worklist-algorithm"></a> Constant Propagation &amp; Worklist Algorithm</h2><p>​这里可以直接参考 <a href="https://static-analysis.cuijiacai.com/04-dfa-fd/#_4-6-%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD">这个博客</a></p><blockquote><p>这里之后就参考 <a href="https://static-analysis.cuijiacai.com/05-inter/">这篇博客了</a>，之后记录的是我对某些知识点的理解与记录</p></blockquote><h1 id="interprocedural-analysis"><a class="markdownIt-Anchor" href="#interprocedural-analysis"></a> Interprocedural Analysis</h1><ol><li><code>Dispatch </code>是从本身开始查找方法实现，如果没有找到，则继续向父类索引; 而对于在 CHA 中的 <code>Call Resolution</code> 算法而言, 对于 <code>virtual call</code> 需要对<strong>它本身和它所有的子类及其子类的子类</strong>都调用 <code>Dispatch</code></li><li>这里需要区分一下 ICFG 与 IDFA 的区别，控制流是基础骨架, 而数据流是在骨架上的血肉</li></ol><p>​<strong>过程间控制流图（Interprocedural Control Flow Graph，ICFG）</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310252003222.png" alt="image-20231025200307155" /></p><p>​<strong>过程内数据流分析（Intraprocedural Data-Flow Analysis，IDFA）</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310252003060.png" alt="image-20231025200324017" /></p><h1 id="pointer-analysis"><a class="markdownIt-Anchor" href="#pointer-analysis"></a> Pointer Analysis</h1><ul><li>我们将分析一个指针可能指向的 <strong>内存区域(Memory Location)</strong>，以 <strong>程序(Program)</strong> 为输入，以程序中的 <strong>指向关系(Point-to Relation)</strong> 为输出的分析称作 <strong>指针分析(Pointer Analysis)</strong> 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081 实验</title>
    <link href="/posts/3fdc6854.html"/>
    <url>/posts/3fdc6854.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><p>​这里使用Ubuntu22.04进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按官方指南手册 安装必须的工具链</span><br>$ sudo apt-get update &amp;&amp; sudo apt-get upgrade<br>$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br><span class="hljs-comment"># 单独移除掉qemu的新版本, 因为不知道为什么build时候会卡壳</span><br>$ sudo apt-get remove qemu-system-misc<br><span class="hljs-comment"># 额外安装一个旧版本的qemu</span><br>$ wget https://download.qemu.org/qemu-5.1.0.tar.xz<br>$ tar xf qemu-5.1.0.tar.xz<br>$ <span class="hljs-built_in">cd</span> qemu-5.1.0<br><span class="hljs-comment"># 报错处理</span><br>$ sudo apt-get install libglib2.0-dev<br>$ sudo apt-get install libpixman-1-dev<br>$ ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=<span class="hljs-string">&quot;riscv64-softmmu&quot;</span><br>$ make<br>$ sudo make install<br><br><span class="hljs-comment"># 克隆xv6实验仓库</span><br>$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020<br>$ <span class="hljs-built_in">cd</span> xv6-labs-2020<br>$ git checkout util<br><br><span class="hljs-comment"># 进行编译</span><br>$ make qemu<br><span class="hljs-comment"># 编译成功并进入xv6操作系统的shell</span><br>$ xv6 kernel is booting<br><br>$ hart 2 starting<br>$ hart 1 starting<br>$ init: starting sh<br>$ (shell 等待用户输入...)<br></code></pre></td></tr></table></figure><blockquote><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/624091268">https://zhuanlan.zhihu.com/p/624091268</a></p><p><a href="https://zhuanlan.zhihu.com/p/537461426">MIT6.S081 Ubuntu22.04 WSL2实验环境配置 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/fuxy3/article/details/104732541">glib-2.40 gthread-2.0 is required to compile QEMU and ERROR</a></p></blockquote><h2 id="配置vscode"><a class="markdownIt-Anchor" href="#配置vscode"></a> 配置VsCode</h2><ul><li>远程免密登录<ul><li>[VsCode配置ssh免密远程登录 - 安全兔 - 博客园 (<a href="http://cnblogs.com">cnblogs.com</a>)](<a href="https://www.cnblogs.com/safe-rabbit/p/16254860.html#:~:text=VsCode%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95">https://www.cnblogs.com/safe-rabbit/p/16254860.html#:~:text=VsCode配置ssh免密远程登录</a> 1 （1）打开vscode，点击红色方框处安装插件 2 （2）如果需要汉化可以安装一下这个插件，安装完成后重启一下vscode就可以 3 （3）安装远程连接的插件 4,（5）再点击一下红色方框出齿轮这个按钮 6 （6）点击下面红框，这是SSH远程的配置文件 7 （7）在config里面配置你的虚拟机或者服务器的信息，Host是虚拟机或者服务器的名称，HostName是虚拟机或者服务器的ip地址，User是登录的用户 8 （8）配置成功后左边红色方框处会出现电脑图标，然后点击右边绿色方框处打开新窗口 更多项目)</li><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/">优雅的调试—在vscode上完美调试xv6（完结） (sanbuphy.github.io)</a></li><li><a href="https://jyywiki.cn/">jyywiki.cn</a></li></ul></li></ul><h1 id="lab1"><a class="markdownIt-Anchor" href="#lab1"></a> Lab1</h1><h2 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">// fprintf has one more file pointer printf</span><br>        <span class="hljs-comment">// https://blog.csdn.net/m0_53005929/article/details/119818286</span><br>        <span class="hljs-comment">// 2 indicates a argument which is the shell output</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;ERROR: sleep time required\n&quot;</span>);<br>        <span class="hljs-comment">// the between difference exit(0) and exit(1)</span><br>        <span class="hljs-comment">// https://blog.csdn.net/yjk13703623757/article/details/103507673</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<span class="hljs-comment">//类型转换，从char到int</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong"></a> pingpong</h2><ul><li>注意<ul><li>不用的管道需要关闭</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-comment">//p1是父写给子，p2是子写给父</span><br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>], p2[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[MAXSIZE];<br>    pipe(p1);<br>    pipe(p2);<br>    <span class="hljs-type">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// close the pipe port and prevent others from operating</span><br>        <span class="hljs-comment">// 0 indicates read and 1 indicates write</span><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        <br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, MAXSIZE);<br>        read(p2[<span class="hljs-number">0</span>], buf, MAXSIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br><br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br><br>        read(p1[<span class="hljs-number">0</span>], buf, MAXSIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>        write(p2[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, MAXSIZE);<br><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="primes"><a class="markdownIt-Anchor" href="#primes"></a> primes</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 36</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span>;<br><span class="hljs-comment">//the parent thread is for pl and input the number</span><br><span class="hljs-comment">//the child thread is for selecting and printing, its child is for recursion</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pl[<span class="hljs-number">2</span>];<br>    pipe(pl);<br><br>    <span class="hljs-keyword">if</span>(fork() &gt; <span class="hljs-number">0</span>)&#123;<br>        close(pl[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; NUM; i++)<br>        &#123;<br>            write(pl[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;<br>        close(pl[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        child(pl);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span>* pl)</span>&#123;<br>    <span class="hljs-type">int</span> pr[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> n;<br><br>    close(pl[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//这里读取最开始的35个数字，若是读完了，那么就结束了</span><br>    <span class="hljs-type">int</span> read_result = read(pl[<span class="hljs-number">0</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span>(!read_result)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    pipe(pr);<br>    <span class="hljs-keyword">if</span> (fork() &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        close(pr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, n);<br>        <span class="hljs-type">int</span> prime = n;<br>        <span class="hljs-comment">//子进程从父进程读取数字</span><br>        <span class="hljs-keyword">while</span> (read(pl[<span class="hljs-number">0</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % prime)<br>            &#123;<br>                <span class="hljs-comment">//子进程写给孙进程的数字</span><br>                write(pr[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(pr[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        child(pr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target_file)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: You need pass in only 2 arguments\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> *target_path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> *target_file = argv[<span class="hljs-number">2</span>];<br>    find(target_path, target_file);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target_file)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-comment">//这里打开后给了句柄给fd，里面包含了所含文件和目录的名称</span><br>    <span class="hljs-keyword">if</span>((fd = open(path,<span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot open\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot stat&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//读取该fd(目录)包含的文件或目录的名称,若是一个文件，那就是读取自身的名称</span><br>    <span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>        <span class="hljs-comment">//add the full path</span><br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//移动名称，这个时候p已经指向了/后面，所以直接赋值</span><br>        memmove(p, de.name, DIRSIZ);<br>        <span class="hljs-comment">//最后的数值为0，就是截断标志</span><br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(stat(buf,&amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connot stat&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span>(st.type)&#123;<br>            <span class="hljs-keyword">case</span> T_FILE:<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(de.name,target_file))&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> T_DIR:<br>                <span class="hljs-comment">//排除了.与..目录</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>)) &#123;<br>                    find(buf, target_file);<br>                &#125;<br>        &#125;<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xargs"><a class="markdownIt-Anchor" href="#xargs"></a> xargs</h2><ul><li>注意<ul><li>这里需要知道<code>echo ab | xargs echo 12 34</code>是输出<code>12 34 ab</code>，即<code>xargs</code>把前面的输出加到了自己指引的命令<code>echo</code>的参数中</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM 100</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">char</span> argument[MAXARG][MAXNUM];<br><span class="hljs-comment">//这里while(1)是判断&#x27;\n&#x27;的情况，没有了就在下面使用read_result读不到了退出</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">memset</span>(argument, <span class="hljs-number">0</span>, MAXARG * MAXNUM);<br>        <span class="hljs-type">int</span> count = argc - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//argv[0]是xargs本身，需要剔除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>        &#123;<br>            <span class="hljs-built_in">strcpy</span>(argument[i<span class="hljs-number">-1</span>], argv[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> xargc = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> buf;<br>        <span class="hljs-type">int</span> read_sult;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//这里从标准输出符0处读取前面命令的输出内容，这里一个一个字符地读，来区分不同地arg</span><br>        <span class="hljs-keyword">while</span> ((read_sult = read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; buf != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(buf == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; flag)&#123;<br>                count++;<br>                xargc = <span class="hljs-number">0</span>;<br>                flag = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buf != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                argument[count][xargc++] = buf;<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//读到了&#x27;\n&#x27;,退出while(1)</span><br>        <span class="hljs-keyword">if</span>(read_sult &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//这里xargs后面的第一个参数是一个命令</span><br>        <span class="hljs-type">char</span> *command = argv[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">char</span> *xargs[MAXARG];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXARG - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            xargs[i] = argument[i];<br>        &#125;<br>        <span class="hljs-comment">//0截断</span><br>        xargs[MAXARG - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (fork() &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            exec(command, xargs);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win64 Kernel 实验</title>
    <link href="/posts/7394324b.html"/>
    <url>/posts/7394324b.html</url>
    
    <content type="html"><![CDATA[<h1 id="ia-32e模式"><a class="markdownIt-Anchor" href="#ia-32e模式"></a> IA-32e模式</h1><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><h1 id="smep-smap"><a class="markdownIt-Anchor" href="#smep-smap"></a> SMEP &amp; SMAP</h1><h2 id="visual-studio配置"><a class="markdownIt-Anchor" href="#visual-studio配置"></a> Visual Studio配置</h2><ul><li>x64asm.asm<ul><li>属性-&gt;配置属性-&gt;常规-&gt;{从生成项中排除:<code>否</code> ^ 项类型:<code>自定义生成工具</code>}</li><li>属性-&gt;配置属性-&gt;自定义生成工具-&gt;{命令行:<code>ml64 /c %(filename).asm</code> ^ 输出:<code>%(filename).obj;%(Outputs)</code>}</li><li>确保asm可以和C文件进行混合编译</li></ul></li><li>项目配置<ul><li>属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;{启动增量链接:<code>否(/INCREMENTAL:NO)</code>}</li><li>属性-&gt;配置属性-&gt;C/C+±&gt;代码生成-&gt;{运行库:<code>多线程(/MT)</code>}</li><li>属性-&gt;配置属性-&gt;链接器-&gt;高级-&gt;{随机基址:<code>否</code> ^ 固定基址:<code>是</code> ^ 基址:<code>0x0000000100000000</code>}</li><li>固定基址是符合代码需要，正常来说并不需要</li></ul></li><li>解决方案生成<ul><li>x64生成解决方案</li></ul></li></ul><h2 id="smep"><a class="markdownIt-Anchor" href="#smep"></a> SMEP</h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h3><h4 id="x64asasm"><a class="markdownIt-Anchor" href="#x64asasm"></a> x64as.asm</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x64asm.asm<br>option casemap:none<br><br>EXTERN x:qword<br><br>.DATA<br><br>.CODE<br><br>IntEntryPROC<br>iretq<br>IntEntryENDP<br><br>goPROC<br>int 21h<br>ret<br>goENDP<br><br>END<br></code></pre></td></tr></table></figure><h4 id="testc"><a class="markdownIt-Anchor" href="#testc"></a> test.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//对于cpp文件，则是extern &quot;C&quot;…… 这里注意区分c与cpp的不同</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">IntEntry</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> ULONG64 x;<br><br>ULONG64 x;<br><span class="hljs-comment">//构造中断门(IDT),使程序可以通过int 21h 进入IntEntry函数</span><br><span class="hljs-comment">//eq idtr+210 0000ee00`00101000</span><br><span class="hljs-comment">//eq idtr+218 1</span><br><span class="hljs-comment">//修改SMEP，Cr4的第20位清零</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">if</span> ((ULONG64)IntEntry != <span class="hljs-number">0x0000000100001000</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong IntEntry at %p \n&quot;</span>, IntEntry);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>go();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p \n&quot;</span>, x);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="smap"><a class="markdownIt-Anchor" href="#smap"></a> SMAP</h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> Code</h3><h4 id="x64asasm-2"><a class="markdownIt-Anchor" href="#x64asasm-2"></a> x64as.asm</h4><ul><li><p>代码修改1</p><ul><li>自己把Cr4的第21位(SMAP)清零</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">IntEntryPROC<br>mov rax, qword ptr [0fffff8034b290fd0h]// gdt[4]<br>mov x, rax<br>iretq<br>IntEntryENDP<br></code></pre></td></tr></table></figure></li><li><p>代码修改2</p><ul><li>使用 <code>stac</code> 将 <code>SMAP</code> 清零，但是只是运行时生效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">IntEntryPROC<br>mov rax, qword ptr [0fffff8048528e000h]<br>stac;如果找不到这条指令，可以emit对应的字节码<br>mov x, rax<br>iretq<br>IntEntryENDP<br></code></pre></td></tr></table></figure></li></ul><h2 id="代码功能"><a class="markdownIt-Anchor" href="#代码功能"></a> 代码功能</h2><ul><li>对于<code>SMEP</code>与<code>SMAP</code>的存在检验，<code>test.c</code>主要就是构造函数执行的主窗口，<code>x64asm.asm</code>中则是对于相关函数进行实现</li><li>对于<code>x64asm.asm</code>文件<ul><li><code>go</code>函数主要实现通过中断门进入到内核，这里需要提前在<code>Windbg</code>中进行中断门构造</li><li><code>IntEntry</code>则在不同的验证代码中具体实现对于内核地址数据的访问与写入</li></ul></li></ul><h1 id="9-9-9-9-12分页"><a class="markdownIt-Anchor" href="#9-9-9-9-12分页"></a> 9-9-9-9-12分页</h1><h2 id="visual-studio配置-2"><a class="markdownIt-Anchor" href="#visual-studio配置-2"></a> Visual Studio配置</h2><ul><li>x64asm.asm<ul><li>属性-&gt;配置属性-&gt;常规-&gt;{从生成项中排除:<code>否</code> ^ 项类型:<code>自定义生成工具</code>}</li><li>属性-&gt;配置属性-&gt;自定义生成工具-&gt;{命令行:<code>ml64 /c %(filename).asm</code> ^ 输出:<code>%(filename).obj;%(Outputs)</code>}</li><li>确保asm可以和C文件进行混合编译</li></ul></li><li>项目配置<ul><li>删除项目中Driver Files中的文件</li><li>属性-&gt;配置属性-&gt;C/C+±&gt;常规-&gt;{将警告视为错误:<code>否</code>}</li><li>属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;{启动增量链接:<code>否(/INCREMENTAL:NO)</code>}</li><li>属性-&gt;配置属性-&gt;lnf2Cat-&gt;{Run lnf2Cat:<code>是</code>}</li><li>属性-&gt;配置属性-&gt;Driver Signing-&gt;{Sign Mode:<code>Off</code>}</li></ul></li><li>解决方案生成<ul><li>x64生成解决方案</li></ul></li></ul><h2 id="coda"><a class="markdownIt-Anchor" href="#coda"></a> Coda</h2><h3 id="entryc"><a class="markdownIt-Anchor" href="#entryc"></a> entry.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//entry.c-&gt;驱动的主函数和入口</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><br><span class="hljs-comment">//定义全局变量,这里需要定义asm与scan.c用到的变量</span><br>ULONG64 g_NT_BASE;<br>ULONG64 g_PTE_BASE;<br>ULONG64 g_PDE_BASE;<br>ULONG64 g_PPE_BASE;<br>ULONG64 g_PXE_BASE;<br>ULONG64 g_IDT;<br>ULONG64 g_Cr4;<br><br>VOID <span class="hljs-title function_">DriverUnload</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span><br>&#123;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Driver is unloading...\n----------------------------------------------\n&quot;</span>);<br>&#125;<br><br>NTSTATUS <span class="hljs-title function_">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT  driver, PUNICODE_STRING RegistryPath)</span><br>&#123;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;----------------------------------------------\nDriver is loading  ...\n&quot;</span>);<br><br>    <span class="hljs-comment">//通过遍历模块匹配设置g_NT_BASE(nt模块的基址)的数据</span><br>    GetNtBaseAddress(driver);<br>    <span class="hljs-comment">//通过Nt模块首地址计算页表基址</span><br>    GetPageAddress(g_NT_BASE);<br><br>    driver-&gt;DriverUnload = DriverUnload;<br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="commomh"><a class="markdownIt-Anchor" href="#commomh"></a> commom.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//common.h-&gt;相关结构体的定义和函数的声明(包含asm文件的引用)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMMON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMON_H</span><br><br><span class="hljs-comment">//这里是用来遍历内核模块，从而找到NT模块的基地址</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LDR_DATA_TABLE_ENTRY</span> &#123;</span><br>    LIST_ENTRY InLoadOrderLinks;               <span class="hljs-comment">//链表存储，两个成员Flink(后)与Blink(前),指向一个LDR_DATA_TABLE_ENTRY结构</span><br>    LIST_ENTRY InMemoryOrderLinks;<br>    LIST_ENTRY InInitializationOrderLinks;<br>    PVOID DllBase;                             <span class="hljs-comment">//基址</span><br>    PVOID EntryPoint;<br>    ULONG SizeOfImage;<br>    UNICODE_STRING FullDllName;                <span class="hljs-comment">//完整模块名，以\??\格式(0环格式)开始</span><br>    UNICODE_STRING BaseDllName;                <span class="hljs-comment">//存放着驱动模块名</span><br>    ULONG Flags;<br>    USHORT LoadCount;<br>    USHORT TlsIndex;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        LIST_ENTRY HashLinks;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            PVOID SectionPointer;<br>            ULONG CheckSum;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            ULONG TimeDateStamp;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            PVOID LoadedImports;<br>        &#125;;<br>    &#125;;<br>&#125;LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;<br><br><span class="hljs-comment">//设置自定义函数，在scan.c中实现</span><br><span class="hljs-comment">//根据页表规则计算地址</span><br>PULONG64 <span class="hljs-title function_">GetPteAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPdeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPpeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPxeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br><br><span class="hljs-comment">//根据页表分级获得地址</span><br>VOID <span class="hljs-title function_">GetPageAddress</span><span class="hljs-params">(ULONG64 g_NT_BASE)</span>;<br><span class="hljs-comment">//获得Nt模块的基址地址</span><br>VOID <span class="hljs-title function_">GetNtBaseAddress</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span>;<br><span class="hljs-comment">//线性地址转化为物理地址</span><br>VOID <span class="hljs-title function_">Address_translation</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//引用entry.c文件中的变量与函数</span><br><span class="hljs-keyword">extern</span> ULONG64 g_NT_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PTE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PDE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PPE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PXE_BASE;<br><br><span class="hljs-comment">//引用asm文件中的变量与函数</span><br><span class="hljs-keyword">extern</span> ULONG64 g_Cr4;<br><span class="hljs-keyword">extern</span> ULONG64 g_IDT;<br><span class="hljs-keyword">extern</span> VOID <span class="hljs-title function_">Asm_Read_Cr4</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> VOID <span class="hljs-title function_">Asm_Read_IDT</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// COMMON_H</span></span><br><span class="hljs-comment">//#-&gt;这是一个预处理器指令，没有定义就创建宏，定义了就跳过，防止重复包含</span><br></code></pre></td></tr></table></figure><h3 id="scanc"><a class="markdownIt-Anchor" href="#scanc"></a> scan.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//scan.c-&gt;实现函数的定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><br><span class="hljs-comment">//根据线性地址得到物理地址</span><br>PULONG64 <span class="hljs-title function_">GetPxeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">39</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PXE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPpeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PPE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPdeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">21</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PDE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPteAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PTE_BASE);<br>&#125;<br><br><br><span class="hljs-comment">//获取内核模块NT的基址与IDTR的基址</span><br>VOID <span class="hljs-title function_">GetNtBaseAddress</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span> &#123;<br>    PLDR_DATA_TABLE_ENTRY pLDR_Head = <span class="hljs-literal">NULL</span>;<br>    PLDR_DATA_TABLE_ENTRY pLDR_Tail = <span class="hljs-literal">NULL</span>;<br>    UNICODE_STRING ModuleName = &#123; <span class="hljs-number">0</span> &#125;;<br>    RtlInitUnicodeString(&amp;ModuleName, <span class="hljs-string">L&quot;ntoskrnl.exe&quot;</span>);<br><br>    pLDR_Head = (PLDR_DATA_TABLE_ENTRY)driver-&gt;DriverSection;<br>    pLDR_Tail = pLDR_Head;<br><br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">if</span> (RtlCompareUnicodeString(&amp;pLDR_Tail-&gt;BaseDllName, &amp;ModuleName, TRUE) == <span class="hljs-number">0</span>) &#123;<br>            DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;NtModuleBase = %p \n&quot;</span>, pLDR_Tail-&gt;DllBase);<br>            g_NT_BASE = (ULONG64)pLDR_Tail-&gt;DllBase;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pLDR_Tail = (PLDR_DATA_TABLE_ENTRY)pLDR_Tail-&gt;InLoadOrderLinks.Flink;<br>    &#125; <span class="hljs-keyword">while</span> (pLDR_Head != pLDR_Tail);<br><br>    <span class="hljs-comment">//DbgPrintEx(77, 0, &quot;NtModuleBase = %p \n&quot;, g_IDTR);</span><br>&#125;<br><br><span class="hljs-comment">//获取PTE等页表基址</span><br>VOID <span class="hljs-title function_">GetPageAddress</span><span class="hljs-params">(ULONG64 g_NT_BASE)</span> &#123;<br>    g_PTE_BASE = *(PULONG64)(g_NT_BASE + <span class="hljs-number">0xC8BC</span>);<br>    <span class="hljs-comment">//这里的0xC8BC是使用WinDbg搜索的PTE距离NT_BASE的偏移</span><br>    g_PDE_BASE = (ULONG64)GetPteAddress((PVOID)g_PTE_BASE);<br>    g_PPE_BASE = (ULONG64)GetPteAddress((PVOID)g_PDE_BASE);<br>    g_PXE_BASE = (ULONG64)GetPteAddress((PVOID)g_PPE_BASE);<br><br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pte Base Address = %p\n&quot;</span>, (PVOID)g_PTE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pde Base Address = %p\n&quot;</span>, (PVOID)g_PDE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Ppe Base Address = %p\n&quot;</span>, (PVOID)g_PPE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pxe Base Address = %p\n&quot;</span>, (PVOID)g_PXE_BASE);<br><br>    <span class="hljs-comment">//为g_Cr4与g_IDT赋值</span><br>    Asm_Read_Cr4();<br>    Asm_Read_IDT();<br>    <span class="hljs-comment">//调整g_IDT为在WinDbg中的显示地址</span><br>    g_IDT = ((g_IDT) &gt;&gt; <span class="hljs-number">16</span>) | <span class="hljs-number">0xffff000000000000</span>;<br>    <span class="hljs-comment">//获取某一个线性地址所在的页面的页表地址(线性地址)</span><br>    ULONG64 terget_address = g_IDT;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;g_IDT: %p\n&quot;</span>, (PVOID)g_IDT);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;g_Cr4: %p\n&quot;</span>, (PVOID)g_Cr4);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PTE: %p\n&quot;</span>, GetPteAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PDE: %p\n&quot;</span>, GetPdeAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PPE: %p\n&quot;</span>, GetPpeAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PXE: %p\n&quot;</span>, GetPxeAddress((PVOID)terget_address));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x64asmasm"><a class="markdownIt-Anchor" href="#x64asmasm"></a> x64asm.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x64asm.asm-&gt;实现64位c的混合汇编<br>option casemap:none<br><br>;结构体的定义,举个例子<br>IDTDescriptor STRUC  2<br>baseqword 0 <br>limitqword  0<br>IDTDescriptor ENDS<br><br>;这里的参数是引用的entry.c中的参数，所以在c代码中需要定义<br>EXTERN g_Cr4:qword<br>EXTERN g_IDT:qword<br><br>.DATA<br><br>.CODE<br><br>;获得Cr4的线性地址<br>Asm_Read_Cr4 PROC <br>mov rax,cr4<br>mov [g_Cr4],rax<br>ret<br>Asm_Read_Cr4 ENDP<br><br>;获取IDT的基址<br>Asm_Read_IDT PROC<br>sidt [g_IDT]<br>ret<br>Asm_Read_IDT ENDP<br><br>END<br></code></pre></td></tr></table></figure><h2 id="代码功能-2"><a class="markdownIt-Anchor" href="#代码功能-2"></a> 代码功能</h2><ul><li>对于9-9-9-9-12分页模式，这里在<code>entry.c</code>中进行相关模块的引用与注释介绍，在<code>scan.c</code>与<code>x64asm.asm</code>中实现相关函数的具体功能，在<code>commom.h</code>中实现相关结构体与变量的引用</li><li>这里简单讲解一下<code>scan.c</code>中实现的函数<ul><li>类<code>GetPteAddress</code>函数的功能就是根据基于页表基址的直接物理搜索的规则来进行公式的陈列。这里的<code>pte</code>就是在基址上左移12位–去掉后12位的物理属性，之后左移3位–乘以每个表项8位的长度，这样就得到了线性地址转换而来的它所属的<code>pte</code>地址(线性地址)</li><li><code>GetNtBaseAddress</code>则是获取了Nt模块的基址。这里对于本驱动中存储的<code>PLDR_DATA_TABLE_ENTRY pLDR_Head</code>链进行遍历，这个双向链表挂载着所有的驱动，由此经过驱动名称的比对找到相应的驱动，从而获得驱动的开始地址</li><li><code>GetPageAddress</code>则是根据Nt模块基址与相应公式，查找<code>pte</code>等表的<code>基址</code>(windbg中可以使用<code>!pte 0</code>查看)与计算线性地址的所属的页表地址。由于win10机制，每次开机的pte等基址会发生改变，所以需要对win10中Nt模块的源代码进行逆向，查找具体的偏移地址来查找pte等的基址。<ul><li>对于基址的查找都是使用<code>GetPteAddress</code>函数，这里可以理解为<strong>执行 PTE 所在物理页面的 PTE 是 PDE</strong>：就是说页表基址也是被一个PDT所指向的，所以可以根据页表地址来逆推出其他的基址。</li><li>这里同时根据某一个线性地址，实现了去查找它所属的pte,pde,ppe,pxe的页表开始地址</li><li>这里都是线性地址范畴，同时需要理解pte,pde,ppe,pxe的基址与地址的概念，它们都是一张张表构成的，基址指第一张表的开始地址，而地址指每一张表的开始地址</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VM保护攻防</title>
    <link href="/posts/6b79a6f5.html"/>
    <url>/posts/6b79a6f5.html</url>
    
    <content type="html"><![CDATA[<h1 id="vm保护攻防"><a class="markdownIt-Anchor" href="#vm保护攻防"></a> VM保护攻防</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win64_Kernel简述</title>
    <link href="/posts/9fe68f2a.html"/>
    <url>/posts/9fe68f2a.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>详细参考</p><ul><li><a href="https://lzyddf.blog.csdn.net/?type=blog">Windows x64内核学习笔记</a></li><li><a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467288">x64内核研究</a></li></ul></blockquote><h1 id="ia-32e模式"><a class="markdownIt-Anchor" href="#ia-32e模式"></a> IA-32e模式</h1><h2 id="前瞻"><a class="markdownIt-Anchor" href="#前瞻"></a> 前瞻</h2><p><strong>描述</strong>：</p><ul><li><p>在64位下，有两种<code>CPU</code>模式，一种是<code>IA-32e</code>模式，是<code>IA-32</code>模式的扩展，另一个是<code>Legacy</code>模式。<code>IA-32e</code>模式是指内核64位，用户64或32位均可，它强制平坦段，不支持任务切换；而<code>Legacy</code>模式指内核32位，用户32位支持非平坦段、任务切换、虚拟8086、实模式等。</p></li><li><p>在<code>IA-32e</code>模式下，代码段和数据段仍使用64位描述符，强制平坦（<code>FS</code>，<code>GS</code>除外）；<code>TSS</code>段描述符扩展到<code>128</code>位，<code>TSS</code>段不用来任务切换，主要保存一堆<code>rsp</code>备用指针；中断门描述符扩展到<code>128</code>位</p></li><li><p><strong>IA-32e</strong>是IA-32模式的扩展，它是一种状态，其内核为64位，用户可以是32位，也可以是64位</p></li><li><p>当在64位CPU中安装32位操作系统时，内核和用户都是32位的，这种状态叫做<strong>Legacy模式</strong></p></li></ul><p><strong>IA-32e模式的几个特性</strong>：</p><ul><li>强制平坦段：段基址不可随意设置，即不再兼容16位模式了。</li><li>不支持任务切换：取消了TSS任务切换</li><li>取消了虚拟8086模式和实模式切换</li></ul><h2 id="模式检测"><a class="markdownIt-Anchor" href="#模式检测"></a> 模式检测</h2><p><strong>描述</strong>：</p><ul><li>如果IA32_EFER MSR(下标为0xC0000080)寄存器的值第八位为1，说明当前系统处于IA-32e模式。</li></ul><h2 id="强制平坦段"><a class="markdownIt-Anchor" href="#强制平坦段"></a> 强制平坦段</h2><p><strong>描述</strong>：</p><ul><li><p>在x64模式下，段描述符已经不再描述段的基址和界限(除了FS和GS)，因此把这种机制叫做强制平坦段。</p></li><li><p>对于x64模式的gdt表来说，段描述符比x86系统少了很多，这是因为x64将侧重点放在了页保护而不是段保护。</p></li></ul><h2 id="任务切换"><a class="markdownIt-Anchor" href="#任务切换"></a> 任务切换</h2><p><strong>描述</strong>：</p><ul><li><p>在IA-32e模式下，TSS段描述符扩展到128位，用于满足寻址要求(普通段寄存器不再需要基址和界限)</p></li><li><p>TSS段描述符不用来进行任务切换，而是主要保存一堆RSP的备用指针(当3环和0环发生任务切换时)</p></li></ul><h2 id="中断门描述符"><a class="markdownIt-Anchor" href="#中断门描述符"></a> 中断门描述符</h2><p><strong>描述</strong>：</p><ul><li>在x64模式中，中断门描述符也拓展到了128位，这样才能满足寻址要求</li></ul><h2 id="fs-gs"><a class="markdownIt-Anchor" href="#fs-gs"></a> FS / GS</h2><p><strong>描述</strong>：</p><ul><li><p>在x64系统中，当处于0环时，FS不再指向KPCR，而是由GS指向KPCR，在3环时GS指向TEB</p></li><li><p>并且x64不再支持调用门、陷阱门、任务门，一律只支持中断门。</p></li><li><p>为什么要这么做呢？</p><ul><li>因为如果通过其他门进去后再去关中断，那么执行关中断的指令时，如果产生了外部中断，由于此时FS寄存器和GS寄存器还没被正确设置，因此可能会产生错误，而调用中断门时，系统会自动将EFLAGS中的IF位清零，即关闭外部中断。</li></ul></li><li><p>既然x64已经将段寄存器强制平坦了，FS和GS的基址该去哪里找呢？</p><ul><li>三个MSR寄存器。</li><li><code>IA32_FS_BASE</code>(下标0xC0000100)</li><li><code>IA32_GS_BASE</code>(下标0xC0000101)</li><li><code>IA32_KERNEL_GS_BASE</code>(下标0xC0000102)</li></ul></li></ul><h3 id="模式切换"><a class="markdownIt-Anchor" href="#模式切换"></a> 模式切换</h3><p><strong>中断</strong>：</p><ul><li>只使用一张IDT表，内核可以根据栈上的CS判断先前模式。</li></ul><p><strong>系统调用</strong>：</p><ul><li>只使用一张SSDT表</li><li>64位程序通过<code>syscall</code>进入内核</li><li>32位程序在<code>ring3转入x64模式</code>再进入内核</li></ul><h1 id="smep-smap"><a class="markdownIt-Anchor" href="#smep-smap"></a> SMEP &amp; SMAP</h1><ul><li><p><strong>SMEP</strong>：位于Cr4的第20位，作用是让处于内核权限的CPU无法执行用户代码</p></li><li><p><strong>SMAP</strong>：位于Cr4的第21位，作用是让处于内核权限的CPU无法读写用户代码</p><ul><li>STAC指令相当于Set AC，用于设置AC标志位，能暂时解除系统的一些保护，包括SMAP保护</li></ul></li><li><p>注意：</p><ul><li>即使解除这两个保护，也只能访问一部分0环内存，因为还存在内核页表隔离机制</li></ul></li></ul><h1 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h1><h2 id="9-9-9-9-12分页"><a class="markdownIt-Anchor" href="#9-9-9-9-12分页"></a> 9-9-9-9-12分页</h2><p><strong>描述</strong>：</p><ul><li><p>随着计算机技术的发展，64位系统逐渐占据主流地位，那么也就表示CPU的最大寻址范围为64位。但实际上，CPU只使用了其中的<strong>48位</strong>用于寻址，并使用<strong>9-9-9-9-12分页模式</strong>。即便如此，在未来较长一段时间里，48位寻址范围也足够大部分人的日常使用了</p></li><li><p>9-9-9-9-12分页表示物理地址拥有四级页表，在Intel开发手册中，将这四级页表分别称为<code>PML4E、PDPTE、PDE、PTE</code>，但微软的命名方式略有不同，将这四级页表分别称为 <code>PXE、PPE、PDE、PTE</code>，WinDbg中也是如此</p></li><li><p>对于地址 <code>21BABF52910</code>而言，先按照9-9-9-9-12分级，之后按照每一页占8个字节在<code>Cr3</code>的基础上寻找，这里最后3个字节的数据为物理页的属性，搜索的时候也是需要置零再进行相加搜索</p></li></ul><h2 id="页表基址"><a class="markdownIt-Anchor" href="#页表基址"></a> 页表基址</h2><h3 id="前瞻-2"><a class="markdownIt-Anchor" href="#前瞻-2"></a> 前瞻</h3><ul><li>操作系统会将当前进程的物理页映射在某个线性地址中，以供程序读取自己的页表内容</li><li>在x86系统中，页表基址是固定的，位于<code>0xC0000000</code>，将这个线性地址进行解析，访问其物理页的内容，会发现从这个地址开始，里面保存的数据为当前程序的所有物理页地址</li><li>而在x64系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的</li><li>可以在WinDbg中查看0地址对应的线性地址来确定当前的页表基址，这里可以看到 <code>PXE、PPE、PDE、PTE</code> 的页表基址(只有后48位才是有效地址)<ul><li>其中，每个物理页占8个字节，例如，第一个物理页地址位于线性地址0xFFFF800000000000，第二个物理页地址位于线性地址0xFFFF800000000008，每个物理页中包含1024个字节的数据</li></ul></li></ul><h3 id="定位基址"><a class="markdownIt-Anchor" href="#定位基址"></a> 定位基址</h3><ul><li>关于定位随机化页表基址，这里包含两种方法[<a href="https://bbs.kanxue.com/thread-254276.htm">原创]逆向TesSafe.sys有感：鹅厂是如何定位随机化的PTE_BASE-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></li><li>同时周壑老师的定位方法就是首先在WinDbg中定位内核模块的地址，然后在内核模块中搜索与当前<code>页表基址</code>相同的值出现的位置，接着，在IDA中定位到数据所在的位置，可以看到是某行代码引用了这个值的硬编码，在WinDbg中查看这段代码，能够识别到<code>CcUnpinFileDataEx</code>函数(<strong>这个函数不重要，只要是引用了页表基址的api都可以利用</strong>)<ul><li>那么，由于系统每次启动时基址是不固定的，因此这些值也不可能是固定的硬编码，肯定是有“人”对这些值进行了修改，在需要使用时，可以通过固定的偏移量提取硬编码，从而得到页表基址，但要注意不同版本的内核文件的偏移量可能是不同的</li><li>这里的本质就是通过NT模块+固定偏移来进行定位</li></ul></li></ul><h3 id="线性地址定位"><a class="markdownIt-Anchor" href="#线性地址定位"></a> 线性地址定位</h3><h4 id="pde-to-pxe首地址定位"><a class="markdownIt-Anchor" href="#pde-to-pxe首地址定位"></a> PDE to PXE首地址定位</h4><p>​这里知道了页表基址(线性地址，也是存储着PTI的表的地址)，由此可以知道 <code>PDE PPE PXE</code> 的基址(例如存储着PDT的表的地址)</p><ul><li><p><strong>执行 PTE 所在物理页面的 PTE 是 PDE</strong>：这里的意思就是页表基址也是被一个PDT所指向的，所以可以根据页表地址来逆推出其他的基址。</p></li><li><p><strong>通俗解释</strong>：<strong>页表基址本身也是一个线性地址</strong>，也需要有人来管理，因此将页表基址本身当做一个线性地址，向右移动12位能够得到PDE基址对应的PTI，再乘以8(每个物理页地址占8个字节)就能够得到PDE基址在页表基址中的偏移量，然后将这个偏移量再加上页表基址就能得到PDE基址所在的线性地址。同理，也能够通过PDE基址得到PPE基址和PXE基址的线性地址</p></li><li><p><strong>计算公式</strong>：</p><ul><li><p><code>PDE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PTE_BASE</code></p></li><li><p><code>PPE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PDE_BASE</code></p></li><li><p><code>PXE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PPE_BASE</code></p></li></ul></li></ul><h4 id="物理地址定位"><a class="markdownIt-Anchor" href="#物理地址定位"></a> 物理地址定位</h4><p>​这里知道了 <code>PXE、PPE、PDE、PTE</code> 的基址，来定位当前地址所在的 <code>PXE、PPE、PDE、PTE</code> 地址</p><ul><li><p><strong>计算公式</strong>：</p><ul><li><p>PTE = PTE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3</p></li><li><p>PDE = PDE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3</p></li><li><p>PPE = PPE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 30) &lt;&lt; 3</p></li><li><p>PXE = PXE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 39) &lt;&lt; 3</p></li></ul></li></ul><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><h1 id="kpti"><a class="markdownIt-Anchor" href="#kpti"></a> KPTI</h1><ul><li><strong>KPTI</strong>(Kernel page-table isolation)，即<strong>内核页表隔离机制</strong>。</li><li>通过在windbg中构造提权中断门以及关闭Cr4.SMEP/Cr4.SMAP，可以实现Supervisor执行用户层代码和访问数据，也可以映射内核KVASCODE段的数据(UserMode.Cr3/KernelMode.Cr3均有映射)</li><li>但是由于内核页表隔离机制的存在，内核的.text段并没有映射给UserMode.Cr3，而只映射给了KernelMode.Cr3</li><li>通过构造中断门进入自定义的中断服务例程时，其Cr3为UserMode.Cr3，而非KernelMode.Cr3。而通过Kernel.Cr3对页表映射解析时发现PXE.XD=1，即对KernelMode而言，该页面禁止执行(除非Cr4.SMEP=0&amp;&amp;XD=0)。Supervisor执行User物理页时需要满足Cr4.SMEP=0&amp;&amp;XD=0</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051624205.png" alt="image-20231005162409174" /></p><blockquote><p>注意：这里可能因为Windows的版本问题，导致Cr3在用户态和内核态读取的数值一样(新版的Windows可能不开KPTI保护)</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_43890959/article/details/125477733">x64(win10) KPTI 内核页表隔离机制</a></p><p><a href="https://lzyddf.blog.csdn.net/article/details/123228503?spm=1001.2014.3001.5502">Windows x64内核学习笔记（五）—— KPTI（未完待续）</a></p></blockquote><h1 id="lfencecfg"><a class="markdownIt-Anchor" href="#lfencecfg"></a> LFENCE&amp;CFG</h1><h2 id="lfence"><a class="markdownIt-Anchor" href="#lfence"></a> LFENCE</h2><p><strong>描述</strong>：</p><ul><li>在内核文件中，能够经常看到在某行jcc指令的下方存在一条lfence指令，它的功能是禁止CPU对后面的指令预测执行。虽然禁止预测执行产生了性能上的部分损耗，但是提高了系统整体的安全性</li></ul><h2 id="cfg"><a class="markdownIt-Anchor" href="#cfg"></a> CFG</h2><p><strong>描述</strong>：</p><ul><li><strong>控制流防护</strong>（Control Flow Guard，CFG）是微软在Windows10和Windows8.1Update3中默认启用的一种安全防护机制，它主要是用于在发生间接跳转时，检查目标地址的合法性。</li></ul><h3 id="_guard_dispatch_icall"><a class="markdownIt-Anchor" href="#_guard_dispatch_icall"></a> _guard_dispatch_icall</h3><p><strong>描述</strong>：</p><ul><li><p>_guard_dispatch_icall是<strong>CFG机制的派遣函数</strong></p></li><li><p>在内核中，许多函数都需要进行间接调用，出于安全性考虑，避免目标地址被控制，因此不会直接CALL目标地址，而是先通过_guard_dispatch_icall检查地址合法性，并由其进行调用，如果地址合法，它的作用相当于「CALL RAX」</p></li></ul><h1 id="patch-guard"><a class="markdownIt-Anchor" href="#patch-guard"></a> Patch Guard</h1><h2 id="patch-guard-2"><a class="markdownIt-Anchor" href="#patch-guard-2"></a> Patch Guard</h2><p><strong>描述</strong>：</p><ul><li>Patch Guard(简称PG)是Windows x64系统中用于<strong>保护内核代码完整性和安全性的保护机制</strong>，能够防止任何不受信任的代码或驱动程序修改内核代码，从而防止系统破坏和恶意软件的传播。Patch Guard在系统启动时进行验证，并在系统运行过程中定期执行检查以确保内核代码的完整性。如果发现任何不正确的修改，Patch Guard会使系统蓝屏并重启系统以确保安全性，蓝屏代码为0x109。</li></ul><p><strong>原理</strong>：</p><ul><li>读取内核中的数据，并与系统初始化时的值进行比较。</li></ul><h2 id="context结构体"><a class="markdownIt-Anchor" href="#context结构体"></a> Context结构体</h2><p><strong>描述</strong>：</p><ul><li>PG(内核补丁保护Patch Guard))检测<strong>通常</strong>基于 context 结构体。context 结构体是一个内存数据结构，包含了系统内核的重要信息，包括内核代码的状态、配置和数据。Patch Guard 使用这个 context 结构体来验证内核代码的完整性。在系统启动时，PG 会创建并存储 context 结构体，并在系统运行过程中定期检查这个结构体是否被修改。如果发现任何不正确的修改，Patch Guard 将会重启系统以确保安全性。</li></ul><h3 id="context基本规则"><a class="markdownIt-Anchor" href="#context基本规则"></a> Context基本规则</h3><p>(注意：随着微软更新，以下规则在不同版本的系统中不一定通用)：</p><ol><li>context大部分时间处于加密状态</li><li>context的数据源来自系统初始化时的最初数据</li><li>context的地址作为系统线程，随着DPC等调度被传递</li><li>context的执行周期约为2min，但是每次检测的目标区块是随机的</li><li>context采用接力的方式调度，具体流程包括自解密、检测逻辑、复制自身到新的context、加密新的context、销毁旧的context</li><li>context检测逻辑的调用源有随机性，在PG初始化时决定</li></ol><h3 id="context内容"><a class="markdownIt-Anchor" href="#context内容"></a> Context内容</h3><ol><li>一小段自解密代码</li><li>要用到的系统api指针</li><li>重要的api代码的copy</li><li>INITKDBG节的copy</li><li>要检测的目标地址、大小、checksum、构成的结构体数组</li><li>…</li></ol><h3 id="context结构体包含信息"><a class="markdownIt-Anchor" href="#context结构体包含信息"></a> Context结构体包含信息</h3><ul><li>内核代码的版本信息：用于验证系统内核代码是否是最新版本，以确保安全性</li><li>内核代码的配置信息：用于验证系统内核代码的配置是否正确，以确保系统可以正常运行</li><li>内核代码的数据信息：包括系统内核代码中使用的全局变量、缓存、内存页面等，用于验证内核代码的数据完整性</li><li>内核代码的状态信息：包括系统内核代码的执行状态、挂起的线程和中断处理程序等，用于验证内核代码的状态完整性</li></ul><h3 id="context结构体包含代码"><a class="markdownIt-Anchor" href="#context结构体包含代码"></a> context结构体包含代码：</h3><ul><li>初始化代码：在系统启动时，初始化代码将创建并存储 context 结构体</li><li>检查代码：定期检查代码将检查 context 结构体是否被修改，以确保内核代码的完整性</li><li>重启代码：如果发现任何不正确的修改，重启代码将重启系统以确保安全性</li><li>恢复代码：如果重启系统，恢复代码将恢复系统的正常运行</li></ul><p>​Context 结构体在<strong>大部分时间处于加密状态</strong>，这个过程是通过使用内核级的加密技术实现的，主要使用密钥来对 context 结构体进行加密，并在解密时使用同一密钥。这样，即使恶意代码试图访问或修改 context 结构体，其内容仍然是加密的，因此不可读取。内核级的加密技术在内核空间中实现，因此它需要特殊的权限才能访问。这样，可以保护 - context 结构体不被恶意代码访问</p><h2 id="攻击手法"><a class="markdownIt-Anchor" href="#攻击手法"></a> 攻击手法</h2><ul><li><p><strong>静态补丁</strong>：如直接将函数入口patch为ret，这种方法是最稳定的，唯一的缺点就是要重启才能生效。</p></li><li><p><strong>VT实现读/执行分离</strong>：这种方法是通过禁止执行关键的代码段来避免检测。这种方法可以通过使用虚拟化技术来实现，但不是所有系统都支持。</p></li><li><p><strong>定位所有的context调用源，针对性patch</strong>：这种方法是通过修改代码的特定部分来避免检测。这种方法需要对系统的代码有较深的了解，否则可能导致严重的后果。</p></li><li><p><strong>基于加密算法分析，攻击context的内容</strong>：这种方法是通过对context内容进行解密，并修改检测代码来避免检测。此方法需要深入了解加密算法和检测代码，并可能需要使用特殊工具。</p><ul><li><p>搜索内存，粗筛context</p></li><li><p>基于加密算法特性，定位context</p></li><li><p>解密context，patch检测逻辑，加密写回context</p></li></ul></li><li><p><strong>设置context页面不可执行，接管页面异常处理</strong>：这种方法是通过禁止对context页面的访问来避免检测。此方法需要在页面异常处理过程中进行操作，以防止检测逻辑的执行。</p><ul><li>搜索内存，粗筛context</li><li>hook patch fault，接管执行保护异常</li><li>在异常处理中定位context，阻止检测逻辑</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win32_Kernel简述</title>
    <link href="/posts/705b8369.html"/>
    <url>/posts/705b8369.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>详细参考：</p><ul><li><a href="https://lzyddf.blog.csdn.net/?type=blog">Windows x32相关笔记</a></li><li><a href="https://www.cnblogs.com/wingsummer/p/15420700.html">羽夏看 Win 系统内核</a></li><li><a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467296">Windows 内核实验</a></li><li><a href="https://bbs.kanxue.com/homepage-867232.htm">Windows 内核学习笔记</a></li><li><a href="https://catecat.gitee.io/tags/WinXP%E5%86%85%E6%A0%B8/">WinXP内核</a></li></ul></blockquote><h1 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h1><h2 id="visual-studio"><a class="markdownIt-Anchor" href="#visual-studio"></a> visual studio</h2><ul><li>针对主机的 <code>visual studio 2022</code>, 虚拟机中的 <code>VC6</code> 大部分适合</li><li>使用主机的调试的时候记得选择 <code>release</code>, 同时关闭 <code>ASLR</code> ，防止地址随机化</li></ul><table><thead><tr><th>任务</th><th>快捷键</th></tr></thead><tbody><tr><td>开始调试</td><td>F5</td></tr><tr><td>停止编译</td><td>Ctrl + F5</td></tr><tr><td>设定断点</td><td>F9</td></tr><tr><td>逐过程调试(可以跳过函数)</td><td>F10</td></tr><tr><td>逐语句调试</td><td>F11</td></tr><tr><td>跳到光标处</td><td>Ctrl + F10</td></tr><tr><td>跳出本循环</td><td>Shift + F11</td></tr><tr><td>生成项目</td><td>Ctrl + B</td></tr><tr><td>注释</td><td>Ctrl + /</td></tr></tbody></table><h2 id="windbg"><a class="markdownIt-Anchor" href="#windbg"></a> Windbg</h2><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><table><thead><tr><th>任务</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td>停止长调用</td><td style="text-align:left">Ctrl + Pause / Ctrl + 虚拟键盘(ctrl + win + o)中的ScrLK</td></tr><tr><td>查看寄存器</td><td style="text-align:left">r eax/gdtr    r–将通用的一些寄存器显示出来</td></tr><tr><td>查看内存</td><td style="text-align:left">dq/dd/dw/db [地址:b1b3ddb0] 如果是物理地址的话，就是 !dd [地址]</td></tr><tr><td>查看反编译</td><td style="text-align:left">u–将某一地址之后的内容反编译显示</td></tr><tr><td>修改内存数据</td><td style="text-align:left">eq ……(与上面同)</td></tr><tr><td>单步执行</td><td style="text-align:left">t–step into    p–step over</td></tr><tr><td>继续执行</td><td style="text-align:left">g</td></tr><tr><td>某一地址下断点</td><td style="text-align:left">bp 0040103d</td></tr><tr><td>断点操作</td><td style="text-align:left">bl–列出断点   bc ID–清除断点，这个ID首先需要bl查看</td></tr><tr><td>进程信息</td><td style="text-align:left">!process 0 0 显示进程列表</td></tr></tbody></table><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>windbg中可能会有残留数据存在，所以在使用时注意之前的残留，例如<code>!process 0 0</code>会有之气那的进程残存。这里其 <code>HandleCount</code> 为0则代表无效</li></ul><h1 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式"></a> 保护模式</h1><h2 id="关于段"><a class="markdownIt-Anchor" href="#关于段"></a> 关于段</h2><h3 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器"></a> 段寄存器</h3><ul><li>96位，<strong>ES、CS、SS、DS、FS、GS、LDTR、TR</strong></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023819.png" alt="image-20230912195711665" /></p><h3 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子"></a> 段选择子</h3><ul><li>16位</li><li>Index：处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023767.png" alt="image-20230912195749416" /></p><h3 id="gdt"><a class="markdownIt-Anchor" href="#gdt"></a> GDT</h3><h4 id="相关知识点"><a class="markdownIt-Anchor" href="#相关知识点"></a> 相关知识点</h4><ul><li><p><code>GDT</code>为全局描述符表, 段描述符的大小为64位, <code>GDTR</code> 为存储其位置的寄存器(48位)</p></li><li><p>段选择子16位，段寄存器96位</p></li><li><p>段寄存器</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023827.png" alt="image-20230918091401476" /></p><ul><li>段描述符</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023843.png" alt="image-20230912180656323" /></p><ul><li>区分：<ul><li>红色–<code>base</code></li><li>绿色–<code>seagment limit</code></li><li>蓝色–<code>Type</code><ul><li>S=1时，第4位为1为代码段，反之为数据段</li><li>C=1时，代表一致代码段，反之为非一致代码段</li></ul></li><li>黑色9–<code>P DPL S</code><ul><li>P=1描述符有效</li><li>S=1为代码段或者数据段</li></ul></li><li>黑色c–<code>G D/B 0 AVL</code></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023814.png" alt="image-20230912181129051" /></p><ul><li>参考：<a href="https://www.cnblogs.com/wingsummer/p/15312627.html">段描述符与段选择子</a></li></ul><h4 id="相关指令"><a class="markdownIt-Anchor" href="#相关指令"></a> 相关指令</h4><ul><li><code>r gdtr </code>指令表示读取GDT表的地址</li><li><code>r gdtl</code> 指令表示读取GDT的大小</li><li><code>dp gtdr l40</code> 指令查看gdt表中大小为40个int(32位)的空间</li></ul><h3 id="代码段之间跳转"><a class="markdownIt-Anchor" href="#代码段之间跳转"></a> 代码段之间跳转</h3><ul><li><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段，<strong>它们不同做的权限检查就不同</strong>。同时修改<code>CS</code>与<code>EIP</code>的指令如下：<code>JMP FAR</code>/<code>CALL FAR</code>/<code>RETF</code>/<code>INT</code>/<code>IRETED</code></p></li><li><p>段间跳转只使用 <code>JMP FAR</code>, 即长跳转</p></li><li><p>跳转规则：</p><ul><li>对于一致代码段，也称为共享段：<ul><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li><li>要求：<code>CPL</code>&gt;=<code>DPL</code></li></ul></li><li>对于非一致代码段：<ul><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态</li><li>要求：<code>CPL</code>==<code>DPL</code>且<code>RPL</code>&lt;=<code>DPL</code></li></ul></li></ul></li><li><p>跳转步骤：</p><ol><li>段选择子拆分–记住最后3位为<code>TI RPL</code>, 所以每次选择需要<code>i * 0x8</code></li><li>查表得到段描述符</li><li>权限检查–<code>CPL DPL RPL</code></li><li>加载段描述符–加载到 <code>CS</code> 段寄存器(96位)中</li><li>代码执行–<code>CPU</code>将<code>CS.Base + Offset</code>的值写入<code>EIP</code>然后跳转到将要执行的<code>CS:EIP</code>处的代码，段间跳转结束</li></ol></li><li><p>在跳转过程中, <code>CPL</code>不会发生改变，提权只能通过调用门</p></li></ul><h2 id="关于门"><a class="markdownIt-Anchor" href="#关于门"></a> 关于门</h2><h3 id="idt"><a class="markdownIt-Anchor" href="#idt"></a> IDT</h3><h4 id="相关知识点-2"><a class="markdownIt-Anchor" href="#相关知识点-2"></a> 相关知识点</h4><ul><li><code>IDT</code>为中断描述符表, <code>IDTR</code> 为存储其位置的寄存器，与<code>GDT</code>类似</li><li><code>IDT表</code>包含3种门描述符：任务门描述符、中断门描述符、陷阱门描述符</li></ul><h4 id="相关指令-2"><a class="markdownIt-Anchor" href="#相关指令-2"></a> 相关指令</h4><ul><li><code>r gdtr </code>指令表示读取GDT表的地址</li><li><code>r gdtl</code> 指令表示读取GDT的大小</li><li><code>dp gtdr l40</code> 指令查看gdt表中大小为40个int(32位)的空间</li></ul><h3 id="调用门"><a class="markdownIt-Anchor" href="#调用门"></a> 调用门</h3><ul><li>存储在GDT表中</li><li>长调用:<strong>CALL CS:EIP</strong>, 其中 <code>EIP</code> 废弃，<code>CS</code>为指向<code>调用门</code>的段选择子<ul><li>长调用不提权, 调用者CS入栈(相较于短调用所增加的)</li><li>长调用提权， 调用者SS, 调用者ESP, 调用者CS入栈</li></ul></li><li>指令格式：<code>CALL CS:EIP (EIP是废弃的)</code></li><li>执行流程：<ul><li>根据<code>CS</code>的值查<code>GDT表</code>，找到对应的段描述符且该描述符是一个调用门</li><li>在调用门描述符中存储另一个代码段的段选择子，将其加载到<code>CS</code>中(这里CS就发生了变化)</li><li>选择子指向的段的<code>Base</code>(Srgment Selector指向的代码段的base) + <code>偏移地址</code>(Offset in Segment)就是真正要执行的地址<ul><li>这里注意 <code>Segment Selector</code> 的值，当这里指向 <code>00cf9b00 0000ffff</code>(在它为0008,这里为代码段描述符，与下方的调用门格式不同) 时会显示报错，而指向 <code>00cf9a00 0000ffff</code>(存放在自己定义的地址) 则可以正常访问内核的内存</li><li>这里找出了问题所在，<code>0008</code> 位置的访问一直出现问题，把这个位置的数据放在别的地方就可以正常运行，由此里的访问需要重新指定位置(可能是我电脑的原因，maybe)</li></ul></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023810.png" alt="image-20230912200012728" /></p><ul><li><code>CS</code> 的值可以根据地址直接得出</li></ul><h3 id="中断门"><a class="markdownIt-Anchor" href="#中断门"></a> 中断门</h3><ul><li><p>指令格式：<code>INT N (N为中断门索引号)</code></p></li><li><p>执行步骤：</p><ol><li>在没有权限切换时，会向堆栈顺次压入<code>EFLAG</code>、<code>CS</code>和<code>EIP</code>；如果有权限切换，会向堆栈顺次压入<code>SS</code>、<code>ESP</code>、<code>EFLAG</code>、<code>CS</code>和<code>EIP</code></li><li><code>CPU</code> 会索引到 <code>IDT</code> 表。后面的 <code>N</code> 表示查 <code>IDT表</code> 项的下标。对比调用门，中断门没有了 <code>RPL</code>，故 <code>CPU</code> 只会校验 <code>CPL</code></li><li>在中断门中,不能通过 <code>RETF</code> 返回，而应该通过 <code>IRET</code>/<code>IRETD</code> 指令返回</li></ol><ul><li>这里也要注意真正执行地址也是 <code>Base</code> + <code>偏移地址</code>, 所以这里也会索引到 <code>GDT</code>的一个一致代码段</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023237.png" alt="image-20230912200532795" /></p><ul><li>补充：<ul><li>图中的 <code>D</code> 为1表示为32位</li></ul></li></ul><h3 id="陷阱们"><a class="markdownIt-Anchor" href="#陷阱们"></a> 陷阱们</h3><ul><li>陷阱门执行流程一模一样。与中断门的区别，中断门执行时，将 <code>IF位</code> 清零,使得可以屏蔽中断(关中断) 但陷阱门不会</li><li>关于中断(这里指可屏蔽中断)<ul><li><code>CLI</code> 禁止中断发生，关中断，使中断标志(IF) = 0</li><li><code>STI</code> 允许中断发生，开中断，使中断标志(IF) = 1</li><li>关闭中断指不允许其他操作引起中断，使处理器被其余程序所调用</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023254.png" alt="image-20230912202407828" /></p><h3 id="任务门"><a class="markdownIt-Anchor" href="#任务门"></a> 任务门</h3><ul><li>任务段(TSS)</li></ul><p>​这里需要首先知道TSS段描述符的概念，它是一个系统段描述符，TSS主要作用就是换掉一堆的寄存器，这里也是权限切换时 <code>ESP</code> 与 <code>SS</code> 的来源</p><ul><li><p>描述</p><ul><li>任务门存在于<strong>IDT表</strong></li><li>任务门中包含<strong>TSS段选择子</strong></li><li>可以通过访问任务门达到<strong>切换TSS</strong>的目的</li></ul></li><li><p>执行流程</p><ol><li><p>通过<code>INT N</code> (N为IDT表索引号)的指令进行触发任务门</p></li><li><p>查<code>IDT</code>表，找到对应的任务门描述符</p></li><li><p>通过任务门描述符，则根据任务门描述符中<code>TSS段选择子</code>查找<code>GDT表</code>，找到<code>TSS段描述符</code></p></li><li><p>将TSS段描述符中的值加载到<code>TR</code>寄存器</p></li><li><p>TR段寄存器通过Base和Limit找到<code>TSS</code></p></li><li><p>使用TSS中的值修改寄存器</p></li><li><p><code>IRETD</code>返回</p></li></ol></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023261.png" alt="image-20230913092034031" /></p><h2 id="关于页"><a class="markdownIt-Anchor" href="#关于页"></a> 关于页</h2><h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3><ul><li>地址分为有效地址，线性地址，物理地址<ul><li><code>0x12345678</code> 有效地址</li><li><code>ds.Base + 0x12345678</code> 线性地址</li></ul></li></ul><h3 id="cr3"><a class="markdownIt-Anchor" href="#cr3"></a> Cr3</h3><ul><li>控制寄存器<ul><li>每个进程都有一个Cr3(准确的说是都有一个Cr3的值，Cr3本身是个寄存器，一个核，只有一套寄存器)</li><li>Cr3指向一个物理页，一共4096字节</li></ul></li><li>通过Cr3来找物理地址<ul><li>找第一层和第二层的时候要将<strong>索引 * 4</strong> (每个地址占4个字节)----三次<code>!dd</code>找到位置</li><li>每找到一层都要将地址后三位(3个字节) <strong>属性位</strong> 清零再继续找下一层</li></ul></li></ul><p>​在所有的寄存器中，只有Cr3存储的是<strong>物理地址</strong>，其它寄存器存的都是<strong>线性地址</strong>, Cr3所存储的物理地址指向了一个<strong>页目录表(PDT)</strong>, 在Windows中，一个页的大小通常为<strong>4KB</strong>，即一个页可以存储<strong>1024个</strong>页目录表项(PDE)</p><h3 id="10-10-12"><a class="markdownIt-Anchor" href="#10-10-12"></a> 10-10-12</h3><ol><li>一个物理页的大小为<strong>4096字节</strong>，即<strong>2的12次方</strong>，若要遍历整个物理页，则需要12个比特位</li><li>一个页表有1024个页表项，1024等于2的十次方，即需要10个比特位</li><li>页目录表项同理，也需要10个比特位</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023346.png" alt="image-20230913092144120" /></p><h3 id="pdt与ptt"><a class="markdownIt-Anchor" href="#pdt与ptt"></a> PDT与PTT</h3><h4 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h4><p>​<strong>页目录表(PDT)</strong> 的每一项元素称为 <strong>页目录表项(PDE)</strong>, 每个页目录表项指向一个 页表(PTT), 每个页表的大小为 <strong>4KB</strong>，即一个页表可以存储 <strong>1024个</strong> 页表项(PTE) ----4096(4KB)/4(每个页表项32位)</p><p>​页表(PTT) 的每一个元素称为 页表项(PTE), 页表项(PTE) 所指向的才是真正的物理页</p><ul><li>特征<ul><li>PTE可以指向一个物理页，也可以不指向物理页</li><li>多个PTE可以指向一个物理页</li><li>一个PTE只能指向一个物理页</li></ul></li></ul><h4 id="物理页属性"><a class="markdownIt-Anchor" href="#物理页属性"></a> 物理页属性</h4><p>​物理页属性 = <code>PDE属性</code> &amp; <code>PTE属性</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023317.png" alt="image-20230913094214169" /></p><ul><li><p>P 位</p><ul><li>表示<code>PDE</code>或者<code>PTE</code>是否有效，如果有效为<code>1</code>，反之为<code>0</code></li></ul></li><li><p>R/W 位</p><ul><li>如果<code>R/W = 0</code>，表示是只读的，反之为可读可写</li></ul></li><li><p>U/S 位</p><ul><li>如果<code>U/S = 0</code>，则为特权用户(super user)，即非3环权限。反之，则为普通用户，即为3环权限</li></ul></li><li><p>PS位</p><ul><li>这个位只对<code>PDE</code>有意义。如果<code>PS == 1</code>，则<code>PDE</code>直接指向物理页，不再指向<code>PTE</code>，低22位是页内偏移。它的大小为<code>4MB</code>，俗称“大页”</li></ul></li><li><p><code>PWT</code>全称为<code>Page Write Through</code>，<code>PWT = 1</code>时，写<code>Cache</code>的时候也要将数据写入内存中。</p></li><li><p><code>PCD</code>全称为<code>Page Cache Disable</code>，<code>PCD = 1</code>时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在<code>TLB</code>中了，可能不需要再缓存了。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>页表被映射到了从<code>0xC0000000~0xC03FFFFF</code>的<strong>4M</strong>地址空间</li><li>在这1024个表中有一张特殊的表：<strong>页目录表</strong></li><li>页目录被映射到了0xC0300000开始处的<strong>4K</strong>地址空间</li></ol><ul><li><p>访问页目录表的公式：<code>0xC0300000 + PDI * 4</code></p></li><li><p>这里线性地址 <code>0xc0300000</code> 解析出来指向 <code>PDT</code> 表的第一项，所以我们使用 <code>0xc0300000 + k*4</code> 就可以获得第 <code>k+1</code> 项 <code>PDE</code> 的地址</p></li><li><p>访问页表的公式：<code>0xC0000000 + PDI * 4096 + PTI * 4</code></p></li><li><p>而线性地址 <code>0xc0000000</code> 解析出来指向第一个 <code>PDE</code> 指向的 <code>PTT</code> 表的第一项，所以我们使用<code>0xc0000000 + i*0x1000 + j*4</code> 就可以得到第 <code>i+1</code> 项 <code>PDE</code> 指向的 <code>PTT</code> 表中的第 <code>j+1</code>项 <code>PTE</code> 的地址</p></li></ul><h4 id="关注"><a class="markdownIt-Anchor" href="#关注"></a> 关注</h4><ul><li>修改一个高2G线性地址的<code>PDE</code>/<code>PTE</code>属性，实现<code>Ring3</code>可读<ul><li>这里还要更改别的地方的选项<a href="https://lzyddf.blog.csdn.net/article/details/102627239">博客</a>, 需要看情况修改PDE与PTE的 <code>U/S</code> 位为1，赋予3环的读取权限, 否则不能读取成功</li><li>对于羽夏的教程，这里大页更改也是更改 <code>U/S</code> 位，而不是它写的直接更改一个怪异的物理页</li></ul></li></ul><h3 id="2-9-9-12pae分页"><a class="markdownIt-Anchor" href="#2-9-9-12pae分页"></a> 2-9-9-12(PAE分页)</h3><ul><li><p>这里的 <code>windbg</code> 记得使用 <code>!dq</code> 来查看地址</p></li><li><p>每个<code>PDE</code>和<code>PTE</code>被扩展为8个字节，物理地址描述的位数扩展为<code>24位</code>，故可以描述更多的物理页，但个数减半，变成了512个</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023341.png" alt="image-20230915101737336" /></p><h3 id="pdpttpdtptt"><a class="markdownIt-Anchor" href="#pdpttpdtptt"></a> PDPTT,PDT,PTT</h3><h4 id="pdpte"><a class="markdownIt-Anchor" href="#pdpte"></a> PDPTE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023713.png" alt="image-20230915105429306" /></p><ul><li><code>PDPTE</code> 的12-35位存储了页目录表基址的高24位，低12位(在图上显示)补零, 共36位，即页目录基址。</li></ul><h4 id="pde"><a class="markdownIt-Anchor" href="#pde"></a> PDE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023783.png" alt="image-20230915105902929" /></p><ul><li><p>第7位 <code>PS</code> = 1 时，PDE直接指向大页，21-35(15位)指向大页的物理地址，这样36位的物理地址中低21位为0，即页的大小为2MB，且都是2MB对齐；当 <code>PS</code> = 0 时，21-35是页表基址，低12位补0，共36位。</p></li><li><p>解释一下G位，G=1表示这是全局页，是多个进程共享的，这种页是通过 CreateFileMapping 申请的, G=1，即为全局页，进程（CR3）切换时，TLB中的记录不会被刷新; 与之对应的，G=0就是进程独享的物理页，这种页是通过 VirtualAlloc 分配的。</p></li></ul><h4 id="pte"><a class="markdownIt-Anchor" href="#pte"></a> PTE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023762.png" alt="image-20230915111153273" /></p><ul><li>PTE中12-35是物理页基址, 24位, 低12位补0。</li><li>物理页基址 + 12位的页内偏移指向具体数据</li></ul><h4 id="xd标志位"><a class="markdownIt-Anchor" href="#xd标志位"></a> XD标志位</h4><ul><li>AMD中称为NX，即 No Excetion</li><li>PDE/PTE结构</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023858.png" alt="image-20230915111442369" /></p><ul><li>段的属性有可读、可写和可执行; 页的属性有可读、可写</li><li>当RET执行返回的时候，如果把堆栈里面的数据指向一段提前准备好的数据(把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是)，那么就会产生任意代码执行的后果。 所以，Intel就在这方面做了硬件保护，设置了一个不可执行位 – XD/NX位。</li><li>当XD=1时，软件产生了溢出也没有关系，即使EIP蹦到了危险的“数据区”，也是不可以执行的在PAE分页模式下，PDE与PTE的最高位为XD/NX位.</li></ul><h3 id="plb"><a class="markdownIt-Anchor" href="#plb"></a> PLB</h3><table><thead><tr><th>LA（线性地址）</th><th>PA（物理地址）</th><th>ATTR（属性）</th><th>LRU（统计）</th></tr></thead><tbody><tr><td>0x81010111</td><td>……</td><td>……</td><td>1</td></tr></tbody></table><p>对于<code>TLB</code>，给出如下说明：<br />  1. ATTR（属性）：如果是<code>2-9-9-12</code>分页，属性是<code>PDPE</code>、<code>PDE</code>、<code>PTE</code>三个属性共同决定的。如果是<code>10-10-12</code>分页就是<code>PDE</code>和<code>PTE</code>共同决定。<br />  2. 不同的<code>CPU</code>这个表的大小不一样。<br />  3. 只要<code>Cr3</code>变了，<code>TLB</code>立马刷新，一核一套<code>TLB</code></p><h3 id="控制寄存器"><a class="markdownIt-Anchor" href="#控制寄存器"></a> 控制寄存器</h3><p>​Cr0、Cr1、Cr2、Cr3，<code>Cr1</code>被保留了，<code>Cr3</code>用于页目录表基址</p><h4 id="cr0"><a class="markdownIt-Anchor" href="#cr0"></a> Cr0</h4><p>​<code>Cr0</code>是一个十分重要的寄存器，可以说它是总开关的集合体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023094.png" alt="image-20230917155626976" /></p><h4 id="cr2"><a class="markdownIt-Anchor" href="#cr2"></a> Cr2</h4><p>​当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023097.png" alt="image-20230917155703341" /></p><h4 id="cr4"><a class="markdownIt-Anchor" href="#cr4"></a> Cr4</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023236.png" alt="image-20230917155724613" /></p><ul><li><code>PAE</code>用于确认是哪个分页，<code>PAE = 1</code>，是<code>2-9-9-12</code>分页，<code>PAE = 0</code>是<code>10-10-12</code>分页</li><li><code>PSE</code>是大页是否开启的总开关，如果置0，就算<code>PDE</code>中设置了大页你也得是普通的页</li></ul><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><h2 id="前瞻"><a class="markdownIt-Anchor" href="#前瞻"></a> 前瞻</h2><p>​几个重要的dll</p><ul><li><code>Kernel32.dll</code>: 最核心的功能模块，比如管理内存、进程和线程相关的函数等</li><li><code>User32.dll</code>: 是Windows用户界面相关应用程序接口,如创建窗口和发送消息等</li><li><code>GDI32.dll</code>: 全称是Graphical Device Interface(图形设备接口)，包含用于画图和显示文本的函数。比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li><li><code>Ntdll.dll</code>: 大多数API都会通过这个DLL进入内核(0环)</li></ul><h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2><h3 id="3环进0环"><a class="markdownIt-Anchor" href="#3环进0环"></a> 3环进0环</h3><ul><li>API通过<code>中断门</code>进0环<ul><li>固定中断号为0x2E</li><li>CS/EIP由门描述符提供，ESP/SS由TSS提供</li><li>进入0环后执行的内核函数：<code>NT!KiSystemService</code></li></ul></li><li>API通过<code>sysenter</code>指令进0环<ul><li>CS/ESP/EIP 由MSR寄存器提供(SS是算出来的)</li><li>进入0环后执行的内核函数：<code>NT!KiFastCallEntry</code></li></ul></li></ul><h3 id="保存现场"><a class="markdownIt-Anchor" href="#保存现场"></a> 保存现场</h3><h4 id="tarp-frame"><a class="markdownIt-Anchor" href="#tarp-frame"></a> Tarp Frame</h4><ul><li>无论是通过中断门进入0环，还是通过快速调用进入0环，进入0环前(3环)的所有寄存器都会存到这个结构体中</li><li>这个结构体本身处于0环，由windows操作系统进行维护</li><li>当程序通过中断门从3环进入0环时，ESP指向 <code>TrapFrame+0x64 </code> 的位置<ul><li>在<strong>KiSystemService</strong>函数开始执行时，3环的<code>SS</code>、<code>ESP</code>、<code>EFLAGS</code>、<code>CS</code>、<code>EIP</code>就已经被 CPU 存储到 Trap Frame 结构体</li></ul></li><li>当程序通过快速调用从3环进入0环时，ESP指向 <code>TrapFrame+0x78</code> 的位置<ul><li>这里需要该函数进行压栈处理</li></ul></li></ul><h3 id="系统服务表"><a class="markdownIt-Anchor" href="#系统服务表"></a> 系统服务表</h3><ul><li><p>系统服务表：<code>System Service Table</code></p></li><li><p>系统服务表共有<strong>两张</strong>，第一张表后紧接第二张表</p></li><li><p>系统服务表里的函数都是来自<strong>内核文件</strong>导出的函数</p></li><li><p>它并不包含内核文件导出的所有函数，而是<strong>3环最常用的</strong>内核函数</p></li><li><p>系统服务表位于 <code>_KTHREAD +00xE0</code></p></li></ul><h3 id="ssdt"><a class="markdownIt-Anchor" href="#ssdt"></a> SSDT</h3><ul><li><p>全称：<strong>System Services Descriptor Table</strong>（系统服务描述符表）</p></li><li><p>SSDT的<strong>每个成员</strong>叫做<strong>系统服务表</strong></p></li><li><p>SSDT的<strong>第一个成员是导出的</strong>，声明一下即可使用</p></li><li><p>SSDT的<strong>第二个成员是未导出的</strong>，需要通过其它方式查找</p></li><li><p>在Windows中，SSDT的<strong>第三个成员和第四个成员未被使用</strong></p></li></ul><h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1><h2 id="前瞻-2"><a class="markdownIt-Anchor" href="#前瞻-2"></a> 前瞻</h2><p>​关注几个结构体</p><ul><li><p>进程</p><ul><li>EPROCESS<ul><li><code>Pcb</code> _KPROCESS</li><li><code>Peb</code> Ptr32 _PEB</li></ul></li></ul></li><li><p>线程</p><ul><li>ETHREAD<ul><li><code>Tcb</code> _KTHREAD</li><li><code>Teb</code> Ptr32 Void</li></ul></li></ul></li><li><p>CPU</p><ul><li>KCPR<ul><li><code>NtTib</code>    _NT_TIB</li><li><code>PrcbData</code> _KPRCB</li></ul></li></ul></li></ul><h2 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h2><h3 id="线程切换"><a class="markdownIt-Anchor" href="#线程切换"></a> 线程切换</h3><ul><li>主动切换<ul><li>Windows中绝大部分API都调用了<strong>SwapContext</strong>这个函数，也就是说，只要调用了该函数，就会导致线程切换</li><li>线程切换时会比较是否属于同一个进程，如果不是，便切换Cr3，Cr3换了，进程也就切换了</li><li><strong>KiSwapThread</strong> -&gt; <strong>KiSwapContext</strong> -&gt; <strong>SwapContext</strong></li></ul></li><li>时钟切换<ul><li>当前线程的CPU时间片到期</li><li><strong>KiDispatchInterrupt</strong> -&gt; <strong>KiQuantumEnd</strong> -&gt; <strong>SwapContext</strong></li><li>存在备用线程(<code>KPCR.PrcbData.NextThread</code>)</li><li><strong>KiDispatchInterrupt</strong> -&gt; <strong>SwapContext</strong></li></ul></li><li>异常处理<ul><li>如果一个线程<strong>不调用API</strong>，并且在代码中<strong>屏蔽中断</strong>（调用CLI指令），并且<strong>不会出现异常</strong>，那么当前线程将永久占有CPU</li><li>单核CPU占用率100%，2核CPU占用率50%</li><li>Windows<strong>并非</strong>是“抢占式”操作系统，所谓的“抢“”必须是当前线程允许其它线程“抢”，否则是“抢”不到的</li></ul></li></ul><h1 id="apc相关"><a class="markdownIt-Anchor" href="#apc相关"></a> APC相关</h1><h2 id="前瞻-3"><a class="markdownIt-Anchor" href="#前瞻-3"></a> 前瞻</h2><ol><li>线程是不能被“<strong>杀掉</strong>”、“<strong>挂起</strong>”、“<strong>恢复</strong>”的，线程在执行的时候自己占据着CPU，别人不能控制它</li><li>举个极端的例子：如果<strong>不调用API</strong>，<strong>屏蔽中断</strong>，<strong>并保证代码不出现异常</strong>，线程将<strong>永久</strong>占用CPU</li><li>所以说线程如果想“死”，一定是自己执行代码把自己杀死，不存在“他杀”的情况</li></ol><p>​即这里想改变一个线程的行为，可以给他提供一个函数，让它自己去调用：<strong>APC(Asyncroneus Procedure Call，异步过程调用)</strong></p><h2 id="重点-2"><a class="markdownIt-Anchor" href="#重点-2"></a> 重点</h2><h3 id="结构体相关"><a class="markdownIt-Anchor" href="#结构体相关"></a> 结构体相关</h3><ul><li><code>ApcState</code> _KAPC_STATE: 在 KTHREAD 中存在的一个结构体，其中有元素指向 KAPC 结构体</li></ul><h3 id="挂入过程"><a class="markdownIt-Anchor" href="#挂入过程"></a> 挂入过程</h3><ul><li>用户层调用：QueueUserAPC(kernel32.dll)–&gt;NtQueueApcThread(ntosker.exe)–&gt;内核层</li><li>很多内核函数调用：KeInitializeApc(分配空间 初始化KAPC结构体)–&gt;KeInsertQueueApc–&gt;KiInsertQueueApc(将KAPC插入指定APC队列)</li></ul><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>内核APC执行过程，执行点：线程切换</p><ol><li><code>SwapContext</code> 判断是否有内核APC</li><li><code>KiSwapThread</code></li><li><code>KiDeliverApc</code> 执行内核APC函数</li></ol><p>用户APC执行过程</p><ul><li>执行用户APC时的堆栈操作处理用户APC要比内核APC复杂的多，因为，用户APC函数要在用户空间执行的，这里涉及到大量换栈的操作：</li></ul><ol><li>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等(<code>_Trap_Frame</code>)，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。</li><li>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核–&gt;用户空间–&gt;再回到内核空间</li></ol><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><ol><li>内核APC在线程切换时执行，不需要换栈，比较简单，一个循环执行完毕</li><li>用户APC在系统调用、中断或异常返回3环前会进行判断，如果有要执行的用户APC，再执行</li><li>用户APC执行前会先执行内核APC</li></ol><h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1><h2 id="x86"><a class="markdownIt-Anchor" href="#x86"></a> x86</h2><p><a href="http://betacat.github.io/2011/10/19/SEH-x86/">资料</a></p><ul><li>CPU异常与模拟异常----3环</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023222.png" alt="image-20231001144040446" /></p><ul><li><code>KiDispatchException</code><ul><li>对于0环异常，直接处理</li><li>对于3环异常，修改返回3环的 EIP ，使其指向 KiUsertExceptionDispatcher</li></ul></li><li>3环返回 <code>KiUsertExceptionDispatcher</code> 函数，然后它又调用 RtlDispatchExceptin，这个函数就是查找异常处理程序在哪里</li><li><code>RtlDispatchExceptin</code><ul><li>首先查找 <code>VEH</code></li><li>若是没有，则查找 <code>SEH</code><ul><li>SEH是线程相关的，实际上是一个链表，指向异常处理函数在哪里</li><li>这里展示经过编译器扩展的SEH，这里自己先在栈中构建一个结构体，然后使 <code>prev</code> 指向之前的结构体，然后让 <code>FS:[0]</code> 指向自己；</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023309.png" alt="image-20231001145115314" /></li><li>之后这里 <code>scopetable</code> 的作用就是指向构建 <code>excrpt()</code> 所需要的处理函数。这里也适合 <code>finally</code> 区别在于它的过滤函数为空，然后在后面会执行一个局部展开，来调用位于 <code>scopetable_entry </code>异常处理程序地址的 <code>finally</code> 代码来执行</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023504.png" alt="image-20231001145312210" /></li><li>这里总体流程就是先把自己构建的结构体加入到 SEH 链中，然后使用只在最开始构造的 <code>handler</code> 来对不同的try异常进行分发处理，它根据 <code>trylevel</code> 来寻找不同的 <code>scopetable</code> 来寻找过滤函数和异常处理函数来处理异常，若是没有找到(这里就是过滤函数的返回值，返回0表示不处理这个异常)，则根据 <code>scopetable_entry</code> 结构体中的 <code>previous TryLevel</code> 寻找它的上层处理函数，直到可以处理，或者找到了 <code>-1</code> 表示最高层也不能处理结束，交给编译器处理</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023571.png" alt="image-20231001144903487" /></li></ul></li></ul></li></ul><h2 id="x64"><a class="markdownIt-Anchor" href="#x64"></a> x64</h2><p><a href="https://www.pediy.com/kssd/pediy12/142371.html">资料</a></p><h1 id="驱动开发"><a class="markdownIt-Anchor" href="#驱动开发"></a> 驱动开发</h1><h2 id="内核编程"><a class="markdownIt-Anchor" href="#内核编程"></a> 内核编程</h2><h3 id="内核函数"><a class="markdownIt-Anchor" href="#内核函数"></a> 内核函数</h3><ul><li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档</li><li>WDK查到的函数就一定在导出表里：<ul><li>文档化函数：函数在导出表里，有文档说明，有头文件</li><li>未文档化函数：导出表里有，没有文档说明，没有头文件，定义<strong>函数指针</strong>去使用(<code>*pFN = GetProcessAddress(&quot;xyz&quot;)</code>)</li><li>未导出函数：不在导出表，无文档说明，没有头文件，可以找到该函数的地址，然后使用<strong>函数指针</strong>去使用(<code>*pFN = 0x89765786</code>)<ul><li>WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。如果要使用未导出的函数，只要定义一个<strong>函数指针</strong>，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：<ul><li>特征码搜索</li><li>解析内核PDB文件(使用<code>uf 函数名称</code>或<code>u 地址</code>)</li></ul></li></ul></li></ul></li><li>内核函数前缀</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023822.png" alt="f6z1tYC8iWxBM4v" /></p><h2 id="内核空间与内核模块"><a class="markdownIt-Anchor" href="#内核空间与内核模块"></a> 内核空间与内核模块</h2><ul><li>内核空间中，每个进程低2G各不相同，高2G相同，在高2G中做任何事情影响的是所有进程</li><li>在高2G中，并不是只有一个内核模块为所有进程提供服务，而是由许多个模块组成，<strong>每个模块在高2G中都有属于自己独立的内存地址和大小</strong></li><li>若想了解每个内核模块的具体信息，可以通过 <code>_DRIVER_OBJECT</code> 这个结构体，它存储了当前内核模块的具体信息</li><li>任意加载一个驱动，便可通过 <code>_LDR_DATA_TABLE_ENTRY</code> 这个结构体中的双向链表得到所有内核模块的信息</li></ul><h1 id="事件等待"><a class="markdownIt-Anchor" href="#事件等待"></a> 事件等待</h1><h2 id="临界区和自旋锁"><a class="markdownIt-Anchor" href="#临界区和自旋锁"></a> 临界区和自旋锁</h2><ul><li>临界区<ul><li>通过 <code>sleep()</code> 实现</li></ul></li><li>自旋锁<ul><li>通过使当前CPU <code>空转</code> 实现</li></ul></li></ul><h2 id="等待与唤醒"><a class="markdownIt-Anchor" href="#等待与唤醒"></a> 等待与唤醒</h2><ol><li>可等待对象正常情况下都是以 <code>_DISPATCHER_HEADER</code> 结构体开头的，但是有一些特殊的结构体并不是以 <code>_DISPATCHER_HEADER</code> 开头的（如 _FILE_OBJECT），但是windows又希望把它们也变成所谓的可等待对象，因此在它们内部嵌入一个 <code>_DISPATCHER_HEADER</code> 这样的结构体</li><li>只要是包含 <code>_DISPATCHER_HEADER</code> 结构体的对象，都可以看作是可等待对象，都可以使用 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 这两个函数进入等待状态</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023751.png" alt="image-20231003151136267" /></p><ul><li>等待中的线程，一定在等待链表中(<code>KiWaitListHead</code>)，同时也一定在这张网上(<code>KTHREAD +5C的位置不为空</code>)</li><li>线程通过调用<code>WaitForSingleObject/WaitForMultipleObjects</code>函数将自己挂到这张网上</li><li>线程什么时候会再次执行取决于其他线程何时调用相关函数，等待对象不同调用的函数也不同</li></ul><h2 id="waitfoesingleobject函数"><a class="markdownIt-Anchor" href="#waitfoesingleobject函数"></a> WaitFoeSingleObject函数</h2><ol><li><p>不同的等待对象，用不同的方法来修改 <code>_DISPATCHER_HEADER-&gt;SignalState</code></p></li><li><p>如果可等待对象是 <code>EVENT</code>，其他线程通常使用 <code>SetEvent</code> 来设置 <code>SignalState = 1</code>，并且，将正在等待该对象的其他线程唤醒，也就是从等待链表<code>(KiWaitListHead</code>)中摘出来，此时线程临时复活</p></li><li><p><code>SetEvent</code> 函数并不会将线程从等待网上摘下来，是否要下来，由当前线程自己来决定。此时线程会在<code>WaitForSingleObject </code>或者 <code>WaitForMultipleObjects </code> 恢复执行（在哪切换就在哪开始执行），如果符合唤醒条件，就将自己从 <strong>等待网</strong> 上摘下来，此时的线程才是真正的唤醒</p></li><li><p>若使用 <code>SetEvent</code> 这种函数直接将线程从等待网上摘下来，将会非常麻烦，因为可能有非常多的线程在等待一个对象，无法判断该将谁摘下(一个也线程可能等待着多个对象)</p><ul><li>比如：线程A和线程B同时在等待着一个对象，这时如果有线程C调用了SetEvent(将等待对象的信号量置1)，线程A和线程B会被临时唤醒(从KiWaitLkistHead摘下)，并行进入关键循环，假设线程A先运行，线程A会设置等待对象的信号量&lt;=0，然后将自己从等待网上摘下来，此时线程A彻底复活。线程B再去判断等待对象是否有信号量时，已经没有信号量了，这时线程B会将自己重新挂入等待链表中</li></ul></li><li><p>不同对象调用API修改信号个数只在细节上有差异，本质上都是一样的</p><ul><li>这里区分<strong>事件的type属性的不同，信号量，互斥体</strong>。对于这几种不同的对象，其具体的修改策略也是不同的，但是本质上大同小异，都是修改 SignalState</li></ul></li></ol><ul><li>关于强制唤醒<ul><li>在APC专题中，当插入一个用户APC时(<strong>Alertable=1</strong>)，当前线程是可以被唤醒的，但并不是真正的唤醒。因为如果当前的线程在等待网上，执行完用户APC后，线程仍然要进入等待状态</li></ul></li></ul><h1 id="句柄表"><a class="markdownIt-Anchor" href="#句柄表"></a> 句柄表</h1><h2 id="句柄表-2"><a class="markdownIt-Anchor" href="#句柄表-2"></a> 句柄表</h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><ol><li>当一个进程创建或者打开一个内核对象时，将获得一个句柄，通过这个句柄可以访问对应的内核对象</li><li>句柄表存储在<strong>零环</strong>，一个进程使用了几个句柄，在该进程的句柄表中就会存储几个句柄</li><li>所有的句柄所对应的内核对象，都包含在 <code>_OBJECT_HEADER</code> 中，真正的内核对象保存在 <code>_OBJECT_HEADER +0x018 body</code> 的位置</li></ol><h3 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3><ol><li><strong>窗口、字体、笔刷</strong>等句柄与本章所学句柄是两码事</li><li>创建句柄不等同于打开句柄，当创建的时候，操作系统会在零环为内核对象分配一个结构体(例如<code>CreateEvent</code>)，如果自己或他人打开了这个内核对象(例如<code>OpenProcess</code>)，那么将不会再次为这个内核对象分配一个结构体，而是返回一个句柄的索引值</li><li>若同一个内核对象被引用了100次，那么在句柄表中就会存储100个内核对象的地址</li><li>句柄的值并非如上图所显示的只占4个字节，而是<strong>占8个字节</strong>，但是句柄表的值仍然按照<strong>4个字节</strong>进行计算</li></ol><p><strong>句柄索引定位对应句柄的计算公式</strong>：<code>handle = index / 4 * 8</code></p><h2 id="全局句柄表"><a class="markdownIt-Anchor" href="#全局句柄表"></a> 全局句柄表</h2><ol><li><p>进程的句柄表是私有的，每个进程都有一个自己的句柄表</p></li><li><p>除此之外，系统还有一个全局句柄表：<code>PsdCidTable</code>，为 <code>_HANDLE_TABLE</code> 结构，所有的进程和线程无论无论是否打开，都在这个表中</p></li><li><p>每个进程和线程都有一个唯一的编号：<code>PID和CID</code> 这两个值其实就是全局句柄表中的索引</p></li><li><p>进程和线程的查询,主要是以下三个函数,按照给定的PID或CID从PspCidTable从查找相应的进线程对象：</p><ul><li><p>PsLookupProcessThreadByCid()</p></li><li><p>PsLookupProcessByProcessId()</p></li><li><p>PsLookupThreadByThreadId()</p></li></ul></li></ol><h1 id="软件调试"><a class="markdownIt-Anchor" href="#软件调试"></a> 软件调试</h1><h2 id="调试相关"><a class="markdownIt-Anchor" href="#调试相关"></a> 调试相关</h2><h3 id="调试对象"><a class="markdownIt-Anchor" href="#调试对象"></a> 调试对象</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023788.png" alt="image-20231003200338832" /></p><ol><li>调试器与被调试进程通过 <code>DEBUG_OBJECT</code> 结构体建立联系</li><li><code>DEBUG_OBJECT</code> 中有一个链表成员，用于记录所有<strong>调试事件</strong></li><li>当被调试进程产生调试事件时，调试器从链表中取出调试事件进行处理</li></ol><ul><li>调试事件有不同种类，只有几个最关键的种类才会被记录到链表中，例如被调试进程进行文件读写、申请内存、释放内存等行为时不会产生调试事件，即不是所有的调试事件都会被记录到链表中</li></ul><h3 id="调试事件的采集"><a class="markdownIt-Anchor" href="#调试事件的采集"></a> 调试事件的采集</h3><ol><li>调试事件有多种，真正需要关注的只有<strong>7种</strong></li><li>Windows通过在被调试进程的<strong>必经之路</strong>上调用调试事件采集函数，向 <code>DEBUG_PORT</code> 中挂入调试事件</li><li>不同事件的必经之路所使用的调试事件采集函数不同，但最终都通过 <code>DbgkSendApiMessage</code> 向链表中写入调试事件信息(封装好的调试事件结构体)<ul><li><code>DbgkSendApiMessage</code> 有两个参数，第一个参数为调试事件类型，第二个参数为是否挂起其它线程，有时需要，比如0xCC，有时不需要，比如模块加载</li></ul></li></ol><h3 id="调试事件的处理"><a class="markdownIt-Anchor" href="#调试事件的处理"></a> 调试事件的处理</h3><ol><li>调试器在创建进程时，除了能得到进程创建、创建线程、模块加载等调试事件之外，还会收到一个<code>异常事件</code></li><li>异常来源于调试器创建进程时触发的<code>系统断点</code>，目的是给调试器一个中断的机会</li><li>调试器在附加进程时，能够得到一份<code>模拟的</code>进程创建时产生的相关调试事件信息</li><li>这些虚假的调试事件信息可靠性较低，程序在执行过程中可能已经处理过部分信息</li></ol><h3 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023040.png" alt="image-20231003201011971" /></p><ul><li><p>这里注意<strong>未处理异常: 最后一道防线</strong></p></li><li><p><code>UnhandledExceptionFilter</code> 执行流程：</p><ol><li><p>通过<code>NtQueryInformationProcess</code>查询当前进程是否正在被调试，如果是，返回<code>EXCEPTION_CONTINUE_SEARCH</code>，此时会进入第二轮分发</p></li><li><p>如果没有被调试：</p><ul><li>查询是否通过<code>SetUnhandledExceptionFilter</code>注册处理函数，如果有就调用</li></ul><p>如果没有通过<code>SetUnhandledExceptionFilter</code>注册处理函数，弹出窗口，让用户选择终止程序还是启动即时调试器。</p><ul><li>如果用户没有启用即时调试器，那么该函数返回<code>EXCEPTION_EXECUTE_HANDLER</code></li></ul></li></ol></li><li><p>这里若是原程序通过 <code>SetUnhandledExceptionFilter</code> 来注册处理函数的话，使用调试器不会关注这个处理，所以会导致执行结果与原程序不相符的情况发生</p></li></ul><h2 id="断点"><a class="markdownIt-Anchor" href="#断点"></a> 断点</h2><h3 id="调试的本质"><a class="markdownIt-Anchor" href="#调试的本质"></a> 调试的本质</h3><p><strong>描述</strong>：</p><ol><li>调试的本质是<strong>触发异常</strong>与<strong>调试器接管异常的过程</strong></li><li>不论是软件断点，硬件断点还是 <code>INT 3</code> 断点，本质都是触发异常</li></ol><h3 id="软件断点"><a class="markdownIt-Anchor" href="#软件断点"></a> 软件断点</h3><p><strong>描述</strong>：</p><ul><li>当使用调试器在任意代码位置设置断点时，本质上是将当前代码位置的字节码改为<strong>0xCC</strong>，对应的汇编指令为<strong>INT 3</strong>，调试器为了界面的美观，不会直接在反汇编界面将修改后的数据显示出来</li></ul><p><strong>执行流程</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU检测到INT 3指令</li><li>查IDT表找到对应的中断处理函数</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><h3 id="内存断点"><a class="markdownIt-Anchor" href="#内存断点"></a> 内存断点</h3><p><strong>描述</strong>：</p><ul><li>当需要在某块内存被访问时产生中断，可以使用内存断点。</li><li>内存断点能够分为两种类型：<ul><li>内存访问：内存被读写时产生中断</li><li>内存写入：内存被写入时产生中断</li></ul></li><li>通过 <code>VirtualProtectEx</code> 来实现<ul><li>内存访问：将指定内存的属性修改为 <code>PAGE_NOACCESS</code>(修改后，PTE的P位等于0)</li><li>内存写入：将指定内存的属性修改为 <code>PAGE_EXECUTE_READ</code>(修改后，PTE的P位等于1，R/W位等于0)</li></ul></li></ul><p><strong>内存断点的执行流程</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU访问错误的内存地址，触发页异常</li><li>查IDT表找到对应的中断处理函数(nt!_KiTrap0E)</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型，共有7种类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><h3 id="硬件断点"><a class="markdownIt-Anchor" href="#硬件断点"></a> 硬件断点</h3><p><strong>描述</strong>：</p><ol><li>与软件断点与内存断点不同，<strong>硬件断点</strong>不依赖被调试程序，而是依赖于CPU中的<strong>调试寄存器</strong></li><li>调试寄存器有<strong>8个</strong>，分别为 <strong>Dr0~Dr7</strong></li><li>用户最多能够设置4个硬件断点，这是由于只有<strong>Dr0~Dr3</strong>用于存储线性地址</li><li>其中，Dr4和Dr5是保留的</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023053.png" alt="image-20231003202224792" /></p><p><strong>设置硬件断点</strong>：</p><ul><li><strong>Dr0~Dr3</strong> 用于设置硬件断点，由于只有4个断点寄存器，所以最多只能设置4个硬件调试断点。</li><li><strong>Dr7</strong> 是最重要的寄存器：<ul><li><strong>L0/G0 ~ L3/G3</strong>：控制Dr0~Dr3是否有效，局部还是全局；每次异常后，Lx都被清零,Gx不清零。</li><li><strong>断点长度(LENx)</strong>：00(1字节)、01(2字节)、11(4字节)</li><li><strong>断点类型(R/Wx)</strong>：00(执行断点)、01(写入断点)、11(访问断点)</li></ul></li></ul><p><strong>触发硬件断点</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU执行时检测当前线性地址与调试寄存器(Dr0~Dr3)中的线性地址相等</li><li>查IDT表找到对应的中断处理函数(nt!_KiTrap01)</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型，共有7种类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><p><strong>处理硬件断点</strong>：</p><ul><li>硬件调试断点产生的异常是 <code>STATUS_SINGLE_STEP</code>(单步异常)</li><li>检测Dr6寄存器的B0~B3：判断哪个寄存器触发的异常</li></ul><h3 id="单步步入"><a class="markdownIt-Anchor" href="#单步步入"></a> 单步步入</h3><p><strong>描述</strong>：</p><ol><li><strong>单步步入</strong>的实现依赖于<strong>单步异常</strong></li><li>当我们需要观察每一行代码(包括函数内部的代码)执行之后寄存器与内存的变化，通常会采用单步步入</li><li>当使用单步步入时，可采用在下一行代码的首字节设置INT 3断点的方式实现</li><li>CPU为我们提供了一种更为方便的方法，即使用<strong>陷阱标志位（TF位）</strong></li></ol><p><strong>设置单步异常</strong></p><ul><li>将TF位置1</li></ul><p><strong>处理单步异常</strong></p><ul><li>单步产生的异常与硬件断点产生的异常一致，都是 <code>STATUS_SINGLE_STEP</code>(单步异常)</li></ul><h3 id="单步步过"><a class="markdownIt-Anchor" href="#单步步过"></a> 单步步过</h3><p><strong>描述</strong>：</p><ul><li>当遇到CALL指令时，若无需进入函数内部进行调试，可以使用单步步过。</li><li>与单步步入不同的是，单步步过的实现依赖于软件断点或硬件断点。</li></ul><p><strong>实现思路</strong>：</p><ol><li>判断当前指令是否为CALL指令</li><li>若不是CALL指令，设置TF为1触发单步异常</li><li>若是CALL指令，判断OPCODE是E8还是FF15</li><li>若<code>OPCODE</code>是E8，在当前地址之后的第5个字节设置软件断点(E8指令占5个字节)</li><li>若<code>OPCODE</code>是FF15，在当前地址之后的第6个字节设置软件断点(FF15指令占6个字节)</li></ol><ul><li>这里识别出 <code>CALL</code> 指令后，通常需要根据反汇编引擎来识别下一条指令的地址(call指令明面上的下一条)，然后在该地址设置硬件断点或者是软件断点</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些记录2</title>
    <link href="/posts/1ea6e51b.html"/>
    <url>/posts/1ea6e51b.html</url>
    
    <content type="html"><![CDATA[<h1 id="minil"><a class="markdownIt-Anchor" href="#minil"></a> MiniL</h1><h2 id="easypass"><a class="markdownIt-Anchor" href="#easypass"></a> EasyPass</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><ul><li><a href="https://dua0g.top/archives/385">llvm的讲解</a></li><li><a href="https://bbs.kanxue.com/thread-273119.htm">llvm实战分析</a></li><li>LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。总体而言，PASS就是对IR进行额外处理，通过自己编写的函数来统计信息或者插入处理，这里对于源文件没有任何影响，只是在优化的过程中产生结果罢了。</li></ul><h3 id="运行与编译"><a class="markdownIt-Anchor" href="#运行与编译"></a> 运行与编译</h3><ul><li><p>按照 <code>Usage.md</code> 所言使用 PASS 对 IR 进行优化处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141010620.png" alt="image-20230714101016577" /></p><p>没有什么信息，那么就通过编译 IR 为汇编文件分析</p></li><li><p>使用 <code>clang-10 -o main main.bc</code> 将LLVM bitcode 进一步编译为汇编(ELF文件)</p></li></ul><h4 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h4><ul><li><p>首先对于 <code>EasyPass。so</code> 文件进行分析，根据 LLVM PASS 的性质，找到虚表中的 <code>runOnFunction</code> 函数(通过定位虚表，找到最后一个函数即是目标函数)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141028472.png" alt="image-20230714102834441" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141028952.png" alt="image-20230714102855930" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141029342.png" alt="image-20230714102914323" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141030271.png" alt="image-20230714103011250" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141031753.png" alt="image-20230714103110707" /></p></li><li><p>分析 <code>runOnFunction</code> 函数，发现函数很大，反编译不成功，看汇编发现前面很多调用过了固定返回1的函数，则nop掉再进行反汇编分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x2673</span>,<span class="hljs-number">0x6C9B</span>):<br>    patch_byte(i,<span class="hljs-number">0x90</span>)<br></code></pre></td></tr></table></figure></li><li><p>首先是通过 <code>getName</code> 获得16个 <code>llvm::Value</code> 的类型的输入，这里根据 a2 是llvm中的 Value 对象，在llvm中 <code>Function</code> 是 Value 的⼀个⼦类，则a2 就是 LLVM 中的 <code>Function &amp;F</code> 的参数 F，即这里先通过 getName 获取函数名称，转为C语⾔字符串之后存⼊ <code>unk_41B0</code> 数组中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141049081.png" alt="image-20230714104929056" /></p></li><li><p>之后进入一个函数进行加密处理，这里采用虚拟机形式，通过异或处理进行加密处理—分析加密函数，发现是前半截异或后半截，后半截异或0xff</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141048916.png" alt="image-20230714104824893" /></p></li><li><p>当该 FunctionPass 遍历了26个函数之后(<code>通过调试可以发现遍历的函数就是main.bc编译成ELF中主函数的26个函数</code>)开始进行密钥比较。经过26轮加密后进⾏密⽂⽐较</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141052465.png" alt="image-20230714105245439" /></p></li></ul><h4 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h4><ul><li><p>配置好 LLVM 的环境(可以使用 <code>'opt-10 -load ……'</code>进行操作)</p></li><li><p>之后需要将<code>.so</code>文件进行链接，否则找不到此动态链接库(首先使用 <code>find / -type f -name EasyPass.so 2&gt;/dev/null</code> 查找 <code>.so</code> 文件所在目录，之后使用 <code>sudo ln -s /home/re/CTF/EasyPass.so /usr/lib</code> 对动态链接库进行链接)</p></li><li><p>之后配置 IDA 进行动态调试</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141149719.png" alt="image-20230714114944674" /></p></li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br>str0 = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x4D</span>,<br>        <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>,<br>        <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x61</span>,<br>        <span class="hljs-number">0x74</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x66</span>,<br>        <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x67</span>]<br><br>text1 = [BitVec(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">124</span> - <span class="hljs-number">97</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>):<br>    str0[i] = text1[i - <span class="hljs-number">97</span>]<br>str0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>names = [<span class="hljs-string">&quot;aaCCzCzzMMaMCMa&quot;</span>,<br>         <span class="hljs-string">&quot;bbMMyMyyZZbZMZb&quot;</span>,<br>         <span class="hljs-string">&quot;ccCCxCxxJJcJCJc&quot;</span>,<br>         <span class="hljs-string">&quot;ddQQwQwwMMdMQMd&quot;</span>,<br>         <span class="hljs-string">&quot;eeYYvYvvKKeKYKe&quot;</span>,<br>         <span class="hljs-string">&quot;ffHHuHuuCCfCHCf&quot;</span>,<br>         <span class="hljs-string">&quot;ggDDtDttKKgKDKg&quot;</span>,<br>         <span class="hljs-string">&quot;hhDDsDssOOhODOh&quot;</span>,<br>         <span class="hljs-string">&quot;iiCCrCrrIIiICIi&quot;</span>,<br>         <span class="hljs-string">&quot;jjOOqOqqDDjDODj&quot;</span>,<br>         <span class="hljs-string">&quot;kkSSpSppEEkESEk&quot;</span>,<br>         <span class="hljs-string">&quot;llXXoXooTTlTXTl&quot;</span>,<br>         <span class="hljs-string">&quot;mmLLnLnnVVmVLVm&quot;</span>,<br>         <span class="hljs-string">&quot;nnII_I__HHnHIHn&quot;</span>,<br>         <span class="hljs-string">&quot;ooOO_O__CCoCOCo&quot;</span>,<br>         <span class="hljs-string">&quot;ppFF_F__NNpNFNp&quot;</span>,<br>         <span class="hljs-string">&quot;qqDD_D__BBqBDBq&quot;</span>,<br>         <span class="hljs-string">&quot;rrTT_T__BBrBTBr&quot;</span>,<br>         <span class="hljs-string">&quot;ssJJ_J__CCsCJCs&quot;</span>,<br>         <span class="hljs-string">&quot;ttGG_G__XXtXGXt&quot;</span>,<br>         <span class="hljs-string">&quot;uuDD_D__OOuODOu&quot;</span>,<br>         <span class="hljs-string">&quot;vvUU_U__JJvJUJv&quot;</span>,<br>         <span class="hljs-string">&quot;wwOO_O__SSwSOSw&quot;</span>,<br>         <span class="hljs-string">&quot;xxRR_R__SSxSRSx&quot;</span>,<br>         <span class="hljs-string">&quot;yyEE_E__KKyKEKy&quot;</span>,<br>         <span class="hljs-string">&quot;zzJJ_J__TTzTJTz&quot;</span>,<br>         ]<br><span class="hljs-keyword">for</span> str1 <span class="hljs-keyword">in</span> names:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str1) + <span class="hljs-number">1</span>):<br>        str0[i] = <span class="hljs-built_in">ord</span>(str1[i - <span class="hljs-number">1</span>])<br>    str0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>):<br>        v4 = str0[str0[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>]<br>        v3 = str0[str0[<span class="hljs-number">0</span>]]<br>        v2 = str0[str0[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>]<br>        str0[<span class="hljs-number">0</span>] += <span class="hljs-number">3</span><br>        str0[v2] = (~(str0[v4] &amp; str0[v3])) &amp; <span class="hljs-number">0xff</span><br>s = Solver()<br>cipher = [<span class="hljs-number">0x64</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x00</span>,<br>          <span class="hljs-number">0x16</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA9</span>,<br>          <span class="hljs-number">0x92</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xCA</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>):<br>    s.add(cipher[i - <span class="hljs-number">97</span>] == str0[i])<br><span class="hljs-built_in">print</span>(s.check())<br>m = s.model()<br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> m.decls():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;d.name()&#125;</span> = <span class="hljs-subst">&#123;m[d]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># final = &#123;20: 109,</span><br><span class="hljs-comment">#          18: 108,</span><br><span class="hljs-comment">#          13: 112,</span><br><span class="hljs-comment">#          17: 76,</span><br><span class="hljs-comment">#          10: 115,</span><br><span class="hljs-comment">#          21: 95,</span><br><span class="hljs-comment">#          15: 101,</span><br><span class="hljs-comment">#          23: 52,</span><br><span class="hljs-comment">#          7: 79,</span><br><span class="hljs-comment">#          5: 48,</span><br><span class="hljs-comment">#          6: 111,</span><br><span class="hljs-comment">#          8: 111,</span><br><span class="hljs-comment">#          0: 81,</span><br><span class="hljs-comment">#          2: 81,</span><br><span class="hljs-comment">#          12: 109,</span><br><span class="hljs-comment">#          3: 95,</span><br><span class="hljs-comment">#          16: 95,</span><br><span class="hljs-comment">#          14: 108,</span><br><span class="hljs-comment">#          22: 80,</span><br><span class="hljs-comment">#          9: 95,</span><br><span class="hljs-comment">#          11: 105,</span><br><span class="hljs-comment">#          1: 119,</span><br><span class="hljs-comment">#          25: 53,</span><br><span class="hljs-comment">#          19: 86,</span><br><span class="hljs-comment">#          24: 115,</span><br><span class="hljs-comment">#          4: 115,</span><br><span class="hljs-comment">#          &#125;</span><br></code></pre></td></tr></table></figure><h2 id="maze_aot"><a class="markdownIt-Anchor" href="#maze_aot"></a> maze_aot</h2><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>分析文件，首先就是 <code>Input a 64-bit hex number to solve the maze:</code> ，就是以十六进制输入64位的整数，然后到了 <code>maze_walk()</code> 函数，这里都是跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152321226.png" alt="image-20230715232115144" /></p></li><li><p>之后查看其中 <code>maze_stop</code> 函数与 <code>maze_final</code> 函数，发现需要经过64个跳转(对应输入的64-bit)，这里存在着<code>steps &amp; 1</code> 和 <code>steps = steps &gt;&gt; 1</code>，即把输入转化为一串二进制数，从后往前根据末尾是否为 1 决定是否跳跃。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152321978.png" alt="image-20230715232149948" /></p><ul><li>在其中一个跳转中，存在一个 <code>maze_final</code> 函数，这个函数就是最后结束的条件，到达这个函数所在的地方就是得到flag的条件</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152322144.png" alt="image-20230715232201123" /></p><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><p>​这里首先需要知道该程序的控制流，</p><h3 id="法1"><a class="markdownIt-Anchor" href="#法1"></a> 法1</h3><p>​使用 IDAPython 脚本时需要知道其中函数的意义，这里弄懂<a href="%5Bhttps://zhuanlan.zhihu.com/p/21330930">基本快和控制流的概念</a>。简单而言，函数中的基本块就是以跳转分类，只有一个入口和一个出口的可供程序顺序执行的语句序列，</p><ul><li>首先使用 <code>idapython</code> 提取改题目中的数据结构</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idaapi<br><br>function_address = <span class="hljs-number">0x1500</span><br>function = idaapi.get_func(function_address) <span class="hljs-comment"># 由给定的函数地址获取函数对象</span><br>graph = <span class="hljs-built_in">dict</span>() <span class="hljs-comment"># 创建一个空的字典，用于存储函数的控制流程图，用于之后存储基本快之间的连接关系</span><br>cfg = idaapi.FlowChart(function) <span class="hljs-comment"># 接受一个函数对象作为参数，并返回一个表示控制流程图的对象，该对象包含函数的基本块和它们之间的控制流转移关系</span><br>exclusive_nodes = <span class="hljs-built_in">list</span>()<span class="hljs-comment"># 空列表，用于存储跳转目标地址小于等于5的节点，这些节点可能是特殊的或特定情况下的跳转块</span><br>first = <span class="hljs-literal">None</span><br>jmp_dict = <span class="hljs-built_in">dict</span>() <span class="hljs-comment"># 空字典，用于存储跳转指令的信息。在后续的分析过程中，可能会将跳转指令的类型和目标地址存储在这个字典中</span><br><br><span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> cfg: <span class="hljs-comment"># 遍历所有的基本块</span><br>    graph[block.start_ea] = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># 为每个基本块的起始地址创建一个空的列表，用于存储与之相连的后继节点---&gt;&#123;&#x27;0x1500&#x27;: [], &#x27;0x1501&#x27;: []…………&#125;</span><br>    start_address = block.start_ea<br>    end_address = block.end_ea<br>    <span class="hljs-keyword">if</span> first <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting&quot;</span>)<br>        first = start_address<br>    <br>    <span class="hljs-keyword">if</span> end_address - start_address &lt;= <span class="hljs-number">5</span>: <span class="hljs-comment"># 这里专门找jnz jmp类型的程序，获取其中只有 jmp 的基本块</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;found jmp block&quot;</span>)<br>        exclusive_nodes.append(start_address) <span class="hljs-comment"># 存储跳转目标地址小于等于5的节点 </span><br>        <span class="hljs-keyword">for</span> succ <span class="hljs-keyword">in</span> block.succs():  <span class="hljs-comment">#遍历当前基本块的后继节点。通过这个循环，可以获取基本块之间的连接关系，并将其存储在graph字典中</span><br>            graph[block.start_ea].append(succ.start_ea)<br>        <span class="hljs-keyword">continue</span><br>        <br>    ea = <span class="hljs-number">0</span>   <span class="hljs-comment"># 迭代计算指令地址</span><br>    flag = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录跳转指令类型</span><br>    tgt = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录跳转目标地址</span><br>    <span class="hljs-keyword">while</span> (end_address - ea) != start_address: <span class="hljs-comment"># 循环直到迭代到当前基本块的起始地址</span><br>        <span class="hljs-keyword">if</span> idc.GetDisasm(end_address - ea).startswith(<span class="hljs-string">&quot;jnz&quot;</span>):<span class="hljs-comment"># 检查当前指令是否以&quot;jnz&quot;开头</span><br>            <span class="hljs-comment"># print(int(idc.GetDisasm(end_address - ea)[-4::],16))</span><br>            flag = <span class="hljs-number">1</span> <span class="hljs-comment"># 设置flag为1，表示跳转指令为&quot;jnz&quot;</span><br>            tgt = <span class="hljs-built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="hljs-number">4</span>::],<span class="hljs-number">16</span>) <span class="hljs-comment"># 将跳转目标地址解析为十六进制整数并赋值给tgt</span><br>        <span class="hljs-keyword">elif</span> idc.GetDisasm(end_address - ea).startswith(<span class="hljs-string">&quot;jz&quot;</span>):<br>            flag = <span class="hljs-number">2</span><br>            tgt = <span class="hljs-built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="hljs-number">4</span>::], <span class="hljs-number">16</span>)<br>        ea += <span class="hljs-number">1</span> <span class="hljs-comment"># 迭代下一个指令</span><br>    <span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span>: <span class="hljs-comment"># 检查flag是否不为0，即是否存在跳转指令</span><br>        jmp_dict[block.start_ea] = (flag,tgt) <span class="hljs-comment"># 将跳转指令的信息添加到jmp_dict字典中，即表明了跳转类型与跳转地址</span><br>    <span class="hljs-keyword">for</span> succ <span class="hljs-keyword">in</span> block.succs():<br>        graph[block.start_ea].append(succ.start_ea) <span class="hljs-comment"># 将当前基本块的起始地址与后继节点的起始地址连接起来</span><br><br><span class="hljs-built_in">print</span>(jmp_dict)<br></code></pre></td></tr></table></figure><ul><li>之后使用 <code>DFS</code> 来计算路径，将这两部分代码合在一起执行IDAPython语句即可得到最后路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">BFS</span>(<span class="hljs-params">grap, star</span>):                    <span class="hljs-comment"># BFS算法</span><br>    queue = []                          <span class="hljs-comment"># 定义一个队列</span><br>    seen = <span class="hljs-built_in">set</span>()                        <span class="hljs-comment"># 建立一个集合，集合就是用来判断该元素是不是已经出现过</span><br>    queue.append(star)                  <span class="hljs-comment"># 将任一个节点放入</span><br>    seen.add(star)                      <span class="hljs-comment"># 同上</span><br>    parent = &#123;star:<span class="hljs-literal">None</span>&#125;                <span class="hljs-comment"># 存放parent元素</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>):             <span class="hljs-comment"># 当队列里还有东西时</span><br>        ver = queue.pop(<span class="hljs-number">0</span>)              <span class="hljs-comment"># 取出队头元素</span><br>        notes = grap[ver]               <span class="hljs-comment"># 查看grep里面的key,对应的邻接点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> notes:                 <span class="hljs-comment"># 遍历邻接点</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:           <span class="hljs-comment"># 如果该邻接点还没出现过</span><br>                queue.append(i)         <span class="hljs-comment"># 存入queue</span><br>                seen.add(i)             <span class="hljs-comment"># 存入集合</span><br>                parent[i] = ver         <span class="hljs-comment">#将元素对应的parent元素存入字典中</span><br>    <span class="hljs-keyword">return</span> parent<br><br><span class="hljs-comment"># path = bfs(graph, first, end)</span><br>parent = BFS(graph,first)<br><br>a = end<br>p=[]<br><span class="hljs-keyword">while</span> a != <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># print(a)</span><br>    p.append(a)<br>    a = parent[a]<br>path = p<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;路径: <span class="hljs-subst">&#123;path&#125;</span>&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> path[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> exclusive_nodes <span class="hljs-keyword">and</span> path[i] != <span class="hljs-number">5376</span>:<br>        <span class="hljs-built_in">next</span> = path[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] == <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1&#x27;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] != <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] == <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] != <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ERR&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="法2"><a class="markdownIt-Anchor" href="#法2"></a> 法2</h3><p>从汇编代码中抽象出控制流块的前后关系，然后用最短路径算法求解。这里由于<code>maze_walk</code>中的指令比较单一，直接用capstone反汇编引擎恢复控制流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> elftools.elf.elffile <span class="hljs-keyword">import</span> ELFFile<br><span class="hljs-keyword">from</span> elftools.construct <span class="hljs-keyword">import</span> Container<br><span class="hljs-keyword">from</span> capstone <span class="hljs-keyword">import</span> Cs, CS_ARCH_X86, CS_MODE_64<br><span class="hljs-keyword">from</span> networkx <span class="hljs-keyword">import</span> DiGraph, shortest_path<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><br><span class="hljs-comment"># 从符号获取字节数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getdata</span>(<span class="hljs-params">elf: ELFFile, entry: Container</span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    addr, size = entry.st_value, entry.st_size<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> elf.iter_sections():<br>        start = section.header.sh_addr<br>        end = start + section.header.sh_size<br>        <span class="hljs-keyword">if</span> start &lt;= addr &lt;= end:<br>            <span class="hljs-keyword">assert</span> addr + size &lt;= end<br>            <span class="hljs-keyword">return</span> section.data()[addr-start:addr-start+size]<br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;cannot find data from 0x%x to 0x%x&#x27;</span> % (addr, addr + size))<br><br>elf = ELFFile(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;maze&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>))<br>symtab = elf.get_section_by_name(<span class="hljs-string">&#x27;.symtab&#x27;</span>)<br><br><span class="hljs-comment"># 获取函数的偏移和数据</span><br>maze_walk = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_walk&#x27;</span>)[<span class="hljs-number">0</span>].entry<br>code = getdata(elf, maze_walk)<br>maze_walk_addr = maze_walk.st_value<br>maze_step_addr = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_step&#x27;</span>)[<span class="hljs-number">0</span>].entry.st_value<br>maze_final_addr = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_final&#x27;</span>)[<span class="hljs-number">0</span>].entry.st_value<br><br><span class="hljs-comment"># 获取加密的flag数据</span><br>flag_enc = getdata(elf, symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_flag&#x27;</span>)[<span class="hljs-number">0</span>].entry)<br>flag_enc = flag_enc[:-<span class="hljs-number">1</span>] <span class="hljs-comment"># 最后一个字节为结束字符</span><br><br><span class="hljs-comment"># 使用capstone将字节数据转换为汇编</span><br>cs = Cs(CS_ARCH_X86, CS_MODE_64)<br><br><span class="hljs-comment"># 把控制流块提取出来</span><br>blocks, current = [], <span class="hljs-literal">None</span><br>final_block_addr = <span class="hljs-literal">None</span> <span class="hljs-comment"># 最终块的地址</span><br><span class="hljs-keyword">for</span> addr, _, op, opr <span class="hljs-keyword">in</span> cs.disasm_lite(code, maze_walk_addr):<br>    <span class="hljs-comment"># insn = op + (&#x27; &#x27; + opr if opr else &#x27;&#x27;)</span><br>    <span class="hljs-comment"># print(&#x27;%04x %s&#x27; % (addr, insn))</span><br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;nop&#x27;</span>: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># 存在nop是因为指令对齐，过滤即可</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;call&#x27;</span>: <span class="hljs-comment"># 可能调用maze_step和maze_final</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(opr, <span class="hljs-number">0</span>) == maze_step_addr:<br>            current = []<br>            blocks.append(current)<br>            current.append((addr, op, opr))<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">int</span>(opr, <span class="hljs-number">0</span>) == maze_final_addr:<br>            final_block_addr = addr<br>        <span class="hljs-keyword">else</span>: <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;unknown function %s&#x27;</span> % opr)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 其他指令直接插入当前块</span><br>            current.append((addr, op, opr))<br><br><span class="hljs-comment"># patterns = set() # 先统计基本块模式的种类</span><br><span class="hljs-comment"># for block in blocks:</span><br><span class="hljs-comment">#     pattern = &#x27; &#x27;.join(op for _, op, _ in block)</span><br><span class="hljs-comment">#     patterns.add(pattern)</span><br><span class="hljs-comment">#     for addr, op, opr in block:</span><br><span class="hljs-comment">#         if opr: op += &#x27; &#x27; + opr</span><br><span class="hljs-comment">#         print(&#x27;%04x %s&#x27; % (addr, op))</span><br><span class="hljs-comment">#     print()</span><br><span class="hljs-comment"># print(patterns) # &gt; &#123;&#x27;call test je&#x27;, &#x27;call test jne&#x27;, &#x27;call test jne jmp&#x27;, &#x27;call test je jmp&#x27;&#125;</span><br><br>graph = [] <span class="hljs-comment"># 地址，0分支，1分支</span><br>blocks.append((final_block_addr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">for</span> i, block <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(blocks[:-<span class="hljs-number">1</span>]):<br>    pattern = <span class="hljs-string">&#x27; &#x27;</span>.join(op <span class="hljs-keyword">for</span> _, op, _ <span class="hljs-keyword">in</span> block)<br>    <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">&#x27;call test je&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), blocks[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test jne&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], blocks[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test jne jmp&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test je jmp&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(block[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">else</span>: <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;unknown pattern %r&#x27;</span> % pattern)<br><br><span class="hljs-comment"># 转换成有向图</span><br>addr2idx = &#123;node[<span class="hljs-number">0</span>]: i <span class="hljs-keyword">for</span> i, node <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph)&#125;<br>addr2idx[final_block_addr] = <span class="hljs-built_in">len</span>(addr2idx) <span class="hljs-comment"># 最终块</span><br>graph = <span class="hljs-built_in">list</span>((addr2idx[node[<span class="hljs-number">1</span>]], addr2idx[node[<span class="hljs-number">2</span>]]) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph)<br><span class="hljs-comment"># -&gt; [(1, 5), (8, 2), (11, 3), ...]</span><br><br><span class="hljs-comment"># 求最短路径可以直接调库</span><br>G = DiGraph()<br><span class="hljs-keyword">for</span> i, node <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br>    G.add_edge(i, node[<span class="hljs-number">0</span>])<br>    G.add_edge(i, node[<span class="hljs-number">1</span>])<br>path = shortest_path(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(graph))<br><br>key, current = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-number">65</span><br><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(path[<span class="hljs-number">1</span>:]):<br>    key |= graph[current].index(v) &lt;&lt; i<br>    current = v<br>key = key.to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;miniLctf&#123;%s&#125;&#x27;</span> % ARC4.new(key).decrypt(flag_enc).decode())<br></code></pre></td></tr></table></figure><h3 id="法3"><a class="markdownIt-Anchor" href="#法3"></a> 法3</h3><p>注意到程序控制流复杂但逻辑简单，而且没有太多层函数调用，我们可以利用<a href="https://github.com/angr/angr">angr</a>符号执行框架来进行求解（为了避免路径爆炸，实现了一个自定义的<code>ExplorationTechnique</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span><br><span class="hljs-keyword">from</span> angr <span class="hljs-keyword">import</span> Project, SimState, SimulationManager, ExplorationTechnique<br><span class="hljs-keyword">from</span> angr.sim_options <span class="hljs-keyword">import</span> ZERO_FILL_UNCONSTRAINED_REGISTERS<br><span class="hljs-keyword">from</span> cle.backends.symbol <span class="hljs-keyword">import</span> Symbol<br><span class="hljs-keyword">from</span> claripy <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MazeWalker</span>(<span class="hljs-title class_ inherited__">ExplorationTechnique</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;遍历方法：跳过已访问的代码，类似于BFS&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, maze_range: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>], nstep_addr: <span class="hljs-built_in">int</span>, final_addr: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._<span class="hljs-built_in">range</span> = maze_range<br>        self._nstep_addr = nstep_addr<br>        self._final_addr = final_addr<br>        self._depth: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>] = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self, simgr: SimulationManager</span>) -&gt; <span class="hljs-literal">None</span>:<br>        simgr.stashes[<span class="hljs-string">&#x27;visited&#x27;</span>] = []<br>        simgr.stashes[<span class="hljs-string">&#x27;found&#x27;</span>] = []<br>        self._depth[simgr.active[<span class="hljs-number">0</span>].addr] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">current_pos</span>(<span class="hljs-params">self, state: SimState</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回`current`变量的值&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> state.solver.<span class="hljs-built_in">eval</span>(state.mem[self._nstep_addr].unsigned.resolved, cast_to=<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inside_maze</span>(<span class="hljs-params">self, state: SimState</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;是否在`maze_walk`函数中&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> self._<span class="hljs-built_in">range</span>[<span class="hljs-number">0</span>] &lt;= state.addr &lt; self._<span class="hljs-built_in">range</span>[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, simgr: SimulationManager, stash: <span class="hljs-built_in">str</span>=<span class="hljs-string">&#x27;active&#x27;</span>, **kwargs: <span class="hljs-type">Any</span></span>) -&gt; SimulationManager:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;在`step`方法中作额外的处理&#x27;&#x27;&#x27;</span><br>        simgr.step(stash=stash, **kwargs)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">state_spiltter</span>(<span class="hljs-params">states: <span class="hljs-built_in">list</span>[SimState]</span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">list</span>[SimState], <span class="hljs-built_in">list</span>[SimState]]:<br>            keep, split = [], []<br>            <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> states:<br>                <span class="hljs-keyword">if</span> self.inside_maze(state): <span class="hljs-comment"># 只处理函数内部</span><br>                    addr = state.addr<br>                    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(addr, <span class="hljs-built_in">int</span>)<br>                    current = self.current_pos(state)<br>                    <span class="hljs-keyword">if</span> addr <span class="hljs-keyword">in</span> self._depth <span class="hljs-keyword">and</span> self._depth[addr] &lt; current:<br>                        split.append(state) <span class="hljs-comment"># 丢弃已经访问过的部分</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self._depth[addr] = current<br>                        keep.append(state)<br>                <span class="hljs-keyword">else</span>:<br>                    keep.append(state)<br>            <span class="hljs-keyword">return</span> keep, split<br>        simgr.split(state_spiltter, from_stash=<span class="hljs-string">&#x27;active&#x27;</span>, to_stash=<span class="hljs-string">&#x27;visited&#x27;</span>)<br>        simgr.move(<span class="hljs-string">&#x27;active&#x27;</span>, <span class="hljs-string">&#x27;found&#x27;</span>, <span class="hljs-keyword">lambda</span> state: state.addr == self._final_addr)<br>        <span class="hljs-keyword">return</span> simgr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params">self, simgr: SimulationManager</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(simgr.found)<br><br>proj = Project(<span class="hljs-string">&#x27;maze&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>, main_opts=&#123;<span class="hljs-string">&#x27;base_addr&#x27;</span>: <span class="hljs-number">0</span>&#125;)<br>key: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;key&#x27;</span>)<br>steps: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;steps&#x27;</span>)<br>current: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;current&#x27;</span>)<br>maze_walk: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;maze_walk&#x27;</span>)<br>maze_final: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;maze_final&#x27;</span>)<br><br>state: SimState = proj.factory.call_state(maze_walk.rebased_addr, prototype=<span class="hljs-string">&#x27;void f()&#x27;</span>)<br>state.options.add(ZERO_FILL_UNCONSTRAINED_REGISTERS)<br>key_value = BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">64</span>)<br>state.memory.store(steps.rebased_addr, key_value)<br>state.memory.store(key.rebased_addr, key_value)<br><br><span class="hljs-comment"># 使用我们自己的`ExplorationTechnique`</span><br>tech = MazeWalker(<br>    (maze_walk.rebased_addr, maze_walk.rebased_addr + maze_walk.size),<br>    current.rebased_addr,<br>    maze_final.rebased_addr<br>)<br>simgr = proj.factory.simgr(state)<br>simgr.use_technique(tech)<br><br><span class="hljs-comment"># 运行直到产生 `found` stash</span><br>simgr.run()<br>simgr.remove_technique(tech)<br><br><span class="hljs-comment"># 继续运行直到输出flag</span><br><span class="hljs-built_in">print</span>(<br>    proj.factory<br>    .simgr(simgr.found[<span class="hljs-number">0</span>])<br>    .run()<br>    .deadended[<span class="hljs-number">0</span>]<br>    .posix.dumps(<span class="hljs-number">1</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="生成"><a class="markdownIt-Anchor" href="#生成"></a> 生成</h3><p>从<a href="assets/maze.zip">这里</a>查看生成二进制文件的源代码。控制流的生成使用了<a href="https://github.com/numba/llvmlite">llvmlite</a>库，在Linux下运行<code>./maze.py</code>即可生成<code>maze</code>可执行文件，在windows下运行时也可以生成<code>maze.exe</code>，但是它没有生成<code>maze.pdb</code>导致最终二进制没有符号信息。</p><h3 id="类似"><a class="markdownIt-Anchor" href="#类似"></a> 类似</h3><p><a href="https://zzzzsky.com/2021/12/09/networkx%E8%A7%A3%E5%86%B3CTF_RE%E5%9B%BE%E9%97%AE%E9%A2%98/">networkx解决CTF_RE图问题</a></p><h2 id="magical_syscall"><a class="markdownIt-Anchor" href="#magical_syscall"></a> magical_syscall</h2><h3 id="几个要点"><a class="markdownIt-Anchor" href="#几个要点"></a> 几个要点</h3><h4 id="_init_array"><a class="markdownIt-Anchor" href="#_init_array"></a> _init_array</h4><p>_init_array是程序的初始化列表，其中注册的函数会在main函数开始之前被调用。</p><h4 id="两个简单的反调试"><a class="markdownIt-Anchor" href="#两个简单的反调试"></a> 两个简单的反调试</h4><p>在初始化列表里注册了两个反调试函数。</p><p>一个是通过检查<code>/proc/self/status</code>文件中<code>TracePid</code>内容，判断是否被调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">nsigned __int64 <span class="hljs-title function_">sub_128C</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *i; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">size_t</span> v1; <span class="hljs-comment">// rax</span><br>  FILE *stream; <span class="hljs-comment">// [rsp+10h] [rbp-120h]</span><br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  stream = fopen(<span class="hljs-string">&quot;/proc/self/status&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">for</span> ( i = fgets(v4, <span class="hljs-number">256</span>, stream); i; i = fgets(v4, <span class="hljs-number">256</span>, stream) )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strstr</span>(v4, <span class="hljs-string">&quot;TracerPid&quot;</span>) )<br>    &#123;<br>      v1 = <span class="hljs-built_in">strlen</span>(v4);<br>      <span class="hljs-keyword">if</span> ( atoi(&amp;v4[v1 - <span class="hljs-number">3</span>]) )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;debugger detected, exit...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v5 - __readfsqword(<span class="hljs-number">0x28</span>u);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个是自定义了signal handler，并在程序运行10s后alarm，即当程序运行超过10s后会直接退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_1253</span><span class="hljs-params">()</span><br>&#123;<br>  signal(<span class="hljs-number">14</span>, handler);<br>  signal(<span class="hljs-number">5</span>, (<span class="hljs-type">__sighandler_t</span>)sub_1236);<br>  <span class="hljs-keyword">return</span> alarm(<span class="hljs-number">0xA</span>u);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这不是这道题的重点，所以没有在这为难大家，只是让大家了解一下。至于绕过只要给exit扬了就行。alarm信号在IDA调试时也可以直接忽略。</p><h4 id="ptrace"><a class="markdownIt-Anchor" href="#ptrace"></a> Ptrace</h4><p>​ptrace是linux的一个系统调用，一个进程可以通过ptrace查看甚至控制另一个进程的内部状态。大名鼎鼎的调试器gdb就是基于ptrace实现的，这里推荐一篇<a href="https://xz.aliyun.com/t/6882">文章</a></p><p>ptrace函数是C标准库对ptrace syscall的封装，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span>       </span><br><span class="hljs-type">long</span> <span class="hljs-title function_">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">void</span> *addr, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><ul><li>request：要进行的ptrace操作</li><li>pid：要操作的进程号</li><li>addr：要监控/修改的内存地址</li><li>data：要读取/写入的数据变量</li></ul><p>常见的request操作可以看<a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">这</a></p><p>详细解释</p><ul><li><p>ptrace系统调⽤提供了⼀个进程(<code>tracer</code>)可以控制另⼀个进程(<code>tracer</code>)运⾏的⽅法，并且 <code>tracer</code> 可以监控和修改 <code>tracer</code> 的内存和寄存器，主要⽤作实现断点调试和系统调⽤追踪。</p></li><li><p>当⽗进程使⽤ <code>ptrace</code> 函数并传递 <code>PTRACE_SYSCALL</code> 参数来监控⼦进程时，它会暂停⼦进程的执行并等待下⼀个系统调⽤。</p></li><li><p>具体来说，当子进程调⽤⼀个系统调⽤并引发⼀个中断时，⽗进程会收到⼀个 <code>SIGTRAP</code> 信号，并可以通过 <code>waitpid</code> 函数等待⼦进程进⼊暂停状态。此时，⽗进程可以使⽤ <code>ptrace</code> 函数再次传 递 <code>PTRACE_SYSCALL</code> 参数来恢复⼦进程的执⾏，并让子进程继续进⾏系统调用。</p></li><li><p>在这种情况下，父进程不会修改子进程的寄存器或内存值，只是简单地等待并恢复子进程的执行。这 个过程可以反复进行，直到子进程结束或父进程选择终止跟踪操作。</p></li></ul><h4 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h4><ul><li><p>fork是linux的一个系统调用，用来根据当前进程创建子进程。</p></li><li><p>fork函数是C标准库对fork syscall的封装。值得关注的是函数的返回值。返回值小于0说明创建子进程失败，在子进程中，返回值为0，而在父进程中，返回值为子进程的进程号(pid)。在实际编程中常用if分支通过返回值来区分父子进程，执行不同的代码。</p></li></ul><h4 id="user_regs_struct"><a class="markdownIt-Anchor" href="#user_regs_struct"></a> user_regs_struct</h4><p>这是一个定义了一系列寄存器的结构体，本身是专门为gdb写的，想看详细内容的话可以在C源文件里写一句<code>#include &lt;sys/user.h&gt;</code>，然后戳进去看就行了。</p><p>这个东西在进行ptrace操作（读写内存、寄存器）时很有用，可以在IDA里导入这个结构体方便分析。</p><ul><li><p>导入结构体前</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307181650024.png" alt="image-20230718165027981" /></p></li><li><p>导入后</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307181651189.png" alt="image-20230718165100151" /></p></li></ul><h4 id="通过ptrace自定义syscall"><a class="markdownIt-Anchor" href="#通过ptrace自定义syscall"></a> 通过ptrace自定义syscall</h4><p>syscall的过程是代码从用户态进入内核态的过程。如果我们把用户态换成子进程，内核态换成父进程，通过ptrace进行父进程对子进程内存空间的读写，模拟内核执行代码时的数据处理，就能实现自定义syscall。这是理解这道题运行逻辑的核心。</p><p><a href="https://filippo.io/linux-syscall-table/">常见的系统调用号</a></p><p>对应Syscall的过程可以参考<a href="https://blog.csdn.net/yanbw/article/details/123076039">syscall过程</a></p><h3 id="程序运行逻辑"><a class="markdownIt-Anchor" href="#程序运行逻辑"></a> 程序运行逻辑</h3><p>下面按顺序梳理一下整个程序的运行逻辑</p><p>首先fork出子进程，子进程执行tracee函数，父进程执行tracer函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1D8B</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  v1 = fork();<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;failed to creat subprocess&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( v1 )<br>    tracer(v1);<br>  <span class="hljs-keyword">return</span> tracee();<br>&#125;<br></code></pre></td></tr></table></figure><p>子进程进入tracee函数，先ptrace TRACEME告诉操作系统自己要被父进程追踪，然后发送SIGCONT信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1386</span><span class="hljs-params">()</span><br>&#123;<br>  ptrace(PTRACE_TRACEME, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> raise(SIGCONT);<br>&#125;<br></code></pre></td></tr></table></figure><p>父进程进入tracer函数，先通过waitpid函数等待子进程SIGCONT信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">waitpid(a1, &amp;stat_loc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int8)stat_loc != <span class="hljs-number">127</span> ) <span class="hljs-comment">// !WIFSTOPPED(status) 如果子进程不是正常退出的，则进入if分支</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;debugger detected, exit...&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>ptrace(PTRACE_SETOPTIONS, a1, <span class="hljs-number">0LL</span>, PTRACE_O_EXITKILL); <span class="hljs-comment">// 如果子进程处于退出状态，则kill掉父进程</span><br></code></pre></td></tr></table></figure><p>下面就是父进程中一个非常大的while循环，里面定义了一系列syscall，if判断的条件则是上面介绍的user_regs_struct里的<code>orig_rax</code>，即自定义syscall的系统调用号。</p><p>还有一个要点就是在while循环的开头和结尾都有这一句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ptrace(PTRACE_SYSCALL, a1, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br></code></pre></td></tr></table></figure><p>用处是使子进程在每次syscall开始和结束时停下，把控制权交给父进程进行相应操作。</p><p>到这有一点要明确，父进程会一直在while循环里呆着，永远也不会执行到main函数，而只有子进程真正去执行main函数代码。父进程最终会走到以下两个分支之一得以退出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">8888</span> )                         <span class="hljs-comment">// FAIL</span><br>  <span class="hljs-keyword">break</span>; <br><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">9999</span> )                         <span class="hljs-comment">// SUCCESS</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;congratulations&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>即程序最后check成功或失败的判断。</p><p>子进程执行的main函数非常简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;input your flag:&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    syscall(<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">1</span> + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">2</span> + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">3</span> + <span class="hljs-number">468</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印提示信息后，只有一个死循环，里面不断去执行syscall，正是这里执行的syscall会被父进程拦截并进行相应操作，syscall的参数即分别为系统调用号和所需参数。有些自定义的syscall并不需要3个参数，但由于这里并不会修改这些值，所以传几个多余的参数不会有任何影响。</p><h3 id="vm逆向"><a class="markdownIt-Anchor" href="#vm逆向"></a> VM逆向</h3><p>有经验的逆向壬应该一眼vm了，以上内容不关心靠猜也能七七八八。</p><p>这道题中vm的突破点应该在变量的识别。首先pc应该很容易看出来，毕竟每个syscall之后都会把它加上2或3或4，即那条指令的长度。其次是导入user_regs_struct之后就可以比较清晰的看懂几个参数了。</p><p>然后通过几个syscall对比来看应该也能看出来一些特殊的指令。</p><p>比如完全对称的push和pop：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3904</span> )                         <span class="hljs-comment">// PUSH</span><br>    &#123;<br>      dword_40B4 = ptrace(PTRACE_PEEKDATA, a1, &amp;dword_40B4, <span class="hljs-number">0LL</span>);<br>      dword_40AC[++dword_40A4 + <span class="hljs-number">4</span>] = dword_40B4;<br>      ++pc;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3905</span> )                         <span class="hljs-comment">// POP</span><br>    &#123;<br>      dword_40B4 = dword_40AC[dword_40A4-- + <span class="hljs-number">4</span>];<br>      ++pc;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br></code></pre></td></tr></table></figure><p>互相有联系的CMP、JE、JNE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3906</span> )                         <span class="hljs-comment">// CMP</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( arg2 )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( arg2 == <span class="hljs-number">1</span> )<br>          flag_zf = dword_40A8 == dword_40B4;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        flag_zf = dword_40B0 == arg3;<br>      &#125;<br>      pc += <span class="hljs-number">3</span>;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3907</span> )                         <span class="hljs-comment">// JE</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( flag_zf )<br>      &#123;<br>        pc = arg2;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)arg2);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        pc += <span class="hljs-number">2</span>;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3908</span> )                         <span class="hljs-comment">// JNE</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( flag_zf )<br>      &#123;<br>        pc += <span class="hljs-number">2</span>;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        pc = arg2;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)arg2);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后基本就能看出来像<code>dword_40B0</code>这样的是一些通用寄存器(ax、bx、cx…)</p><p>再往下就是一些计算类的指令，比如INC、MOD、XOR、RESET（置零）应该也不难看出</p><p>难度较大的应该是ADD、MOV指令，因为这俩实际做的事取决于参数，会对不同的寄存器/内存地址进行ADD、MOV操作，这里就需要认真对参数进行分析，搞清楚具体的指令的含义。</p><p>整个VM实际实现了一个RC4加密，然后和密文比较的过程，出题时写的伪汇编看<a href="https://github.com/XDSEC/miniLCTF_2023/blob/main/Challenges/magical_syscall/src/assembly.txt">这里</a></p><p>另一个点在于XCHG指令，即实现两个值的交换，但这里因为并没有使用临时变量存储其中一个变量原先的值，所以是个假的交换，相当于<code>a = b; b = a;</code>这样的操作，这也是RC4的魔改点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3912</span> )                         <span class="hljs-comment">// XCHG</span><br>&#123;<br>  *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40B0) = *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[<span class="hljs-number">0</span>]);<br>  *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[<span class="hljs-number">0</span>]) = *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40B0);<br>  ++pc;<br>  ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4_init</span>(<span class="hljs-params">s, key, key_len</span>):<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        j = (j + s[i] + key[i%key_len])%<span class="hljs-number">256</span><br>        <span class="hljs-comment"># tmp = s[i]</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4_generate_keystream</span>(<span class="hljs-params">s, length</span>):<br>    i = <span class="hljs-number">0</span><br>    j = <span class="hljs-number">0</span><br>    key_stream = []<br>    <span class="hljs-keyword">while</span> length:<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>    <span class="hljs-comment"># 可以保证每256次循环后s盒中的每个元素至少被交换一次</span><br>        j = (j + s[i]) % <span class="hljs-number">256</span><br>        <span class="hljs-comment"># tmp = s[i]</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br>        key_stream.append(s[(s[i] + s[j]) % <span class="hljs-number">256</span>])<br>        length -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> key_stream<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    key = [<span class="hljs-built_in">ord</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;MiniLCTF2023&quot;</span>]        <span class="hljs-comment"># 准备一些变量</span><br>    key_len = <span class="hljs-built_in">len</span>(key)<br>    <span class="hljs-comment"># enc = [ord(i) for i in &quot;llac$ys_laci9am_ht1w_en1hc@m_l@utr1v_a&quot;]</span><br>    enc = [<span class="hljs-number">147</span>, <span class="hljs-number">163</span>, <span class="hljs-number">203</span>, <span class="hljs-number">201</span>, <span class="hljs-number">214</span>, <span class="hljs-number">211</span>, <span class="hljs-number">240</span>, <span class="hljs-number">213</span>, <span class="hljs-number">177</span>, <span class="hljs-number">26</span>, <span class="hljs-number">84</span>, <span class="hljs-number">155</span>, <span class="hljs-number">80</span>, <span class="hljs-number">203</span>, <span class="hljs-number">176</span>, <span class="hljs-number">178</span>, <span class="hljs-number">235</span>, <span class="hljs-number">15</span>, <span class="hljs-number">178</span>, <span class="hljs-number">141</span>, <span class="hljs-number">47</span>, <span class="hljs-number">230</span>, <span class="hljs-number">21</span>, <span class="hljs-number">203</span>, <span class="hljs-number">181</span>, <span class="hljs-number">61</span>, <span class="hljs-number">215</span>, <span class="hljs-number">156</span>, <span class="hljs-number">197</span>, <span class="hljs-number">129</span>, <span class="hljs-number">63</span>, <span class="hljs-number">145</span>, <span class="hljs-number">144</span>, <span class="hljs-number">241</span>, <span class="hljs-number">155</span>, <span class="hljs-number">171</span>, <span class="hljs-number">47</span>, <span class="hljs-number">242</span>]<br>    enc_len = <span class="hljs-built_in">len</span>(enc)<br>    cipher = [<span class="hljs-number">0</span>] * enc_len<br><br>    s = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)]    <span class="hljs-comment"># 初始化s盒</span><br>    rc4_init(s, key, key_len)      <span class="hljs-comment"># 使用key打乱s盒</span><br>    key_stream = rc4_generate_keystream(s[:], enc_len) <span class="hljs-comment"># 生成密钥流</span><br>    <span class="hljs-comment"># print(key_stream)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(enc_len):     <span class="hljs-comment"># 逐字节异或加密</span><br>        cipher[i] = enc[i] ^ key_stream[i]<br>    cipher = cipher[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cipher))<br>    <span class="hljs-comment"># print(cipher)</span><br>    <span class="hljs-comment"># print(len(cipher))</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="巅峰极客"><a class="markdownIt-Anchor" href="#巅峰极客"></a> 巅峰极客</h1><h2 id="g0re"><a class="markdownIt-Anchor" href="#g0re"></a> g0Re</h2><h3 id="upx脱壳"><a class="markdownIt-Anchor" href="#upx脱壳"></a> UPX脱壳</h3><p>​可以用 DIE 检测出来是 go程序 和 UPX 壳，但是工具脱不了，只有手动脱壳，<a href="https://xz.aliyun.com/t/6881">参考</a>获得 <code>dumpfile</code> 文件</p><h3 id="go逆向"><a class="markdownIt-Anchor" href="#go逆向"></a> go逆向</h3><p>​首先分析go中的最后flag比对处，根据动调可以发现这里将一个 <code>base64</code> 加密的结果和字符串<code>wvgitbygwbk2b46d</code>进行相加之后再异或。之后根据 IDA 的插件感觉加密方式为 <code>AES</code> 加密，上面的字符串就是密钥。</p><p>​这里进行动调，首先锁定之后出现的那个 base64 的可疑字符，记住其地址，加硬件断点，之后直接动调(动调记得把其余的线程暂停suspended，否则程序会跳转到很奇怪的地方去)。观察硬件断点的变化。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307212201006.png" alt="image-20230721220157932" /></p><p>​这里发现可能就是变表的base64加密，之后提取改变的base64表。之后得到了这个 <code>main_sub_12da08()</code> 函数在进行base64加密的操作。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307212202817.png" alt="image-20230721220252766" /></p><p>​然后又有动调分析了 <code>main_io_read()</code> 函数是得到了密钥， <code>runtime_stringtoslicebyte()</code> 函数知识将输入加到了密钥后面，则动调分析比对之前仅剩的 <code>main_sub_53d398()</code> 函数，发现其中有一个 <code>crypto_aes_NewCipher()</code> 函数，肯定了 <code>AES</code> 加密的猜想，之后再动调分析。 这里动调没有找到输入点，这里对于go的逆向还是有点菜，再接再厉。</p><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> base64<br>key = <span class="hljs-string">&#x27;wvgitbygwbk2b46d&#x27;</span><br>enc = [<span class="hljs-number">0xE6</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xD9</span>,<br>  <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0xC0</span>,<br>  <span class="hljs-number">0x96</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0xA5</span>,<br>  <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xC9</span>,<br>  <span class="hljs-number">0xB7</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0xED</span>,<br>  <span class="hljs-number">0x92</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0xA3</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xA5</span>,<br>  <span class="hljs-number">0xAA</span>, <span class="hljs-number">0xB2</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0xA7</span>]<br><br>enc1 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  enc[i] = (enc[i] - <span class="hljs-built_in">ord</span>(key[i % <span class="hljs-built_in">len</span>(key)])) ^ <span class="hljs-number">0x1A</span><br>enc = <span class="hljs-built_in">bytes</span>(enc).decode()<br>new_table = <span class="hljs-string">&quot;456789&#125;#IJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123ABCDEFGH&quot;</span><br>old_table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>aes_enc = base64.b64decode(enc.translate(<span class="hljs-built_in">str</span>.maketrans(new_table, old_table)))<br>aes = AES.new(<span class="hljs-string">b&#x27;wvgitbygwbk2b46d&#x27;</span>, AES.MODE_ECB) <span class="hljs-comment">#创建一个aes对象</span><br>flag = aes.decrypt(aes_enc) <span class="hljs-comment"># 解密密文</span><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="m1_read"><a class="markdownIt-Anchor" href="#m1_read"></a> m1_read</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>​这是一个关于 m1读卡器 的问题，其中包含 <code>DFA分析白盒AES算法</code> 的知识，具体参考：<a href="https://www.qinless.com/1647">DFA</a></p><h3 id="整体分析"><a class="markdownIt-Anchor" href="#整体分析"></a> 整体分析</h3><p>​这里是MFC写的读卡程序，发现那些按钮的主要处理函数似乎都会调用 <code>sub_140004A00</code>，跟进去看发现应该是对程序输入的数据进行统一处理的函数。其中调用了函数 <code>sub_140004BF0</code>，细看一下可以发现前面应该是AES白盒加密算法（可以对比N1CTF2021 hello这题），后面对数据异或0x66。</p><h3 id="qiling模拟执行"><a class="markdownIt-Anchor" href="#qiling模拟执行"></a> Qiling模拟执行</h3><p>​这里我们的目的就是模拟执行函数 <code>sub_140004BF0</code> 来插入缺陷数据和获取错误密文，这里由分析，需要 16 个错误的密文才能恢复原始密钥。</p><h4 id="参数传入"><a class="markdownIt-Anchor" href="#参数传入"></a> 参数传入</h4><p>​这里的 <code>rcx</code> 存储着输入的地址，即传入的第一个参数的地址(没有读卡器，从别的 WP 中获取的信息)。这里模拟执行该函数，需要在函数起始地址修改寄存器的值，使其指向在内存中分配并初始化的<code>输入</code>。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242131745.png" alt="image-20230724213132695" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_args</span>(<span class="hljs-params">ql: Qiling</span>):<br>    ql.mem.write(<span class="hljs-number">0x500000000</span>, <span class="hljs-string">b&quot;\x01&quot;</span> * <span class="hljs-number">16</span>) <span class="hljs-comment"># 在虚拟内存地址0x500000000(不干扰程序的内存空间)处写入一个16字节的字节序列，这是在向指定地址写⼊需要加密的内容</span><br>    ql.arch.regs.write(<span class="hljs-string">&quot;rcx&quot;</span>, <span class="hljs-number">0x500000000</span>) <span class="hljs-comment"># 将模拟器的rcx寄存器设置为 0x500000000</span><br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rdx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rbx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br>start_addr = <span class="hljs-number">0x140004BF0</span><br>ql.hook_address(hook_args, start_addr)<br></code></pre></td></tr></table></figure><h4 id="定位插入缺陷数据的位置"><a class="markdownIt-Anchor" href="#定位插入缺陷数据的位置"></a> 定位插入缺陷数据的位置</h4><p>​首先确认 AES 最后两次列混合的位置，这里分为了前9轮和第10轮两种，那么最后两次列混合就在第8轮与第9轮之间，这里可知第九轮为<code>v4 == 0x9000</code> ，则需要在第八轮后，即 <code>v4 == 0x8000 ---- r12 == 8000h </code> 的位置之后插入缺陷数据。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242013258.png" alt="image-20230724201323127" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242015656.png" alt="image-20230724201532610" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">index = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_code</span>(<span class="hljs-params">ql: Qiling</span>):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.read(<span class="hljs-string">&quot;r12&quot;</span>) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> index <span class="hljs-comment"># 定义为全局变量</span><br>        ql.mem.write(<span class="hljs-number">0x500000000</span> + index, <span class="hljs-string">b&quot;\x00&quot;</span>)<span class="hljs-comment"># 这里的 b&quot;\x00&quot; 就是插入的残缺数据</span><br>        index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>​这里 <code>ql.mem.write(0x500000000 + index, b&quot;\x00&quot;)</code> 与后面的16次循环都是为了插入缺陷数据而服务的，但是还需要一个正确的第10轮之后的密钥，所以不再加上这个语句和16个循环再单独执行一遍。</p><h4 id="获取密文"><a class="markdownIt-Anchor" href="#获取密文"></a> 获取密文</h4><p>​函数在 <code>ecx的地址处</code> 进行更改，所以最后也在ecx处获取错误密文即可。(先不关注最后的 xor 0x66)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242217734.png" alt="image-20230724221758695" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242218611.png" alt="image-20230724221820579" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_enc</span>(<span class="hljs-params">ql: Qiling</span>):<br><span class="hljs-built_in">print</span>(ql.mem.read(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).<span class="hljs-built_in">hex</span>())<br><span class="hljs-keyword">return</span><br><br>enc_after = <span class="hljs-number">0x1400053CA</span><br>ql.hook_address(hook_enc, enc_after)<br></code></pre></td></tr></table></figure><h4 id="获取所有错误密文"><a class="markdownIt-Anchor" href="#获取所有错误密文"></a> 获取所有错误密文</h4><p>​这里经过验证，错误密文与原先密文相比，只有4个字节不同，则此方法可行。那么就来只需要逐字节来插入缺陷数据即可得到所有的错误密文。这里通过更改 <code>index</code> 的值来逐字节插入缺陷数据。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> qiling <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> qiling.const <span class="hljs-keyword">import</span> QL_VERBOSE<br><br><span class="hljs-keyword">index</span> = <span class="hljs-number">0</span><br>ql = Qiling(<br>    [&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows\\m1_read.exe&quot;],<br>    r&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows&quot;,<br>    <span class="hljs-keyword">verbose</span>=QL_VERBOSE.<span class="hljs-keyword">OFF</span>,<br>)<br><br><br>def hook_args(ql: Qiling):<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span>, b&quot;\x01&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rcx&quot;, <span class="hljs-number">0x500000000</span>)<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, b&quot;\x00&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rdx&quot;, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, b&quot;\x00&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rbx&quot;, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br><br>def hook_code(ql: Qiling):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.<span class="hljs-keyword">read</span>(&quot;r12&quot;) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> <span class="hljs-keyword">index</span><br>        ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-keyword">index</span>, b&quot;\x00&quot;)<br>        <span class="hljs-keyword">index</span> += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br><br><br>def hook_enc(ql: Qiling):<br>    print(ql.mem.<span class="hljs-keyword">read</span>(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).hex())<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == &quot;__main__&quot;:<br>    index_addr = <span class="hljs-number">0x1400052C5</span><br>    start_addr = <span class="hljs-number">0x140004BF0</span><br>    end_addr = <span class="hljs-number">0x14000542D</span><br>    enc_after = <span class="hljs-number">0x1400053CA</span><br>    ql.hook_address(hook_args, start_addr)<br>    ql.hook_address(hook_code, index_addr)<br>    ql.hook_address(hook_enc, enc_after)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>):<br>        ql.run(<span class="hljs-keyword">begin</span>=start_addr, end=end_addr)<br></code></pre></td></tr></table></figure><h4 id="获取正确第10轮密文"><a class="markdownIt-Anchor" href="#获取正确第10轮密文"></a> 获取正确第10轮密文</h4><p>​将 <code>ql.mem.write(0x500000000 + index, b&quot;\x00&quot;)</code> 与 <code>16轮循环</code> 从获取错误密钥的代码中去掉即可。</p><h4 id="获得原始密钥"><a class="markdownIt-Anchor" href="#获得原始密钥"></a> 获得原始密钥</h4><p>​得到16个错误密文，再加上一个正确的密文，就可以获得第10轮的密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> phoenixAES<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tracefile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> t:<br>    t.write(<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    e14d5d0ee27715df08b4152ba23da8e0</span><br><span class="hljs-string">    d24d5d0ee27715ac08b4bf2ba272a8e0</span><br><span class="hljs-string">    e14d5d73e27708df0878152b843da8e0</span><br><span class="hljs-string">    e14dd50ee23415df7fb4152ba23da890</span><br><span class="hljs-string">    e16f5d0e537715df08b415e7a23dc6e0</span><br><span class="hljs-string">    e11a5d0e057715df08b4151ba23d99e0</span><br><span class="hljs-string">    574d5d0ee277157508b4df2ba234a8e0</span><br><span class="hljs-string">    e14d5d49e27785df0840152bff3da8e0</span><br><span class="hljs-string">    e14db80ee2d215dfceb4152ba23da868</span><br><span class="hljs-string">    e14dc60ee2bf15dfc4b4152ba23da8bf</span><br><span class="hljs-string">    e1425d0e5e7715df08b415b6a23d4ce0</span><br><span class="hljs-string">    5d4d5d0ee277159608b42f2ba297a8e0</span><br><span class="hljs-string">    e14d5d6ce2773ddf089d152ba93da8e0</span><br><span class="hljs-string">    e14d5dcde2772adf084b152bba3da8e0</span><br><span class="hljs-string">    e14df40ee27115df96b4152ba23da881</span><br><span class="hljs-string">    e11b5d0e337715df08b41544a23df3e0</span><br><span class="hljs-string">    fa4d5d0ee27715af08b42e2ba2c2a8e0</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.encode(<br>            <span class="hljs-string">&quot;utf8&quot;</span><br>        )<br>    )<br>phoenixAES.crack_file(<span class="hljs-string">&quot;tracefile&quot;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>​之后使用 <code>Stark</code> 项目就可以得到原始密钥</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242234920.png" alt="image-20230724223417776" /></p><h4 id="获得flag"><a class="markdownIt-Anchor" href="#获得flag"></a> 获得flag</h4><p>​之后由 <code>out.bin</code> 文件中提取出密文，然后使用AES算法进行解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br>enc = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;0B 98 7E F5 D9 4D D6 79 59 2C 4D 2F AD D4 EB 89&quot;</span>))<br>enc = <span class="hljs-built_in">bytes</span>([enc[i] ^ <span class="hljs-number">0x66</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>)])<br>key = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>)<br>aes = AES.new(key=key, mode=AES.MODE_ECB)<br><span class="hljs-built_in">print</span>(aes.decrypt(enc))<br></code></pre></td></tr></table></figure><h3 id="直接解密"><a class="markdownIt-Anchor" href="#直接解密"></a> 直接解密</h3><p>​分析出了 ARS白盒加密算法，<code>比对N1CTF2021 hello</code> <a href="https://github.com/Nu1LCTF/n1ctf-2021/tree/84a3fff50ee0ef2f1fece112c75104600cc86a5d/Re/hello">参考解法</a>即Chow方案，然后对数据进行 xor 0x66操作。这里 hello 可以参考最开始的 DFA 的文章一起分析。</p><p>​首先从tbox解出key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> CryptoAttacks.Block.whitebox_aes_sage <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> CryptoAttacks.Utils <span class="hljs-keyword">import</span> *<br><br>T = [<span class="hljs-number">0x7C</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x39</span>, ... , <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>]<br><br>TTyboxFinal = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(T), <span class="hljs-number">256</span>):<br>    TTyboxFinal.append(T[i:i+<span class="hljs-number">256</span>])<br><br>key_recovered = recover_key_unprotected_wbaes_from_TTyboxFinal(TTyboxFinal)<br>key = matrix_to_array(key_recovered)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment"># print(&#x27;&#x27;.join(list(map(chr,key))))</span><br></code></pre></td></tr></table></figure><p>​得到key为：b’\x00’*16，之后就是正常aes进行解密。</p><blockquote><p>库的地址为:<a href="https://github.com/GrosQuildu/CryptoAttacks%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%85%B6%E4%B8%ADwhitebox_aes.sage%E5%A4%9A%E6%96%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%9C%A8sage%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AE%9E%E7%8E%B0(maybe)">https://github.com/GrosQuildu/CryptoAttacks，但是安装并不成功，其中whitebox_aes.sage多方报错，可能需要在sage环境中实现(maybe)</a></p></blockquote><h3 id="frida模拟执行"><a class="markdownIt-Anchor" href="#frida模拟执行"></a> frida模拟执行</h3><blockquote><p>frida -p &lt;PID或者进程名称&gt; -l hook_example.js</p></blockquote><h4 id="得到161个密文"><a class="markdownIt-Anchor" href="#得到161个密文"></a> 得到16+1个密文</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> baseAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;m1_read.exe&quot;</span>);<span class="hljs-comment">//使用frida的&quot;Module.findBaseAddress&quot;来查找目标程序</span><br><span class="hljs-keyword">var</span> whiteAES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4BF0</span>), <span class="hljs-string">&#x27;pointer&#x27;</span>, [<span class="hljs-string">&#x27;pointer&#x27;</span>, <span class="hljs-string">&#x27;pointer&#x27;</span>])<span class="hljs-comment">// 创建一个NativeFunction对象，用于调用位于&quot;m1_read.exe&quot;程序基址加上0x4BF0偏移的函数。接收两个参数，均为指针，并返回一个指针。这里实际上是在将&quot;m1_read.exe&quot;中的函数whiteAES绑定到JavaScript中，以便我们可以在后面的代码中调用它。</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">9</span>;<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4C2C</span>), &#123;<br>    <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<span class="hljs-comment">//进入目标函数时</span><br>        count++;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">9</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">rdi</span>.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">16</span>)).<span class="hljs-title function_">writeU8</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>))<br>        &#125;<br>    &#125;,<span class="hljs-comment">//在这里，count递增，并且如果count等于9，则在rdi寄存器指向的内存地址上随机写入一个字节（0-255的随机值）</span><br>    <span class="hljs-attr">onLeave</span>: <span class="hljs-function">(<span class="hljs-params">retval</span>) =&gt;</span> &#123;<br><br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">33</span>; index++) &#123;<br>    <span class="hljs-keyword">var</span> l = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">allocAnsiString</span>(<span class="hljs-string">&quot;1234567890abcdef&quot;</span>);<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-title function_">whiteAES</span>(l, b);<span class="hljs-comment">//这行代码调用之前绑定的whiteAES函数，传入l和b作为参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-title function_">readByteArray</span>(<span class="hljs-number">16</span>));<span class="hljs-comment">//最后，它将读取并打印由b指向的16字节内存区域的内容</span><br>    count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里进行异或处理，恢复正常AES的结果(从结果中随意挑选了17个)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">str_table = [<span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f 36 6b fa ee 5e 54 c8 8f 14 c9 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 2a dc 6b 53 9b 5e f2 0c 8f 14 b0 3b ae 05&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f b4 6b fa 7d 5e 54 fd 8f 14 fe 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;fd 42 9f dc 6b fa 9b 72 54 0c a8 14 b0 48 ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f 70 6b fa ba 5e 54 21 8f 14 3f 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 0c dc 6b d7 9b 5e 2a 0c 8f 14 b0 3b ae 6b&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 39 dc 6b a0 9b 5e ec 0c 8f 14 b0 3b ae c0&quot;</span>,<br>             <span class="hljs-string">&quot;2b 42 9f dc 6b fa 9b f5 54 0c 80 14 b0 af ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;c1 42 9f dc 6b fa 9b 95 54 0c 0e 14 b0 34 ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 ec dc 6b 77 9b 5e f7 0c 8f 14 b0 3b ae 51&quot;</span>,<br>             <span class="hljs-string">&quot;ca 5e 9f dc 52 fa 9b 5e 54 0c 8f 99 b0 3b df 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 02 9f dc c0 fa 9b 5e 54 0c 8f 92 b0 3b f1 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f b4 6b fa 7d 5e 54 fd 8f 14 fe 3b ae 88&quot;</span>]<br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> str_table:<br>    val = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(s))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<br>        val[i] ^= <span class="hljs-number">0x66</span><br>    <span class="hljs-built_in">print</span>(val.<span class="hljs-built_in">hex</span>())<br></code></pre></td></tr></table></figure><h4 id="获得正确第10轮密文"><a class="markdownIt-Anchor" href="#获得正确第10轮密文"></a> 获得正确第10轮密文</h4><p>​同上，把相应的数据填入上面的代码中</p><h4 id="获得flag-2"><a class="markdownIt-Anchor" href="#获得flag-2"></a> 获得flag</h4><p>​之后使用 <code>Stark</code> 项目就可以得到原始密钥，然后使用上述代码获得flag</p><h1 id="das7月"><a class="markdownIt-Anchor" href="#das7月"></a> DAS7月</h1><h2 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> helloworld</h2><p>​根据字符串信息可得知程序基于oatpp框架开发，程序无符号，所以尝试编译一份demo，可参考<a href="https://blog.51cto.com/u_13999641/5101994">文章</a>生成demo，编译完成后使用bindiff恢复符号(这里我bindiff的插件恢复报错，直接IDA import symbols / comments，然后函数名很诡异，感觉是有的字符识别不出来)。</p><p>​知识点：在 oatpp 框架中，HTTP 响应的处理通常发生在控制器(Controller)或请求处理器(Request Handler)中。具体来说，当 oatpp 接收到一个 HTTP 请求时，它会根据路由配置找到相应的控制器或请求处理器，并由它们来处理请求并生成相应的 HTTP 响应。在这个过程中，响应的创建和处理通常在控制器或请求处理器中完成。具体的处理代码可能涉及到 oatpp 框架提供的一系列类和方法，如 <code>oatpp::web::protocol::http::outgoing::ResponseFactory</code> 和其他相关类。</p><p>​就是指的下面这个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义请求处理程序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> : <span class="hljs-keyword">public</span> oatpp::web::server::HttpRequestHandler<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 处理传入的请求，并返回响应</span><br>    <span class="hljs-function">std::shared_ptr&lt;OutgoingResponse&gt; <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;IncomingRequest&gt;&amp; request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-built_in">O_UNUSED</span>(request);<br><br>        <span class="hljs-keyword">return</span> ResponseFactory::<span class="hljs-built_in">createResponse</span>(Status::CODE_200, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​然后查找此函数的交叉引用，发现 <code>sub_40617E</code> 是关键函数，分析此函数。这里 <code>v16</code> 与 <code>v17</code> (截图的上面memcpy) 都被赋值进行操作，所以猜测需要还原 <code>v15</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307252202050.png" alt="image-20230725220207925" /></p><p>​之后根据对 <code>v16</code> 的判断作为决定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br>v16 = [<span class="hljs-number">0</span>]*<span class="hljs-number">40</span><br>v16[<span class="hljs-number">0</span>] = <span class="hljs-number">33211</span><br>v16[<span class="hljs-number">1</span>] = <span class="hljs-number">36113</span><br>v16[<span class="hljs-number">2</span>] = <span class="hljs-number">28786</span><br>v16[<span class="hljs-number">3</span>] = <span class="hljs-number">44634</span><br>v16[<span class="hljs-number">4</span>] = <span class="hljs-number">30174</span><br>v16[<span class="hljs-number">5</span>] = <span class="hljs-number">39163</span><br>v16[<span class="hljs-number">6</span>] = <span class="hljs-number">34923</span><br>v16[<span class="hljs-number">7</span>] = <span class="hljs-number">44333</span><br>v16[<span class="hljs-number">8</span>] = <span class="hljs-number">33574</span><br>v16[<span class="hljs-number">9</span>] = <span class="hljs-number">23555</span><br>v16[<span class="hljs-number">10</span>] = <span class="hljs-number">35015</span><br>v16[<span class="hljs-number">11</span>] = <span class="hljs-number">42724</span><br>v16[<span class="hljs-number">12</span>] = <span class="hljs-number">34160</span><br>v16[<span class="hljs-number">13</span>] = <span class="hljs-number">49166</span><br>v16[<span class="hljs-number">14</span>] = <span class="hljs-number">35770</span><br>v16[<span class="hljs-number">15</span>] = <span class="hljs-number">45984</span><br>v16[<span class="hljs-number">16</span>] = <span class="hljs-number">39754</span><br>v16[<span class="hljs-number">17</span>] = <span class="hljs-number">51672</span><br>v16[<span class="hljs-number">18</span>] = <span class="hljs-number">38323</span><br>v16[<span class="hljs-number">19</span>] = <span class="hljs-number">27511</span><br>v16[<span class="hljs-number">20</span>] = <span class="hljs-number">31334</span><br>v16[<span class="hljs-number">21</span>] = <span class="hljs-number">34214</span><br>v16[<span class="hljs-number">22</span>] = <span class="hljs-number">28014</span><br>v16[<span class="hljs-number">23</span>] = <span class="hljs-number">41090</span><br>v16[<span class="hljs-number">24</span>] = <span class="hljs-number">29258</span><br>v16[<span class="hljs-number">25</span>] = <span class="hljs-number">37905</span><br>v16[<span class="hljs-number">26</span>] = <span class="hljs-number">33777</span><br>v16[<span class="hljs-number">27</span>] = <span class="hljs-number">39812</span><br>v16[<span class="hljs-number">28</span>] = <span class="hljs-number">29442</span><br>v16[<span class="hljs-number">29</span>] = <span class="hljs-number">22225</span><br>v16[<span class="hljs-number">30</span>] = <span class="hljs-number">30853</span><br>v16[<span class="hljs-number">31</span>] = <span class="hljs-number">35330</span><br>v16[<span class="hljs-number">32</span>] = <span class="hljs-number">30393</span><br>v16[<span class="hljs-number">33</span>] = <span class="hljs-number">41247</span><br>v16[<span class="hljs-number">34</span>] = <span class="hljs-number">30439</span><br>v16[<span class="hljs-number">35</span>] = <span class="hljs-number">39434</span><br>v16[<span class="hljs-number">36</span>] = <span class="hljs-number">31587</span><br>v16[<span class="hljs-number">37</span>] = <span class="hljs-number">46815</span><br>v16[<span class="hljs-number">38</span>] = <span class="hljs-number">35205</span><br>v16[<span class="hljs-number">39</span>] = <span class="hljs-number">20689</span><br><br>v17 = [<span class="hljs-number">0x00000017</span>, <span class="hljs-number">0x0000000D</span>, <span class="hljs-number">0x00000004</span>, <span class="hljs-number">0x00000030</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x0000002A</span>, <span class="hljs-number">0x00000021</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000045</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x0000000D</span>, <span class="hljs-number">0x0000002D</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x00000008</span>, <span class="hljs-number">0x00000050</span>, <span class="hljs-number">0x0000000F</span>, <span class="hljs-number">0x0000002A</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x00000013</span>, <span class="hljs-number">0x0000003E</span>, <span class="hljs-number">0x00000046</span>, <span class="hljs-number">0x00000017</span>, <span class="hljs-number">0x0000003F</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x00000044</span>, <span class="hljs-number">0x00000011</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x0000000C</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x0000001F</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000011</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x0000003A</span>, <span class="hljs-number">0x00000009</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x00000053</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x00000034</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000059</span>, <span class="hljs-number">0x0000004C</span>, <span class="hljs-number">0x00000044</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000034</span>, <span class="hljs-number">0x0000002B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000002C</span>, <span class="hljs-number">0x00000032</span>, <span class="hljs-number">0x00000020</span>, <span class="hljs-number">0x00000032</span>, <span class="hljs-number">0x0000001F</span>, <span class="hljs-number">0x00000014</span>, <span class="hljs-number">0x0000003F</span>, <span class="hljs-number">0x00000002</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000039</span>, <span class="hljs-number">0x0000004F</span>, <span class="hljs-number">0x0000002B</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x00000013</span>, <span class="hljs-number">0x00000050</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x0000005D</span>, <span class="hljs-number">0x0000003A</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x0000004A</span>, <span class="hljs-number">0x00000051</span>, <span class="hljs-number">0x0000002D</span>, <span class="hljs-number">0x00000037</span>, <span class="hljs-number">0x00000015</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x0000001C</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x0000000C</span>, <span class="hljs-number">0x0000004D</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x00000004</span>, <span class="hljs-number">0x00000025</span>, <span class="hljs-number">0x00000043</span>, <span class="hljs-number">0x0000003C</span>, <span class="hljs-number">0x00000036</span>, <span class="hljs-number">0x00000033</span>, <span class="hljs-number">0x0000004F</span>, <span class="hljs-number">0x00000026</span>, <span class="hljs-number">0x00000057</span>, <span class="hljs-number">0x00000030</span>, <span class="hljs-number">0x00000010</span>]<br>v15 = [Int(<span class="hljs-string">&quot;v15[%d]&quot;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>)]<span class="hljs-comment"># 创建了&quot;v15[i]&quot;这种参数</span><br>s = Solver()<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            v16[<span class="hljs-number">10</span> * k + m] -= v15[<span class="hljs-number">10</span> * k + n] * v17[<span class="hljs-number">10</span> * n + m]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        s.add(v16[<span class="hljs-number">10</span>*i+j] == <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> s.check() == z3.sat:<br>    m = s.model()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(m[v15[i]].as_long()), end=<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-comment"># 从m中取出标号为”v15[i]“的值，然后转化为字符串</span><br></code></pre></td></tr></table></figure><h1 id="n1ctf-2023"><a class="markdownIt-Anchor" href="#n1ctf-2023"></a> N1CTF 2023</h1><h2 id="n1lua"><a class="markdownIt-Anchor" href="#n1lua"></a> N1Lua</h2><ul><li>首先使用 <code>AssetStudio</code> 把 <code>n1llua_Data目录</code>下的 <code>resources.assets文件</code> 进行解密(有报错直接点击确定即可), 之后得到 <code>main.lua文件</code>, 之后使用 <code>java -jar unluac_2023_09_20.jar --rawstring .\main.lua &gt; src.lua </code> 将<code>编译后的main.lua反编译为lua程序</code></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题型记录</title>
    <link href="/posts/436bbb1a.html"/>
    <url>/posts/436bbb1a.html</url>
    
    <content type="html"><![CDATA[<h1 id="vm"><a class="markdownIt-Anchor" href="#vm"></a> VM</h1><h2 id="理论研究"><a class="markdownIt-Anchor" href="#理论研究"></a> 理论研究</h2><p><a href="https://equinox-shame.github.io/2022/07/04/VM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/">理论</a></p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><h3 id="gwctf-2019babyvm"><a class="markdownIt-Anchor" href="#gwctf-2019babyvm"></a> [GWCTF 2019]babyvm</h3><h4 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h4><ul><li><p>关注这里的vm初始化操作，将传递进来的局部变量进行处理，前4个有效位置为寄存器，后面的通过 <code>0xF1</code> 等字节表示需要进行的 <code>sub</code> 函数操作。注意这里的 <code>a1</code> 存储的都是地址坐标，具体实现需要到程序段索引。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072226346.png" alt="image-20230507222653297" /></p></li><li><p>之后就是模拟执行 <code>opcode</code> ，找到程序的逻辑，之后反推</p></li></ul><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><p>​这里使用angr不能得到正确答案，因为在主函数中有一个虚假的判断，而按照 <code>opcode</code> 模拟逻辑得到的是两段过程，其中第一段符合最后的 <code>check</code> 判定，从而 <code>angr</code> 识别这个判断为正确答案，即最后输出这个错误的答案</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072257567.png" alt="image-20230507225731537" /></p><h3 id="nctf-2018wcyvm"><a class="markdownIt-Anchor" href="#nctf-2018wcyvm"></a> [NCTF 2018]wcyvm</h3><h4 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h4><ul><li><p>直接分析可以得到逻辑，这里 <code>v4</code> 表示的就是寄存器，而 <code>v5</code> 就是表示的存储  <code>opcode</code> 的地方，可以按其逻辑进行操作</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072237892.png" alt="image-20230507223733797" /></p></li><li><p>也可以直接使用 <code>angr</code> 碰碰运气，直接硬推出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>p=angr.Project(<span class="hljs-string">&quot;./WcyVM&quot;</span>)         <span class="hljs-comment">#加载文件</span><br>state=p.factory.entry_state()          <span class="hljs-comment">#创造状态state， entry_state构造一个从函数入口点执行的状态</span><br>sm=p.factory.simgr(state)              <span class="hljs-comment">#模拟管理器</span><br>good=<span class="hljs-number">0x401366</span>                         <span class="hljs-comment">#想要的地址</span><br>sm.explore(find=good,avoid=<span class="hljs-number">0x401372</span>)<br><span class="hljs-keyword">if</span> sm.found:                           <span class="hljs-comment">#如果found分类不为空</span><br>    find_state=sm.found[<span class="hljs-number">0</span>]             <span class="hljs-comment">#found里的状态给find_state</span><br>    <span class="hljs-built_in">print</span>(find_state.posix.dumps(<span class="hljs-number">0</span>))    <span class="hljs-comment">#获取输入</span><br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072240623.png" alt="image-20230507224004604" /></p></li></ul><h3 id="unctf-easyvm"><a class="markdownIt-Anchor" href="#unctf-easyvm"></a> [UNCTF] EasyVM</h3><p><a href="https://equinox-shame.github.io/2022/07/22/UNCTF%20-%202019%20EasyVm/">EasyVM</a></p><h3 id="dasctfe4sy_mix"><a class="markdownIt-Anchor" href="#dasctfe4sy_mix"></a> [DASCTF]E4sy_Mix</h3><p><a href="https://equinox-shame.github.io/2022/07/29/DASCTF%202022.07%20E4sy_Mix%20%E5%A4%8D%E7%8E%B0/">E4sy_Mix</a></p><h3 id="d3ctfd3sky"><a class="markdownIt-Anchor" href="#d3ctfd3sky"></a> [D3CTF]d3sky</h3><p><a href="https://equinox-shame.github.io/2023/05/06/d3sky%20%E5%A4%8D%E7%8E%B0/">d3sky</a></p><p><a href="https://ppppz.net/2023/08/03/D3CTF2023-REVERSE/">d3sky–PZ</a></p><h1 id="maze"><a class="markdownIt-Anchor" href="#maze"></a> Maze</h1><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><p>​直接py代码进行查找<a href="https://blog.csdn.net/qq_41890466/article/details/116900574">python求迷宫最短路径-小黄怪-的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Tue Apr 27 13:48:14 2021</span><br><span class="hljs-string"></span><br><span class="hljs-string">@author: Administrator</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">###无递归、类求迷宫最短路径算法</span><br><span class="hljs-comment">#import random</span><br>pre_route=<span class="hljs-built_in">list</span>()    <span class="hljs-comment">#宽度搜索得到的节点</span><br>q=<span class="hljs-built_in">list</span>()    <span class="hljs-comment">#队列结构控制循环次数</span><br>xx=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]   <span class="hljs-comment">#右移、下移、左移、上移</span><br>yy=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>visited=<span class="hljs-built_in">list</span>()  <span class="hljs-comment">#记录节点是否已遍历</span><br>father=<span class="hljs-built_in">list</span>()   <span class="hljs-comment">#每一个pre_route节点的父节点</span><br>route=<span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">l,x,y,m,n</span>):<br>    visited=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>]))]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l))]<br>    visited[x][y]=<span class="hljs-number">1</span> <span class="hljs-comment">#入口节点设置为已遍历</span><br>    q.append([x,y])<br>    <span class="hljs-keyword">while</span> q:    <span class="hljs-comment">#队列为空则结束循环</span><br>        now=q[<span class="hljs-number">0</span>]<br>        q.pop(<span class="hljs-number">0</span>)    <span class="hljs-comment">#移除队列头结点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            point=[now[<span class="hljs-number">0</span>]+xx[i],now[<span class="hljs-number">1</span>]+yy[i]]   <span class="hljs-comment">#当前节点</span><br>            <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>]&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> point[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> point[<span class="hljs-number">0</span>]&gt;=<span class="hljs-built_in">len</span>(l) <span class="hljs-keyword">or</span> point[<span class="hljs-number">1</span>]&gt;=<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> visited[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> l[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]==<span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">continue</span><br>            father.append(now)<br>            visited[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span><br>            q.append(point)<br>            pre_route.append(point)<br>            <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>]==m <span class="hljs-keyword">and</span> point[<span class="hljs-number">1</span>]==n:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;success&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;false&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_route</span>(<span class="hljs-params">father,pre_route</span>):    <span class="hljs-comment">#输出最短迷宫路径</span><br>    route=[pre_route[-<span class="hljs-number">1</span>],father[-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pre_route)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> pre_route[i]==route[-<span class="hljs-number">1</span>]:<br>            route.append(father[i])<br>    route.reverse()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;迷宫最短路径为：\n&quot;</span>,route)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;步长：&quot;</span>,<span class="hljs-built_in">len</span>(route)-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> route<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prn_map</span>(<span class="hljs-params">route,l,m,n</span>):   <span class="hljs-comment">#打印包含路径的迷宫图</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>        l[i]=<span class="hljs-built_in">list</span>(l[i])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(route)):<br>        l[route[i][<span class="hljs-number">0</span>]][route[i][<span class="hljs-number">1</span>]]=<span class="hljs-string">&#x27;2&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> l[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;  &#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> l[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;██&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;░░&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> i==m <span class="hljs-keyword">and</span> j==n:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;☀&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br><br>l=[<span class="hljs-string">&#x27;01010101001011001001010110010110100100001000101010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00001000100000101010010000100000001001100110100101&#x27;</span>,<br>   <span class="hljs-string">&#x27;01111011010010001000001101001011100011000000010000&#x27;</span>,<br>   <span class="hljs-string">&#x27;01000000001010100011010000101000001010101011001011&#x27;</span>,<br>   <span class="hljs-string">&#x27;00011111000000101000010010100010100000101100000000&#x27;</span>,<br>   <span class="hljs-string">&#x27;11001000110101000010101100011010011010101011110111&#x27;</span>,<br>   <span class="hljs-string">&#x27;00011011010101001001001010000001000101001110000000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100000101000100110101010111110011000010000111010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00111000001010100001100010000001000101001100001001&#x27;</span>,<br>   <span class="hljs-string">&#x27;11000110100001110010001001010101010101010001101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00010000100100000101001010101110100010101010000101&#x27;</span>,<br>   <span class="hljs-string">&#x27;11100100101001001000010000010101010100100100010100&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000010000000101011001111010001100000101010100011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101010011100001000011000010110011110110100001000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101010100001101010100101000010100000111011101001&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000000101100010000101100101101001011100000000100&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101001000000010100100001000100000100011110101001&#x27;</span>,<br>   <span class="hljs-string">&#x27;00101001010101101001010100011010101101110000110101&#x27;</span>,<br>   <span class="hljs-string">&#x27;11001010000100001100000010100101000001000111000010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00001000110000110101101000000100101001001000011101&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100101000101000000001110110010110101101010100001&#x27;</span>,<br>   <span class="hljs-string">&#x27;00101000010000110101010000100010001001000100010101&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100001000110010001000010101001010101011111010010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000100101000000110010100101001000001000000000010&#x27;</span>,<br>   <span class="hljs-string">&#x27;11010000001001110111001001000011101001011011101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000110100010001000100000001000011101000000110011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101000101000100010001111100010101001010000001000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000010100101001010110000000100101010001011101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00111100001000010000000110111000000001000000001011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000001100111010111010001000110111010101101111000&#x27;</span>]<br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    x=<span class="hljs-number">0</span>;y=<span class="hljs-number">0</span><br>    m=<span class="hljs-number">25</span>;n=<span class="hljs-number">40</span><br>    <span class="hljs-keyword">if</span> bfs(l,x,y,m,n)==<span class="hljs-number">1</span>:<br>        route=get_route(father,pre_route)<br>        prn_map(route,l,m,n)<br></code></pre></td></tr></table></figure><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><h3 id="领航杯maze"><a class="markdownIt-Anchor" href="#领航杯maze"></a> [领航杯]maze</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些记录</title>
    <link href="/posts/a87d0386.html"/>
    <url>/posts/a87d0386.html</url>
    
    <content type="html"><![CDATA[<h1 id="hdctf2023"><a class="markdownIt-Anchor" href="#hdctf2023"></a> HDCTF2023</h1><h2 id="double_game"><a class="markdownIt-Anchor" href="#double_game"></a> double_game</h2><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>打开ida，发现是一个非常典型的上线器，shellcode loader。我们需要做的是找到其中的shellcode。这是 WP 说的，但是没有理解 shellcode loader 的含义，目前我的认识就是它加载 shellcode，然后顺利执行 shellcode</p><p>一个介绍的文章 <a href="https://paper.seebug.org/1413/">如何实现一款 shellcodeLoader</a></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242327238.png" alt="image-20230424232717199" /></p></li><li><p>这个地方加载了 <code>sub_</code>，这里就是 shellcode</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242328475.png" alt="image-20230424232802405" /></p></li><li><p>查看后发现 IDA 将这里反编译成了一个函数，但是逻辑还是有点困难，那么就将这个 shellcode的内容复制下来，整合为一个文件，然后再使用ida打开文件分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242329993.png" alt="image-20230424232945959" /></p></li><li><p>这里是 <code>u</code> + <code>p</code> 后的结果，重新生成函数后就很好认了</p></li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><ul><li>以二进制写入文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct<br><br>list_dec = [<span class="hljs-number">0x55</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xE8</span>,<br>  <span class="hljs-number">0x52</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x54</span>,<br>  <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x2F</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC6</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x43</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x01</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0xEB</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x66</span>,<br>  <span class="hljs-number">0x66</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>,<br>  <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x02</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>,<br>  <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>,<br>  <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x83</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>,<br>  <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x83</span>,<br>  <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>,<br>  <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x50</span>, <span class="hljs-number">0xFD</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>,<br>  <span class="hljs-number">0x04</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>,<br>  <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xFC</span>, <span class="hljs-number">0x8D</span>, <br>  <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>,<br>  <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1C</span>,<br>  <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>,<br>  <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>,<br>  <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0xFD</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0xC3</span>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;hexBin.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_dec:<br>        a = struct.pack(<span class="hljs-string">&#x27;B&#x27;</span>, x)<span class="hljs-comment"># struct.pack将要变成字节的数据打包然后以字节的形式写入到二进制文件，字节的形式是b&#x27;\x01&#x27;</span><br>        fp.write(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>得到flag</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [<span class="hljs-number">0x48</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x45</span>,<span class="hljs-number">0x51</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x7b</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x6a</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x68</span>,<span class="hljs-number">0x6c</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0x32</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x5b</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x53</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x6c</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x7c</span>,<span class="hljs-number">0x63</span>,<span class="hljs-number">0x69</span>,<span class="hljs-number">0x2d</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0x46</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x75</span>,<span class="hljs-number">0x7d</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  tmp = i % <span class="hljs-number">5</span><br>  <span class="hljs-keyword">if</span> tmp == <span class="hljs-number">1</span>:<br>    enc[i] ^= <span class="hljs-number">0x23</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">2</span>:<br>    enc[i] -= <span class="hljs-number">2</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">3</span>:<br>    enc[i] += <span class="hljs-number">3</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">4</span>:<br>    enc[i] += <span class="hljs-number">4</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">5</span>:<br>    enc[i] += <span class="hljs-number">25</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  flag += <span class="hljs-built_in">chr</span>(enc[i])<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="enc"><a class="markdownIt-Anchor" href="#enc"></a> enc</h2><h3 id="分析1"><a class="markdownIt-Anchor" href="#分析1"></a> 分析1</h3><ul><li>先是一个 TEA 找到密钥，这里注意格式与往常不太一样，这里要注意和普遍脚本之间的区别。最后得到了密钥 <code>0x3</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251425960.png" alt="image-20230425142555881" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251426260.png" alt="image-20230425142607216" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt1</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x61C88647</span><br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br>    <br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value -= delta<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= ((v0.value &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; <span class="hljs-number">5</span>) + k3)<br>        v0.value -= ((v1.value &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; <span class="hljs-number">5</span>) + k1)<br>        total.value += delta<br>    <span class="hljs-keyword">return</span> v0.value, v1.value<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt2</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br>    <br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value -= <span class="hljs-number">0x61C88647</span><br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= ((v0.value &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; <span class="hljs-number">5</span>) + k3)<br>        v0.value -= ((v1.value &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; <span class="hljs-number">5</span>) + k1)<br>        total.value -= delta<br>    <span class="hljs-keyword">return</span> v0.value, v1.value<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x60FCDEF7</span>, <span class="hljs-number">0x236DBEC</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>]<br>    res = decrypt1(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    <br>    <span class="hljs-comment"># 这里是decrypto1 和 decrypto2 的区别</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    如下测试可以发现，加与减的最后4个字节是一样的，这里通过c_uint32的类型锁定了字节的数量</span><br><span class="hljs-string">    也就是高位会被舍去，所以这个的结果是一样的</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    a = c_uint32(<span class="hljs-number">0xc6ef3720</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(a.value + <span class="hljs-number">0x61C88647</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(a.value - <span class="hljs-number">0x9e3779b9</span>))<br></code></pre></td></tr></table></figure><p>这里注意两种方式，一个是 WP 提供的，最后发现就是一个高位舍去的差别，但是开阔了视野</p><h3 id="分析2"><a class="markdownIt-Anchor" href="#分析2"></a> 分析2</h3><ul><li>这里就是 SMC，其中 0x3 就是异或的值。这里将 <code>.hdctf</code> 段进行了 SMC 处理，可以脚本，也可以动调(自己的动调结果有点不太好看)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251429980.png" alt="image-20230425142922951" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251429571.png" alt="image-20230425142926548" /></p><ul><li>这里脚本写出来的就是一个 RC4 加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251434725.png" alt="image-20230425143442690" /></p><ul><li>脚本一直跑不通，然后CyberChef直接就出来了，只能说自己整理得脚本还是不如工具</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251454112.png" alt="image-20230425145423070" /></p><h2 id="basketball"><a class="markdownIt-Anchor" href="#basketball"></a> Basketball</h2><ul><li>这里主要考虑如何将一堆RGB值变成一张图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 打开文件并读取内容</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;array.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read()<br><br><span class="hljs-comment"># 将文件内容转换为一维数组</span><br>data = np.fromstring(content, dtype=np.uint8, sep=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><span class="hljs-comment"># 将一维数组转换为[561][637][3]的三维数组</span><br>data = data.reshape((<span class="hljs-number">561</span>, <span class="hljs-number">637</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 创建一个空白的图像宽637高561</span><br>img = Image.new(<span class="hljs-string">&#x27;RGB&#x27;</span>, (<span class="hljs-number">637</span>, <span class="hljs-number">561</span>))<br><br><span class="hljs-comment"># 将三维数组中的RGB值写入图像中</span><br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">561</span>):<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">637</span>):<br>        r, g, b = data[y][x]<br>        img.putpixel((x, y), (r, g, b))<br><br><span class="hljs-comment"># 保存图像</span><br>img.save(<span class="hljs-string">&#x27;message.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="suctf2023"><a class="markdownIt-Anchor" href="#suctf2023"></a> SUCTF2023</h1><h2 id="easyre"><a class="markdownIt-Anchor" href="#easyre"></a> easyRE</h2><ul><li>给了一个exe文件，直接反编译成pyc文件</li></ul><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>观察 pyinstxtractor 解包时的信息，可知打包的 Python 版本为 Python 3.11所以uncompyle6用不了。对该 pyc 文件进行反编译也需要对应版本的 Python 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> dis<br><span class="hljs-keyword">import</span> marshal<br><br>PATH = <span class="hljs-string">&quot;./easyRE.exe_extracted/easyRE.pyc&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(PATH, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    code = f.seek(<span class="hljs-number">16</span>)<br>    code = marshal.load(f)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;easyRE.pyc.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        dis.dis(code, file=f)<br><br></code></pre></td></tr></table></figure><p>这里也可以使用 pycdc直接生成字节码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>r = random.Random(<span class="hljs-number">322376503</span>)<br><br>pt = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter your flag: &#x27;</span>).encode()<br>ct = <span class="hljs-string">b&#x27;\x8b\xcck\xd3\xed\x96\xffFb\x06r\x085\x82\xbc \xb2\xde)p\x88Q`\x1bf\x18\xb6QUSw\x10\xcd\xd9\x13A$\x86\xe5\xcd\xd9\xff&#x27;</span><br><br>buf = []<br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> pt:<br>    buf.append((r.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>) ^ b))<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">bytes</span>(buf) == ct:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Correct!&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>大致含义如上，之后就可以写出脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>r = random.Random(<span class="hljs-number">322376503</span>)<br>ct = <span class="hljs-string">b&#x27;\x8b\xcck\xd3\xed\x96\xffFb\x06r\x085\x82\xbc \xb2\xde)p\x88Q`\x1bf\x18\xb6QUSw\x10\xcd\xd9\x13A$\x86\xe5\xcd\xd9\xff&#x27;</span><br>enc = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ct:<br>    enc.append(i)<br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    flag += <span class="hljs-built_in">chr</span>(r.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>) ^ enc[i])<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="gotots"><a class="markdownIt-Anchor" href="#gotots"></a> gotots</h2><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>​使用 IDA fREE 查看 GO 的程序(使用idagohelper会报错)</p><ul><li>利用错误显示 <code>Incorrect!</code> 找到主函数，然后下断点调试到输入的位置</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071453755.png" alt="image-20230507145353639" /></p><ul><li>经过查找，发现输入的位置是 <code>v13</code> 所在的位置，按 <code>D</code> 改变成数据查看。之后点击进去下一个读写断点(硬件断点)，并在hex窗口显示该地址数据(<code>G</code>)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071457015.png" alt="image-20230507145721957" /></p><ul><li>后来在 <code>runtime_stringtoslicebyte</code> 这里触发了读写断点，猜测这里并不是具体的操作过程，之后经过动态调式，发现这个函数复制数据到另一个位置(由hex窗口数据看出)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071458161.png" alt="image-20230507145852127" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071504488.png" alt="image-20230507150454442" /></p><ul><li>经过某一位置发现数值发生了改变，猜测这里就是主要加密位置，根据伪代码可以看出来只是一个简单的异或处理，之后可以发现下面的 <code>if</code> 语句就是判断的含义</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071506438.png" alt="image-20230507150654384" /></p><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [ <span class="hljs-number">0x35</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x82</span>,<br>  <span class="hljs-number">0x27</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x8E</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x1E</span>,<br>  <span class="hljs-number">0x81</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x6B</span>,<br>  <span class="hljs-number">0x70</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x7D</span>]<br>key = [<span class="hljs-number">0x66</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xBF</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xD2</span>,<br>  <span class="hljs-number">0x25</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x17</span>,<br>  <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0xA7</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0x6D</span>,<br>  <span class="hljs-number">0x79</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x2F</span>]<br><br><span class="hljs-built_in">input</span> = [ <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(key[i] ^ enc[i] ^ <span class="hljs-built_in">input</span>[i]), end=<span class="hljs-string">&quot;&quot;</span>)<br>    <br></code></pre></td></tr></table></figure><h3 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h3><p>​由于 Go 是多线程的，所以调试的时候可能会出现进入其它未知地方情况的发生，这时可以禁止其余线程的运行</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071455904.png" alt="image-20230507145550874" /></p><ul><li>不禁止可能走偏，例如下面</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071501614.png" alt="image-20230507150105577" /></p><h1 id="安洵杯-2023"><a class="markdownIt-Anchor" href="#安洵杯-2023"></a> 安洵杯 2023</h1><h2 id="ez_cpp"><a class="markdownIt-Anchor" href="#ez_cpp"></a> ez_cpp</h2><ul><li><p>对于整个程序的分析可知，该程序使用对于输入字符串进行单个字符加密，之后与内置数据进行对比得出正确与否的结果</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307061640632.png" alt="image-20230706164056589" /></p></li><li><p>因此可以对于比较结果进行更改，利用python运行程序得到结果，从而实现对于单个字符的爆破处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307061644516.png" alt="image-20230706164407476" /></p></li><li><p>将每次对比的数值拿出来，从而判断字符的爆破进行到了哪一步</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br>table = string.ascii_letters+string.digits+<span class="hljs-string">&#x27;!-&#123;&#125;&#x27;</span><br>theflag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(theflag) &lt; <span class="hljs-number">32</span>:<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> table:<br>        flag = (theflag+ch).ljust(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;#&#x27;</span>)<br>        exitcode = os.system(<span class="hljs-string">f&quot;echo <span class="hljs-subst">&#123;flag&#125;</span> | ez_cpp1.exe 1&gt;&amp;0&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;try: &quot;</span> + theflag + ch + <span class="hljs-string">&quot; exitcode:&quot;</span> + <span class="hljs-built_in">hex</span>(exitcode))<br>        <span class="hljs-keyword">if</span> exitcode &gt;= <span class="hljs-built_in">len</span>(theflag) + <span class="hljs-number">1</span>:<br>            theflag += ch<br>            <span class="hljs-built_in">print</span>(theflag, exitcode)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(theflag + <span class="hljs-string">&#x27;not found&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="ezr3"><a class="markdownIt-Anchor" href="#ezr3"></a> ezr3</h2><h3 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h3><ul><li><p>首先这是 arm64 elf 文件，运行在Android上，这里查看文件，发现魔改 UPX 壳，之后恢复并脱壳（共5处的HCK需要改成 UPX）</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081737836.png" alt="img" /></p></li></ul><h3 id="逻辑查看"><a class="markdownIt-Anchor" href="#逻辑查看"></a> 逻辑查看</h3><ul><li><p>之后查看main函数逻辑，发现先运行 <code>V</code> 函数，之后再输入flag，查看V函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081739723.png" alt="image-20230708173922681" /></p></li><li><p>这里查看auth数据，同时更改其为4字节一组的数组(上面的memStore也是这样)，之后可以发现此函数只是对内存数据进行了更改，动调可以获得数据，静态查看可以看出加密逻辑（我看不出来，建议还是动态调试拿数据）</p></li><li><p><strong>这里之后再看，发现v2与v3的数据相连，则</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082009042.png" alt="image-20230708200933003" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">v1 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        auth[i * <span class="hljs-number">6</span> + j] ^= memStore[v1 + <span class="hljs-number">12</span> * j]<br>    v1 += <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>之后主程序是进行一系列对于flag格式的检测工作，之后来到了 <code>P</code> 函数，首先很难理解 v8(输入的flag) 相关的操作，则更改其数据类型，得到可理解的伪代码—这里官方WP是改为37，这是后文memset设置的长度，只要比这个长度大即可满足条件，使代码更容易阅读</p></li><li><p>这里的代码先是对每个数据进行移位处理，之后倒序异或处理；后来就是进行比较，就是将flag与memStore进行相乘来比较flag是否正确</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081931420.png" alt="image-20230708193153346" /></p><p><strong>这里C中v8[-1]其实指向了v8最开始字符的前一个字符</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081932216.png" alt="image-20230708193218180" /></p></li></ul><h3 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">auth32 = [<br>    <span class="hljs-number">0x0003BC69</span>, <span class="hljs-number">0x000D3FA0</span>, <span class="hljs-number">0x0003A94A</span>, <span class="hljs-number">0x00044AFF</span>, <span class="hljs-number">0x00045254</span>, <span class="hljs-number">0x0000CDD1</span>,<br>    <span class="hljs-number">0x00001815</span>, <span class="hljs-number">0x00003B08</span>, <span class="hljs-number">0x00070868</span>, <span class="hljs-number">0x000C6560</span>, <span class="hljs-number">0x00065662</span>, <span class="hljs-number">0x000855C8</span>,<br>    <span class="hljs-number">0x0000DCF6</span>, <span class="hljs-number">0x00004CE6</span>, <span class="hljs-number">0x0014EEC2</span>, <span class="hljs-number">0x0002CFD6</span>, <span class="hljs-number">0x00032766</span>, <span class="hljs-number">0x0014F6BA</span>,<br>    <span class="hljs-number">0x00025E69</span>, <span class="hljs-number">0x0006A9A3</span>, <span class="hljs-number">0x00121EBD</span>, <span class="hljs-number">0x0005991C</span>, <span class="hljs-number">0x00050016</span>, <span class="hljs-number">0x00004A3D</span>,<br>    <span class="hljs-number">0x00097485</span>, <span class="hljs-number">0x0008D0A0</span>, <span class="hljs-number">0x0003B916</span>, <span class="hljs-number">0x00054C58</span>, <span class="hljs-number">0x00096F94</span>, <span class="hljs-number">0x00010334</span>,<br>    <span class="hljs-number">0x000DAD22</span>, <span class="hljs-number">0x0004B234</span>, <span class="hljs-number">0x0002FE96</span>, <span class="hljs-number">0x000F33CC</span>, <span class="hljs-number">0x0012C1E8</span>, <span class="hljs-number">0x00148F9E</span><br>]<br>memStore = [<br>    <span class="hljs-number">0x00000D21</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000009D</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000094B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000003C9</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000C3F</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000017E9</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000130E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000088</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000486</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x0000202F</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00002230</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000024B4</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000008B1</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000A9F</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001AD2</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000023EB</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000C7E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000042B</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x000005BF</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000113C</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000449</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001751</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000ACE</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001894</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000208A</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000E82</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000006BD</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x00000CEE</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00002386</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000013D4</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000111</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000D1C</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000238E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001759</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000012B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000214D</span>, <span class="hljs-number">0x00000000</span><br>]<br>v2 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        auth32[i * <span class="hljs-number">6</span> + j] ^= memStore[v2 + <span class="hljs-number">12</span> * j]<br>    v2 += <span class="hljs-number">2</span><br>v2 = <span class="hljs-number">0</span><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        flag.append(auth32[i * <span class="hljs-number">6</span> + j] // memStore[v2 + j * <span class="hljs-number">12</span>])<br>    v2 += <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flag)):<br>    flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] ^= flag[i]<br>    flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] = (flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] &gt;&gt; <span class="hljs-number">4</span>) | (flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] &lt;&lt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xFF</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(flag))<br></code></pre></td></tr></table></figure><h2 id="3d_maze"><a class="markdownIt-Anchor" href="#3d_maze"></a> 3D_Maze</h2><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><ul><li><p>有题目，可以知道是个三维迷宫题目，有前面的知识可以知道flag的长度为62。这里就是使用小写的<code>awsd</code>和大写的<code>AWSD</code>作为转移，小写是在一个平面上操作，而大写是在立体中进行不同面的变换</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082138095.png" alt="image-20230708213820034" /></p></li><li><p>这里对于边界条件进行了限制，同时点出了迷宫的大小范围为 <code>6 x 10 x 10</code> 其中主义dword需要将数据转换为dword类型再比较(一开始可以清楚看到100)，后来更改了数据类型，结果也随之改变</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082140410.png" alt="image-20230708214028372" /></p></li></ul><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-comment"># 分割迷宫</span><br><span class="hljs-built_in">map</span> = [<span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000005</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>]<br>maplist=[<span class="hljs-built_in">map</span>[i*<span class="hljs-number">100</span>:i*<span class="hljs-number">100</span>+<span class="hljs-number">100</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br><span class="hljs-comment"># print(maplist)</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> maplist:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(t[i*<span class="hljs-number">10</span>:i*<span class="hljs-number">10</span>+<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># z=0</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1====1==</span><br><span class="hljs-comment"># ==1=1111==</span><br><span class="hljs-comment"># ==1=1=====</span><br><span class="hljs-comment"># ==1=111111</span><br><span class="hljs-comment"># ==1=1=====</span><br><span class="hljs-comment"># ==11111111</span><br><span class="hljs-comment"># ==5=1=====</span><br><span class="hljs-comment"># ===*======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># wddwwdddddD</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=1</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># =1111=====</span><br><span class="hljs-comment"># =1==111111</span><br><span class="hljs-comment"># =1========</span><br><span class="hljs-comment"># 11========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># 11111=====</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># dwwwdddsdddddD</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=2</span><br><span class="hljs-comment"># 1=========</span><br><span class="hljs-comment"># 1=========</span><br><span class="hljs-comment"># 1==1=1===1</span><br><span class="hljs-comment"># ==1=1=1=1=</span><br><span class="hljs-comment"># ==1====1==</span><br><span class="hljs-comment"># ===1===1==</span><br><span class="hljs-comment"># ====1==1==</span><br><span class="hljs-comment"># ==1=1==1==</span><br><span class="hljs-comment"># ===1===1==</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># wwW</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=4</span><br><span class="hljs-comment"># ========11</span><br><span class="hljs-comment"># ========1=</span><br><span class="hljs-comment"># 111111111=</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># assaaaaaaaaA</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=3</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=11====</span><br><span class="hljs-comment"># ==11==1===</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==11==1===</span><br><span class="hljs-comment"># ==1=11====</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sssssssssS</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=5</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># 111=======</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># dddwwdwwwwwW</span><br><span class="hljs-comment"># w</span><br><br><span class="hljs-comment">#0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt;3 -&gt;5 -&gt; 0</span><br><span class="hljs-comment"># wddwwdddddDdwwwdddsdddddDwwWassaaaaaaaaAsssssssssSddwwdwwwwwWw</span><br></code></pre></td></tr></table></figure><h1 id="dasctf2023二进制"><a class="markdownIt-Anchor" href="#dasctf2023二进制"></a> DASCTF2023二进制</h1><h2 id="babyre"><a class="markdownIt-Anchor" href="#babyre"></a> babyRe</h2><ul><li><p>查看关键函数，发现是一个线程注入的技术 注入的代码是从资源中解密出的shellcode，分析线程的shellcode，其中存在两个反调试</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092154373.png" alt="image-20230709215416238" /></p></li><li><p>其中judge……函数中存在调试判断，这里对于调试进行处理后，动调卡在了 <code>argc!=2</code> 的判断上，所以动态得到shellcode的数据不不成功(自己绕过后还是因为参数不为2的原因调试失败)</p></li><li><p>之后重点关注杜宇“cod”数据的处理，由xor函数可以知道这是对于cod进行异或处理，则得到资源文件，之后进行异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;COD101.bin&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>key=[<span class="hljs-number">24</span>, <span class="hljs-number">87</span>, <span class="hljs-number">104</span>, <span class="hljs-number">100</span>]<br>arr = []<br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f):<br>    arr.append(key[i%<span class="hljs-number">4</span>]^j)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;dump&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>).write(<span class="hljs-built_in">bytes</span>(arr))<br></code></pre></td></tr></table></figure></li><li><p>得到dump文件后，进行64位分析，将其中(call+5)与sub_1EE进行nop以及调整retn后，程序大致可以看出来了为魔改的RC4算法，由此结合后面的StartAddress来进行解密处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092200561.png" alt="image-20230709220059494" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> size1 = <span class="hljs-number">0x100</span>;<br><br><span class="hljs-type">void</span> __stdcall  <span class="hljs-title function_">rc4</span><span class="hljs-params">(<span class="hljs-type">char</span>* data)</span><br>&#123;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sbox[<span class="hljs-number">257</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, j, k;<br> <span class="hljs-type">int</span> tmp;<br> <span class="hljs-type">char</span> key[] = &#123; <span class="hljs-number">93</span> ,<span class="hljs-number">66</span>,<span class="hljs-number">98</span>,<span class="hljs-number">41</span>,<span class="hljs-number">3</span>,<span class="hljs-number">54</span>,<span class="hljs-number">71</span>,<span class="hljs-number">65</span>,<span class="hljs-number">21</span>,<span class="hljs-number">54</span> &#125;;<br> <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br> <span class="hljs-type">char</span>* p = data;<br><br> <span class="hljs-keyword">while</span> (*p)<br> &#123;<br>  len++;<br>  p++;<br> &#125;<br> <span class="hljs-comment">//printf(&quot;len:%d\n&quot;, len);</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;<br>  sbox[i] = i;<br> &#125;<br><br> j = k = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;<br>  tmp = sbox[i];<br>  j = (<span class="hljs-number">2</span> * j + tmp + key[k]) % size1;<br>  sbox[i] = sbox[j];<br>  sbox[j] = tmp;<br>  <span class="hljs-keyword">if</span> (++k &gt;= <span class="hljs-number">10</span>)<br>   k = <span class="hljs-number">0</span>;<br> &#125;<br> j = k = <span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> R;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>  j = (j + k) % size1;<br>  k = (k + sbox[j]) % size1;<br><br>  tmp = sbox[j];<br>  sbox[j] = sbox[k];<br>  sbox[k] = tmp;<br><br><br>  R = sbox[(sbox[j] + sbox[k] + k) % size1];<br>  data[i] -= (i % <span class="hljs-number">13</span>);<br>  data[i] ^= R ;<br>  <br> &#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">char</span> enc[]=&#123; <span class="hljs-number">0xF7</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0xEC</span>, <br>  <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xDA</span>, <br>  <span class="hljs-number">0x6C</span>, <span class="hljs-number">0xBD</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xC6</span>, <br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x37</span>, <br>  <span class="hljs-number">0xF5</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0x58</span>&#125;;<br> rc4(enc);<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,enc);<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h2 id="ez_exe"><a class="markdownIt-Anchor" href="#ez_exe"></a> ez_exe</h2><ul><li><p>这是一个Python打包而成的exe文件，利用python进行解出源码，之后运行程序，得到需要同样方法解密bin2</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092218547.png" alt="image-20230709221810499" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ctypes<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> wintypes<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> Structure<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> _STARTUPINFO<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> _PROCESS_INFORMATION<br><br>StartupInfo = _STARTUPINFO()<br>ProcessInfo = _PROCESS_INFORMATION()<br><br>key1 = md5(<span class="hljs-string">b&#x27;bin1bin1bin1&#x27;</span>).hexdigest().encode()<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read()<br><br>arr = [key1[i % <span class="hljs-built_in">len</span>(key1)] ^ file[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file))]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-built_in">bytes</span>(arr))<br><br>time.sleep(<span class="hljs-number">0</span>)<br><br>bet = ctypes.windll.kernel32.CreateProcessA(<span class="hljs-string">b&#x27;bin1&#x27;</span>, ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), byref(StartupInfo), byref(ProcessInfo))<br><br>ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-<span class="hljs-number">1</span>))<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(file)<br></code></pre></td></tr></table></figure></li></ul><h3 id="法1"><a class="markdownIt-Anchor" href="#法1"></a> 法1</h3><ul><li><p>之后查看源码的字节码，得到加密过程为根据密钥进行异或处理，然后再对bin2进行解密，得到bin_dump文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br>key1 = <span class="hljs-built_in">bytes</span>(md5(<span class="hljs-string">b&quot;bin2bin2bin2&quot;</span>).hexdigest().encode())<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;bin2&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>).read()<br>arr = [key1[i % <span class="hljs-built_in">len</span>(key1)] ^ file[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file))]<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;bin_dump&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>).write(<span class="hljs-built_in">bytes</span>(arr))<br></code></pre></td></tr></table></figure></li></ul><h3 id="法2"><a class="markdownIt-Anchor" href="#法2"></a> 法2</h3><ul><li><p>观察源码，这是先解密，之后再加密的操作，这里直接把<strong>pyc</strong>里的密钥<code>bin1</code>改成<code>bin2</code>，加密后的结果存储在<code>bin3</code>中，然后使用python3.11运行pyc文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092300898.png" alt="image-20230709230022851" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092300148.png" alt="image-20230709230031072" /></p></li><li><p>报错，但是可以用，之后就是正常解密后的bin2文件了</p></li></ul><h3 id="exp-5"><a class="markdownIt-Anchor" href="#exp-5"></a> exp</h3><ul><li><p>得到的bin_dump是一个32位exe文件，其中进行了<a href="https://blog.csdn.net/libinjlu/article/details/43030369">btea加密</a>，直接获取数据解密即可</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092241730.png" alt="image-20230709224140685" /></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>using namespace std;<br><br><span class="hljs-comment">#include &lt;stdint.h&gt;</span><br><br>//delta changed<br><span class="hljs-comment">#define DELTA 0x7937B99E</span><br><span class="hljs-comment">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><br>void btea(uint32_t* v, <span class="hljs-built_in">int</span> n, uint32_t const key[<span class="hljs-number">4</span>]) &#123;<br>uint32_t y, z, <span class="hljs-built_in">sum</span>;<br>unsigned p, rounds, e;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;          /* Coding Part */<br>rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>z = v[n - <span class="hljs-number">1</span>];<br>do &#123;<br><span class="hljs-built_in">sum</span> += DELTA;<br>e = (<span class="hljs-built_in">sum</span> &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n - <span class="hljs-number">1</span>; p++) &#123;<br>y = v[p + <span class="hljs-number">1</span>];<br>z = v[p] += MX;<br>&#125;<br>y = v[<span class="hljs-number">0</span>];<br>z = v[n - <span class="hljs-number">1</span>] += MX;<br>&#125; <span class="hljs-keyword">while</span> (--rounds);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; -<span class="hljs-number">1</span>) &#123;  /* Decoding Part */<br>n = -n;<br>//<span class="hljs-built_in">round</span> changed <br>rounds =  <span class="hljs-number">52</span> / n;<br><span class="hljs-built_in">sum</span> = rounds * DELTA;<br>y = v[<span class="hljs-number">0</span>];<br>do &#123;<br>e = (<span class="hljs-built_in">sum</span> &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (p = n - <span class="hljs-number">1</span>; p &gt; <span class="hljs-number">0</span>; p--) &#123;<br>z = v[p - <span class="hljs-number">1</span>];<br>y = v[p] -= MX;<br>&#125;<br>z = v[n - <span class="hljs-number">1</span>];<br>y = v[<span class="hljs-number">0</span>] -= MX;<br>&#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">sum</span> -= DELTA) != <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>uint32_t key[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4B5F</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">0xDEAD</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">0x11ED</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">0xB3CC</span>;<br>uint32_t v5[<span class="hljs-number">11</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>v5[<span class="hljs-number">0</span>] = <span class="hljs-number">0xCC45699D</span>;<br>v5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x683D5352</span>;<br>v5[<span class="hljs-number">2</span>] = <span class="hljs-number">0xB8BB71A0</span>;<br>v5[<span class="hljs-number">3</span>] = <span class="hljs-number">0xD3817AD</span>;<br>v5[<span class="hljs-number">4</span>] = <span class="hljs-number">0x7547E79E</span>;<br>v5[<span class="hljs-number">5</span>] = <span class="hljs-number">0x4BDD8C7C</span>;<br>v5[<span class="hljs-number">6</span>] = <span class="hljs-number">0x95E25A81</span>;<br>v5[<span class="hljs-number">7</span>] = <span class="hljs-number">0xC4525103</span>;<br>v5[<span class="hljs-number">8</span>] = <span class="hljs-number">0x7049B46F</span>;<br>v5[<span class="hljs-number">9</span>] = <span class="hljs-number">0x5417F77C</span>;<br>v5[<span class="hljs-number">10</span>] = <span class="hljs-number">0x65567138</span>;<br>btea(v5, -<span class="hljs-number">11</span>, key);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">44</span>; i++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%c&quot;</span>,*((char *)v5 +i) &amp; <span class="hljs-number">0xff</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cap"><a class="markdownIt-Anchor" href="#cap"></a> cap</h2><ul><li><p>程序主逻辑：程序截图并进行处理保存为cap.bin(对于API的查找发现这里一起调用最终会实现屏幕图像截取的功能，这里最终会生成一个bmp文件)</p></li><li><p>首先查看cap.bin文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101540001.png" alt="image-20230710154058936" /></p></li><li><p>之后动调程序，发现在程序中进行了异或处理，对于异或数值的观察中发现，这里异或的对象中出现了(0x42,0x4D—这是bmp文件的首部标识)，同时出现了nc_by_dasctf的可能异或密钥的字符</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101552629.png" alt="image-20230710155205577" /></p></li><li><p>之后对于文件进行逐一字符查看，最后看出这是对于cap.bin文件的异或处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101554841.png" alt="img" /></p></li><li><p>之后从密钥第二位开始，循环异或。注意这里需要使用最开始的cap.bin进行操作，因为每次运行re3.exe，就是进行截屏操作，所以需要使用最开始的cap.bin文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">key = <span class="hljs-string">&quot;enc_by_dasctf&quot;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;cap.bin&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    s = <span class="hljs-built_in">bytearray</span>(f.read())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-built_in">ord</span>(key[(i+<span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(key)])<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.bmp&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(s)<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101559824.png" alt="image-20230710155936627" /></p></li></ul><h2 id="unsym"><a class="markdownIt-Anchor" href="#unsym"></a> unsym</h2><ul><li><p>go语言逆向，使用 <code>go_parser</code> 恢复符号表，之后在main_main中发现了65537，同时其中与大整数相关，猜测可能与RSA有关</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101607362.png" alt="image-20230710160723312" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101607433.png" alt="image-20230710160744386" /></p></li><li><p>之后查看程序的逻辑流程，发现通过RSA判断KEY的正确性，右边是KEY正确的路径</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101613005.png" alt="image-20230710161319957" /></p></li><li><p>后来对文件message进行AES(CBC)加密，之后保存为encrypted.bin文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101615358.png" alt="image-20230710161513312" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101615248.png" alt="image-20230710161538200" /></p></li><li><p>之后写脚本进行解密工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br>n = <span class="hljs-number">0x1d884d54d21694ccd120f145c8344b729b301e782c69a8f3073325b9c5</span><br>p = <span class="hljs-number">37636318457745167234140808130156739</span><br>q = <span class="hljs-number">21154904887215748949280410616478423</span><br>c = <span class="hljs-number">0xfad53ce897d2c26f8cad910417fbdd1f0f9a18f6c1748faca10299dc8</span><br>e = <span class="hljs-number">0x10001</span><br>phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>d = gmpy2.invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><br>password = long_to_bytes(m)  <span class="hljs-comment"># 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据</span><br>iv = long_to_bytes(m)  <span class="hljs-comment"># iv 偏移量，bytes 类型</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;encrypted.bin&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    en_text = f.read()<br>aes = AES.new(password, AES.MODE_CBC, iv)  <span class="hljs-comment"># CBC 模式下解密需要重新创建一个 aes 对象</span><br>de_text = aes.decrypt(en_text)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;decrypt.exe&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(de_text)<br></code></pre></td></tr></table></figure></li><li><p>运行decrypt.exe得到了flag</p></li></ul><h1 id="vnctf2023"><a class="markdownIt-Anchor" href="#vnctf2023"></a> VNCTF2023</h1><h1 id="西湖论剑2023"><a class="markdownIt-Anchor" href="#西湖论剑2023"></a> 西湖论剑2023</h1><h1 id="ciscn"><a class="markdownIt-Anchor" href="#ciscn"></a> CISCN</h1>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/posts/d04bd5bc.html"/>
    <url>/posts/d04bd5bc.html</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a class="markdownIt-Anchor" href="#概论"></a> 概论</h1><h2 id="问题相关"><a class="markdownIt-Anchor" href="#问题相关"></a> 问题相关</h2><ul><li>操作系统的定义、功能、特征及其含义  P1-2-3-5</li><li>操作系统的分类及其特点，实时、分时、网络、嵌入式等  P11</li><li>操作系统的接口有哪些  P15</li><li>操作系统的发展、功能及特点，并发、共享、异步(随机)、虚拟各有什么含义  P9</li><li>了解现在热门的操作系统、国产操作系统</li></ul><h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3><ul><li>定义：操作系统是一组计算机程序的集合，主要用以控制和管理计算机的硬件和软件资源，合理地组织计算机的工作流程， 向应用程序和用户提供方便、快捷、友好的使用接口</li><li>特征：<ul><li>并发性–两个或多个事件在同一时间间隔内发生</li><li>共享性–共享计算机的硬件和软件资源，分为互斥共享方式和交替共享方式</li><li>随机性(异步性)–每道程序在何时运行，各个程序运行的顺序，以及每道程序所需的时间都是不确定的，也是不可预知的</li><li>虚拟性–将一个物理实体映射为一个或多个逻辑对象</li></ul></li><li>接口：<ul><li>程序接口：系统调用，API</li><li>操作接口：命令界面，图形界面，作业控制命令</li></ul></li></ul><h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1><h2 id="问题相关-2"><a class="markdownIt-Anchor" href="#问题相关-2"></a> 问题相关</h2><ul><li>顺序执行、并发执行、并行执行  P31</li><li>进程的概念与特征，与程序的区别与联系，进程与线程的区别与联系，进程上下文  P33-70</li><li>三态模型、五态模型及七态模型的状态转化  P34-35-36</li><li>什么是进程控制块？包含哪些信息？有什么功能？  P36</li><li>同步与互斥概念，饥饿与死锁概念，临界区与临界资源概念，临界区调度原则与管理方法  P40-41-42</li><li>进程通信的机制及对应的工作原理(重点管道通信)  P52</li><li>进程调度模型及其对应的主要功能  P56</li><li>死锁产生的四个必要条件，预防、避免、检测及接触死锁对应的方法  P65</li></ul><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><ul><li>顺序执行：<ul><li>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行</li><li>顺序性，封闭性、可再现性</li></ul></li><li>并发执行：<ul><li>多个事件在同一时期内发生</li><li>本质是一个CPU在多个程序运行过程中的时分复用</li><li>间断性、开放性、不可再现性</li></ul></li></ul><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><ul><li><p>引入目的：</p><ul><li>使多个程序并发运行，以改善资源利用率及提高系统的吞吐量</li></ul></li><li><p>定义：</p><ul><li>可并发运行的程序在某个数据集合上的一次运行过程，是操作系统资源分配、保护和调度的基本单位</li></ul></li><li><p>特征：</p><ul><li>结构性、动态性、独立性、并发性</li></ul></li><li><p>进程上下文</p><ul><li>进程的生命周期中，进程实体和支持执行进程的环境合称为进程上下文</li><li>用户级上下文、系统级上下文、寄存器上下文</li></ul></li></ul><h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3><ul><li>引入目的：<ul><li>减少程序并发运行时所付出的时空开销</li></ul></li><li>定义：<ul><li>线程是操作系统进程中除处理器外的资源分配和保护的单位，它有一个独立的虚拟地址空间，用来容纳进程映像。</li><li>这是CPU调度的基本单位</li></ul></li></ul><h3 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h3><ul><li>进程控制块—为了描述和控制进程运行的数据结构<ul><li>记录了描述进程的当前状态以及控制进程运行的信息，主要包括进程标识信息、现场信息和控制信息。</li></ul></li></ul><h3 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h3><ul><li>高级调度(作业调度)</li><li>中级调度(平衡调度，内存调度)</li><li>低级调度(进程调度)</li></ul><h3 id="互斥与同步"><a class="markdownIt-Anchor" href="#互斥与同步"></a> 互斥与同步</h3><h4 id="竞争和协作"><a class="markdownIt-Anchor" href="#竞争和协作"></a> 竞争和协作</h4><ul><li>死锁：一组进程都陷入永远等待的状态</li><li>饥饿：被调度程序长期忽视</li><li>协作—同步：一个进程的执行依赖于其协作进程的消息或信号</li><li>竞争—互斥：互斥也是一种特殊的同步——以一定次序协调地使用共享资源</li></ul><h4 id="临界"><a class="markdownIt-Anchor" href="#临界"></a> 临界</h4><ul><li>临界资源：<ul><li>在某段时间内只能允许一个进程使用的资源</li><li>几个进程若共享同一临界资源，它们必须以互斥的方式使用这个临界资源</li></ul></li><li>临界区：<ul><li>进程中访问临界资源的代码段</li></ul></li></ul><h3 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h3><ul><li>消息传递通信<ul><li>直接通信</li><li>间接通信</li></ul></li><li>共享内存通信<ul><li>基于共享数据结构的通信方式—低效</li><li>基于共享存储区的通信方式—建立，管理，映射与断开</li></ul></li><li>管道通信<ul><li>实质为一个共享文件，物理上是由文件系统的高速缓冲区完成</li></ul></li></ul><h2 id="考试要点"><a class="markdownIt-Anchor" href="#考试要点"></a> 考试要点</h2><ol><li>信号量机制解决进程同步互斥问题：信号量(记录性数据结构)及其取值范围，P、V操作及含义，P、V操作解决同步互斥问题的方法流程  P45</li><li>调度算法：<code>非抢占式</code>(FCFS、SJF、HRRF)，<code>抢占式</code>(SRTF、HPF、RR、MFQ)，作业或者进程的执行顺序，计算周转时间及带权周转时间  P 58</li><li>死锁的避免：银行家算法及安全性测试算法  P67</li></ol><h3 id="信号量机制"><a class="markdownIt-Anchor" href="#信号量机制"></a> 信号量机制</h3><h4 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h4><ul><li><p>信号量s — 信号量表示系统资源的实体</p><ul><li>记录型数据结构，一个分量为信号量的值，一个分量是在信号量关联资源上阻塞的进程队列的队头指针。</li><li>三种操作进行修改：赋初值，P操作，V操作。</li><li>主要作用是封锁临界区、 进程同步和维护资源计数</li></ul></li><li><p>P、V操作— <strong>书P45</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305052356101.png" alt="image-20230505235624964" /></p><ul><li><p>P(s)：将信号量s减1……</p></li><li><p>V(s)：将信号量s加1……</p></li><li><p>补充定义— <strong>书P46</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305052356855.png" alt="image-20230505235642802" /></p></li></ul></li></ul><h4 id="方法流程"><a class="markdownIt-Anchor" href="#方法流程"></a> 方法流程</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301031289.png" alt="image-20230430103109210" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301037878.png" alt="image-20230430103735854" /></p><ul><li>经典问题<ul><li>生产者-消费者问题</li><li>多生产者-多消费者问题</li><li>读者-写者问题</li><li>哲学家就餐问题</li><li>睡眠理发师问题</li></ul></li></ul><h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301124647.png" alt="image-20230430112422583" /></p><ul><li>周转时间和带权周转时间越小越好</li></ul><h4 id="非抢占式"><a class="markdownIt-Anchor" href="#非抢占式"></a> 非抢占式</h4><h5 id="fcfs"><a class="markdownIt-Anchor" href="#fcfs"></a> FCFS</h5><ul><li>先来先服务(First-Come First-Served)</li></ul><h5 id="sjf"><a class="markdownIt-Anchor" href="#sjf"></a> SJF</h5><ul><li>短作业优先(Shortest-Job-First)</li></ul><h5 id="hrrf"><a class="markdownIt-Anchor" href="#hrrf"></a> HRRF</h5><ul><li>高响应比优先(Highest Response Ratio First)</li><li>响应比 = 1 + (已等待时间 / 估计运行时间)</li></ul><h4 id="抢占式"><a class="markdownIt-Anchor" href="#抢占式"></a> 抢占式</h4><h5 id="srtf"><a class="markdownIt-Anchor" href="#srtf"></a> SRTF</h5><ul><li>最短剩余时间优先(Shortest Remaining Time First)</li></ul><h5 id="hpf"><a class="markdownIt-Anchor" href="#hpf"></a> HPF</h5><ul><li>优先权(Highest-Priority-First)</li><li>静态优先权和动态优先权</li></ul><h5 id="rr"><a class="markdownIt-Anchor" href="#rr"></a> RR</h5><ul><li>时间片轮转(Round-Ribon)</li></ul><h5 id="mfo"><a class="markdownIt-Anchor" href="#mfo"></a> MFO</h5><ul><li>多级反馈队列(Multilevel-Feed-Queue)</li></ul><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h4><ul><li>并发进程对临界资源的竞争 和 并发进程推进顺序不当</li></ul><h4 id="发生的必要条件"><a class="markdownIt-Anchor" href="#发生的必要条件"></a> 发生的必要条件</h4><ul><li>互斥条件：资源的使用互斥的</li><li>请求与保持条件：一个进程得到资源并再请求资源时，若请求的资源不能得到，已得到的资源也不会释放</li><li>不剥夺条件：当进程得到资源后，只能由其自身主动释放，系统或其他进程正在占用的资源，形成永远等待</li><li>环路等待条件：系统中若干进程形成环路，每个进程都在等待相邻进程正在占用的资源，形成永远等待</li></ul><h4 id="检测与解除"><a class="markdownIt-Anchor" href="#检测与解除"></a> 检测与解除</h4><ul><li>重启，撤销，剥夺，回滚</li></ul><h4 id="死锁的避免"><a class="markdownIt-Anchor" href="#死锁的避免"></a> 死锁的避免</h4><ul><li>银行家算法<ul><li>Claim Possession Shortage Available</li></ul></li></ul><h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1><h2 id="问题相关-3"><a class="markdownIt-Anchor" href="#问题相关-3"></a> 问题相关</h2><ul><li><p>内存管理四大功能  P96</p></li><li><p>地址的表示(逻辑地址空间、物理地址空间)  P98</p></li><li><p>重定位，静态重定位，动态重定位  P99</p></li><li><p>单一连续内存管理、固定分区管理、可变分区管理：  P102</p><p>内存的分配与回收，地址转换，优缺点分析，可变分区的内存分配算法</p></li><li><p>程序的局部性原理，虚拟存储的基本思想，虚拟存储器  P119</p></li><li><p>页式存储管理与请求页式管理的区别与联系？两种管理方式下页表机制和地址转换过程有何不同？</p></li><li><p>请求页式虚拟存储管理的页面分配策略、页面调入策略、页面置换策略  P124</p></li><li><p>段式管理的基本思想，其与页式管理有何区别，段式与段页式、请求段式管理、请求段页式管理的区别与联系</p></li><li><p>各种内存管理方式中的”碎片“问题如何解决</p></li></ul><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><ul><li>内存的分配和回收</li><li>实现地址转换</li><li>内存的共享和保护</li><li>内存扩充</li></ul><h3 id="地址重定位"><a class="markdownIt-Anchor" href="#地址重定位"></a> 地址重定位</h3><ul><li>地址转换(地址重定位)：把程序和数据的逻辑地址转换为物理地址</li><li>静态重定位：<ul><li>在用户作业装入内存时由装入程序实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li><li>缺点：必须为程序分配一段连续的存储空间</li></ul></li><li>动态重定位：<ul><li>在程序执行过程中，CPU在访问程序和数据之前才实现从逻辑地址到物理地址的转换</li><li>优点：内存的使用更加灵活，容易实现内存的动态扩充和共享</li></ul></li></ul><h3 id="覆盖和交换"><a class="markdownIt-Anchor" href="#覆盖和交换"></a> 覆盖和交换</h3><ul><li>覆盖技术<ul><li>让不同时运行的程序段先后共享同一块内存区域</li></ul></li><li>交换技术<ul><li>内存和外存的交换</li></ul></li></ul><h3 id="程序的局部性原理"><a class="markdownIt-Anchor" href="#程序的局部性原理"></a> 程序的局部性原理</h3><ul><li>时间局部性：<ul><li>程序中的某条指令一旦被执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问</li></ul></li><li>空间局部性：<ul><li>一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被访问</li></ul></li></ul><h3 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器"></a> 虚拟存储器</h3><ul><li>定义：<ul><li>具有请求调入功能和置换功能，能够从逻辑上对内存空间进行扩展，允许用户的逻辑地址空间大于物理内存地址空间的存储器系统</li></ul></li></ul><h2 id="考试要点-2"><a class="markdownIt-Anchor" href="#考试要点-2"></a> 考试要点</h2><ol><li>地址转换：页式管理和请求页式虚拟存储管理中的逻辑地址转化为物理地址(页号、页内偏移量以及所占位数)，快表的地址转换过程，多级页表的地址转换过程</li><li>页面置换：置换算法(FIFO、OPT、LRU、Clock)，算法流程、缺页次数及缺页率计算—添加(前几次也是缺页，但是不统计)</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305061034871.png" alt="image-20230506103405823" /></p><h1 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h1><h2 id="问题相关-4"><a class="markdownIt-Anchor" href="#问题相关-4"></a> 问题相关</h2><ul><li>设备的不同分类方法  P151</li><li>设备管理四大功能  P153</li><li>设备控制方法(四种)，工作原理以及优缺点分析  P154</li><li>缓冲技术的作用、不同缓冲技术的工作机制  P159</li><li>输入输出软件的层次及相应的功能  P163</li><li>设备分配与回收时使用的数据结构、设备分配策略  P166</li><li>SPOOLing技术的功能和基本思想，如何实现共享打印机  P168</li></ul><h3 id="设备分类"><a class="markdownIt-Anchor" href="#设备分类"></a> 设备分类</h3><ul><li>按服务功能分类<ul><li>存储类设备</li><li>输入/输出类设备</li><li>通信类设备</li></ul></li><li>按每次信息交换的单位分类<ul><li>字符设备</li><li>块设备</li></ul></li><li>按使用特征分类(这里注意SPOOLing技术的特点)<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><h3 id="设备管理功能"><a class="markdownIt-Anchor" href="#设备管理功能"></a> 设备管理功能</h3><ul><li>设备的分配与回收</li><li>缓冲区管理</li><li>设备控制和中断处理</li><li>实现虚拟设备</li></ul><h3 id="设备控制方法"><a class="markdownIt-Anchor" href="#设备控制方法"></a> 设备控制方法</h3><p>​输入输出控制在计算机处理中具有重要的地位，随着计算机结构和软硬件技术的发展，产生了不同的控制方法。按照 I/O 控制器与 CPU 之间联系方式的不同，可把 I/O 设备的控制方式分为四类</p><ul><li>查询方式 - 程序循环查询方式<ul><li><strong>优点</strong>：控制简单</li><li><strong>缺点</strong>：但是 CPU 极大浪费</li></ul></li><li>中断方式 - 中断驱动方式<ul><li><strong>优点</strong>：消除了设备驱动程序不断地轮询<strong>控制器</strong>和<strong>状态寄存器</strong>的开销，提高 CPU 的利用率，提高整个系统资源的利用率及吞吐量</li></ul></li><li>DMA方式 - 直接内存访问方式<ul><li><strong>本质</strong>：通过 DMA控制器DMAC 控制从内存向设备输入输出</li><li><strong>特点</strong>：<ol><li>数据传输的基本单位是<strong>数据块</strong>，即每次传送至少一个数据块。</li><li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li><li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li></ol></li><li><strong>优点</strong>：进一步提高了 CPU 与 I/O 设备的并行操作程度</li></ul></li><li>通道方式<ul><li><strong>通道分类</strong>：字节多路通道，选择通道，成组多路通道</li><li><strong>优点</strong>：进一步减少 CPU 的干预</li></ul></li></ul><p>​主要差别在于中央处理器和外围设备并行工作的方式不同，并行工作的程度不同。</p><h3 id="缓冲技术"><a class="markdownIt-Anchor" href="#缓冲技术"></a> 缓冲技术</h3><ul><li><p>作用</p><ul><li>它能改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和I/O 设备的并行性。</li><li>它能减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求。</li><li>缓冲技术还能协调逻辑记录大小与物理记录大小不一致的问题。</li></ul></li><li><p>分类</p><ul><li>根据缓冲性质<ul><li>硬件缓冲：以专用的寄存器作为缓冲器</li><li>软件缓冲：在内存中划出若干个单元作为缓冲区</li></ul></li><li>根据缓冲区个数的多少和结构<ul><li>单缓冲<ul><li>输入和输出实际上是串行工作</li></ul></li><li>双缓冲<ul><li>两个缓冲区交替使用</li></ul></li><li>多缓冲<ul><li>循环缓冲</li><li>缓冲池</li></ul></li></ul></li></ul></li></ul><h3 id="输入输出软件"><a class="markdownIt-Anchor" href="#输入输出软件"></a> 输入输出软件</h3><ul><li>层次结构（自底向上）<ul><li>中断处理程序</li><li>设备驱动程序</li><li>设备独立性程序</li><li>用户 I/O 软件</li></ul></li></ul><h3 id="设备分配与回收"><a class="markdownIt-Anchor" href="#设备分配与回收"></a> 设备分配与回收</h3><ul><li>设备分配策略—由设备本身属性分类而来<ul><li>独占方式</li><li>共享方式</li><li>虚拟方式</li></ul></li><li>SPOOLing 技术<ul><li>重点：<ul><li>在多道程序技术中，利用其中一道程序模拟脱机输入输出时的外围控制机功能，实现脱机输入输出技术</li><li>外围操作与CPU对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为SPOOLing，或称为假脱机系统</li></ul></li><li><strong>特点</strong>：<ol><li>提高了I/O的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li><li>将独占设备改造为共享设备，提高了设备的利用率</li><li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li></ol></li><li>应用：<ul><li>共享打印机—守护进程和SPOOLing目录<ul><li>通过禁止用户直接使用打印机设备解决了打印机的独占问题</li></ul></li></ul></li></ul></li></ul><h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1><h2 id="考试要点-3"><a class="markdownIt-Anchor" href="#考试要点-3"></a> 考试要点</h2><ol><li>文件的物理结构：根据文件的物理组织情况，计算所支持文件的大小；对于一个给定大小的文件，计算其占用物理盘块情况</li></ol><h2 id="问题相关-5"><a class="markdownIt-Anchor" href="#问题相关-5"></a> 问题相关</h2><ul><li>文件系统基本功能  P199</li><li>文件的逻辑结构和物理结构定义及分类  P201</li><li>记录式文件的组织方式有哪些，各有什么特点  P204</li><li>文件的存储方法、文件存储空间的分配及管理  P213</li><li>文件目录和目录文件的区别与联系    P217</li><li>目录的结构与检索  P217</li><li>文件系统调用的实现  P225</li><li>文件的共享  P230</li></ul><h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3><ol><li>实现文件的“按名存取”功能</li><li>实现能够快速定位文件的目录结构；考虑如何组织目录文件</li><li>向用户提供一套使用方便、简单的操作命令</li><li>管理磁盘、磁带等组成的文件存储器</li><li>…………</li></ol><h3 id="文件分类"><a class="markdownIt-Anchor" href="#文件分类"></a> 文件分类</h3><ul><li>按照<strong>文件的逻辑结构</strong>的不同（对比文件<strong>按照外存物理块分配方式的不同</strong>分类—物理结构）<ul><li>流式文件（无结构）</li><li>纪录式文件（有结构）</li></ul></li><li>按照用途<ul><li>系统文件、库文件和用户文件</li></ul></li><li>按照性质<ul><li>普通文件</li><li>目录文件</li><li>特殊文件</li></ul></li></ul><h3 id="纪录式文件"><a class="markdownIt-Anchor" href="#纪录式文件"></a> 纪录式文件</h3><p>有结构的文件</p><h4 id="组织方式分类"><a class="markdownIt-Anchor" href="#组织方式分类"></a> 组织方式分类</h4><ul><li>顺序文件<ul><li>记录之间按某种顺序排列组织所形成的文件</li><li>存取方式：<ul><li>顺序存取</li><li>直接存取</li></ul></li><li><strong>优点</strong>：<ul><li>适合大量记录批量存取的场合</li><li>只有顺序文件才能被存储在磁带上</li></ul></li><li><strong>缺点</strong>：<ul><li>不适合交互系统中用户要求查找或修改单个记录的情况</li><li>增删记录比较困难</li></ul></li></ul></li><li>索引文件<ul><li>索引文件可以根据不同的关键字建立索引，形成包含多个索引表的索引文件</li><li><strong>优点</strong>：<ul><li>通过建立索引极大地提高了对文件的查找速度</li><li>对增加和删除记录也非常方便</li></ul></li><li><strong>缺点</strong>：存储开销变大，增删记录时还需要修改索引表</li></ul></li><li>索引顺序文件<ul><li>将顺序文件中的多个记录组合成一组，并对每一组记录建立一个索引，通过索引指针指向该记录组中的第一条记录</li><li><strong>优点</strong>：索引表占用空间小，同时查找效率比顺序文件又高，因此在文件记录比较多时采用索引顺序文件比较适合</li></ul></li></ul><h3 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h3><p>​文件的物理结构不仅取决于存储介质的存储特性，还与采用的外存分配方式有关</p><ul><li>按照外存物理块分配方式的不同，文件的物理结构分类<ul><li>连续文件<ul><li><strong>优点</strong>：在顺序存取时速度较快，非常便于顺序访问</li></ul></li><li>链接文件<ul><li><strong>优点</strong>：<ul><li>能适应文件的动态增长</li><li>消除了磁盘的外部碎片</li><li>添加、删除和修改记录也更方便</li></ul></li><li>实现链接组织的方式<ul><li>隐式链接：每个物理块自身存放下一物理块的链接指针</li><li>显示链接：把用于链接文件的各物理块指针显式地放在内存 的一张表格中</li></ul></li></ul></li><li>索引文件<ul><li>索引表的索引形式<ul><li>无键索引表—适用于流式文件</li><li>有键索引表—适用于纪录式文件</li></ul></li><li><strong>优点</strong>:<ul><li>实现了离散分配</li><li>有利于直接存取</li></ul></li><li><strong>缺点</strong>：<ul><li>索引表增加了空间开销</li><li>索引表的查找增加了时间开销</li><li>不适合中小型文件，对于中小型文件会有空间的浪费</li></ul></li></ul></li><li>多级索引文件<ul><li>Unix中混合了四种寻址方式：直接寻址、一级索引寻址、二级索引寻址和三级索引寻址</li><li>解决以及索引文件存在的索引表过大占用物理块过多的问题</li></ul></li><li>直接文件<ul><li>利用哈希函数直接建立逻辑记录的关键字与其物理地址的对应关系的文件组织形式</li><li><strong>优点</strong>：<ul><li>记录在介质上不需要按序存放，因为它能根据关键字直接计算出物理地址，所以最适合直接存取</li><li>相对于索引文件，它不需索引，节省了索引存储空间和索引查找时间</li></ul></li></ul></li></ul></li></ul><h3 id="文件的存取方式"><a class="markdownIt-Anchor" href="#文件的存取方式"></a> 文件的存取方式</h3><ul><li>顺序存取</li><li>直接存取</li><li>按键存取</li></ul><h3 id="文件存储空间管理"><a class="markdownIt-Anchor" href="#文件存储空间管理"></a> 文件存储空间管理</h3><ul><li>磁盘空间的分配</li><li>磁盘空闲空间的有效管理<ul><li>空闲区表法</li><li>空闲块链表法</li><li>位示图法</li></ul></li></ul><h3 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h3><ul><li>任务<ul><li>对大量文件实施有效的管理</li><li>实现“按名存取”</li><li>提高对目录的检索速度</li><li>支持文件共享和文件重名</li></ul></li><li>FCB–用于描述和控制文件的数据结构<ul><li>有关文件存取控制的信息</li><li>有关文件结构的信息</li><li>有关文件使用的信息</li><li>有关文件管理的信息</li></ul></li><li>区别<ul><li>文件目录是文件控制块的有序集合，即一个文件控制块就是一个文件目录项。</li><li>文件目录以文件的形式保存在外存上的，这就形成了目录文件。</li></ul></li></ul><h3 id="文件的共享"><a class="markdownIt-Anchor" href="#文件的共享"></a> 文件的共享</h3><ul><li>静态共享<ul><li>硬链接<ul><li>基于索引节点的链接静态共享</li></ul></li><li>软连接<ul><li>符号链接静态共享</li></ul></li></ul></li><li>动态共享</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>壳相关</title>
    <link href="/posts/6d13a265.html"/>
    <url>/posts/6d13a265.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://ctf-wiki.org/reverse/windows/unpack/packer-introduction/">壳的介绍及脱壳技巧</a></p><h1 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h1><blockquote><p>以ESP定理为例</p></blockquote><ul><li><p>使用x32dbg脱壳时，一开始可能是 <code>jmp</code></p><ol><li><p><code>pushad</code> 可以在断点中找到，因为它是一次性断点，所以出现一次就过去了，可以在断点中找到，然后 <code>F4</code> 跳转</p></li><li><p>一直使用 <code>F9</code> 跳转可以找到 <code>pushad</code></p></li></ol></li><li><p>使用 <code>ESP定理</code> (在pushad之后ESP指向的内存中下硬件断点，之后 <code>F9</code> 跳转) 脱壳时，<code>popad</code> 后面跟着的可能不是主程序入口，这个时候需要查看上下文。一般情况下，<code>popad</code> 之后有一个大跳 (<code>jmp</code>)，跳转后 dump 即可</p><ol><li><code>jmp</code> 之后是 <code>call 函数</code> ，此为 VS 编译 OEP 的特征</li></ol></li><li><p>找到 <code>OEP</code> 之后，使用插件 <code>Scylla</code> 进行 <code>IAT Autosearch</code> 并 <code>Get Imports</code>，之后使用 dump 转储，得到 <code>dump.exe</code> 文件 (此文件可能不能运行，因为没有修复重定位表IAT)</p></li><li><p>然后依然在此插件中 (dbg不要关闭，否则定位不到OEP) 修复重定位表。点击 <code>Fix Dump</code>，得到的 <code>_SCY.exe</code> 文件即为可执行文件</p></li></ul><p>参考地址：<a href="https://www.52pojie.cn/thread-1534675-1-1.html">upx脱壳</a>，<a href="https://blog.csdn.net/weixin_46287316/article/details/109669066#">xdbg手动脱壳</a></p><h1 id="upx"><a class="markdownIt-Anchor" href="#upx"></a> UPX</h1><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><h2 id="去除-upx-特征"><a class="markdownIt-Anchor" href="#去除-upx-特征"></a> 去除 UPX 特征</h2><h3 id="区段名"><a class="markdownIt-Anchor" href="#区段名"></a> 区段名</h3><p>​<code>IMAGE_SECTION_HEADER SectionHeader</code> 字段</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304012357341.png" alt="image-20230401235746301" /></p><ul><li>upx 壳可以看到三个区段名<ul><li><code>UPX0</code> 和 <code>UPX1</code> 是加 UPX 壳后的两个区段名，<strong>可以被随意改成任何字符串</strong>，这样不会被 <code>./upx.exe -d [filename]</code> 识别<ul><li><code>UPX1</code> 区段包含了需要解压的数据块。</li></ul></li><li><code>UPX2</code> 是自身不含资源段程序加壳之后的结果，若是程序含有资源段，那么加壳之后是<code>.rsrc</code><ul><li><code>.rsrc</code> 是程序资源信息区段名，包含原资源段的完整头部、图标、Mainifst、版本等未被压缩的资源，还有UPX本身需要导入的信息等。</li></ul></li></ul></li></ul><h3 id="upx-header-字段"><a class="markdownIt-Anchor" href="#upx-header-字段"></a> <code>UPX Header</code> 字段</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020917186.png" alt="image-20230402091703153" /></p><ul><li><code>3E 2E 30 32 00</code>- 版本</li><li><code>55 50 58 21</code> - UPX Tag</li><li><code>0D 09 08 07</code> - 版本代码、格式、压缩方式、压缩等级</li><li><code>0A 88 3F EF 02 D1 CF F7</code> - 压缩前和压缩后的hash</li><li><code>80 4A 0E 00</code> - 压缩前的长度</li><li><code>D5 40 04 00</code> - 压缩后的长度</li><li><code>81 B1 15 00</code> - 原文件长度</li><li><code>26 18 00 1C</code> - 压缩相关参数</li><li>UPX头是供 UPX 通过 <code>upx - d</code> 命令脱壳使用的，并不影响程序运行。全部抹零，则命令无效。</li></ul><h3 id="特征码"><a class="markdownIt-Anchor" href="#特征码"></a> 特征码</h3><ul><li>出了上面两个方面之外，exeinfo之类查壳程序还能识别出 UPX 壳，这是因为检测UPX是通过一些特征码来检测的。在 UPX 解压缩时，必然会使用一些汇编指令，这些指令的机器码就成为了用来检测 UPX 的特征码。修改特征码，达到保持汇编指令的含义不变，而使用别的指令。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 特征码1:60 BE ?? ?? ?? 00 8D BE ?? ?? ?? FF<br><br>2. 特征码2:60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 EB 0B 90 8A 06 46 88 07 47 01 DB 75 ?? 8B 1E 83 ?? ?? 11 DB 72 ?? B8 01 00 00 00 01 DB 75<br><br>3. 特征码3:55 FF 96 ?? ?? ?? ?? 09 C0 74 07 89 03 83 C3 04 EB ?? FF 96 ?? ?? ?? ?? 8B AE ?? ?? ?? ?? 8D BE 00 F0 FF FF BB 00 10 00 00 50 54 6A 04 53 57 FF D5 8D 87 ?? ?? 00 00 80 20 7F 80 60 28 7F 58 50 54 50 53 57 FF D5 58 61 8D 44 24 80 6A 00 39 C4 75 FA 83 EC 80<br></code></pre></td></tr></table></figure><ul><li>特征码1 / 特征码2</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021005714.png" alt="image-20230402100545695" /></p><p>​特征码2也是 pushad 开头，是另外一种特征，这里没有显示</p><ul><li>特征码3</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021014712.png" alt="image-20230402101429691" /></p><p>​特征码3 匹配到 popad 结尾</p><h3 id="移动pe头"><a class="markdownIt-Anchor" href="#移动pe头"></a> 移动PE头</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020944416.png" alt="image-20230402094451392" /></p><ul><li>删除DOS存根，不影响程序运行，但是需要修改 PE入口地址，并且保证PE头的长度等于原来的DOS头加PE头的长度，不然之后的地址会出现问题。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020958802.png" alt="image-20230402095850765" /></p><ul><li>这里 DOS存根的大小是 0x40(x86文件)，删去之后修改 <code>PE头地址</code> 和 <code>可选PE头的大小</code>，之后<code>填充无用数据</code>(0x40大小) 使地址偏移不发生改变</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021001269.png" alt="image-20230402100153227" /></p><ul><li>之后就识别不出来是 UPX 头了。</li></ul><h1 id="themida"><a class="markdownIt-Anchor" href="#themida"></a> Themida</h1><ul><li>可以直接使用 <a href="https://github.com/ergrelet/unlicense">unlicense</a> 直接进行脱壳处理。运行几分钟之后会出现一个<code>unpacked_&lt;程序名&gt;.exe</code> 的文件</li><li>题目：<code>HZNUCTF TMD</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向技巧</title>
    <link href="/posts/5d944f2a.html"/>
    <url>/posts/5d944f2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="ida-pro"><a class="markdownIt-Anchor" href="#ida-pro"></a> IDA PRO</h1><p><a href="https://www.hex-rays.com/products/ida/support/freefiles/IDA_Pro_Shortcuts.pdf">快捷方式</a></p><h2 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h2><h3 id="graph-is-too-big"><a class="markdownIt-Anchor" href="#graph-is-too-big"></a> Graph is too big</h3><ul><li><p>显示错误</p></li><li><p>解决:更改<code>Options----Graph----Max number of nodes</code>,增大参数</p></li></ul><h3 id="graph界面显示地址"><a class="markdownIt-Anchor" href="#graph界面显示地址"></a> Graph界面显示地址</h3><ul><li><p>Graph界面无地址显示</p></li><li><p>更改<code>Options----Disassembly----Line prefixes(non-graph)(勾选)</code></p></li></ul><h3 id="窗口设置"><a class="markdownIt-Anchor" href="#窗口设置"></a> 窗口设置</h3><ul><li>设置汇编窗口和伪代码窗口关联-<code>synchronize with -&gt; IDA View-A Hex View-1</code></li></ul><h3 id="idapython"><a class="markdownIt-Anchor" href="#idapython"></a> IDAPython</h3><ol><li>在 <code>&quot;IDA\python\3&quot;</code> 目录下添加 <code>idc_bc695.py</code> 文件</li><li>之后在IDAPython脚本中手动添加 <code>from idc_bc695 import *</code> 防止api差异</li></ol><h2 id="静态调试"><a class="markdownIt-Anchor" href="#静态调试"></a> 静态调试</h2><h3 id="快捷方式"><a class="markdownIt-Anchor" href="#快捷方式"></a> 快捷方式</h3><ol><li><code>ctrl + e</code> 找到main函数</li><li><code>Shift + f12</code> 可以打开 string 窗口，一键找出所有的字符串，右击setup，对窗口的属性进行设置。同时附加时使用可以显示 strings</li><li><code>Shift + f7</code> 可以查看 Segments 窗口。查看不同的段</li><li><code>空格</code> 在Text View和Group View中来回切换</li><li><code>f5/Tab</code> 一键反汇编，Tab可以在汇编界面与伪代码界面来回切换</li><li><code>Ctrl + X</code> 交叉引用</li><li><code>Ctrl + Alt + K</code>(Keypatch快捷键) 进行patch</li><li><code>Alt + T</code> 在汇编界面中搜索汇编语言</li><li><code>Shift + E</code></li></ol><h3 id="更改"><a class="markdownIt-Anchor" href="#更改"></a> 更改</h3><ol><li><p><code>D</code> (DATA) 转换为原始数据</p><p><code>C</code> (CODE) 转换为汇编代码</p><p><code>P</code> 重新生成函数</p><p><code>a</code> 将数据转换为字符串，主要可以应对小端序存储</p></li><li><p><code>N</code> 更改变量的名称</p><p><code>Y</code> 更改变量的类型，比如把_int64 更正为BYTE*(或者char *)</p><p><code>U</code> undefine，取消定义函数、代码、数据的定义，转化为原始字节的形式</p><p><code>V</code> 简化函数的格式，有时候函数没有return时可以使用，查看更方便</p><p><code>M</code> 枚举所有相同的数据</p></li><li><p><code>;</code> 在反汇编后的界面中写下注释</p><p><code>/</code> 在反编译后伪代码的界面中写下注释</p></li><li><p><code>\</code> 在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述</p><ul><li>有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</li><li>右键点击Hide casts----也可以隐藏类似*（DWORD）的类型描述</li></ul></li></ol><h2 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h2><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><code>F2</code> 增加断点</li><li><code>F7</code> 单步步入，遇到函数，将进入函数代码内部</li><li><code>F8</code> 单步步过，执行下一条指令，不进入函数代码内部</li><li><code>F4</code> 运行到光标处（断点处）</li><li><code>F9</code> 继续运行</li><li><code>Ctrl+F2</code> 终止一个正在运行的调试进程</li><li><code>Ctrl+F7</code> 运行至返回,直到遇到RETN（或断点）时才停止</li></ol><h3 id="附加"><a class="markdownIt-Anchor" href="#附加"></a> 附加</h3><ul><li>应对一些强壳，可以先启动 <code>.exe</code> 程序，之后使用IDA的附加功能<code>(Debugger-&gt;attach)</code>，附加进程，可以越过壳。</li><li>之后可以使用<code>Shift + f12</code> 和 <code>Shift + f7</code> 定位关键字符位置和段属性，将该程序的 Code 段使用 IDAPYTHON 转化为反汇编形式进行动调。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ida_ua <span class="hljs-keyword">import</span> *<br>cur_addr = <span class="hljs-number">0x401000</span> <span class="hljs-comment">#起始地址</span><br>end_addr = <span class="hljs-number">0x410000</span>   <span class="hljs-comment">#终止地址</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_insn</span>(<span class="hljs-params">start,end</span>):<br>adr = start<br>out_ins = insn_t()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span>(adr &gt;= end): <br><span class="hljs-keyword">break</span><br>create_insn(adr)<br>size = decode_insn(out_ins,adr)<br>adr += size<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end!&quot;</span>)<br>make_insn(cur_addr,end_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>可能 Code 段很大，编译很慢，可以结合手动按c反汇编结合查看</p></blockquote><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><h4 id="ida动态调试elf"><a class="markdownIt-Anchor" href="#ida动态调试elf"></a> IDA动态调试ELF</h4><p><a href="https://blog.csdn.net/weixin_44959377/article/details/105866347">Kali虚拟机开启远程服务</a></p><p><a href="https://www.cnblogs.com/DorinXL/p/12732721.html">IDA调试ELF文件</a></p><p><a href="https://blog.csdn.net/abc_670/article/details/80066817">ida动态调试elf</a></p><p><a href="https://www.cnblogs.com/longyuan-z/p/7787860.html">使用GDB调试时attach ID不被允许 - longyuan-z - 博客园 (cnblogs.com)</a></p><ul><li>Linux开启远程连接服务，在虚拟机中打开IDA在Linux中的调试工具</li><li>首先需要将文件提权，否则不能运行，也就不能调试了</li><li>IDA连接虚拟机，开始动调</li><li>Linux进行附加时，需要先打开linux_server服务，然后另起端口打开运行的程序，之后就可以附加了。这里需要先使用 <code>sudo vim /etc/sysctl.d/10-ptrace.conf</code> 更改最后一行 <code>kernel.yama.ptrace_scope = 0</code>，重启系统后，普通用户就可以使用attach ID连接程序调试了。</li></ul><h2 id="idapython-2"><a class="markdownIt-Anchor" href="#idapython-2"></a> IDAPYTHON</h2><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/">IDAPYTHON文档</a></p><p>[IDApython - 比翼飞 - 博客园 (<a href="http://cnblogs.com">cnblogs.com</a>)](<a href="https://www.cnblogs.com/biyifei/p/17153109.html#:~:text=idc.get_reg_value">https://www.cnblogs.com/biyifei/p/17153109.html#:~:text=idc.get_reg_value</a> (string Register) %23 获取寄存器的值%2Cdbg必须处于运行状态 idc.set_reg_Value,(long Value%2C string Register) %23 通过寄存器名获得寄存器值。)</p><h3 id="导入模块"><a class="markdownIt-Anchor" href="#导入模块"></a> 导入模块</h3><ul><li><p><code>import ida_bytes</code>和<code>import idc_bc695</code>的效果一样，都是让idapython的脚本可以执行7.0之前的简单样式，但是要区分二者的不同：</p><ul><li><p>对于patch_byte，ida_bytes中是patch_byte，而idc_bc695中是PatchByte----注意区分</p></li><li><blockquote><p>不知道是否是导入了idc_bc695的py与pyc文件，现在的IDA7.7<strong>新旧函数</strong>都可以使用----<strong>不一定</strong></p></blockquote></li></ul></li></ul><h3 id="函数解释"><a class="markdownIt-Anchor" href="#函数解释"></a> 函数解释</h3><ul><li><p><code>Patch</code>：</p><ul><li><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>PatchByte(addr,value)</td><td>将value赋值到addr上，字节形式修改</td></tr><tr><td>PatchWord(addr,value)</td><td>将value赋值到addr上，双字形式修改</td></tr><tr><td>PatchDword(addr,value)</td><td>将value赋值到addr上，四字形式修改</td></tr><tr><td>PatchQword(addr,value)</td><td>将value赋值到addr上，八字形式修改</td></tr></tbody></table></li></ul></li><li><p><code>Byte</code>：</p><ul><li><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Byte(addr)</strong></td><td>以字节为单位获取地址处的值</td></tr><tr><td><strong>Word(addr)</strong></td><td>同上. 以2字节(字)的单位获取</td></tr><tr><td><strong>Dword(addr)</strong></td><td>4字节</td></tr><tr><td><strong>Qword(addr)</strong></td><td>8字节</td></tr></tbody></table></li></ul></li></ul><h3 id="花指令"><a class="markdownIt-Anchor" href="#花指令"></a> 花指令</h3><h4 id="模板一"><a class="markdownIt-Anchor" href="#模板一"></a> 模板一</h4><ul><li><code>jnz--jz</code> 跳转后加入<code>E8</code>问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_nop</span>(<span class="hljs-params">addr,endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        patch_byte(addr,<span class="hljs-number">0x90</span>)<br>        addr += <span class="hljs-number">1</span><br>pattern = <span class="hljs-string">&quot;33 C0 85 C0 74 03 75 00 E8&quot;</span><br>cur_addr = <span class="hljs-number">0x401000</span> <span class="hljs-comment">#开始地址</span><br>end_addr = <span class="hljs-number">0x405000</span> <span class="hljs-comment">#结束地址</span><br><span class="hljs-keyword">while</span> cur_addr &lt;= end_addr:<br>    cur_addr = idc.find_binary(cur_addr,SEARCH_DOWN,pattern)<span class="hljs-comment"># find_binary() 函数搜索 pattern，其中SEARCH_DOWN表示从cur_addr向高地址方向搜索</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;patch address: &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(cur_addr))) <span class="hljs-comment"># 打印信息</span><br>    <span class="hljs-keyword">if</span> cur_addr == idc.BADADDR:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        my_nop(cur_addr,cur_addr + <span class="hljs-number">9</span>)<br>    cur_addr = idc.next_head(cur_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="模板二"><a class="markdownIt-Anchor" href="#模板二"></a> 模板二</h4><ul><li>去除 <code>jmp</code> 花指令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#idapy去除花指令，特征值查看按键为D</span><br><span class="hljs-keyword">import</span> idc_bc695 <span class="hljs-keyword">as</span> idc<br>cur_addr = <span class="hljs-number">0x80487C4</span> <span class="hljs-comment">#开始地址</span><br>enc_addr = <span class="hljs-number">0x80488DF</span> <span class="hljs-comment">#结束地址</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cur_addr,end_addr):<br>    <span class="hljs-keyword">if</span> idc.Dword(i) == <span class="hljs-number">0x05ebb866</span>:<span class="hljs-comment">#请修改此处特征值</span><br>        <span class="hljs-keyword">if</span> idc.Dword(i+<span class="hljs-number">4</span>) == <span class="hljs-number">0xfa74c031</span>:<span class="hljs-comment">#请修改此处花指令特征值</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                idc.PatchByte(i+j,<span class="hljs-number">0x90</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><h4 id="dump内存"><a class="markdownIt-Anchor" href="#dump内存"></a> dump内存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc_bc695 <span class="hljs-keyword">as</span> idc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    cur_addr = <span class="hljs-number">0x140003040</span>; <span class="hljs-comment"># 起始地址</span><br>    size = <span class="hljs-number">0x34166</span>  <span class="hljs-comment"># 大小</span><br>    <span class="hljs-built_in">list</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>        byte_tmp = idc.Byte(begin + i)<br>        <span class="hljs-built_in">list</span>.append(byte_tmp)<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) % <span class="hljs-number">0x1000</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All count:&#123;&#125;, collect current:&#123;&#125;, has finish&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(size), <span class="hljs-built_in">hex</span>(i + <span class="hljs-number">1</span>), <span class="hljs-built_in">float</span>(i + <span class="hljs-number">1</span>) / size))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;collect over&#x27;</span>)<br>    file = <span class="hljs-string">&quot;LOADER2.exe&quot;</span>  <span class="hljs-comment">#输出文件地址+名</span><br>    buf = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fw:<br>        fw.write(buf)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;write over&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="取数值"><a class="markdownIt-Anchor" href="#取数值"></a> 取数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> idc_bc695 <span class="hljs-keyword">import</span> *<br>cur_addr = <span class="hljs-number">0x6020c0</span>  <span class="hljs-comment">#起始地址</span><br>end_addr = <span class="hljs-number">0x60213c</span>  <span class="hljs-comment">#终止地址</span><br><span class="hljs-built_in">len</span> = end_addr - cur_addr<br>arr1 = []<br>arr2 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>):<br>    arr1.append(Byte(cur_addr + i)) <span class="hljs-comment">#单个字节获取</span><br>    arr2.append(Dword(cur_addr + <span class="hljs-number">4</span> * i))<span class="hljs-comment">#四个字节获取</span><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="插件及其使用"><a class="markdownIt-Anchor" href="#插件及其使用"></a> 插件及其使用</h2><h3 id="bindiff"><a class="markdownIt-Anchor" href="#bindiff"></a> bindiff</h3><ul><li>可以看出二进制文件中的差异，样例:GUDOCTF–L!S!</li></ul><h3 id="go_parser"><a class="markdownIt-Anchor" href="#go_parser"></a> go_parser</h3><ul><li>直接在 file/Script file里面运行<code>go_parser.py</code>即可解析</li></ul><h3 id="d-810"><a class="markdownIt-Anchor" href="#d-810"></a> D-810</h3><ul><li>选择适当的规则，然后点击 <code>start</code>，之后就可以按 F5 自动反编译，解决OLLVM混淆。如果已经存在 F5缓存，可以将一段代码nop掉，之后撤销操作，再 F5 反编译即可</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401152139298.png" alt="image-20240115213925148" /></p><h1 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> GDB</h1><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb调试利器</a></p><p><a href="https://www.cnblogs.com/murkuo/p/15965270.html">pwngdb操作</a></p><h2 id="相关操作"><a class="markdownIt-Anchor" href="#相关操作"></a> 相关操作</h2><h3 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h3><ul><li><code>run</code>：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li><code>continue</code>：简写c，继续执行，到下一个断点处(或运行结束)</li><li><code>next</code>：简写 n，单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li><code>step</code>：简写s，单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li><code>until</code>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li><code>finish</code>：运行程序，<strong>直到当前函数完成返回</strong>，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a class="markdownIt-Anchor" href="#设置断点"></a> 设置断点</h3><ul><li><p><code>break n</code> :简写b n，在第n行处设置断点，例如：b *0x80345C</p><p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p></li><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p><code>break func</code>：在函数func()的入口处设置断点，如：break cb_button</p></li><li><p>delete 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p>clear 行号n：清除第n行的断点</p></li><li><p><code>info b</code>(info breakpoints)：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点</p></li></ul><h3 id="查看源代码"><a class="markdownIt-Anchor" href="#查看源代码"></a> 查看源代码</h3><ul><li><code>list</code> ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h3 id="查看内存数据"><a class="markdownIt-Anchor" href="#查看内存数据"></a> 查看内存数据</h3><ul><li><p>格式：<code>x /nfu</code>----例如：<strong>x/s 0x80457F</strong>显示字符串</p></li><li><p>说明：</p><ul><li><p><code>x</code>：examine的缩写，检查</p></li><li><p><code>n</code>：表示要显示的内存单元的个数，比如：20</p></li><li><p><code>f</code>：表示显示方式</p><ul><li><table><thead><tr><th>显示方式</th><th>含义</th></tr></thead><tbody><tr><td>x</td><td>按十六进制格式显示变量</td></tr><tr><td>d</td><td>按十进制格式显示变量</td></tr><tr><td>u</td><td>按十进制格式显示无符号整型</td></tr><tr><td>o</td><td>按八进制格式显示变量</td></tr><tr><td>t</td><td>按二进制格式显示变量</td></tr><tr><td>a</td><td>按十六进制格式显示变量</td></tr><tr><td>i</td><td>指令地址格式</td></tr><tr><td>c</td><td>按字符格式显示变量</td></tr><tr><td>f</td><td>按浮点数格式显示变量</td></tr></tbody></table></li></ul></li><li><p><code>u</code>：表示一个地址单元长度</p><ul><li><table><thead><tr><th>显示方式</th><th>含义</th></tr></thead><tbody><tr><td>b</td><td>表示单字节</td></tr><tr><td>h</td><td>表示双字节</td></tr><tr><td>w</td><td>表示四字节</td></tr><tr><td>g</td><td>表示八字节</td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="打印表达式"><a class="markdownIt-Anchor" href="#打印表达式"></a> 打印表达式</h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息"><a class="markdownIt-Anchor" href="#查询运行信息"></a> 查询运行信息</h3><ul><li><code>where/bt</code>：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口"><a class="markdownIt-Anchor" href="#分割窗口"></a> 分割窗口</h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><blockquote><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便</p></blockquote><h1 id="经验"><a class="markdownIt-Anchor" href="#经验"></a> 经验</h1><h2 id="ida使用相关"><a class="markdownIt-Anchor" href="#ida使用相关"></a> IDA使用相关</h2><ol><li><p><code>Windows</code> 体系下注意小端序，使用 <code>Shift + e</code> 提取的字符串是转化过后的字符串，不需要再次转化。注意汇编模块读取可能会把地址也读进来，注意区分数据和地址。</p></li><li><p><code>Patch</code> 函数的时候，可以直接使用汇编。然后另存为文件即可跳过函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,0x1<br>retn x #这里的x需要根据函数末尾的返回来抄写，防止栈不平衡<br></code></pre></td></tr></table></figure></li><li><p>遇到 <code>(_BYTE *)&amp;qword_4058</code> 之类的，若是知道这是表示的数组，那么可以再汇编界面按 <code>D</code> 变成数据，之后 <code>F5</code> 重新生成伪代码，则可以看到数组变成 <code>byte_4058[]</code> 之类的数组形式</p></li><li><p>若是函数格式中有 <code>(_BYTE)</code> 等干扰分析时，可以：</p><ol><li>使用 <code>Y</code> 更改变量的类型，比如把_int64 更正为BYTE*(或者char *)</li><li>使用 <code>V</code> 简化函数的格式，有时候函数没有 return 时可以使用，这样看更方便</li></ol></li><li><p>IDA在识别花指令时，很可能在一个连续的函数中显示红色的 <code>sub_3D9 endp ; sp-analysis failed</code> 类似的信息，这个时候可以使用 <code>Edit -&gt; Function -&gt; Delete function</code> 删除函数定义，然后在正确的位置 <code>retn</code> 使用 <code>Edit -&gt; Function -&gt; Set function end</code> 设置函数结尾。之后 <code>F5</code> 反编译可以看到正常的函数</p></li><li><p>有时候 <code>U</code> + <code>P</code> 不能生成函数，可以先删除函数定义，选中函数块之后按 <code>P</code> 定义函数</p></li></ol><h2 id="识别相关"><a class="markdownIt-Anchor" href="#识别相关"></a> 识别相关</h2><ol><li>代码最好两边夹击，从前往后看对输入的操作，从后往前看得到最终结果的操作</li><li>看 main 函数之前先看一下 <code>init</code> 段，这里会在main函数之前执行，可能隐藏了核心代码</li><li>若是函数的识别发现<code>变量异常</code>，可以点进去函数，然后在局部变量上按 <code>y</code> 之后返回主函数，就可以看到识别出变量的函数了</li></ol><h2 id="exp书写相关"><a class="markdownIt-Anchor" href="#exp书写相关"></a> exp书写相关</h2><ol><li><p>在python中 <code>&amp;0xff</code> 就是一个整数的后八位，在逆向中，常常有 <code>unsigned __int8</code> 作为数据类型，这个时候得出的结果就是取后八位作为结果，如果在python中使用，需要使用 <code>&amp; </code> 操作。同样，16位，32位的操作也是这样。</p></li><li><p>对于算法进行解密运算时，时刻注意小端序的问题，因为解密的过程中可能就需要将上一步的结果逆序放入下一步中 (TEA类型的解密最为拧巴，往往需要调换多次位置)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = <span class="hljs-number">0x67616c66</span><br>tmp1 = <span class="hljs-built_in">hex</span>(enc)[<span class="hljs-number">2</span>:]<br><span class="hljs-comment"># 将enc以两个字节为单位进行逆序排列</span><br>res1 = <span class="hljs-string">&#x27;0x&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tmp),<span class="hljs-number">2</span>):<br>    res1 += tmp[<span class="hljs-built_in">len</span>(tmp) - i - <span class="hljs-number">2</span>: <span class="hljs-built_in">len</span>(tmp) - i]<br><span class="hljs-built_in">print</span>(res1)<br><br><span class="hljs-comment"># 将enc以两个字节为单位进行逆序排列并转化为字符</span><br>res2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tmp),<span class="hljs-number">2</span>):<br>    tmp2 = tmp[<span class="hljs-built_in">len</span>(tmp) - i - <span class="hljs-number">2</span>: <span class="hljs-built_in">len</span>(tmp) - i]<br>    res2 += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;0x&#x27;</span> + tmp2))<br><span class="hljs-built_in">print</span>(res2)<br></code></pre></td></tr></table></figure></li></ol><h2 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理"></a> 数据处理</h2><ol><li>从IDA中获取数据时，如果在分析程序中发现数据的排列为 qword 等，建议不要以小端序转化，而是直接从IDA的 <code>IDA View-RIP</code> 界面复制，不用 <code>Ctrl + e</code> 提取数据。除此之外， qword 的转化可能会出现一些多余数据，记得识别。<ul><li>这里补充一点：若是在 <code>IDA View-RIP</code> 界面中的数据不是正规数据(这里指十六进制)，则采用 <code>Ctrl + e</code> 进行十六进制提取，再分别以4个字节为一组，然后倒转称为小端序的顺序进行解密操作。</li><li>总而言之<ol><li><p>可以首先使用 <code>Ctrl + e</code> 进行提取，然后手动进行倒转转换。</p></li><li><p>也可以使用 <code>D</code> 进行打乱，再分别使用 <code>D</code> 聚合成每4个字节为一组的形式</p></li><li><p>也可以使用插件 <code>lazyida</code>，在数据上 <code>右键</code> -&gt; <code>convert</code> -&gt; <code>Covern to …… DWORD list</code>(这里注意看前面的标识进行相依字节长度的转化) 就可以在下方output框看见正确的小端序数组。</p></li></ol></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="/posts/87126416.html"/>
    <url>/posts/87126416.html</url>
    
    <content type="html"><![CDATA[<h1 id="first_page"><a class="markdownIt-Anchor" href="#first_page"></a> First_Page</h1><h2 id="2019红帽杯easyre"><a class="markdownIt-Anchor" href="#2019红帽杯easyre"></a> [2019红帽杯]easyRE</h2><h3 id="具体流程"><a class="markdownIt-Anchor" href="#具体流程"></a> 具体流程</h3><ul><li><p>首先<code>Shift + F12</code>查看字符串，找到了base64编码的东西</p><ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052153730.png" alt="image-20230305215330684" /></li><li>base64解了十次，得到了<a href="https://bbs.kanxue.com/thread-254172.htm">看雪CTF从入门到存活（六）主动防御</a>这个网站，然后没有一点信息，应该是被耍了。</li></ul></li><li><p>接着从主函数出发，找到关键函数<code>sub_4009C6</code></p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052215011.png" alt="image-20230305221551966" /></p></li><li><p>分析前半段(如注释)，代码解出v18的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">v15 = <span class="hljs-string">&#x27;Iodl&gt;Qnb(ocy\x7F&#x27;</span><br>v16 = <span class="hljs-string">&#x27;y.i\x7F&#x27;</span><br>v17 = <span class="hljs-string">&#x27;d`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span><br>v = v15 + v16 + v17<br>enc =[]<br>key = <span class="hljs-built_in">list</span>(v14)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>    enc.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key[i]) ^ i))<br>tmp = <span class="hljs-string">&#x27;&#x27;</span>.join(enc)<br><span class="hljs-built_in">print</span>(tmp)<br><span class="hljs-comment"># tmp = Info:The first four chars are `flag`</span><br></code></pre></td></tr></table></figure></li><li><p>由得出的结果，知道这里没有flag，继续往下看</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052254462.png" alt="image-20230305225421428" /></p></li><li><p>这里进行了十次base64加密，对应了上文中的base解密出来为网站的事情</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052255104.png" alt="image-20230305225555059" /></p></li></ul></li><li><p>查看0ff_6CC090时(也就是base64加密数据的存放地址)，看到了新的数据off_6CC0A0，直接查看其引用，找到<code>sub_400D35</code>函数</p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052259863.png" alt="image-20230305225937825" /></p></li><li><p>观察函数，猜测v1为数组，其的值应该是<code>flag</code>。这里由于 <strong>HIBYTE</strong> 函数的作用是获取高字节也就是数组的最后一位，在由上面的Info信息得到结果，而与 <strong>HIBYTE</strong> 相对应的还有 <strong>BYTE()</strong>、<strong>BYTE1()</strong>、**BYTE2()**第一个是获取数组的第一位，第二个就是获取第二位，依次类推。由此编写脚本得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">key = [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x2F</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>,<br>  <span class="hljs-number">0x72</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x5B</span>]<br>key2 = <span class="hljs-string">&#x27;flag&#x27;</span><br>key3 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key2)):<br>    key3.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key2[i]) ^ key[i]))<br><span class="hljs-built_in">print</span>(key3)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    key3.append(<span class="hljs-built_in">chr</span>(key[i]^<span class="hljs-built_in">ord</span>(key3[i%<span class="hljs-number">4</span>])))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(key3))<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>判断IDA给出定义的真实含义，如上述的v1指代一个数组，确切而言指示这v1[0]</li><li>根据上下文判断伪代码对于语句的操作，如上述的字符串相加</li></ul><h2 id="youngter-drive"><a class="markdownIt-Anchor" href="#youngter-drive"></a> Youngter-drive</h2><blockquote><p>知识点：多线程处理</p></blockquote><p>参考：<a href="https://tokameine.top/2021/04/30/buuctf-youngter-drive/">BUUCTF Youngter-drive笔记与思考 (线程) – TokameinE</a></p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><h4 id="识别"><a class="markdownIt-Anchor" href="#识别"></a> 识别</h4><ul><li>查壳，UPX壳，直接脱</li><li>拖到IDA中，发现调用Windows的API<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101734236.png" alt="image-20230304094722528" /></li><li>这里<code>CreateThread</code>是创建一个线程，属于新知识点。这里创建了两个互斥的线程对象，一个线程处于休眠状态时，另一个线程开始运作，以实现并发操作。</li></ul></li></ul><h4 id="具体流程-2"><a class="markdownIt-Anchor" href="#具体流程-2"></a> 具体流程</h4><ul><li><p>结合给出的IDA分析与注释，这里分别追踪 <code>StartAddress</code> 和 <code>sub_41119F</code> 两个线程。</p></li><li><p><code>StartAddress</code></p><ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101740626.png" alt="image-20230304094927047" /></li><li>这里执行<strong>sub_41112C</strong>操作，其中<strong>dword_418008</strong>的值为29—综合下文sub_411940可以判断出此值为flag的长度。继续追踪，找到sub_411940函数。</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101740951.png" alt="image-20230304095634491" /></li><li>由分析，此时对于flag数组进行了替换操作，其操作从后往前(a2一开始为29，之后递减)。此操作含义就是在 <strong>off_418000中查询下标为flag[i]-38对应的值，赋值给flag[i]</strong>。</li></ul></li><li><p><code>sub_41119F</code></p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102141867.png" alt="image-20230310214101827" /></p></li><li><p><code>WaitForSingleObject</code></p><ul><li>一种Windows API函数，当等待仍在挂起状态时，句柄被关闭，那么函数行为是未定义的。该句柄必须具有 SYNCHRONIZE 访问权限。</li><li>其用来检测 hHandle 事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds 毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds 毫秒，但hHandle所指向的对象还没有变成有信号状态，函数照样返回。</li></ul></li><li><p><code>ReleaseMutex</code></p><ul><li>一种线性指令，具有释放线程拥有的互斥体的控制权。</li></ul></li><li><p><code>Sleep</code></p><ul><li>此函数可使线程暂停自己的运行，直到dwMilliseconds过去为止。即该线程不想在某个时间段内被调度。</li></ul></li></ul></li><li><p><code>sub_411190</code></p><ul><li>判断最后更改后的Source数组是否与给定的数组相等</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102152825.png" alt="image-20230310215237808" /></li></ul></li></ul><h4 id="综合分析"><a class="markdownIt-Anchor" href="#综合分析"></a> 综合分析</h4><ul><li>当第一个线程(<code>StartAddress</code>)执行到 <code>Sleep</code> 语句时，此线程暂停，转为另一个线程，然后经过<strong>dword_418008</strong>减1的操作后，第二个进程(<code>sub_41119F</code>)暂停，转为第一个线程，循环交替。而由于第二个进程只是进行了自减操作，所以可以判断出在 <strong>dword_418008</strong> 为奇数时执行第一个线程操作，并对flag进行了更改。</li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;0abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br>text1=<span class="hljs-string">&#x27;TOiZiZtOrYaToUwPnToBsOaOapsyS&#x27;</span><br>text2=<span class="hljs-string">&#x27;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#x27;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br>s=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)):<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>):<br>        flag+=text1[i]<br>    <span class="hljs-keyword">else</span>:<br>        s=text2.index(text1[i])<br>        flag+=<span class="hljs-built_in">str</span>[s]<br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment"># 或者</span><br>key = <span class="hljs-string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span><br>flagRe = <span class="hljs-string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySa&quot;</span><br>flag = []<br><br>i = <span class="hljs-number">0x1d</span><br><span class="hljs-keyword">while</span> i &gt; -<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> key.find(flagRe[i]):<br>        position = key.find(flagRe[i])<br>        <span class="hljs-keyword">if</span> position &lt;= <span class="hljs-number">26</span>:<br>            flag.append(<span class="hljs-built_in">chr</span>(position + <span class="hljs-number">96</span>))<br>        <span class="hljs-keyword">else</span>:<br>            flag.append(<span class="hljs-built_in">chr</span>(position + <span class="hljs-number">38</span>))<br>        i -= <span class="hljs-number">1</span><br>        <br>    flag.append(flagRe[i])<br>    i -= <span class="hljs-number">1</span><br><br>flag = <span class="hljs-built_in">reversed</span>(flag)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.join(flag))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(flag))<br></code></pre></td></tr></table></figure><h3 id="知识点多线程"><a class="markdownIt-Anchor" href="#知识点多线程"></a> 知识点：多线程</h3><ul><li><p>多线程：指一个程序中有多个顺序流在执行。其中 <code>CreateThread</code> 是创造一个线程，创造的线程要用句柄 <code>HANDLE</code> 来储存， <code>CloseHandle</code> 是关闭该线程。</p></li><li><p>API函数：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">CreateThread(<br>lpThreadAttributes<br>dwStackSize    <br>lpStartAddress<br>lpParameter<br>dwCreationFlags<br>lpThreadId<br>)<br></code></pre></td></tr></table></figure><ul><li><code>lpThreadAttributes</code>：NULL</li><li><code>dwStackSize</code>：栈空间大小，0表示1MB</li><li><code>lpStartAddress</code>：执行的线程函数地址</li><li><code>lpParameter</code>：传给线程函数的参数</li><li><code>dwCreationFlags</code>：控制线程的创建，0表示可以立即调用；如果为 <code>CREATE_SUSPENDED</code> ，则创建后无法调用，直到调用 <code>ResumeThread()</code></li><li><code>lpThreadId</code>：NULL</li><li><code>CreateMutexW</code>：实现进程互斥，IDA中实际作用</li></ul></li><li><p>一个程序在运行时占用整个进程，一个进程可以建立多个线程。这些线程能够并行 (同时进行代码处理)以加快程序的运行速度。其中线程分为 “对等线程”，“分离线程”，“主线程”。而当一个处理器在处理一个线程时遇到 <strong>慢速系统调用(sleep、read等)</strong> 等需要消耗较多时间的处理需求时，控制器便通过上下文切换传送到下一个对等进程，以加快程序的运行。</p></li></ul><h2 id="crackrtf"><a class="markdownIt-Anchor" href="#crackrtf"></a> CrackRTF</h2><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><ul><li><p>识别，32位无壳，直接打开</p></li><li><p>找到 <strong>main</strong> 函数，分析 mian 函数，可以发现函数分为两个部分</p></li><li><p><code>password1</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102341004.png" alt="image-20230310231125442" /></p><ul><li><p>这里 <strong>auti</strong> 函数的作用就是将输入的字符串转化为整型，然后这里限定其整型数值大于100000。然后其中 <strong>strcat</strong> 将 @DBApp 附加到输入的input后面，然后经过 <code>sub_40100A</code> 函数进行加密之后与if中的字符串相比较。</p></li><li><p>追踪 <code>sub_40100A</code> 函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102340276.png" alt="image-20230310234029242" /></p></li><li><p><code>CryptCreateHash </code><a href="https://www.cnblogs.com/rnss/p/15328653.html">HASH指计算函数相关</a>–不过此API已被弃用</p><ul><li><p>此函数启动数据流的哈希。它创建并返回到调用应用程序，该句柄指向加密服务提供程序 (CSP) 哈希对象。 此句柄用于后续调用 <code>CryptHashData</code> 和 <code>CryptHashSessionKey</code> 以哈希会话键和其他数据流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CryptCreateHash</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTPROV hProv,</span></span><br><span class="hljs-params"><span class="hljs-function">  ALG_ID     Algid,</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTKEY  hKey,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD      dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTHASH *phHash</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>关键为第二个参数 <code>Algid</code>，标识要使用的哈希算法的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecCrypto/alg-id">ALG_ID</a> 值，此参数的有效值因使用的 CSP 而异。而此时无符号数 0x8004 指哈希算法的类型为 SHA1 加密。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102324419.png" alt="image-20230310232406385" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>string=<span class="hljs-string">&#x27;@DBApp&#x27;</span><br>password1=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>,<span class="hljs-number">999999</span>):<br>    flag=<span class="hljs-built_in">str</span>(i)+string <span class="hljs-comment"># str(i)就是把整数i换成字符串类型</span><br>    x = hashlib.sha1(flag.encode())  <span class="hljs-comment"># 这里加密前需要转化为byte类型</span><br>    y = x.hexdigest()     <span class="hljs-comment"># hexdigest()使用十六进制表示</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot;</span> == y:<br>            password1 = flag<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(password1)<br><span class="hljs-comment"># password1 = 123321@DBApp</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>password2</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102341829.png" alt="image-20230310231241758" /></p><ul><li><p>此处的 <code>password2</code> 的形式与 <code>password1</code> 形似，这里 <code>sub_401019</code> 就是指 MD5 加密，但此时没有爆破信息，无法爆破，这里查看 <code>sub_40100F</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111034062.png" alt="image-20230311103417993" /></p></li><li><p>其中显示资源文件 <strong>AAA</strong> ，则使用 Resource Hacker 打开文件查看资源文件信息</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111151820.png" alt="image-20230311115101765" /></p></li><li><p>函数解析</p><ul><li><p><code>FindResource</code></p><ul><li><p>该函数确定指定模块中指定类型和名称的资源所在位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRSRC <span class="hljs-title">FindResourceA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR  lpName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR  lpType</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>HMODULE</strong>：处理包含资源的可执行文件的模块。NULL值则指定模块句柄指向操作系统通常情况下创建最近过程的相关位图文件。</p></li><li><p><strong>LPCSTR</strong>：指定资源名称</p></li><li><p><strong>LPCSTR</strong>：指定资源类型</p></li></ul></li><li><p><code>LoadResource</code></p><ul><li><p>检索可用于获取指向内存中指定资源的第一个字节的指针的句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HGLOBAL <span class="hljs-title">LoadResource</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">  HRSRC   hResInfo</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>hModule</strong>：其可执行文件包含资源的模块句柄。 如果 <em>hModule</em> 为 <strong>NULL</strong>，系统会从用于创建当前进程的模块加载资源。</p></li><li><p><strong>HRSRC</strong>：要加载的资源的句柄。</p></li></ul></li></ul></li><li><p>追踪 <code>sub_401005</code>，这里将 <code>lpString(password2)</code> 与 <code>a2(lpBuffer)</code> 进行了异或操作，对 a2 进行了修改，使之成为 .rtf 文件的格式。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111045780.png" alt="image-20230311104503742" /></p></li></ul></li></ul><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><ul><li><p>根据最后的信息，password2需要由 .rtf 的文件格式和 AAA文件格式进行异或得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rtf = <span class="hljs-string">&#x27;&#123;\\rtf1&#x27;</span><br>source = [<span class="hljs-number">0x05</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x01</span> ]<br>password2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rtf)):<br>    password2 += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(rtf[i]) ^ source[i])<br><span class="hljs-built_in">print</span>(password2)<br></code></pre></td></tr></table></figure></li></ul><h2 id="actf新生赛2020usualcrypt"><a class="markdownIt-Anchor" href="#actf新生赛2020usualcrypt"></a> [ACTF新生赛2020]usualCrypt</h2><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303120019578.png" alt="image-20230312001921502" /></p></li><li><p>可以看出是将输入的进行base64加密，之后与原字符串比较而得到答案</p></li><li><p>深入 <code>sub_401080</code> 函数，找到存储base64表的数组 <code>table_40E0A0</code> 之后查看引用，发现对表进行了更改</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303120021667.png" alt="image-20230312002136637" /></p></li><li><p>由分析，这里的 <code>byte_40E0A0</code> 与 <code>byte_40E0AA</code> 都是地址，都是对于一个base64表数组进行操作</p></li></ul><h4 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> result; <br>  <span class="hljs-type">char</span> v1; <br><span class="hljs-type">char</span> k[<span class="hljs-number">66</span>] = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-type">char</span>* a0 = k;<br><span class="hljs-type">char</span>* aa = a0 + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> ( result = <span class="hljs-number">6</span>; result &lt; <span class="hljs-number">15</span>; ++result )<br>&#123;<br>v1 = aa[result];<br>    aa[result] = a0[result];<br>    a0[result] = v1;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,k);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>table_old = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br>table_new = <span class="hljs-string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br><span class="hljs-comment"># 这里获得table_new的时候出现问题，不能很好地理解byte_40E0A0和byte_40E0AA都是指针的作用，不过指向数组的不同位置而已</span><br><span class="hljs-comment"># 我错误地理解为两个数组进行位置的交换，从而导致了错误的答案</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(table_new))<br>key = <span class="hljs-string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span>.swapcase()<br><br><span class="hljs-built_in">print</span>(base64.b64decode(key.translate(<span class="hljs-built_in">str</span>.maketrans(table_new,table_old))))<br><br></code></pre></td></tr></table></figure><h1 id="sencond_page"><a class="markdownIt-Anchor" href="#sencond_page"></a> Sencond_Page</h1><h2 id="xxor"><a class="markdownIt-Anchor" href="#xxor"></a> xxor</h2><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><ul><li><p>无壳，直接IDA分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121437154.png" alt="image-20230312143746093" /></p><ul><li>得到伪代码，这里 <code>HIDWORD</code> 获取 <code>v6[j]</code> 的 下一个双字(这里是小端序存储，所以高位的就是下一位的)，则这里循环了3次，也将6个输入给整合了进去。之后经过 <code>sub_400686</code> 的加密，最后又赋值到 v7 上</li></ul></li><li><p><code>sub_400686</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121716686.png" alt="image-20230312171608633" /></p><ul><li>这是 xtea 加密，不过进行了部分改变</li></ul></li><li><p>最后的对比函数 <code>sub_400770</code> ，可以使用 z3 找到 <code>v7</code> 的值</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121720876.png" alt="image-20230312172048847" /></p></li></ul><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br>s = Solver()<br>a0,a1,a2,a3,a4,a5 = BitVecs(<span class="hljs-string">&quot;a1 a1[1] a1[2] a1[3] a1[4] a1[5]&quot;</span>, <span class="hljs-number">32</span>)<br>s.add(a2 - a3 == <span class="hljs-number">0x84A236FF</span>)<br>s.add(a3 + a4 == <span class="hljs-number">0xFA6CB703</span>)<br>s.add(a2 - a4 == <span class="hljs-number">0x42D731A8</span>)<br>s.add(a0 == <span class="hljs-number">0xDF48EF7E</span>)<br>s.add(a5 == <span class="hljs-number">0x84F30420</span>)<br>s.add(a1 == <span class="hljs-number">0x20CAACF4</span>)<br><br>check = s.check()<br>model = s.model()<br><span class="hljs-built_in">print</span>(model)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrypt</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">uint32_t</span>* k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i +=<span class="hljs-number">2</span>)&#123;<br><br>    <span class="hljs-type">uint32_t</span> v3 = v[i], v4 = v[i+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">uint32_t</span> v5 = <span class="hljs-number">1166789954</span>*<span class="hljs-number">64</span>;<br>    <span class="hljs-type">uint32_t</span> *a2 = k;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">64</span>; i++) &#123;<br>        v4 -= (v3 + v5 + <span class="hljs-number">20</span>) ^ ((v3 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">2</span>]) ^ ((v3 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">3</span>]) ^ <span class="hljs-number">0x10</span>;<br>        v3 -= (v4 + v5 + <span class="hljs-number">11</span>) ^ ((v4 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">0</span>]) ^ ((v4 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">1</span>]) ^ <span class="hljs-number">0x20</span>;<br>        v5 -= <span class="hljs-number">1166789954</span>;<br>    &#125;<br>    v[i]=v3; <br>    v[i+<span class="hljs-number">1</span>]=v4;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> v[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">3746099070</span>, <span class="hljs-number">550153460</span>, <span class="hljs-number">3774025685</span>, <span class="hljs-number">1548802262</span>, <span class="hljs-number">2652626477</span>, <span class="hljs-number">2230518816</span>&#125;;<br>    <span class="hljs-type">uint32_t</span> k[<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">decrypt</span>(v,k);<br>    <span class="hljs-comment">// 注意windows小端序输出 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>    <span class="hljs-type">char</span> a3 = v[i] &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-type">char</span> a2 = v[i] &gt;&gt; <span class="hljs-number">8</span>;<br><span class="hljs-type">char</span> a1 = v[i];<span class="hljs-comment">//舍弃高位，保留低位 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%c%c&quot;</span>,a3,a2,a1);<br>    <span class="hljs-comment">//或者cout &lt;&lt; *((char*)&amp;v[i] + 2) &lt;&lt; *((char*)&amp;v[i] + 1) &lt;&lt;  * ((char*)&amp;v[i]);</span><br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="overlong"><a class="markdownIt-Anchor" href="#overlong"></a> OverLong</h2><h3 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121932873.png" alt="image-20230312193202829" /></p><ul><li><p>这里 <code>MessageBoxA</code> 显示文本框</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageBoxA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HWND   hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpText,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpCaption,</span></span><br><span class="hljs-params"><span class="hljs-function">  UINT   uType</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>LPCTSTR</code><ul><li>要显示的消息。 如果字符串由多个行组成，则可以使用回车符和/或每行之间的换行符分隔这些行。</li></ul></li><li><code>LPCTSTR</code><ul><li>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</li></ul></li></ul></li></ul></li><li><p>由此可知，这里输出了 <code>Text</code> 的内容，也就是 <code>v6</code> 的内容，而 <code>v6</code> 使用 <code>sub_401160</code> 进行了更改</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121935826.png" alt="image-20230312193553796" /></p><ul><li>查看函数，循环了28次，而又由于改变的数据 <code>unk_402008</code> 的数据长度不止为28位，同时根据运行程序得到了28字节的字符串，料想需要对于全部数据进行处理，则在动调中改变 28 的值, 最后得到答案。</li></ul><table style="border:none;text-align:center;width:auto;margin: 0 auto;">  <tbody>  <tr>  <td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121938309.png" ></td><td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121944927.png" ></td>  </tr>      <tr><td><strong>未修改之前</strong></td><td><strong>修改之后</strong></td></tr>  </tbody></table></li></ul><h2 id="oruga"><a class="markdownIt-Anchor" href="#oruga"></a> oruga</h2><h3 id="分析-6"><a class="markdownIt-Anchor" href="#分析-6"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121953195.png" alt="image-20230312195358159" /></p></li><li><p>前面是判断前缀是否相同，关键函数是 <code>sub_78A</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122017480.png" alt="image-20230312201735441" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122018150.png" alt="image-20230312201807123" /></p></li><li><p>函数逻辑分内外两层循环，外循环确定方向，内循环位移。与常见迷宫题目不同的是，这里的位移是一直移动，直到碰到非0字符(由内循环实现)。这里内循环依据 <code>v4</code> 的值一直进行操作，直到尽头，而外循环中的<code>v2 -= v4</code>实际上是为了解决内循环中多余的一次位移而进行的操作。WMJE分别代表上下左右。</p></li><li><p>由dump出的数据，可以判断出路径(可以先用常规方向键走，之后再替换)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122021310.png" alt="image-20230312202147279" /></p></li></ul><h2 id="easy-strcmp"><a class="markdownIt-Anchor" href="#easy-strcmp"></a> easy strcmp</h2><p>[buuoj-<a href="https://www.cnblogs.com/Hznuxxw/p/16989358.html">Zer0pts2020]easy strcmp</a></p><h3 id="分析-7"><a class="markdownIt-Anchor" href="#分析-7"></a> 分析</h3><ul><li><p>无壳，直接分析。但是直接看main函数没有看出来什么</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130836500.png" alt="image-20230313083654457" /></p></li><li><p>查看 <code>init</code> 函数，这里有个 <code>funcs_889</code> 函数，跟入查看，调用了 <code>sub_795</code> 函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130838948.png" alt="image-20230313083858918" /></p></li><li><p>这里出现了 <code>strcmp</code> ，怀疑之前的<code>strcmp</code> 有问题，查看其地址，发现是调用了 <code>off_201028</code> 地址函数，在这个函数中刚好看出调用了 <code>sub_6EA</code> 函数，深入查看。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130843698.png" alt="image-20230313084354655" /></p></li><li><p>这里一个(char)为一组，之后减去一个字节对应长度的数值，最后得到 <code>main</code> 函数中比较的那个字符串。注意给的数据以小端序的形式存储，不过shift+e提取就是小端序。</p></li></ul><h3 id="exp-5"><a class="markdownIt-Anchor" href="#exp-5"></a> exp</h3><ul><li>这里字符串相加的大致实现是：将大数做成多个字节，将每个字节与对应的字符串相加(指相同字节位对齐相加，多者溢出)，这里溢出处理是关键。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x09</span>,<br>  <span class="hljs-number">0x4A</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x0B</span>,<br>  <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x4A</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x3A</span>,<br>  <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>]<br>key = <span class="hljs-string">&#x27;zer0pts&#123;********CENSORED********&#125;&#x27;</span><br><br>f = <span class="hljs-number">0</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>  <span class="hljs-keyword">if</span> f != <span class="hljs-number">0</span>:<br>    tmp = enc[i] + <span class="hljs-built_in">ord</span>(key[i]) + f<br>    f = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">else</span>:<br>    tmp = enc[i] + <span class="hljs-built_in">ord</span>(key[i])<br>  <span class="hljs-keyword">if</span> tmp &gt; <span class="hljs-number">0xff</span>:<br>    f = <span class="hljs-number">1</span><br>  tmp &amp;= <span class="hljs-number">0xff</span><br>  flag += <span class="hljs-built_in">chr</span>(tmp)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="level4"><a class="markdownIt-Anchor" href="#level4"></a> level4</h2><h3 id="分析-8"><a class="markdownIt-Anchor" href="#分析-8"></a> 分析</h3><ul><li><p>直接IDA，查看伪代码</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130859803.png" alt="image-20230313085904775" /></p></li><li><p>这里查看 <code>type1</code> 和 <code>type2</code></p></li></ul><table style="border:none;text-align:center;width:auto;margin: 0 auto;">  <tbody>  <tr>  <td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130859242.png" ></td><td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130900138.png" ></td>  </tr>      <tr><td><strong>type1</strong></td><td><strong>type2</strong></td></tr>  </tbody></table><ul><li><p>可以发现这里为二叉树的中序遍历和后续遍历。那么根据这两个遍历，可以知道前序遍历的结果，也就是 <code>type3</code> 为前序遍历。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130907542.png" alt="image-20230313090751513" /></p></li><li><p>运行截图，可以得到中序和后序遍历的结果</p></li></ul><h3 id="exp-6"><a class="markdownIt-Anchor" href="#exp-6"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ToPreOrder</span>(<span class="hljs-params">Postorder,Inorder</span>):<br>    length = <span class="hljs-built_in">len</span>(Postorder)<br>    <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    root = Postorder[length-<span class="hljs-number">1</span>] <span class="hljs-comment">#根节点　</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<span class="hljs-comment">#找到中序遍历中根节点的位序</span><br>        <span class="hljs-keyword">if</span> root == Inorder[i]:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(root,end=<span class="hljs-string">&quot;&quot;</span>)<br>    ToPreOrder(Postorder[<span class="hljs-number">0</span>:i],Inorder[<span class="hljs-number">0</span>:i]) <span class="hljs-comment">#递归，传入左子树的后序和中序遍历序列</span><br>    ToPreOrder(Postorder[i:length-<span class="hljs-number">1</span>],Inorder[i+<span class="hljs-number">1</span>:length])<span class="hljs-comment">#递归，传入右子树的后序和中序遍历序列</span><br>    <br>ToPreOrder(<span class="hljs-string">&quot;20f0Th&#123;2tsIS_icArE&#125;e7__w&quot;</span>,<span class="hljs-string">&quot;2f0t02T&#123;hcsiI_SwA__r7Ee&#125;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="third_page"><a class="markdownIt-Anchor" href="#third_page"></a> Third_Page</h1><h2 id="2019红帽杯childre"><a class="markdownIt-Anchor" href="#2019红帽杯childre"></a> [2019红帽杯]childRE</h2><p>​<strong>Windows 内置函数的理解</strong></p><h3 id="分析-9"><a class="markdownIt-Anchor" href="#分析-9"></a> 分析</h3><ul><li>无壳，64位，直接IDA分析</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072344923.png" alt="image-20230407234421853" /></p><ul><li>首先检测了输入长度，之后 <code>if语块</code> 没多关注，构造输入 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcde</code>，进行动调，查看v5发现将输入的顺序打乱为 <code>PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072346858.png" alt="image-20230407234656810" /></p><ul><li>之后从后往前看，发现 <code>a123456789Qwer</code>，<code>a46200860044218</code>，<code>a55565653255552</code> 有相应数据，直接爆破得到了 <code>outputString</code> 的最终值 <code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072348861.png" alt="image-20230407234800829" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">key = <span class="hljs-string">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;,27h,&#x27;ASDFGHJKL:\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,.&quot;</span><br>f1 = <span class="hljs-string">&#x27;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&#x27;</span><br>f2 = <span class="hljs-string">&#x27;55565653255552225565565555243466334653663544426565555525555222&#x27;</span><br><br>message = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">62</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">127</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(key[j % <span class="hljs-number">23</span>]) == <span class="hljs-built_in">ord</span>(f1[i]) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(key[j//<span class="hljs-number">23</span>]) == <span class="hljs-built_in">ord</span>(f2[i]):<br>            message +=<span class="hljs-built_in">chr</span>(j)<br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><ul><li>由上文在动调中，执行此函数之前，<code>v5</code> 和 <code>name</code> 占用同一块空间，都是 <code>PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA</code> ，可以发现 if语块负责打乱输入的字符顺序。之后执行此函数后，打乱的结果传递给了 <code>outputString</code>，可以推测出 <code>outputString  = private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li><li>综合目前的信息，可以知道函数 <code>UnDecorateSymbolName(v5, outputString, 0x100u, 0);</code> 获得一个打乱的输出 <code>v5</code>，经过函数的性质，转化为了 <code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081553288.png" alt="image-20230408155333208" /></p><h3 id="关键函数"><a class="markdownIt-Anchor" href="#关键函数"></a> 关键函数</h3><ul><li><p>现在问题就是明白 <code>UnDecorateSymbolName(v5, outputString, 0x100u, 0);</code> 函数的具体含义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DWORD IMAGEAPI <span class="hljs-title">UnDecorateSymbolName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  PCSTR name,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] PSTR  outputString,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  DWORD maxStringLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  DWORD flags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>[in] name</code> 修饰的 C++ 符号名称。 此名称可由名称的第一个字符标识，该名称始终是问号 (？)</li><li><code>[out] outputString</code> 指向接收未编码名称的字符串缓冲区的指针</li><li><code>[in] maxStringLength</code> <em>UnDecoratedName</em> 缓冲区的大小（以字符为单位）</li><li><code>[in] flags</code> 修饰名称如何取消编码的选项。 此参数为 0x0000 标识医用完全消除记录</li></ul></li></ul><p>*<em>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char <em>)</em></em></p><ul><li>参考资料1</li></ul><blockquote><p>目前根据函数知道了第一个参数为输出地址，第二个参数是未修饰的名字，第三个参数为长度，第四个参数为0表示完全修饰</p></blockquote><ul><li>参考资料2</li></ul><blockquote><p><em>c++函数名的修饰更为复杂，提供的信息也更为丰富。</em><br /><em>无论 __cdecl，__fastcall还是__stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字。再后面是参数表的开始标识和依照参数类型代号拼出的参数表。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN</code> - 函数修饰以“？”开始，后面跟随函数的名字</p><blockquote><p><em>对于C<ins>的类成员函数(其调用方式是thiscall)，函数的名字修饰与非成员的C</ins>函数稍有不同，首先就是在函数名字和参数表之间插入以“@”字符引导的类名。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@ROPxx</code> - 类名是 <code>ROPxx</code></p><blockquote><p>其次是参数表的开始标识不同，</p><p><em>公有（public）成员函数的标识是“@@QAE”，</em></p><p><em>保护（protected）成员函数的标识是 “@@IAE”，</em></p><p><em>私有(private)成员函数的标识是“@@AAE”，</em></p><p><em>假设函数声明使用了constkeyword，则对应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@ROPxx@@AAE</code> - 私有成员(private)</p><blockquote><p><em>参数表的拼写代号如下：</em><br /><em>X–void</em><br /><em>D–char</em><br /><em>E–unsigned char</em><br /><em>F–short</em><br /><em>H–int</em><br /><em>I–unsigned int</em><br /><em>J–long</em><br /><em>K–unsigned long（DWORD）</em><br /><em>M–float</em><br /><em>N–double</em><br /><em>_N–bool</em><br /><em>U–struct</em><br /><em>…</em><br /><em>指针的方式有些特别。用PA表示指针，用PB表示const类型的指针。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPAD</code> - 类名之后就是参数表，这个先加入函数返回值参数为 <code>char *</code></p><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPADPAE</code> - 之后就是添加形参了，这里是 <code>unsigned char *</code></p><blockquote><p><em>参数表后以“@Z”标识整个名字的结束。假设该函数无参数，则以“Z”标识结束。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</code> - 结尾标识</p><h3 id="exp-7"><a class="markdownIt-Anchor" href="#exp-7"></a> exp</h3><ul><li>得到了 <code>v5</code> 的值，可以根据前文字符的打乱顺序进行还原，之后进行md5加密</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>m = <span class="hljs-string">&#x27;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&#x27;</span><br>enc1 = <span class="hljs-string">&#x27;PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA&#x27;</span><br>enc2 = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcde&#x27;</span><br>c = [<span class="hljs-string">&#x27;0&#x27;</span>] * <span class="hljs-number">31</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc2)):<br>    c[i] = m[enc1.find(enc2[i])]<br>k = <span class="hljs-string">&#x27;&#x27;</span>.join(c)<br>obj = hashlib.md5(k.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(obj.hexdigest())<br></code></pre></td></tr></table></figure><h2 id="swpu2019reverseme"><a class="markdownIt-Anchor" href="#swpu2019reverseme"></a> [SWPU2019]ReverseMe</h2><p>​<strong>内存访问断点的使用</strong></p><h3 id="分析-10"><a class="markdownIt-Anchor" href="#分析-10"></a> 分析</h3><ul><li>正常使用IDA分析</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081909327.png" alt="image-20230408190950254" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081910191.png" alt="image-20230408191010144" /></p><ul><li>从前后进行动调分析，最后得到 <code>sub_402350</code> 对输入的flag 进行操作，和 <code>v36</code> 等内置数据进行比较得到结果。这里 <code>sub_402350</code> 太过于复杂，搜索别人的学会了内存断点的方法。</li></ul><h3 id="内存断点"><a class="markdownIt-Anchor" href="#内存断点"></a> 内存断点</h3><h4 id="禁用aslr"><a class="markdownIt-Anchor" href="#禁用aslr"></a> 禁用ASLR</h4><blockquote><p>首先记得关闭ASLR，否则OD和IDA中基址就不太一样</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082000293.png" alt="image-20230408200039234" /></p><ul><li><p>微软从windows vista/windows server 2008（kernel version 6.0）开始采用ASLR技术，主要目的是为了防止缓冲区溢出。ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。这里只要PE头 DLL Charateristics 有 0x40 时，每次OD加载时的基址就不一样。去掉IMAGE_OPTIONAL_HEADER.DLLCharacteristics 的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 可以禁用随机基址。</p></li><li><p>使用 <code>Study PE</code> 直接固定基址，之后另存为文件即可</p></li></ul><h4 id="od调试"><a class="markdownIt-Anchor" href="#od调试"></a> OD调试</h4><ul><li>根据上下文，找到了调用 <code>sub_402350</code> 之前的位置，并在内存窗口看到打乱顺序的input(一开始输入了32个 ‘1’)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082006374.png" alt="image-20230408200623320" /></p><ul><li>在内存窗口(红框)下 <code>内存访问断点</code>，然后 <code>F9</code> 执行，找到了函数中对于 input 地址的更改。发现这里使用 <code>ecx</code> 对数据进行了异或处理，之后又赋值到 <code>[ebx + eax - 0x4]</code> 的位置。<code>PS:F9 抵达断点位置时，这个时候[ebi + eax] 已经对 ecx进行了赋值操作，所以一开始的数据需要在内存窗口往上翻才能找到</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082028713.png" alt="image-20230408202843658" /></p><ul><li>之后在内存新地址下 <code>内存访问断点</code> 。发现这里将 <code>eax</code> 和 <code>edx</code> 逐个进行比较，这里 <code>eax</code> 来自 ecx，如下内存窗口。而 <code>edx</code> 就是下内存访问断点的地方，就是数据存储的区域。这里也验证了IDA中最后对比的过程。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082034829.png" alt="image-20230408203403780" /></p><h3 id="exp-8"><a class="markdownIt-Anchor" href="#exp-8"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">ipt = <span class="hljs-string">&#x27;11111111111111111111111111111111&#x27;</span> <span class="hljs-comment"># len is 32</span><br>v10 = <span class="hljs-built_in">list</span>(ipt)<br>v35 = <span class="hljs-string">&#x27;SWPU_2019_CTF&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ipt)):<br>    v10[i] = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">ord</span>(v10[i]) ^ <span class="hljs-built_in">ord</span>(v35[i % <span class="hljs-built_in">len</span>(v35)]))<br><span class="hljs-built_in">print</span>(v10)<br><br>enc = [  <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x5A</span>,<br>  <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x16</span>,<br>  <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x6B</span>,<br>  <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x67</span>]<br><br>key = [<span class="hljs-number">0x86</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x98</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x19</span>,  <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xB0</span>,<br><span class="hljs-number">0x69</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x28</span><br>]<br>flag = [<span class="hljs-string">&#x27;0&#x27;</span>] * <span class="hljs-number">32</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    flag[i] = <span class="hljs-built_in">chr</span>(enc[i] ^ key[i] ^ <span class="hljs-built_in">ord</span>(v35[i % <span class="hljs-built_in">len</span>(v35)]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure><h2 id="npuctf2020你好sao啊"><a class="markdownIt-Anchor" href="#npuctf2020你好sao啊"></a> [NPUCTF2020]你好sao啊</h2><ul><li><p>查壳，一个无壳的64位程序</p></li><li><p>查看内部信息，这里可以观察对于输入的s进行了RxEncode的函数操作，之后把这个结果s1与本身赋值的s2进行对比，相同就是正确的flag了</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302051129.png" alt="image-20230930205151048" /></p></li><li><p>查看 RxEncode 函数的内容，发现是一个base64加密的操作，只不过是表进行了更换</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302053251.png" alt="image-20230930205241620" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302053278.png" alt="image-20230930205354245" /></p></li><li><p>最后直接使用python逆推base64加密的过程即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> *<br><br>table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234&#123;&#125;789+/=&quot;</span><br>raw = [<span class="hljs-number">0xFD370FEB59C9B9E</span>, <span class="hljs-number">0xDEAB7F029C4FD1B2</span>, <span class="hljs-number">0xFACD9D40E7636559</span>]<br>target = <span class="hljs-string">b&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-comment"># print(pack(&quot;Q&quot;, raw[i]))</span><br>    target += pack(<span class="hljs-string">&quot;Q&quot;</span>, raw[i])<br>    <br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(target), <span class="hljs-number">3</span>):<br>    v8 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        v8 |= target[i + j] &lt;&lt; <span class="hljs-number">8</span> * (<span class="hljs-number">2</span> - j)<br><br>    v7 = v8<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        idx = (v7 &gt;&gt; <span class="hljs-number">6</span> * j) &amp; <span class="hljs-number">0b111111</span><br>        flag += table[idx]<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure></li></ul><h2 id="安洵杯-2019crackme"><a class="markdownIt-Anchor" href="#安洵杯-2019crackme"></a> [安洵杯 2019]crackMe</h2><h3 id="分析-11"><a class="markdownIt-Anchor" href="#分析-11"></a> 分析</h3><ul><li><p>首先查壳无壳，然后直接载入IDA</p></li><li><p>这里通过字符串搜索到 <code>please Input the flag:\n</code>，直接引用查看，发现来到了<code>main</code>函数。这里有一个内存访问异常，再结合MessageBoxW中的信息，感觉这里会有异常处理的存在。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051057731.png" alt="image-20231005105703690" /></p></li><li><p>之后再函数列表中就发现了 <code>Handler</code> 函数，跟进发现这是使用 <code>SetUnhangledExceptionFilter</code> 来注册的未处理异常，这个调试器不会运行到这里处理，由此可知前面的内粗访问异常可以阻止调试器调试，因为得不到正确信息。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051108003.png" alt="image-20231005110821954" /></p></li><li><p>之后查看 <code>sub_411172</code> 函数，发现其中关键的数字0xA3B1BAC6，经过查阅，发现这个是<code>SM4</code>加密，那么 <code>where_are_u_now?</code>就是密钥，同时 <code>unk_41A218</code> 的数据也被main函数的<code>sub_41100F</code>函数所引用</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051111426.png" alt="image-20231005111144377" /></p></li><li><p>同时观察 <code>TopLevelExceptionFilter</code> 的内容，跟进发现首先对于最后的 <code>Str2</code>进行了更改，之后有对数据 <code>byte_41A180</code> 进行了处理传递给 <code>Str1</code> ，最后在 <code>sub_411136</code> 函数进行了正确性比对，由此可以看出<code>Str1</code>来自于自己的输入。又由于查看汇编，发现 <code>byte_41A180</code>与 <code>unk_41A1E4</code>是连续的，所以可以视为对于输入进行了操作。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051117612.png" alt="image-20231005111717569" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051117437.png" alt="image-20231005111730401" /></p></li><li><p>这里跟进 <code>sub_41126C</code> 函数会发现这是一个变种的base64加密，对于输入进行了转换处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051120575.png" alt="image-20231005112029524" /></p></li><li><p>但是再尝试运行程序时，跳出的是 <code>hooked</code> 标识的信息，由此怀疑还有别的操作，查找字符串找到<code>hooked</code>，由此可以看出对于base64的表进行了处理。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051122180.png" alt="image-20231005112215145" /></p></li><li><p>综上，可以分析出：该程序首先通过hook改变了main函数中message的消息传递，并且改变了base64表，之后通过内存访问异常来引出handler来进行处理，在该函数中，首先经过一个函数进行SM4加密，之后传递加密后的字符串进行异常处理，之后就是一个变种的base64加密，与更改后的Str2进行对比，成功就是正确的flag</p></li></ul><h3 id="exp-9"><a class="markdownIt-Anchor" href="#exp-9"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> pysm4 <span class="hljs-keyword">import</span> encrypt, decrypt<br>base = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br>diy_base = <span class="hljs-string">&#x27;yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx&#x27;</span><br><br>str2 = <span class="hljs-string">&#x27;U1ATIOpkOyWSvGm/YOYFR4!!&#x27;</span><br>sstr2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str2)-<span class="hljs-number">2</span>):<br>sstr2 += base[diy_base.find(str2[i])]<br>sstr2 += <span class="hljs-string">&#x27;==&#x27;</span><br>dec_64 = base64.b64decode(sstr2)<br>cipher_num = <span class="hljs-string">&quot;0x&quot;</span> + dec_64.<span class="hljs-built_in">hex</span>()<br>cipher_num = <span class="hljs-built_in">int</span>(cipher_num,<span class="hljs-number">16</span>)<br>mk = <span class="hljs-number">0x77686572655f6172655f755f6e6f773f</span><br>clear_num = decrypt(cipher_num, mk)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag&#123;&#x27;</span>+<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-built_in">hex</span>(clear_num)[<span class="hljs-number">2</span>:]).decode()+<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理与应用</title>
    <link href="/posts/1b8dd184.html"/>
    <url>/posts/1b8dd184.html</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a class="markdownIt-Anchor" href="#绪论"></a> 绪论</h1><h2 id="考试要点"><a class="markdownIt-Anchor" href="#考试要点"></a> 考试要点</h2><ul><li>数据库(DB)、数据库管理系统(DBMS)、数据库系统(DBS)、数据库应用系统(DBAS)</li><li>数据管理技术的三个发展阶段、数据库系统的优点</li><li>数据模型的分类、组成要素、E-R图、常用逻辑数据模型优缺点比较、关系模型(关系模式)</li><li>数据库系统的三级模式结构、两级映像和数据独立性(优点)</li></ul><h2 id="区分数据库相关含义"><a class="markdownIt-Anchor" href="#区分数据库相关含义"></a> 区分数据库相关含义</h2><h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3><p>​<strong>数据库(DB)</strong>：指在计算机的存储设备上合理存放相关联，有结构的数据集合。<code>数据库在硬件存放</code></p><ul><li><strong>有结构</strong>：数据库与文件系统相比最大的特点之一</li></ul><h3 id="数据库管理系统"><a class="markdownIt-Anchor" href="#数据库管理系统"></a> 数据库管理系统</h3><p>​<strong>数据库管理系统(DBMS)</strong>：是一个操作和管理数据库的大型软件(是一组软件)，它由一组计算机程序构成，位于用户于操作系统之间的一层数据管理系统(属于系统软件)。</p><h3 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h3><p>​<strong>数据库系统(DBS)</strong>：用于实现有组织、动态地存储大量相关地结构化数据，便于用户使用数据库地计算机软件和硬件资源组成的系统。即数据库系统是指在<strong>计算机系统</strong>中引进<strong>数据库</strong>和<strong>数据库管理系统</strong>后地系统。</p><ul><li>数据库系统一般由<strong>硬件、软件、数据库和用户</strong>4部分组成。<ul><li>硬件、软件—计算机系统</li><li>用户(包括管理、开发和终端用户)—数据库管理系统<ul><li><strong>数据库管理员(DBA)</strong>：负责整个数据库系统的建设、管理、维护和协调工作。主要职责：<ol><li>参与数据库系统的设计于建设</li><li>对系统的运行实行监控</li><li>定义数据的安全性要求和完整性约束条件</li><li>负责数据库性能的改进和数据库的重组及重构工作</li></ol></li></ul></li></ul></li></ul><h3 id="数据库应用系统"><a class="markdownIt-Anchor" href="#数据库应用系统"></a> 数据库应用系统</h3><p>​<strong>数据库应用系统(DBAS)</strong>：指数据库系统及应用程序的组成。</p><h2 id="数据库系统的产生与发展"><a class="markdownIt-Anchor" href="#数据库系统的产生与发展"></a> 数据库系统的产生与发展</h2><h3 id="区分概念"><a class="markdownIt-Anchor" href="#区分概念"></a> 区分概念</h3><p>​<strong>数据管理</strong>：数据处理中心环节</p><h3 id="数据管理技术的产生与发展"><a class="markdownIt-Anchor" href="#数据管理技术的产生与发展"></a> 数据管理技术的产生与发展</h3><h4 id="人工管理阶段"><a class="markdownIt-Anchor" href="#人工管理阶段"></a> 人工管理阶段</h4><ul><li>程序和数据密不可分</li><li>数据不能共享</li><li>数据不具有独立性(<code>缺乏数据独立性</code>)</li></ul><h4 id="文件系统阶段"><a class="markdownIt-Anchor" href="#文件系统阶段"></a> 文件系统阶段</h4><ul><li>优点：<ul><li>程序与数据可以分别独立存放，数据可以组成数据文件，并且可以独立命名</li></ul></li><li>问题：<ul><li>数据冗余度大、共享性差、易产生数据不一致性</li><li>数据独立性差</li><li>用户负担重</li><li><code>数据无结构</code></li></ul></li></ul><h4 id="数据库系统阶段"><a class="markdownIt-Anchor" href="#数据库系统阶段"></a> 数据库系统阶段</h4><ul><li><code>数据结构化</code>：文件系统与数据库系统的根本区别之一</li><li><code>类别</code>：层次型数据库，网状数据库和关系型数据库</li></ul><h3 id="数据库系统的特点"><a class="markdownIt-Anchor" href="#数据库系统的特点"></a> 数据库系统的特点</h3><ol><li>数据结构化：文件系统与数据库系统的根本区别之一</li><li>数据冗余度小、共享性高、避免了数据的不一致性</li><li>具有较高的数据独立性</li><li>数据由DBMS统一管理和控制</li></ol><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><h3 id="相关解释"><a class="markdownIt-Anchor" href="#相关解释"></a> 相关解释</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>​现有数据库系统均是基于某种数据模型的，<code>数据模型是数据库系统的核心和基础</code></p><h4 id="数据模型的分类"><a class="markdownIt-Anchor" href="#数据模型的分类"></a> 数据模型的分类</h4><ol><li>概念数据模型(概念模型)：是独立于计算机系统的数据模型，完全不涉及信息在计算机中的表示，是<strong>面向数据库用户的现实世界模型</strong>，主要用来描述现实世界的概念化结构。</li><li>逻辑数据模型(数据模型)：<strong>用户所看到的模型</strong>，是具体的DBMS所支持的数据模型，如<strong>层次数据模型，网状数据模型，关系模型和面向对象模型</strong>。</li><li>物理数据模型(物理模型)：对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方式，是<strong>面向计算机系统的</strong>。</li></ol><h4 id="数据模型的组成要素"><a class="markdownIt-Anchor" href="#数据模型的组成要素"></a> 数据模型的组成要素</h4><ol><li>数据结构：支队实体模型和实体间联系的表达和实现。<code>它是数据模型最基本的组成部分，规定了数据模型的静态特性</code>—描述一个模型性质的最重要的方面。</li><li>数据操作：数据操作是指一组用于指定数据结构的任何有效实例执行的操作或推导规则。<code>数据操作规定了数据模型的动态特性</code></li><li>数据完整性约束：数据完整性给出数据及其联系应具有的制约和依赖规则。</li></ol><h3 id="实体联系数据模型"><a class="markdownIt-Anchor" href="#实体联系数据模型"></a> 实体——联系数据模型</h3><ul><li>信息，实体集联系和E-R图</li></ul><h3 id="常用结构数据模型"><a class="markdownIt-Anchor" href="#常用结构数据模型"></a> 常用(结构)数据模型</h3><h4 id="层次模型"><a class="markdownIt-Anchor" href="#层次模型"></a> 层次模型</h4><ul><li>满足条件：有且只有一个节点没有双亲节点(称为根节点)；根节点以外的其他节点有且只有一个双亲节点。</li><li>特点：<ul><li>记录之间得到联系通过指针来实现，常用的物理实现方法由邻接法和链接法。</li><li>由于采用指针实现记录间的联系，所以，<code>层次模型具有查询效率较高的优点</code></li></ul></li><li>缺点：<ul><li>层次数据模型缺乏直接表达现实世界中非层次型结构的复杂联系，如多对多的联系</li><li>层次顺序严格限制</li></ul></li><li>IMS是IBM公司推出的最有影响的一种典型的层次模型数据管理系统</li></ul><h4 id="网状模型"><a class="markdownIt-Anchor" href="#网状模型"></a> 网状模型</h4><ul><li>取消了层次模型的限制，不但允许一个以上的节点无双亲，而且一个节点允许有一个以上的双亲</li><li>比层次数据模型更具<code>普遍性</code>的结构，反映了实体集间普遍存在的更为复杂的联系，<code>层次结构实际上是网状结构的一个特例</code></li></ul><h4 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h4><h5 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释：</h5><ul><li>二维表(数据结构)称为关系，对二维框架的描述称为关系模型</li><li>表中的列称为<strong>属性或者字段</strong>，列中的<strong>值</strong>取自相应的域，<strong>域</strong>是属性所有可能取值的集合</li><li>表中的一行称为一个元组(Tuple)，元组用关键字(Key Word)标识</li></ul><h5 id="关系性质"><a class="markdownIt-Anchor" href="#关系性质"></a> 关系性质：</h5><ul><li>关系中的每一个属性是不可分解的，即所有域都应是原子数据的集合；没有完全相同的行和列，行、列的排列顺序是无关紧要的。</li></ul><h5 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h5><ul><li><p>关系模式是关系中信息内容结构的描述。它包括关系名，属性名，每个属性列的取值集合，数据完整性约束条件以及各属性间固有的数据依赖关系等。</p></li><li><p>关系模式的表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>I</mi><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,I,\sum)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mclose">)</span></span></span></span></span></p><ul><li>R：关系名</li><li>U：组成关系R的全部属性的集合</li><li>DOM：属性列到域的映射，即DOM；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">U \rightarrow D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，且每个属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所有可能的取值集合构成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i(i = 1,2,\ldots ,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，并允许<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msub><mi>D</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">D_i = D_j,i\neq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></li><li>I：一组完整性约束条件</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>：属性集间的一组数据依赖</li><li>通常，在不涉及完整性约束及数据依赖的情况下，为了简化，可用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>表示关系模式，例如，学生关系模式可以表示为：S(学号，姓名，性别，年龄，学院)</li></ul></li></ul><h5 id="数据约束"><a class="markdownIt-Anchor" href="#数据约束"></a> 数据约束</h5><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li><p>什么是数据独立性？ 数据库的体系结构如何保证数据独立性？</p><ul><li>数据独立性是指数据库中数据与应用程序的无关性，也指应用程序和数据结构之间相互独立，不受影响。在三层模式体系结构中数据独立性可定义为：数据库系统在某一层次模式上的改变不会使它的上一层模式也发生改变的能力。其包括数据逻辑独立性和数据物理独立性。其中逻辑独立性是指数据的全局逻辑结构与局部逻辑结构之间的相互独立性，表示一旦模式发生变化，无须改变外模式或应用程序的能力；物理独立性是指数据的存储结构与全局逻辑结构之间的相互独立性，表示不会因为内模式发生改变而导致概念模式发生改变的能力。</li><li>数据独立性是由DBMS在三级模式间提供的两层映像来保证的。两层映像分为外模式/模式映像和模式/内模式映像，实现了三个抽象级别的来实现和转换.当整个系统需要改变模式时，DBMS对于外模式/模式映像做出相应的改变，保证了数据逻辑独立性，而数据的存储结构发生改变时，DBMS对于模式/内模式映像做出相应改变，从而保证了物理独立性</li></ul></li><li><p>什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级结构的优点是什么？</p><ul><li>外部模式又称为子模式，介于模式与应用之间，是用户与数据库之间的接口，是数据库用户能够看见和使用的局部数据和特征的描述。</li><li>概念模式简称模式，是由数据库设计者综合所有用户数据，按照统一的观点构造的对数据库全局逻辑结构的描述。</li><li>内部模式称为存储模式，是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</li><li>一个数据库结构从逻辑上可以划分为三个层次：外部模式，概念模式，内部模式，称为数据库的三级模式结构。</li><li>数据库系统的三级模式是对数据进行三个级别的抽象。它把数据的具体组织留给DBMS去做，用户只要抽象地处理数据，而不必关心数据在机器中地具体表示方式和存储方式。数据库的三级结构是依靠映像来联系和相互转化的，正是这两层映像保证了数据库系统中数据具有较高的数据独立性。</li></ul></li></ol><h1 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库"></a> 关系数据库</h1><h2 id="考试要点-2"><a class="markdownIt-Anchor" href="#考试要点-2"></a> 考试要点</h2><ul><li>关系的定义、码的概念、关系的性质</li><li>关系操作(查询和更新)</li><li>关系完整性约束(实体完整性、参照完整性、用户自定义完整性)</li><li>关系代数(五种基本代数)</li><li>查询优化</li><li>关系系统分类(表示系统、最小关系系统、关系完备系统、全关系系统)</li></ul><h1 id="关系数据库标准语言sql"><a class="markdownIt-Anchor" href="#关系数据库标准语言sql"></a> 关系数据库标准语言SQL</h1><h2 id="考试要点-3"><a class="markdownIt-Anchor" href="#考试要点-3"></a> 考试要点</h2><ul><li>SQL体系结构</li><li>定义功能、查询功能、数据操作功能、数据控制功能(略)</li><li>数据查询(单表、分组、聚集、排序、自连接、嵌套查询、Exists查询)</li></ul><h1 id="关系规范化理论"><a class="markdownIt-Anchor" href="#关系规范化理论"></a> 关系规范化理论</h1><h2 id="考试要点-4"><a class="markdownIt-Anchor" href="#考试要点-4"></a> 考试要点</h2><ul><li>完全函数依赖、部分函数依赖、传递依赖</li><li>主属性、非主属性、主码、外码、候选码</li><li>范式、函数依赖集闭包、属性集闭包、最小覆盖、码值理论</li><li>无损连接的判定、函数依赖保持的判定</li><li>基于 3NF 的分解算法</li></ul><h2 id="数据依赖的公理系统"><a class="markdownIt-Anchor" href="#数据依赖的公理系统"></a> 数据依赖的公理系统</h2><ul><li><p>函数依赖集的闭包</p></li><li><p>函数依赖的推理规则</p><ul><li>独立推理规则</li><li>其他推理规则</li></ul></li><li><p>属性集闭包与 F 逻辑蕴含的充要条件</p><ul><li><p>属性集闭包 — <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>F 逻辑蕴含的充要条件</strong></p><ul><li>设 F 为属性集 U 上的一组函数依赖关系，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊆</mo><mi>U</mi><mo separator="true">,</mo><mi>X</mi><mo>−</mo><mo>&gt;</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X,Y \subseteq U,X-&gt;Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 能由 F 根据 Armstrong 公理导出的充分必要条件是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">Y \subseteq X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></li><li>将函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mo>&gt;</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X-&gt;Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 是否能由 F 根据 Armstrong 公理导出的问题转化为求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li><p>求属性集闭包算法</p></li><li><p>码值理论 — 利用属性集闭包判断某个已知的属性集是否为关系的候选码</p></li></ul></li><li><p>最小函数依赖集</p><ul><li>定义 与 求解算法</li><li>函数依赖集 F 的最小覆盖可能会有多个，与删减顺序有关</li></ul></li><li><p>关系模式的分解方法</p><ul><li>由问题引入模式分解“等价性”的两个判定准则：“无损连接性”和“函数依赖保持性”</li><li>分解的无损连接性(无损分解)<ul><li>构造二维表</li><li>分解为两个关系的情况</li></ul></li><li>分解的函数依赖保持性<ul><li>分解的函数依赖保持行</li><li>保持依赖的判定算法</li></ul></li><li>关系模式的分解算法<ul><li>满足3NF的函数依赖保持分解算法</li><li>满足3NF的函数依赖保持和无损连接的分解算法</li></ul></li></ul></li></ul><h2 id="题型"><a class="markdownIt-Anchor" href="#题型"></a> 题型</h2><ol><li>范式判断</li><li>求属性集闭包</li><li>码值定理求候选码</li><li>求最小函数依赖集，三步走，右化小(单属性)，消除冗余，左删冗余</li><li>判断模式分解是否无损连接(两种情况)</li><li>判断模式分解是否保持函数依赖，需要在 F 中把左边决定属性的闭包加在分出的 R 中，之后再求并集</li><li>3NF的模式分解算法<ol><li>满足3NF的函数依赖保持，求最小函数依赖集，之后合并</li><li>满足3NF的函数依赖保持和无损连接</li></ol></li><li>分解 BC NF，使用码值定理求候选码</li></ol><h1 id="数据库设计"><a class="markdownIt-Anchor" href="#数据库设计"></a> 数据库设计</h1><h2 id="考试要点-5"><a class="markdownIt-Anchor" href="#考试要点-5"></a> 考试要点</h2><ul><li>数据库设计的步骤</li><li>需求分析(数据流图、数据字典)</li><li>概念结构设计(ER图、消除冲突)</li><li>逻辑结构设计(ER图到逻辑结构的转换、规范化)</li></ul><h1 id="数据库保护"><a class="markdownIt-Anchor" href="#数据库保护"></a> 数据库保护</h1><h2 id="考试要点-6"><a class="markdownIt-Anchor" href="#考试要点-6"></a> 考试要点</h2><ul><li>事务、事务特性</li><li>数据库恢复的概念、数据库故障的种类、故障恢复策略</li><li>并发操作引发的问题、可串行化判定方法(冲突可串行化、前驱图)</li><li>建立可串行化调度方法(封锁技术、三级封锁协议及解决的问题，2PL协议，冲突可串行化定义)</li><li>数据库安全性概念、措施、存取控制SQL语句</li><li>数据库完整性概念、约束的类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高级逆向分析技术</title>
    <link href="/posts/d0607d51.html"/>
    <url>/posts/d0607d51.html</url>
    
    <content type="html"><![CDATA[<h1 id="逆向分析技术"><a class="markdownIt-Anchor" href="#逆向分析技术"></a> 逆向分析技术</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-225740.htm">反调试技术总结</a></p></blockquote><h2 id="tls回调函数"><a class="markdownIt-Anchor" href="#tls回调函数"></a> TLS回调函数</h2><p>​TLS(Thread Local Storage, 线程局部存储)回调函数(Callback Function).</p><p><a href="https://xz.aliyun.com/t/12057">TLS回调函数的学习</a></p><h2 id="teb"><a class="markdownIt-Anchor" href="#teb"></a> TEB</h2><p>​<strong>TEB</strong>：线程环境块，该结构包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体。</p><h3 id="重要成员"><a class="markdownIt-Anchor" href="#重要成员"></a> 重要成员</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202139261.png" alt="image-20230320213950169" /></p><ul><li><code>ProcessEnvironmentBlock</code><ul><li>指向PEB结构体的指针。–PEB是进程环境块，每个进程对应一个PEB结构体。</li></ul></li><li><code>NtTib</code><ul><li>TEB结构体的第一个成员为_NT_TIB结构体(TIB指线程信息块)</li></ul></li></ul><h3 id="teb的访问方法"><a class="markdownIt-Anchor" href="#teb的访问方法"></a> TEB的访问方法</h3><ul><li><code>Ntdll.NtCurrentTeb()</code><ul><li>此API用来返回当前线程的TEB结构体的地址(返回 <code>FS:[18]</code>)</li></ul></li></ul><h4 id="fs段寄存器"><a class="markdownIt-Anchor" href="#fs段寄存器"></a> FS段寄存器</h4><ul><li><p>FS段寄存器用来指示当前线程的TEB结构体----<strong>FS寄存器持有SDT的索引，该索引持有实际TEB地址</strong>。而由于段寄存器实际存储的是SDT的索引，所以它也被称为“段选择符”。</p><blockquote><p>SDT 位于内核内存区域，其地址存储在特殊的寄存器 GDTR (全局描述符表寄存器) 中</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202146251.png" alt="image-20230320214632226" /></p></li><li><p><code>FS:[0x18] = TEB 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202147341.png" alt="image-20230320214758319" /></p></li><li><p><code>FS:[0x30] = PEB 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202148834.png" alt="image-20230320214844817" /></p></li><li><p><code>FS:[0] = SEH 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202149069.png" alt="image-20230320214914053" /></p></li></ul><h2 id="peb"><a class="markdownIt-Anchor" href="#peb"></a> PEB</h2><p>​<strong>PEB</strong>：进程环境块，每个进程对应一个PEB结构体。</p><h3 id="重要成员-2"><a class="markdownIt-Anchor" href="#重要成员-2"></a> 重要成员</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202151881.png" alt="image-20230320215125838" /></p><ul><li><p><code>BeingDebugged</code></p><ul><li><code>Kernel32.dll</code> 中的 <code>IsDebuggerPresent()</code> API通过检测 <code>PEB.BeingDebugged</code> 成员来确定是否正在调试进程(是，返回1；否则，返回0)</li></ul></li><li><p><code>ImageBaseAddress</code></p><ul><li><p><code>PEB.ImageBaseAddress</code> 成员用来表示进程的 ImageBase 。其中 <code>GetModuleHandle()</code> API 用来获取 ImageBase。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HMODULE <span class="hljs-title">GetModuleHandleA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpModuleName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>向 <code>IpModuleName</code> 参数赋值为 NULL，调用 <strong>GetModuleHandle()</strong> 函数将返回进程被加载的 ImageBase。</p></li></ul></li><li><p><code>Ldr</code>(+0xC)</p><ul><li>指向 <code>_PEB_LDR_DATA</code> 结构体的指针。</li></ul></li><li><p><code>ProcessHeap &amp; NtGlobalFlag</code></p><ul><li>应用于反调试技术，若进程处于调试状态，则两个成员就持有特定值。</li></ul></li></ul><h2 id="seh"><a class="markdownIt-Anchor" href="#seh"></a> SEH</h2><p>​<code>SEH</code> 是 Windows 操作系统提供的异常处理机制，在程序源代码中使用 <code>__try、__except、__finall</code> 关键字来具体实现。</p><h3 id="os的异常处理方法"><a class="markdownIt-Anchor" href="#os的异常处理方法"></a> OS的异常处理方法</h3><ul><li><p>进程运行过程中若发生异常，OS会委托进程处理。</p><ul><li><p>若是进程代码中存在具体的异常处理(如 SEH 异常处理器) 代码，则能顺利处理相关异常，程序继续运行</p></li><li><p>否则相关异常无法处理，OS就会启动默认的遗产给处理机制，终止程序的运行</p></li></ul></li></ul><h3 id="调试器运行时的异常处理方法"><a class="markdownIt-Anchor" href="#调试器运行时的异常处理方法"></a> 调试器运行时的异常处理方法</h3><ul><li><p>若<strong>被调试进程</strong>内部发生异常，OS会先把异常抛给**调试进程处理 **(即调试器)。这里如果被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下：</p><ol><li><p>直接修改异常：代码、寄存器、内存</p><p>被调试者发生异常时，调试器会在发生异常的代码处暂停，此时可以通过调试器直接修改有问题的代码、内存、寄存器等，排除异常后，调试器继续运行程序</p></li><li><p>将异常抛给被调试者处理</p><p>如果被调试者内部存在SEH (异常处理函数) 能够处理异常，那么异常通知会发送给调试者，由被调试者自行处理。</p></li><li><p>OS默认的异常处理机制</p><p>如果调试器于被调试者都无法处理(或故意不处理)当前的异常，则OS的默认异常处理机制会处理它，终止被调试进程，同时结束调试。</p></li></ol></li></ul><h3 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202214355.png" alt="image-20230320221405286" /></p><ul><li><p><code>EXCEPTION_ACCESS_VIOLATION (C0000005)</code></p><ul><li><p>试图访问不存在或不具有访问权限的内存区域时，就会发生 EXCEPTION_ACCESS_VIOLATION (非法访问异常)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202215544.png" alt="image-20230320221537507" /></p></li></ul></li><li><p><code>EXCEPTION_BREAKPOINT (80000003)</code></p><ul><li>在运行代码中设置断点后，CPU尝试执行该地址处的指令时，将会发生此类异常。调试器就是利用该异常实现断点功能的</li></ul></li><li><p><code>EXCEPTION_ILLEGAL_INSTRUCTION (C000001D)</code></p><ul><li>CPU遇到无法解析的指令时引发该异常</li></ul></li><li><p><code>EXCEPTION_INT_DIVIDE_BY_ZERO (C0000094)</code></p><ul><li>INTEGER 触发运算中，若是分母为0，则引发此异常</li></ul></li><li><p><code>EXCEPTION_SINGLE_STEP (80000004)</code></p><ul><li>Single Step(单步) 的含义时执行1条指令，然后暂停。CPU进入单步模式后，每执行一条指令就会引发此异常，暂停运行。将 EFLAGS 寄存器的 TF(Trap Flag, 陷阱标志) 位设置为1后，CPU就会进入单步工作模式</li></ul></li></ul><p><a href="https://www.yunzh1jun.com/2022/05/27/WindowsSEH/">学习博客</a></p><h1 id="反调试技术"><a class="markdownIt-Anchor" href="#反调试技术"></a> 反调试技术</h1><h2 id="静态反调试技术"><a class="markdownIt-Anchor" href="#静态反调试技术"></a> 静态反调试技术</h2><h3 id="peb-2"><a class="markdownIt-Anchor" href="#peb-2"></a> PEB</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202235513.png" alt="image-20230320223555485" /></p><blockquote><p>获取PEB地址的方法</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202238312.png" alt="image-20230320223800272" /></p><blockquote><p>下方(+0x)的基址为 FS:[0x30]</p></blockquote><h4 id="beingdebugged0x2"><a class="markdownIt-Anchor" href="#beingdebugged0x2"></a> BeingDebugged(+0x2)</h4><ul><li><p>进程处于调试状态时，<code>PEB.BeingDebugged</code> 成员(+0x2)的值被设置为1(TRUE)；进程非调试状态下运行时，其值被设置为0(FALSE)</p><ul><li><code>Kernel32.dll</code> 中的 <code>IsDebuggerPresent()</code> API通过获取 <code>PEB.BeingDebugged</code> 的值来判断进程是否处于被调试状态</li></ul></li><li><p>破解之法：</p><ul><li>借助 DBG 将 <code>PEB.BeingDebugged</code> 的值修改为0即可</li></ul></li></ul><h4 id="ldr0xc"><a class="markdownIt-Anchor" href="#ldr0xc"></a> Ldr(+0xC)</h4><ul><li>调试进程时，其堆内存区域中就会出现一些特殊标识，表示它正处于被调试状态。其中最醒目的是，未使用的堆内存区域全部填充着 <code>0xFEEEFEEE</code> ，这证明正在调试进程。利用这一特征即壳判断进程是否处于被调试状态。</li><li><code>PEB.Ldr</code> 成员是一个指向 <code>_PEB_LDR_DATA</code> 结构体的指针，而 <code>_PEB_LDR_DATA</code> 结构体恰好是在堆内存区域创建的，所以可以使用 <code>PEB.Ldr</code> 指向堆内存地址，查看其是否填充了 <code>0xFEEEFEEE</code>。</li><li>破解之法：<ul><li>将填充着 <code>0xFEEEFEEE</code> 的区域全部覆写为NULL即可。</li></ul></li></ul><blockquote><p>该方法仅适用于 windows XP x系统，之后的系统无法使用。另外，利用附加功能将运行中的进程附加到调试器时，堆内存中并不出现上述标志。</p></blockquote><h4 id="processheap0x18"><a class="markdownIt-Anchor" href="#processheap0x18"></a> ProcessHeap(+0x18)</h4><ul><li><p><code>PEB.ProcessHeap</code> 成员是指向 <code>HEAP</code> 结构体的指针</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291506608.png" alt="image-20230329150650538" /></p></li><li><p>进程正常运行(非调试运行)时，<code>Heap.Flags(+0xC)</code>的值为<code>0x2</code>，<code>Heap.ForceFlags(+0x10)</code>的值为<code>0x0</code>。进程处于被调试状态时，这些值会随之改变</p></li><li><p>破解之法：</p><ul><li>重新设置为特定值即可</li></ul></li></ul><blockquote><p>只适用于Windows XP系统。此外，将运行中的进程附加到调试器时，也不会出现上述特征</p></blockquote><h4 id="ntglobalflag0x68"><a class="markdownIt-Anchor" href="#ntglobalflag0x68"></a> NtGlobalFlag(+0x68)</h4><ul><li><p>调试进程时，<code>PEB.NtGlobalFlag(+0x68)</code> 的值会被设置为<code>0x70</code></p></li><li><p>其被设置为<code>0x70</code>是下列 Flags值进行 <code>bit OR</code> 运算的结果</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291518918.png" alt="image-20230329151804891" /></p></li><li><p>破解之法：</p><ul><li>重设 <code>PEB.NtGlobalFlag</code> 值为0即可 (PEB.NtGlobalFlag = 0)</li></ul></li></ul><blockquote><p>将运行中的进程附加到调试器时，NtGlobalFlag的值不变</p></blockquote><h3 id="ntqueryinformationprocess"><a class="markdownIt-Anchor" href="#ntqueryinformationprocess"></a> NtQueryInformationProcess()</h3><p>​通过 <code>NtQueryInformationProcess() API</code> 可以获取各种与进程调试相关的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// NtQueryInformationProcess 函数原型</span><br><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQueryInformationProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  IN HANDLE           ProcessHandle, <span class="hljs-comment">// 进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  IN PROCESSINFOCLASS ProcessInformationClass,  <span class="hljs-comment">// 检索的进程信息类型</span></span></span><br><span class="hljs-params"><span class="hljs-function">  OUT PVOID           ProcessInformation, <span class="hljs-comment">// 接收进程信息的缓冲区指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">  IN ULONG            ProcessInformationLength,  <span class="hljs-comment">// 缓冲区指针大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  OUT PULONG          ReturnLength<span class="hljs-comment">// 实际接收的进程信息大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​给 <code>NtQueryInformationProcess()</code> 函数的第二个参数 <code>PROCESSINFOCLASS ProcessInformationClass</code> 指定特定的值并调用该函数，则相关信息会设置到其第三个参数 <code>PVOID ProcessInformation</code>。这里关注 <code>PROCESSINFOCALSS</code> 中与调试器探测有关的成员 <code>ProcessDebugPort(0x7)</code>，<code>ProcessDebugObjectHandle(0x1E)</code>， <code>ProcessDebugFlags(0x1F)</code>。(括号中的值代表第二个参数的取值，对应着名称)</p><h4 id="processdebugport0x7"><a class="markdownIt-Anchor" href="#processdebugport0x7"></a> ProcessDebugPort(0x7)</h4><p>​进程处于调试状态时，系统会为它分配一个调试端口(Debug Port)。 <code>ProcessInformationClass</code> 参数的值设置为 <code>ProcessDebugPort(0x7)</code> 时，调用 <code>NtQueryInformationProcess()</code> 函数就能获取调试段口。若进程处于非调试状态，则变量 <code>dwDebugPort</code> 的值设置为0；若进程处于调试状态，则变量 <code>dwDebugPort</code> 的值设置为 0xFFFFFFFF</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311752206.png" alt="image-20230331175210132" /></p><h4 id="processdebugobjecthandle0x1e"><a class="markdownIt-Anchor" href="#processdebugobjecthandle0x1e"></a> ProcessDebugObjectHandle(0x1E)</h4><p>​调试进程时会生成调试对象(<code>Debug Object</code>)。函数的第二个参数值为 <code>ProcessDebugObjectHandle(0x1E)</code> 时，调用函数后通过第三个参数就能获得调试对象的句柄。进程处于调试状态时，调试对象句柄的值就存在；若进程处于非调试状态，则调试对象句柄值为NULL。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311755135.png" alt="image-20230331175507061" /></p><h4 id="processdebugflags0x1f"><a class="markdownIt-Anchor" href="#processdebugflags0x1f"></a> ProcessDebugFlags(0x1F)</h4><p>​检测 <code>Debug Flags(调试标志)</code> 的值也可以判断进程是否处于被调试状态。函数的第二个参数设置为 <code>ProcessDebugFlags(0x1F)</code> 时，调用函数后通过第三个参数即可获取调试标志的值：若为0，则进程处于被调试状态；若为1，则进程处于非调试状态。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311757040.png" alt="image-20230331175707977" /></p><h4 id="破解之法"><a class="markdownIt-Anchor" href="#破解之法"></a> 破解之法</h4><p>​破解使用 <code>NtQueryInformationProcess() API</code> 探测调试器的技术，应当对该函数在特定参数值(<code>ProcessInformationClass</code>) 下输出的值进行操作。特定参数值时前面提过的三个。即将与三个相关的检测返回值(<code>dwDebugPort, DebugObject, DebugFlag</code>)进行更改。</p><h3 id="ntquerysysteminformation"><a class="markdownIt-Anchor" href="#ntquerysysteminformation"></a> NtQuerySystemInformation()</h3><p>​这是基于调试环境检测的反调试技术。运用这种反调试技术可以检测当前OS是否在调试模式下运行。(主要使用windbg调试target主机，查看其OS信息)。这里主要使用 <code>ntdall!NtQuerySystemInformation() API</code> 的系统函数，获取当前运行的多重OS信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQuerySystemInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out]       PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​<code>SYSTEM_INFORMATION_CALSS SystemInformationClass</code> 参数中指定需要的系统信息类型，将某结构体的地址传递给 <code>PVOID SystemInformation</code> 参数，API返回时，该结构体中就填充着相关信息。</p><p>​向 <code>SystemInformation</code> 参数传入 <code>SystemKernelDebuggerInformation</code> 值(0x23)，即可判断出当前OS是否在调试模式下运行</p><h3 id="ntqueryobject"><a class="markdownIt-Anchor" href="#ntqueryobject"></a> NtQueryObject()</h3><p>​系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象。检测该对象是否存在即可判断是否有进程正在呗调试。</p><p>​<code>ntdll!NtQueryObject() API</code> 用来获取系统各种内核对象的信息。调用 <code>NtQueryObject()</code> 函数时，先向第二个参数 <code>OBJECT_INFORMATION_CALSS ObjectInformationClass</code> 赋予某个特定值，调用API后，包含相关信息的结构体指针就返回第三个参数 <code>PVOID ObjectInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">__kernel_entry NTSYSCALLAPI NTSTATUS <span class="hljs-title">NtQueryObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional]  HANDLE                   Handle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PVOID                    ObjectInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG                    ObjectInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="zwsetinformationthread"><a class="markdownIt-Anchor" href="#zwsetinformationthread"></a> ZwSetInformationThread()</h3><p>​利用 <code>ZwSetInformationThread() API</code> 被调试者可将自身从调试器中分离出来—强制分离(Detach)被调试者和调试器的技术</p><p><img src="C:/Users/NU/AppData/Roaming/Typora/typora-user-images/image-20230331185309453.png" alt="image-20230331185309453" /></p><p>​<code>ZwSetInformationTread()</code> 函数用来为线程设置信息的。该函数拥有2个参数，第一个参数 <code>TreadHandle</code> 用来接受当前线程的句柄，第二个参数 <code>ThreadInformationClass</code> 表示线程信息类型，若其值设置为 <code>ThreadHideFromDebugger(0x11)</code>，调用该函数后，调试进程就会被分离出来。<code>ZwSetInformationThread() API</code> 不会对正常运行的程序(非调试运行)产生任何影响，但若运行的时调试器程序，调用该API将使调试器终止运行，同时终止自身进程。</p><h4 id="破解之法-2"><a class="markdownIt-Anchor" href="#破解之法-2"></a> 破解之法</h4><p>​调用API之前，查找存储在栈中的第二个参数 <code>ThreadInformationClass</code> 值，若其值为 <code>ThreadHideFromDebugger(0x11)</code> ，则修改为0后继续运行即可。</p><blockquote><p>Windows XP 以后新增了 DebugActiveProcessStop() API</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">DebugActiveProcessStop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD dwProcessId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​<code>DebugActiveProcessStop() API</code> 用来分离调试器和被调试器，从而停止调试。而 <code>ZwSetInformationTread() API</code> 则用来隐藏当前线程，使调试器无法再受到该线程的调试事件，最终停止调试。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PE文件解析</title>
    <link href="/posts/d7f95dad.html"/>
    <url>/posts/d7f95dad.html</url>
    
    <content type="html"><![CDATA[<h1 id="汇总"><a class="markdownIt-Anchor" href="#汇总"></a> 汇总</h1><ul><li>分析PE格式工具----<a href="https://blog.csdn.net/u013908944/article/details/103356615">PETool</a></li><li><strong>引用</strong><ul><li><a href="https://blog.csdn.net/freeking101/article/details/102752048">PE文件结构详解</a></li><li><a href="https://blog.csdn.net/weixin_43655282/article/details/104291312">PE文件结构详解精华</a></li></ul></li></ul><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="pe文件"><a class="markdownIt-Anchor" href="#pe文件"></a> PE文件</h2><ul><li><p>PE (Portable Execute) 文件是Windows下可执行文件的总称，常见的有 <strong>DLL，EXE，OCX，SYS</strong> 等。它是微软在 UNIX 平台的 COFF (通用对象文件格式) 基础上制作而成。<strong>最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下</strong>。<strong>PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式（请注意不是PE64)</strong></p></li><li><p>早期磁盘空间不足，PE磁盘文件与内存映像结构不同，磁盘每200h为一节，内存则是1000h为一节。后来随之发展，二者相一致</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291126138.png" alt="202301121246317" /></p></li><li><p>PE文件的结构一般来说如下图所示：从起始位置开始依次是 <strong>DOS头</strong>，<strong>NT头</strong>，<strong>节表</strong> 以及<strong>具体的节</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291127620.png" alt="202302250820743" /></p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291127571.png" alt="202301121155957" /></p><h2 id="pe文件执行顺序"><a class="markdownIt-Anchor" href="#pe文件执行顺序"></a> PE文件执行顺序</h2><ol><li>当一个 PE 文件被执行时，<strong>PE 装载器</strong>首先检查 DOS header 里的 PE header 的偏移量。如果找到，则直接跳转到 PE header 的位置。</li><li>当<strong>PE 装载器</strong>跳转到 PE header 后，第二步要做的就是检查 PE header 是否有效。如果该 PE header 有效，就跳转到 PE header 的尾部。</li><li>紧跟 PE header 尾部的是节表。PE装载器 执行完第二步后开始读取节表中的节段信息，并采用文件映射的方法将这些节段映射到内存，<strong>同时附上节表里指定节段的读写属性</strong>。<ul><li><strong>文件映射</strong>----在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射的机制，也就是说，<strong>Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系，只有真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存</strong>，这种机制使文件装入的速度和文件大小没有太大的关系</li></ul></li><li>PE文件映射入内存后，PE装载器 将继续处理PE文件中类似 import table （输入表）的逻辑部分。</li></ol><h2 id="pe文件结构"><a class="markdownIt-Anchor" href="#pe文件结构"></a> PE文件结构</h2><ol><li><strong>DOS头</strong> 是用来兼容 MS-DOS 操作系统的，目的是当这个文件在 MS-DOS 上运行时提示一段文字，大部分情况下是：This program cannot be run in DOS mode. 同时指明 NT 头在文件中的位置。</li><li><strong>NT头</strong> 包含 windows PE 文件的主要信息，其中包括一个 <strong>‘PE’ 字样的签名</strong>，**PE文件头（IMAGE_FILE_HEADER）**和 <strong>PE可选头（IMAGE_OPTIONAL_HEADER32）。</strong></li><li><strong>节表</strong>：是 PE 文件后续节的描述，windows 根据节表的描述加载每个节。</li><li><strong>节</strong>：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个。</li></ol><h2 id="varva"><a class="markdownIt-Anchor" href="#varva"></a> VA&amp;RVA</h2><p>​VA指的是进程虚拟内存的<strong>绝对地址</strong>，RVA指从某个基准位置开始的<strong>相对地址</strong>。VA与RVA满足：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>V</mi><mi>A</mi><mo>+</mo><mi>I</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>=</mo><mi>V</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">RVA + ImageBase = VA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span></span></span></span></span></p><p>​PE头内部大多以RVA形式存在。32位Windows OS中，各进程分配有 4GB 的虚拟内存，因此进程中VA值的范围是0000 0000 ~ FFFF FFFF。</p><h1 id="pe头"><a class="markdownIt-Anchor" href="#pe头"></a> PE头</h1><p>win采用小端序存储，查看十六进制时需要从右往左</p><ul><li><p>32位PE头大小</p><ul><li><p>DOS—40h</p></li><li><p>NT—4h + 14h(FILE) + E0h(Optional)</p></li></ul></li></ul><h2 id="dos头"><a class="markdownIt-Anchor" href="#dos头"></a> DOS头</h2><h3 id="image_dos_header"><a class="markdownIt-Anchor" href="#image_dos_header"></a> IMAGE_DOS_HEADER</h3><p>​所有的PE文件都是以一个<strong>64(40h)字节</strong>(一个字节8位)的<strong>DOS头</strong>(MZ文件头)开始。这个DOS头只是为了兼容早期的DOS操作系统。该结构体中需要掌握的字段只有2个，分别是第一个字段 <code>e_magic</code> 和最后一个字段 <code>e_lfanew</code> 字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DOS_HEADER</span> &#123;</span>　<span class="hljs-comment">// DOS .EXE header</span><br>WORD　e_magic;　　　　<span class="hljs-comment">// Magic number</span><br>WORD　e_cblp;　　　　 <span class="hljs-comment">// Bytes on last page of file</span><br>WORD　e_cp;　　　　　 <span class="hljs-comment">// Pages in file</span><br>WORD　e_crlc;　　　　 <span class="hljs-comment">// Relocations</span><br>WORD　e_cparhdr;　　　<span class="hljs-comment">// Size of header in paragraphs</span><br>WORD　e_minalloc;　　 <span class="hljs-comment">// Minimum extra paragraphs needed</span><br>WORD　e_maxalloc;　　 <span class="hljs-comment">// Maximum extra paragraphs needed</span><br>WORD　e_ss;　　　　　　<span class="hljs-comment">// Initial (relative) SS value</span><br>WORD　e_sp;　　　　　　<span class="hljs-comment">// Initial SP value</span><br>WORD　e_csum;　　　　　<span class="hljs-comment">// ChecksumWORD e_ip;Initial IP valueWORD　e_cs;Initial (relative) CS value</span><br>WORD　e_lfarlc;　　　　<span class="hljs-comment">// File address of relocation table</span><br>WORD　e_ovno;　　　　　<span class="hljs-comment">// Overlay number</span><br>WORD　e_res[<span class="hljs-number">4</span>];　　　　<span class="hljs-comment">// Reserved words</span><br>WORD　e_oemid;　　　　 <span class="hljs-comment">// OEM identifier (for e_oeminfo)</span><br>WORD　e_oeminfo;　　　 <span class="hljs-comment">// OEM information; e_oemid specific</span><br>WORD　e_res2[<span class="hljs-number">10</span>];　　　<span class="hljs-comment">// Reserved words</span><br>LONG　e_lfanew;　　　　<span class="hljs-comment">// File address of new exe header</span><br>&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>e_magic</code> 字段</p><p>DOS 可执行文件的标识符(DOS签名)，占用2字节。该位置保存着的字符是“MZ”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DOS_SIGNATURE　　　　<span class="hljs-comment">//0x5A4D　MZ</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>e_lfanew</code> 字段：<br />只是NT头的偏移----PE头相对于文件的偏移，定位PE文件</p></li><li><p>作用：</p><ul><li><strong>定位PE文件头开始位置</strong>，也可用于<strong>PE文件合法性检测</strong></li></ul></li></ul><h3 id="dos存根"><a class="markdownIt-Anchor" href="#dos存根"></a> DOS存根</h3><p>​DOS存根(stub)在DOS头下方，是个可选项，且大小不固定(即使没有DOS存根，文件也能正常运行)。</p><h2 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h2><h3 id="image_nt_headers"><a class="markdownIt-Anchor" href="#image_nt_headers"></a> IMAGE_NT_HEADERS</h3><p>​<strong>NT头：PE标识</strong>结构体的大小为<strong>F8h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span> <br>        DWORD Signature;                         <br>      <span class="hljs-comment">//该结构体中的Signature就是PE标识符,标识该文件是否是PE文件。4字节，即 50 45 0000 -&gt; 00 00 45 50 -&gt; PE</span><br>        IMAGE_FILE_HEADER FileHeader;             <br>      <span class="hljs-comment">// IMAGE_FILE_HEADER是PE文件头</span><br>        IMAGE_OPTIONAL_HEADER32 OptionalHeader;   <span class="hljs-comment">// </span><br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;  <br></code></pre></td></tr></table></figure><ul><li><p><code>Signature(签名)</code>字段</p><ul><li>类似于 DOS头中的 e_magic，其高16位是0，低16是0x4550，用字符表示是 “PE”。</li></ul></li><li><p><code>File Header</code></p><ul><li>文件头结构体</li></ul></li><li><p><code>Optional Header</code></p><ul><li>可选头结构体</li></ul></li><li><p>为简单分析，此时PE头(file与optional)只看32位，64位的暂且不看</p></li></ul><h3 id="image_file_header"><a class="markdownIt-Anchor" href="#image_file_header"></a> IMAGE_FILE_HEADER</h3><p>​<strong>NT头：文件头</strong>，共<strong>14h</strong>个字节，其中需要掌握的字段有5个(注意NT头有个4字节的Signature)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_FILE_HEADER</span> &#123;</span> <br>        WORD    Machine;              <br>        <span class="hljs-comment">// 每个CPU拥有唯一的Machine码 -&gt; 4C 01 -&gt; PE -&gt; 兼容32位Intel X86芯片</span><br><br>        WORD    NumberOfSections;     <br>        <span class="hljs-comment">// 指文件中存在的节段(又称节区)数量，也就是节表中的项数 -&gt; 00 04 -&gt; 4</span><br>        <span class="hljs-comment">// 该值一定要大于0，且当定义的节段数与实际不符时，将发生运行错误。</span><br><br>        DWORD   TimeDateStamp;         <br>        <span class="hljs-comment">// PE文件的创建时间，一般有连接器填写 -&gt; 38 D1 29 1E</span><br>    <br>        DWORD   PointerToSymbolTable;<br>        <span class="hljs-comment">// COFF文件符号表在文件中的偏移 -&gt; 00 00 00 00</span><br>        DWORD   NumberOfSymbols;       <br>        <span class="hljs-comment">// 符号表的数量 -&gt; 00 00 00 00</span><br><br>        WORD    SizeOfOptionalHeader; <br>        <span class="hljs-comment">// 指出IMAGE_OPTIONAL_HEADER32结构体的长度。-&gt;  00 E0 -&gt; 224字节</span><br>        <span class="hljs-comment">// PE32+ 格式文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，</span><br>        <span class="hljs-comment">// 这两个结构体尺寸是不相同的，所以需要在SizeOfOptionalHeader中指明大小。</span><br><br>        WORD    Characteristics;      <br>        <span class="hljs-comment">// 标识文件的属性，二进制中每一位代表不同属性 -&gt; 0F 01</span><br>    <br>&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br></code></pre></td></tr></table></figure><ul><li><p><code>Machine</code>字段</p><ul><li>指明程序能够运行的CPU型号(运行平台)：</li><li><strong>0x0000</strong> 任何处理器; <strong>0x0014C</strong> x86及后续处理器</li></ul></li><li><p><code>NumberOfSections</code>字段</p><ul><li>文件中存在的节区的总数，如果要新增节或者合并节，就要修改这个值</li></ul></li><li><p><strong>TimeDateStamp</strong>字段</p><ul><li>时间戳：文件的创建时间(和操作系统的创建时间无关)，编译器填写的</li></ul></li><li><p><code>SizeOfOptionalHeader</code>字段</p><ul><li>指出可选PE头(IMAGE_OPTIONAL_HEADER)的大小，32位PE文件默认<strong>E0h</strong>，64位PE文件默认为<strong>F0h</strong>，大小可以自定义</li></ul></li><li><p><code>Characteristics</code>字段</p><ul><li>文件属性，每个位(十六进制转化为二进制)有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020940369.png" alt="202301121638095" /></p><h3 id="image_optional_header"><a class="markdownIt-Anchor" href="#image_optional_header"></a> IMAGE_OPTIONAL_HEADER</h3><p>​<strong>NT头：可选头</strong>，32位下大小为<strong>E0h</strong>个字节，64位下大小为<strong>F0h</strong>个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> &#123;</span> <br>        WORD    Magic;                     <br>        <span class="hljs-comment">// 魔数 32位为0x10B，64位为0x20B，ROM镜像为0x107&#x27;</span><br>        BYTE    MajorLinkerVersion;         <br>        <span class="hljs-comment">// 链接器的主版本号 -&gt; 05</span><br>        BYTE    MinorLinkerVersion;         <br>        <span class="hljs-comment">// 链接器的次版本号 -&gt; 0C</span><br>        DWORD   SizeOfCode;                 <br>        <span class="hljs-comment">// 代码节大小，一般放在“.text”节里，必须是FileAlignment的整数倍 -&gt; 40 00 04 00</span><br>        DWORD   SizeOfInitializedData;      <br>        <span class="hljs-comment">// 已初始化数大小，一般放在“.data”节里，必须是FileAlignment的整数倍 -&gt; 40 00 0A 00</span><br>        DWORD   SizeOfUninitializedData;    <br>        <span class="hljs-comment">// 未初始化数大小，一般放在“.bss”节里，必须是FileAlignment的整数倍 -&gt; 00 00 00 00</span><br>        DWORD   AddressOfEntryPoint;       <br>        <span class="hljs-comment">// 指出程序最先执行的代码起始地址(RVA) -&gt; 00 00 10 00&#x27;</span><br>        DWORD   BaseOfCode;                 <br>        <span class="hljs-comment">// 代码基址，当镜像被加载进内存时代码节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 10 00</span><br> <br>        DWORD   BaseOfData;                 <br>        <span class="hljs-comment">// 数据基址，当镜像被加载进内存时数据节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 20 00</span><br>        <span class="hljs-comment">// 在64位文件中此处被并入紧随其后的ImageBase中。</span><br> <br>        DWORD   ImageBase;                 <br>        <span class="hljs-comment">// 当加载进内存时，镜像的第1个字节的首选地址。</span><br>        <span class="hljs-comment">// WindowEXE默认ImageBase值为00400000，DLL文件的ImageBase值为10000000，也可以指定其他值。</span><br>        <span class="hljs-comment">// 执行PE文件时，PE装载器先创建进程，再将文件载入内存，</span><br>        <span class="hljs-comment">// 然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint&#x27;</span><br>        <span class="hljs-comment">// PE文件的Body部分被划分成若干节段，这些节段储存着不同类别的数据。</span><br>        DWORD   SectionAlignment;          <br>        <span class="hljs-comment">// SectionAlignment指定了节段在内存中的最小单位， -&gt; 00 00 10 00&#x27;</span><br>        DWORD   FileAlignment;             <br>        <span class="hljs-comment">// FileAlignment指定了节段在磁盘文件中的最小单位，-&gt; 00 00 02 00</span><br>        <span class="hljs-comment">// SectionAlignment必须大于或者等于FileAlignment&#x27;</span><br> <br>        WORD    MajorOperatingSystemVersion;<span class="hljs-comment">// 主系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorOperatingSystemVersion;<span class="hljs-comment">// 主系统的次版本号 -&gt; 00 00</span><br>        WORD    MajorImageVersion;          <span class="hljs-comment">// 镜像的主版本号 -&gt; 00 00</span><br>        WORD    MinorImageVersion;          <span class="hljs-comment">// 镜像的次版本号 -&gt; 00 00</span><br>        WORD    MajorSubsystemVersion;      <span class="hljs-comment">// 子系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorSubsystemVersion;      <span class="hljs-comment">// 子系统的次版本号 -&gt; 00 00</span><br>        DWORD   Win32VersionValue;          <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br> <br>        DWORD   SizeOfImage;               <br>        <span class="hljs-comment">// 当镜像被加载进内存时的大小，包括所有的文件头。向上舍入为SectionAlignment的倍数。</span><br>        <span class="hljs-comment">// 一般文件大小与加载到内存中的大小是不同的。 -&gt; 00 00 50 00&#x27;</span><br> <br>        DWORD   SizeOfHeaders;             <br>        <span class="hljs-comment">// 所有头的总大小，向上舍入为FileAlignment的倍数。                                     </span><br>        <span class="hljs-comment">// 可以以此值作为PE文件第一节的文件偏移量。-&gt; 00 00 04 00&#x27;</span><br> <br>        DWORD   CheckSum;                   <span class="hljs-comment">// 镜像文件的校验和 -&gt; 00 00 B4 99</span><br> <br>        WORD    Subsystem;                 <br>        <span class="hljs-comment">// 运行此镜像所需的子系统 -&gt; 00 02 -&gt; 窗口应用程序</span><br>        <span class="hljs-comment">// 用来区分系统驱动文件（*.sys)与普通可执行文件（*.exe，*.dll），</span><br><br> <br>        WORD    DllCharacteristics;         <span class="hljs-comment">// DLL标识 -&gt; 00 00</span><br>        DWORD   SizeOfStackReserve;         <span class="hljs-comment">// 最大栈大小。CPU的堆栈。默认是1MB。-&gt; 00 10 00 00</span><br>        DWORD   SizeOfStackCommit;          <span class="hljs-comment">// 初始提交的堆栈大小。默认是4KB -&gt; 00 00 10 00</span><br>        DWORD   SizeOfHeapReserve;          <span class="hljs-comment">// 最大堆大小。编译器分配的。默认是1MB -&gt;00 10 00 00</span><br>        DWORD   SizeOfHeapCommit;           <span class="hljs-comment">// 初始提交的局部堆空间大小。默认是4K -&gt;00 00 10 00</span><br>        DWORD   LoaderFlags;                <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br> <br>        DWORD   NumberOfRvaAndSizes;       <br>        <span class="hljs-comment">// 指定DataDirectory的数组个数，由于以前发行的Windows NT的原因，它只能为16。 -&gt; 00 00 00 10&#x27;</span><br>        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <br>        <span class="hljs-comment">// 数据目录数组。详见下文。</span><br>    <br>&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span>  <br>    DWORD   VirtualAddress;  <br>    DWORD   Size;  <br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>Magic</code>字段<ul><li>说明文件类型：</li><li>32位下的PE文件–<strong>10B</strong>， 64位下的PE文件–<strong>20B</strong></li></ul></li><li><strong>SizeOfCode</strong>字段<ul><li>所有代码节的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><strong>SizeOfInitializedData</strong>字段<ul><li>已初始化数据大小的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><strong>SizeOfUninitializedData</strong>字段<ul><li>未初始化数据大小的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><code>AddressOfEntryPoint</code>字段<ul><li>程序入口—AddressOfEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址。</li></ul></li><li><strong>BaseOfCode</strong>字段<ul><li>代码开始的基址，编译器填的</li></ul></li><li><strong>BaseOfData</strong>字段<ul><li>数据开始的基址，编译器填的</li></ul></li><li><code>ImageBase</code>字段<ul><li>内存镜像基址。进程虚拟内存的范围是0000 0000 ~ FFFF FFFF(32位系统)。PE文件被加载到内存中时，ImageBase 指出文件的优先装入地址。</li><li>EXE、DLL文件被装载到用户内存的0000 0000 ~ 7FFF FFFF中，SYS文件被载入内核内存的8000 0000 ~ FFFF FFFF中。一般而言，使用开发攻击(VB/VC++/Dephi)创建好EXE文件后，其执行PR文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为 <strong>ImageBase + AddressOfEntryPoint</strong></li></ul></li><li><code>SectionAlignment</code>字段<ul><li>内存对齐—节区在内存中的最小单位</li></ul></li><li><code>FileAlignment</code>字段<ul><li>文件对齐—节区再磁盘文件中的最小单位</li></ul></li><li><code>SizeOfImage</code>字段<ul><li>内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍</li></ul></li><li><code>SizeOfHeaders</code>字段<ul><li>所有头与节表按照<strong>文件对齐</strong>后的大小，否则加载会出错</li><li>指出整个PE头的大小[ DOS + NT( NT + File + Optional ) ]。该值也是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同</li></ul></li><li><strong>CheckSum</strong>字段<ul><li>校验和，一些系统文件有要求.用来判断文件是否被修改</li></ul></li><li><strong>SizeOfStackReserve</strong>字段<ul><li>初始化时保留的堆栈大小</li></ul></li><li><strong>SizeOfStackCommit</strong>字段<ul><li>初始化时实际提交的大小</li></ul></li><li><strong>SizeOfHeapReserve</strong>字段<ul><li>初始化时保留的堆大小</li></ul></li><li><strong>SizeOfHeapCommit</strong>字段<ul><li>初始化时实践提交的大小</li></ul></li><li><code>NumberOfRvaAndSizes</code>字段<ul><li>目录项数目</li><li>指出Data_Directory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数。</li></ul></li><li><code>Data_Directory</code>字段<ul><li>数据目录表，由NumberOfRvaAndSize个IMAGE_DATA_DIRECTORY结构体组成的数组。该数组包含输入表，输出表，资源，重定位等数据目录项的RVA和大小。</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020950878.png" alt="202302242139607" /></p><h2 id="节区头节表"><a class="markdownIt-Anchor" href="#节区头节表"></a> 节区头(节表)</h2><p><strong>IMAGE_SECTION_HEADER</strong></p><p>​在PE文件头与原始数据之间存在一个区块表（Section Table），它是一个IMAGE_SECTION_HEADER结构数组，<code>区块表包含每个块在映像中的信息</code>（如位置、长度、属性），分别指向不同的区块实体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_SECTION_HEADER</span> &#123;</span><br>    Name<span class="hljs-comment">//8个字节的块名</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        DWORD PhysicalAddress;<br>        DWORD VirtualSize;<br>    &#125; Misc;                     <span class="hljs-comment">//区块尺寸(真实)</span><br>    DWORD VirtualAddress;<span class="hljs-comment">//区块的RVA地址</span><br>    DWORD SizeOfRawData;<span class="hljs-comment">//在文件中对齐后的尺寸</span><br>    DWORD PointerToRawData;<span class="hljs-comment">//在文件中偏移</span><br>    DWORD PointerToRelocations;<span class="hljs-comment">//在OBJ文件中使用，重定位的偏移</span><br>    DWORD PointerToLinenumbers;<span class="hljs-comment">//行号表的偏移（供调试使用地）</span><br>    WORD NumberOfRelocations;<span class="hljs-comment">//在OBJ文件中使用，重定位项数目</span><br>    WORD NumberOfLinenumbers;<span class="hljs-comment">//行号表中行号的数目</span><br>    DWORD Characteristics;<span class="hljs-comment">//区块属性如可读，可写，可执行等</span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br></code></pre></td></tr></table></figure><ul><li><p><code>Name</code></p><ul><li><strong>8个字节</strong> 一般情况下是以&quot;\0&quot;结尾的ASCII吗字符串来标识的名称，内容可以自定义</li></ul></li><li><p><code>Misc</code></p><ul><li><strong>双字</strong> 是该节在没有对齐前的真实尺寸,该值可以不准确</li></ul></li><li><p><code>VirtualSize</code></p><ul><li>内存中节区所占大小</li></ul></li><li><p><code>VirtualAddress</code></p><ul><li>节区在<strong>内存中</strong>的偏移地址(RVA)。加上ImageBase才是在内存中的真正地址。由SectionAlignment确定</li></ul></li><li><p><code>SizeOfRawData</code></p><ul><li>节区在<strong>文件中</strong>对齐后的尺寸—磁盘文件中节区所占大小</li></ul></li><li><p><code>PointerToRawData</code></p><ul><li>节区在<strong>文件中</strong>的偏移—磁盘文件中节区的起始位置。由FileAlignment确定</li></ul></li><li><p><code>Characteristics</code></p><ul><li><p>节区属性(bit OR)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128040.png" alt="202302242144521" /></p></li></ul></li></ul><h1 id="rva-to-raw"><a class="markdownIt-Anchor" href="#rva-to-raw"></a> RVA to RAW</h1><p>​PE文件从磁盘到内存映射—PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射(RVA to RAW).方法如下：</p><ol><li><p>查早RVA所在节区</p></li><li><p>使用简单的公式计算文件偏移(RAW/FOA)</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>A</mi><mi>W</mi><mo stretchy="false">(</mo><mi>F</mi><mi>O</mi><mi>A</mi><mo stretchy="false">)</mo><mo>−</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mi>R</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>V</mi><mi>i</mi><mi>r</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">RAW(FOA) - PointerToRawData = RVA - VirtualAddress</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span></span></span></span></span></p><p>PointerToRawData：<strong>磁盘文件中</strong>节区的起始位置。由FileAlignment确定</p><p>virtualAddress：<strong>内存中</strong>节区起始地址(RVA)</p></li></ol><h1 id="数据目录"><a class="markdownIt-Anchor" href="#数据目录"></a> 数据目录</h1><ul><li><p><strong>引用：</strong></p><ul><li><p><a href="https://blog.csdn.net/qq_35289660/category_9995600.html">PE文件结构_C4cke的博客-CSDN博客</a></p></li><li><p><a href="https://www.anquanke.com/member.html?memberId=156165">深度理解win32</a></p></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128802.png" alt="202302261105566" /></p><h2 id="导出表"><a class="markdownIt-Anchor" href="#导出表"></a> 导出表</h2><p>​**基本概念：**导出表是PE文件为其他应用程序提供自身的一些变量、函数以及类，将其导出给第三方程序使用的一张清单，里面包含了可以导出的元素。位于数据目录项的第一个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：真正导出表的RVA</li><li><code>Size</code>：导出表的大小，在这个地方的结构只是说明了导出表在<strong>内存中</strong>所存在的地址以及导出表的大小，并不是真正的导出表，需要通过RVA去找到导出表真正存在的地址</li></ul><h3 id="image_export_directory"><a class="markdownIt-Anchor" href="#image_export_directory"></a> IMAGE_EXPORT_DIRECTORY</h3><p>真正的导出表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br>    DWORD Characteristics; <span class="hljs-comment">// 未使用</span><br>    DWORD TimeDateStamp; <span class="hljs-comment">// 时间戳</span><br>    WORD MajorVersion; <span class="hljs-comment">// 未使用</span><br>    WORD MinorVersion; <span class="hljs-comment">// 未使用</span><br>    DWORD Name;     <span class="hljs-comment">// 指向该导出表文件名字符串</span><br>    DWORD Base;     <span class="hljs-comment">// 导出函数起始序号</span><br>    DWORD NumberOfFunctions;  <span class="hljs-comment">// 所有导出函数的个数</span><br>    DWORD NumberOfNames;  <span class="hljs-comment">// 以函数名字导出的函数个数</span><br>    DWORD AddressOfFunctions;  <span class="hljs-comment">// 导出函数地址表RVA</span><br>    DWORD AddressOfNames;  <span class="hljs-comment">// 导出函数名称表RVA</span><br>    DWORD AddressOfNameOrdinals;  <span class="hljs-comment">// 导出函数序号表RVA</span><br>&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><p>导出表导出方式为两种，分别是以<strong>名字导出</strong>、以<strong>序号导出</strong>：</p></li><li><p>**AddressOfFunctions、AddressOfNames、AddressOfNameOrdinal **这三个RVA指向的是三个存放了函数具体地址的表，如下图所示</p><ul><li><strong>AddressOfFunctions</strong>存放的地址数量由NumberOfFuntions决定，</li><li><strong>AddressOfNameOrdinals</strong>和<strong>AddressOfNames</strong>存放的地址数量由NumberOfNames来决定</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128759.png" alt="202302261031945" /></p></li></ul><h4 id="addressofnames"><a class="markdownIt-Anchor" href="#addressofnames"></a> AddressOfNames</h4><ul><li>这个表里面的宽度为4字节，即0x12345678，存放的地址也为RVA，在这个表里面，名称是按字符顺序排序的<ul><li><p>例如有一个函数名称为apple，另外一个函数名称为bee，那么apple的RVA就在这个表里面的第一项，bee的RVA就在这个表里面的第二项，但是这个可能并不是函数真正的名字，如下图所示</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128671.png" alt="202302261034484" /></p></li></ul></li></ul><h4 id="addressofnameordinals"><a class="markdownIt-Anchor" href="#addressofnameordinals"></a> AddressOfNameOrdinals</h4><ul><li>这个表里面的宽度为2字节，存放的地址也为RVA，通过这个表里面的内容加上Base就可以得到函数的导出序号</li></ul><h4 id="addressoffunctions"><a class="markdownIt-Anchor" href="#addressoffunctions"></a> AddressOfFunctions</h4><ul><li>这个表里面的宽度也是4字节，存放的是所有导出函数的地址，这个地址也是RVA，所以要想得到真正的地址需要加上ImageBase</li></ul><h3 id="导出方式"><a class="markdownIt-Anchor" href="#导出方式"></a> 导出方式</h3><ul><li>以名字导出<ul><li>首先遍历名字表(AddressOfNames)，用名字表中的地址找字符串，与目标字符串比对。如果找到字符串一样的，得到该处的索引。按照相同的索引号从序号表中找到序号值(即<strong>名字表与序号表的下标相同</strong>)，再通过序号值(序号表中的value)为索引，从地址表中找到目标函数的地址(RVA)，之后这个地址需要加上ImagBase，即可得到真正导出函数的地址</li></ul></li><li>以序号导出<ul><li>用目标序号-BASE，得到一个值，直接用这个值为索引，从地址表中找函数的地址(RVA)，之后这个地址需要加上ImagBase，即可得到真正导出函数的地址</li></ul></li></ul><h2 id="导入表"><a class="markdownIt-Anchor" href="#导入表"></a> 导入表</h2><p>​**基本概念：**导入表是记录PE文件中用到的动态连接库的集合，一个dll库在导入表中占用一个元素信息的位置，这个元素描述了该导入dll的具体信息。如dll的最新修改时间、dll中函数的名字/序号、dll加载后的函数地址等。</p><blockquote><p>补充：DLL</p></blockquote><p>​DLL(Dynamic Linked Library)----动态链接库</p><p>DLL概念：</p><ul><li>不把库包含到程序中，单独组成DLL文件，需要时调用即可</li><li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享</li><li>更新库时只要替换相关文件即可，简便易行</li></ul><p>DLL加载：</p><ol><li>显示链接：程序使用DLL时加载，使用完毕后释放内存；</li><li>隐式链接：程序开始时即一同加载DLL，程序终止时再释放占用的内存</li></ol><p><strong>IAT提供的机制即与隐式链接有关</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>    DWORD   VirtualAddress;<br>    DWORD   Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：指向真正导入表结构的RVA</li><li><code>Size</code>：导入表的大小</li></ul><h3 id="image_import_descriptor"><a class="markdownIt-Anchor" href="#image_import_descriptor"></a> IMAGE_IMPORT_DESCRIPTOR</h3><p>​IMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导入哪些库文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">//导入表结束标志</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">//RVA 指向IMAGE_THUNK_DATA结构体数组(INT表)</span><br>    &#125;;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">//时间戳</span><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;                           <span class="hljs-comment">//RVA指向dll名字，以0结尾</span><br>    DWORD   FirstThunk;                     <span class="hljs-comment">//RVA 指向IMAGE_THUNK_DATA结构体数组(IAT表)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p>​执行一个普通程序往往需要导入多个库，导入多少库就存在多少个 <strong>IMAGE_IMPORT_DESCRIPTOR结构体</strong>，这些结构体组成了数组，且结构体数组最后以NULL结束。</p><ul><li><code>OriginalFirstThunk</code><ul><li>该字段保存了指向**导入函数名称(序号)**的 RVA 表(<strong>INT表</strong>)，这个表其实是一个 IMAGE_THUNK_DATA结构体</li></ul></li><li><code>Name</code><ul><li>RVA，指向dll名字(库名称字符串的地址)，该名字以 0 结尾</li></ul></li><li><code>FirstThunk</code><ul><li>RVA，指向IMAGE_THUNK_DATA结构数组，即<strong>指向IAT表</strong></li><li>该字段保存了指向导入地址表的 RVA，在 <strong>PE 文件没有被装载前</strong>它的内容与 OriginalFirstThunk 指向相同的内容，也就是在 PE 文件没有被装载前它也指向 IMAGE_THUNK_ DATA 结构体。</li><li>当<strong>被 Windows 操作系统装入内存后</strong>，它的值则发生了变化，被装载入内存后，这里保存了导入函数实际地址</li></ul></li></ul><h4 id="originalfirstthunk"><a class="markdownIt-Anchor" href="#originalfirstthunk"></a> OriginalFirstThunk</h4><ul><li><strong>OriginalFirstThunk</strong>这个RVA所指向的是INT表（Import Name Table），这个表每个数据占4个字节。顾名思义就是表示要导入的函数的名字表</li><li><code>INT</code>：<ul><li>如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；</li><li>如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。</li></ul></li><li><code>IMAGE_IMPORT_BY_NAME</code>：前两个字节是一个序号，不是导入序号，一般无用，后面接着就是导入函数名字的字符串，以0结尾。</li></ul><h4 id="name"><a class="markdownIt-Anchor" href="#name"></a> Name</h4><p>​这个结构体变量也是一个RVA，直接指向一个字符串，这个字符串就是这个导入表对应的DLL的名字。一个导入表只对应一个DLL。存在多个导入表，则对应目录项里的VirtualAddress（RVA）指向的是所有导入表的首地址，每个导入表占20字节，挨着。最后以一个空结构体作为结尾（20字节全0结构体）。</p><h4 id="firstaddress"><a class="markdownIt-Anchor" href="#firstaddress"></a> FirstAddress</h4><ul><li><p>FirstAddress（RVA）指向的就是<strong>IAT表</strong>。IAT表也是每个数据占4个字节。最后以4字节0结尾。</p></li><li><p><code>PE加载：</code></p><ul><li><p>PE加载前，IAT表和INT表完全相同，此时IAT表可以判断函数导出序号，或指向函数名字结构体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129288.png" alt="202302261010635" /></p></li><li><p>PE加载后：IAT表发生变化，系统会现根据结构体变量Name加载对应的dll(拉伸)，读取dll的导出表，对应原程序的INT表，匹配dll导出函数的地址，返回其地址，贴在对应的IAT表上，挨个修正地址(即GetPeocAddress)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129939.png" alt="202302261010941" /></p></li></ul></li></ul><h3 id="image_thunk_data"><a class="markdownIt-Anchor" href="#image_thunk_data"></a> <strong>IMAGE_THUNK_DATA</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD ForwarderString;      <span class="hljs-comment">// PBYTE </span><br>        DWORD Function;             <span class="hljs-comment">// PDWORD，被输入的函数的内存地址</span><br>        DWORD Ordinal;   <span class="hljs-comment">// 被输入的API的序数值</span><br>        DWORD AddressOfData;        <span class="hljs-comment">// RVA 指向_IMAGE_IMPORT_BY_NAME </span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br></code></pre></td></tr></table></figure><ul><li>首先要判断最高位是否为1，如果最高位的值为1，那么去除最高位的值之后，即为函数的导出序号</li><li>如果最高位的值不为1，那么这个值就是一个RVA，在转成FOA之后指向<code>IMAGE_IMPORT_BY_NAME</code>这个结构</li></ul><h3 id="image_import_by_name"><a class="markdownIt-Anchor" href="#image_import_by_name"></a> IMAGE_IMPORT_BY_NAME</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> &#123;</span>                <br>    WORD    Hint;                <br>    BYTE    Name[<span class="hljs-number">1</span>];                <br>&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure><ul><li>Hint为2字节，为当前函数在导出表中的索引，但是这个值一般起不到什么作用。我们思考一下，如果我们最高位值为1是以序号导出，最高位值不为1则以名字导出，而以名字导出的时候我们才会用到<code>IMAGE_IMPORT_BY_NAME</code>结构，但是我们按名字导出也就不需要管函数的索引了，所以Hint这个值可以忽略，在一些编译器里面会直接将Hint的值置为0。</li><li>我们主要是看一下<code>Name[1]</code>这个结构，可以看到它是BYTE，大小为1字节。因为考虑到了函数名字长度的不确定性，设计者只将函数开头的1字节存到<code>Name[1]</code>这个结构中，函数名是以<code>\0</code>结尾的，也就是说在找到<code>Name[1]</code>里面所存的首字节后，一直往后遍历，直到找到0即为函数名的结束。</li></ul><h3 id="绑定导入表"><a class="markdownIt-Anchor" href="#绑定导入表"></a> 绑定导入表</h3><p>​PE在加载前INT、IAT表都指向一个名称表，但是有的exe程序，在打印IAT表的时候，会发现里面是地址。这是因为我们的PE程序在加载的时候，IAT表会填写函数地址。但是这就造成了一个问题，PE程序启动慢，每次启动都要给IAT表填写函数地址。那么这里我们就可以使用到绑定导入表来使PE程序的启动变快。</p><ul><li>注意：<code>TimeDataStamp</code>(时间戳)。PE加载EXE相关的DLL时，首先会根据<code>IMAGE_IMPORT_DESCRIPTOR</code>结构中的<code>TimeDateStamp</code>来判断是否要重新计算IAT表中的地址。若<code>TimeDataStamp == 0</code> 则未绑定，<code>TimeDataStamp == -1</code> 则已绑定<ul><li>一般的PE文件在加载前INT和IAT表中都是指向<code>IMAGE_IMPORT_BY_NAME</code>这张表的，也就是说INT表和IAT表在PE加载前表中所存的内容都是一样的。</li><li>PE在加载后，IAT表里存的才是函数的地址，这种情况就属于没有绑定导入表的情况，即<code>TimeDataStamp</code>为0的情况。</li></ul></li></ul><p>​真正的绑定导入表位于目录的第12项，其中<code>TimeDataStamp</code>为真正的时间戳，<code>OffsetModuleName</code>为剩余dll的名字，<code>NumberOfModuleForwarderRefs</code>为依赖dll的数量</p><h4 id="image_bound_import_descriptor"><a class="markdownIt-Anchor" href="#image_bound_import_descriptor"></a> IMAGE_BOUND_IMPORT_DESCRIPTOR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span><br>    DWORD   TimeDateStamp;　　　　　　　　　　　　　　　　<span class="hljs-comment">//真正的时间戳</span><br>    WORD    OffsetModuleName;　　　　　　　　　　　　　　<span class="hljs-comment">//DLL的名字,PE的文件名</span><br>    WORD    NumberOfModuleForwarderRefs;　　　　　　　　<span class="hljs-comment">//依赖的另外的DLL有几个</span><br><span class="hljs-comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span><br>&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><ul><li><p>其中要注意的是<code>OffsetModuleName</code>这个值有点特殊，它既不是foa，也不是rva，它的计算公式为第一个<code>DESCRIPTOR</code>的值加上所在结构体的<code>OffsetMoudeleName</code>得到。如果<code>NumberOfModuleForwarderRefs</code>的值为2，则绑定导入表一共就有3个dll。</p></li><li><p>如果<code>NumberOfModuleForwarderRefs</code>的值不为0，绑定导入表下面还会跟一张依赖dll的绑定导入表结构，含义的话跟绑定导入表相同，<code>Reserved</code>值可以不用管。</p><ul><li><pre class="highlight"><code class="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span>    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;&lt;!--code￼<span class="hljs-number">13</span>--&gt;</code></pre></li></ul></li><li><p><code>VirtualAddress</code>：存放真正重定位表地址的RVA</p></li><li><p><code>Size</code>：重定位表的大小</p></li></ul><h3 id="image_base_relocation"><a class="markdownIt-Anchor" href="#image_base_relocation"></a> IMAGE_BASE_RELOCATION</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BASE_RELOCATION</span> &#123;</span><br>    DWORD   VirtualAddress;  <span class="hljs-comment">//RVA</span><br>    DWORD   SizeOfBlock;<br>&#125; IMAGE_BASE_RELOCATION;<br><span class="hljs-keyword">typedef</span> IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;<br></code></pre></td></tr></table></figure><h4 id="sizeofblock"><a class="markdownIt-Anchor" href="#sizeofblock"></a> SizeOfBlock</h4><ul><li>重定位表的核心结构，存储的值以字节为单位，表示的是重定位表的大小</li></ul><h4 id="判断重定位表的数量"><a class="markdownIt-Anchor" href="#判断重定位表的数量"></a> 判断重定位表的数量</h4><ul><li>规定在最后一个结构的VirtualAddress和SizeOfBlock的值都为0，这里就可以进行判断来获取重定位表有多少个结构<ul><li><p>例如：假设重定位结构的数量为3，那么在最后8字节即VirtualAddress和SizeOfBlock的值都为0，可以说重定位表就是很多个块结构所构成的。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129308.png" alt="202302261049857" /></p></li></ul></li></ul><h4 id="具体项"><a class="markdownIt-Anchor" href="#具体项"></a> 具体项</h4><ul><li>在每一块结构的VirtualAddress和SizeOfBlock里面，都有很多宽度为2字节的十六进制数据，这里我们称他们为具体项。</li><li>在内存中页大小的值为1000H，即2的12次方，也就是通过这个1000H就能够表示出一个页里面所有的偏移地址。而具体项的宽度为16位，页大小的值为低12位。</li><li>高四位为0011或0000，对应的十进制就是3或0.<ul><li><strong>当高4位的值为0011</strong>，我们需要修复的数据地址就是VirtualAddress + 低12位的值。<ul><li>例如VirtualAddress是0x12345678，具体项的数值为001100000001，那么这个值就是有意义的，需要修改的RVA = 0x12345678+0x00000001 = 0x12345679。</li></ul></li><li><strong>当高4位的值为0000</strong>，这里就不需要进行重定位的修改，这里的具体项只是用于数据对齐的数据。</li></ul></li></ul><h2 id="资源表"><a class="markdownIt-Anchor" href="#资源表"></a> 资源表</h2><p>​**背景：**资源表是PE所有表里边最复杂的表，造成资源表复杂是有历史原因的，简单说就是微软设计PE的时候错误的以为只要定义16位中的资源类型就够了，后来发现远远不够，但是PE结构已经定下来了，只能在原有基础上修改，因此就造成了资源表这块比较不好理解。</p><ul><li>所谓的不好理解，就是它里边用到的结构，其中的属性会出现<strong>位段/位域</strong>的用法<ul><li>同一个4字节，要根据高位判断它到底是一个整数还是一个偏移；</li><li>偏移并不是RVA，而是相对于资源表的偏移</li></ul></li></ul><h3 id="image_resource_directory"><a class="markdownIt-Anchor" href="#image_resource_directory"></a> IMAGE_RESOURCE_DIRECTORY</h3><p>资源目录的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span>                                <br>    DWORD   Characteristics;                        <span class="hljs-comment">//资源属性  保留 0        </span><br>    DWORD   TimeDateStamp;                        <span class="hljs-comment">//资源创建的时间        </span><br>    WORD    MajorVersion;                        <span class="hljs-comment">//资源版本号 未使用 0        </span><br>    WORD    MinorVersion;                        <span class="hljs-comment">//资源版本号 未使用 0        </span><br>    WORD    NumberOfNamedEntries;                        <span class="hljs-comment">//以名称命名的资源数量        </span><br>    WORD    NumberOfIdEntries;                           <span class="hljs-comment">//以ID命名的资源数量        </span><br><span class="hljs-comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];                                </span><br>&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;<br></code></pre></td></tr></table></figure><h3 id="资源表的真正结构"><a class="markdownIt-Anchor" href="#资源表的真正结构"></a> 资源表的真正结构</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129287.png" alt="202302261111997" /></p><ul><li>其中每一层都有一个资源目录这个结构，这个结构的意义就是用来统计有多少个<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span>                                <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                            <span class="hljs-comment">//目录项的名称、或者ID        </span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                <br>            DWORD NameOffset:<span class="hljs-number">31</span>;                                <br>            DWORD NameIsString:<span class="hljs-number">1</span>;                                <br>        &#125;;                                <br>        DWORD   Name;                                <br>        WORD    Id;                                <br>    &#125;;                                <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                <br>        DWORD   OffsetToData;                        <span class="hljs-comment">//目录项指针        </span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                <br>            DWORD   OffsetToDirectory:<span class="hljs-number">31</span>;                                <br>            DWORD   DataIsDirectory:<span class="hljs-number">1</span>;                                <br>        &#125;;                                <br>    &#125;;                                <br>&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;<br></code></pre></td></tr></table></figure><ul><li><code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>这个结构在每一层里面的含义都不相同，在第一层用来判断资源的类型，第二层用来判断资源的编号，第三层表示的是代码页</li></ul><h4 id="第一层"><a class="markdownIt-Anchor" href="#第一层"></a> 第一层</h4><h5 id="第一个联合体"><a class="markdownIt-Anchor" href="#第一个联合体"></a> 第一个联合体</h5><ul><li><p><code>资源类型</code>：每种资源有类型及名字，它们是数值标识符或字符串。windows定义了十六种预定义类型，如光标对应1，位图对应2，图标对应3等等。而资源类型既可以用序号表示，也可以用字符串表示。第一层里Name表示的就是资源类型，使用NameIsString判断资源类型用什么表示</p><ul><li><p><code>DWORD NameOffset:31;</code> 和 <code>DWORD NameIsString:1;</code> 这两个值，</p><ul><li><code>NameOffset:31</code>就是表示占低31位，而<code>NameIsString</code>则占剩下的1位</li></ul></li><li><p>当最高位为1时，即<code>NameIsString = 1</code> 时，低31位为一个UNICODE指针，指向<code>_IMAGE_RESOURCE_DIR_STRING_U</code>结构，在这个结构里面<code>Length</code>表示长度，<code>NameString[1]</code>表示的是真正UNICODE起始的地址(字符串表示)</p><ul><li><pre class="highlight"><code class="c">ypedef <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span>                            WORD    Length;                            WCHAR   NameString[ <span class="hljs-number">1</span> ];                        &#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;&lt;!--code￼<span class="hljs-number">17</span>--&gt;</code></pre></li></ul></li><li><p><code>VirtualAddress</code>是RVA，表示资源真正存储的位置，</p></li><li><p><code>Size</code>表示资源的大小</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C &amp; C++</title>
    <link href="/posts/4356fc58.html"/>
    <url>/posts/4356fc58.html</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><h2 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h2><h3 id="函数概念"><a class="markdownIt-Anchor" href="#函数概念"></a> 函数概念</h3><ul><li><p>计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果,也称为返回值，在计算机求得之后，由此口带回给调用它的程序。</p></li><li><p>汇编中的函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123136.png" alt="202210032043850" /></p></li><li><p>函数的入口</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123438.png" alt="202210032043993" /></p><ul><li>存储变量传递给函数除了存入堆栈中，也可以存入其余的寄存器中</li></ul></li><li><p>函数的出口</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123896.png" alt="202210032044374" /></p><ul><li>函数的计算结果除了放在寄存器中，还可以放到堆栈中</li></ul></li></ul><h3 id="winodws堆栈"><a class="markdownIt-Anchor" href="#winodws堆栈"></a> Winodws堆栈</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123987.png" alt="202210032045557" /></p><ul><li>特点：<ul><li>先进后出</li><li>向低地址扩展（ESP向上移动要-4）</li></ul></li><li>堆栈平衡：<ul><li>Windows中的堆栈，是一块普通的内存，主要用来存储一些临时的数据和参数等</li><li>可以把Windows中的堆栈想象成是一个公用的书箱，函数就像是使用箱子的人，函数在执行的时候，会用到这个书箱，把一些数据存到里面。但用完的时候，一定要记得把书拿走，否则会乱的，也就是说，你放进去几本书，走的时候也要拿走几本书，这个就是堆栈平衡.</li></ul></li></ul><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ul><li>按Ctrl+G进行查找内存地址，按F2进行CPU定位（加断点），之后按住OD上的暂停按钮使CPU达到此内存处，之后可以正常按F8进行步进</li><li>call需要按F7进行步入，遇到<code>jmp</code>按回车进行跳转<ul><li>F7指遇到函数跳入函数内部执行——单步步入</li><li>F8指直接执行函数，执行完之后到下一行——单步步过</li></ul></li><li>函数调用函数时，编译器会自动增加一个函数，用以检测是否堆栈平衡，按<code>enter</code>进入函数，按<code>-</code>退出</li></ul><h2 id="函数特点"><a class="markdownIt-Anchor" href="#函数特点"></a> 函数特点</h2><h3 id="函数分类"><a class="markdownIt-Anchor" href="#函数分类"></a> 函数分类</h3><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/naked-cpp?view=msvc-170">naked (C++)</a></p><h4 id="裸函数"><a class="markdownIt-Anchor" href="#裸函数"></a> 裸函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __declspec(naked) Function()<br>&#123;<br>  <span class="hljs-comment">// 编译器不对裸函数进行任何处理，无法堆栈平衡，需要自己平衡堆栈</span><br>  __asm<br>    &#123;<br>        ret<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无参数无返回值函数"><a class="markdownIt-Anchor" href="#无参数无返回值函数"></a> 无参数无返回值函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __declspec(naked) Function()  <br>&#123;<br>__asm<br>&#123;<br>  <span class="hljs-comment">// 提升堆栈，为函数执行提供空间</span><br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>  <span class="hljs-comment">// 保留现场</span><br>push ebx<br>push esi<br>push edi<br>  <span class="hljs-comment">// 向分配空间填充数据</span><br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>    <span class="hljs-comment">/*此处实现函数功能*/</span><br>  <span class="hljs-comment">// 恢复现场，将之前保留的寄存器值恢复</span><br>pop edi<br>pop esi<br>pop ebx<br>  <span class="hljs-comment">// 降低堆栈   </span><br>mov esp,ebp<br>  <span class="hljs-comment">// 恢复栈底   </span><br>pop ebp<br>  <span class="hljs-comment">// 函数执行完毕，返回到调用处</span><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有参数有返回值函数"><a class="markdownIt-Anchor" href="#有参数有返回值函数"></a> 有参数有返回值函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __declspec(naked) Function(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)  <br>&#123;<br>__asm<br>&#123;<br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>push ebx<br>push esi<br>push edi<br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>            <br><span class="hljs-comment">/*函数功能实现*/</span><br>mov eax,dword ptr ds:[ebp+<span class="hljs-number">8</span>]<br>add eax,dword ptr ds:[ebp+<span class="hljs-number">0xC</span>]<br><br>pop edi<br>pop esi<br>pop ebx<br>mov esp,ebp<br>pop ebp<br><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带局部变量的函数"><a class="markdownIt-Anchor" href="#带局部变量的函数"></a> 带局部变量的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __declspec(naked) Function(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)  <br>&#123;<br>__asm<br>&#123;<br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>push ebx<br>push esi<br>push edi<br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>          <br>  <span class="hljs-comment">/*局部变量引入*/</span><br>mov dword ptr ds:[ebp<span class="hljs-number">-4</span>],<span class="hljs-number">2</span><br>mov dword ptr ds:[ebp<span class="hljs-number">-8</span>],<span class="hljs-number">3</span><br><br>mov eax,dword ptr ds:[ebp+<span class="hljs-number">8</span>]<br>add eax,dword ptr ds:[ebp+<span class="hljs-number">0xC</span>]<br><br>pop edi<br>pop esi<br>pop ebx<br>mov esp,ebp<br>pop ebp<br><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用约定"><a class="markdownIt-Anchor" href="#调用约定"></a> 调用约定</h3><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈</td><td>调用者清理栈(外平栈)</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理栈(内平栈)</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下:从右至左入栈</td><td>自身清理栈(内平栈)</td></tr></tbody></table><span class="label label-info">__fastcall的参数只有大于两个才需要內平栈，两个参数直接传递寄存器，不需要平衡堆栈</span><h3 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h3><h4 id="一般方式"><a class="markdownIt-Anchor" href="#一般方式"></a> 一般方式</h4><ol><li><p>观察调用处的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push        3<br>push        2<br>push        1<br>call       0040100f<br></code></pre></td></tr></table></figure></li><li><p>找到平衡堆栈的代码(外平栈)或者函数内部(內平栈)继续论证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call        0040100f<br>add         esp,0Ch<br><br>ret 4/8/0xC/0x10<br></code></pre></td></tr></table></figure></li><li><p>将二者结合，确定参数个数</p></li></ol><h4 id="观察代码"><a class="markdownIt-Anchor" href="#观察代码"></a> 观察代码</h4><ol><li><p>不考虑ebp、esp</p></li><li><p>只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi</p></li><li><p>找到以后追查其来源，如果该寄存器中的值不是在<strong>函数内存赋值</strong>的，那一定是传进来的参数</p></li><li><p>获得参数数量</p><ul><li><p>公式一：寄存器 + ret  4 = 参数个数</p></li><li><p>公式二：寄存器 + [ebp+8] + [ebp+0x] = 参数个数</p></li></ul></li></ol><h2 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h2><h3 id="ifelse"><a class="markdownIt-Anchor" href="#ifelse"></a> if……else</h3><ul><li>反汇编语句与if语句含义相反，即若if(x&gt;=1)，则反汇编中表达x&lt;1时跳转，否则继续顺序执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291124190.png" alt="202212241152274" /></p><center><strong> if……else语句</strong></center><h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3><ol><li><p>分支小于4或者数据无规律时，用switch无意义，生成类似if……else的反汇编</p></li><li><p>Switch语句中数值相近时，会自动生成大表(连续数值中多个不存在时，会生成小表)</p><p><a href="https://www.cnblogs.com/Reverse-xiaoyu/p/11711393.html">switch…case…语句分析（大表跟小表何时产生）</a></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">switch</span> (x) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Error&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125123.png" alt="202212241120544" /></p><center><strong> Switch语句中的大表</strong></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">switch</span> (x) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">101</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">108</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">109</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">110</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Error&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125399.png" alt="202212241139348" /></p><center><strong> Switch语句中的小表</strong></center><h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3><ol><li>根据条件跳转指令所跳转到的地址，可以得到循环语句块的结束地址</li><li>根据 jmp 指令所跳转到的地址，可以得到循环语句块的起始地址</li><li>在还原while 比较时，条件跳转的逻辑与源码相反</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">while</span> (x &lt; y)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x);<br>x++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125717.png" alt="202212241157555" /></p><center><strong> while语句</strong></center><h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3><ol><li>第一个 jmp 指令之前为赋初值部分</li><li>第一个 jmp 指令所跳转的地址为循环条件判定部分起始</li><li>判断条件后面的跳转指令条件成立时跳转的循环体外面</li><li>条件判断跳转指令所指向的地址上面有一个 jmp， jmp地址为表达式3的起始位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;y;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125748.png" alt="202212241200812" /></p><center><strong> for语句</strong></center><h1 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h1><h2 id="数据类型及存储"><a class="markdownIt-Anchor" href="#数据类型及存储"></a> 数据类型及存储</h2><h3 id="c语言数据类型"><a class="markdownIt-Anchor" href="#c语言数据类型"></a> c语言数据类型</h3><ol><li><p><strong>基本类型</strong></p><ul><li><p>整数类型</p></li><li><p>浮点类型</p></li></ul></li><li><p><strong>构造类型</strong></p><ul><li><p>数组类型</p></li><li><p>结构体类型</p></li><li><p>共用体(联合)类型</p></li></ul></li><li><p><strong>指针类型</strong></p></li><li><p><strong>空类型(void)</strong></p></li></ol><ul><li>数据类型三个要素<ul><li>存储数据的宽度</li><li>存储数据的格式</li><li>作用范围(作用域)</li></ul></li></ul><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h3><h4 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h4><table><thead><tr><th>数据类型</th><th>长度(bit)</th><th>长度(字节)</th><th>汇编中表示</th></tr></thead><tbody><tr><td>char</td><td>8BIT</td><td>1字节</td><td>BYTE</td></tr><tr><td>short</td><td>16BIT</td><td>2字节</td><td>WORD</td></tr><tr><td>int</td><td>32BIT</td><td>4字节</td><td>DWORD</td></tr><tr><td>long</td><td>32BIT</td><td>4字节</td><td></td></tr></tbody></table><ul><li>认为划分为<strong>有符号(signed)<strong>与</strong>无符号(unsigned)</strong>，其在计算机中存储方式相同，但是根据需求认定为不同的数值</li></ul><h4 id="浮点类型"><a class="markdownIt-Anchor" href="#浮点类型"></a> 浮点类型</h4><ul><li><strong>float</strong>和<strong>double</strong></li><li>二者在存储方式上遵从<strong>IEEE</strong>规范</li></ul><ol><li>float的存储方式</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125885.png" alt="202212222043652" /></p><ol start="2"><li>double的存储方式</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125982.png" alt="202212222044090" /></p><ol start="3"><li>将一个float型转化为内存存储格式：<ul><li>先将这个实数的绝对值化为二进制格式</li><li>将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字(1)的右边</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位</li><li>将移动位数+127并转化为二进制放入第30到23位(例如:右移3位，即127+(-3) = 124)</li><li>若原本数字为负数，则在符号位填入“1”；否则，填入“0”</li></ul></li></ol><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h4><ul><li><p><code>MOVSX</code>先符号扩展，再传送，适用于有符号类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,0xFF<br>movsx cx,al<br>;此时cx == 0XFFFF(看0xFF的第一位是什么，FF == 1111 1111，首位是1，扩展8个1)<br></code></pre></td></tr></table></figure></li><li><p><code>MOVZX</code>先零扩展，再传送，适用于无符号类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,0xFF<br>movsx cx,al<br>;此时cx == 0XFF(直接在FF前面补8个0)<br></code></pre></td></tr></table></figure></li><li><p>小数据类型向大数据类型转换</p><ul><li>采用保留低位数据，舍弃高位数据</li></ul></li></ul><h3 id="构造类型"><a class="markdownIt-Anchor" href="#构造类型"></a> 构造类型</h3><h4 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h4><ul><li><p>一组相同类型的变量，为了方便读写，采用另外一种表示形式。其在声明的时候，必须用常量来指明长度，不能使用变量(<strong>常量是因为在编译的时候，编译器就要知道开辟的缓冲区的大小，所以必须是常量</strong>)</p></li><li><p>数组在使用时，可以通过变量来定位数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例如：</span><br><span class="hljs-type">int</span> arr[m][n][k] = &#123;&#123;&#125;,&#123;&#125;……&#125;;<br><br><span class="hljs-comment">//寻找arr[3][2][1]</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">在编译器中，寻找方式为arr[3*n+2*k+1]。</span><br><span class="hljs-comment">一维数组与多维数组的本质没有区别，arr[m*n*k]与arr[m][n][k]开辟相同</span><br><span class="hljs-comment">*/</span>  <br></code></pre></td></tr></table></figure></li></ul><h4 id="结构体类型"><a class="markdownIt-Anchor" href="#结构体类型"></a> 结构体类型</h4><ul><li>本质是大量数据的内存复制</li></ul><h3 id="指针类型"><a class="markdownIt-Anchor" href="#指针类型"></a> 指针类型</h3><h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4><ol><li><p>格式：<code>数据类型* 变量名</code></p></li><li><p>宽度为4字节， * 可以是任意数量</p></li><li><p>加减操作(+/-/++/–)都是<code>以数据类型的宽度为标准</code>进行增加或减少，例如：char为1，int为4。</p><p><code>总结</code>：加减增加的是去掉一个 * 之后的数据宽度，若是char **，增加的就是4字节</p></li><li><p><code>两种类型相互加减</code>：</p><ul><li>两个类型相同的带 * 类型的变量可以进行减法操作，减完后的数据类型是去掉 * 的数据类型</li><li>相减的结果要除以去掉一个 * 的数据类型的宽度</li></ul></li></ol><h4 id="运用"><a class="markdownIt-Anchor" href="#运用"></a> 运用</h4><ol><li><p><code>&amp;</code> 是地址符，类型是其后面的类型加一个 * ，任何变量都可以使用&amp;来获取地址，但不能用在常量上</p></li><li><p><code>带 * 类型的变量</code>，可以通过在其变量前加 * 来获取<code>其指向内存中存储的值</code>，即在带 * 类型的变量前面加*，类型是其原来的类型减去一个 * 。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x;<br>&amp;x<span class="hljs-comment">//(int*)</span><br>    <br><span class="hljs-type">int</span>* y;<br>*y<span class="hljs-comment">//(int)</span><br></code></pre></td></tr></table></figure><h4 id="结合"><a class="markdownIt-Anchor" href="#结合"></a> 结合</h4><ol><li>指针函数<ul><li>返回值为指针的函数----函数</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span> <span class="hljs-params">(<span class="hljs-type">char</span>* dest,<span class="hljs-type">char</span>* src)</span><br>&#123;<br><span class="hljs-keyword">while</span>((*(dest++)=*(src++))!=<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>函数指针<ul><li>声明----返回类型(*函数名)(参数表)</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明</span><br><span class="hljs-type">int</span> (*pFun)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);<br><span class="hljs-comment">//赋值</span><br>pFun = (<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>))<span class="hljs-number">10</span>;<br>pFun = 函数名;<br></code></pre></td></tr></table></figure><ol start="2"><li>指针数组<ul><li>数组的类型是指针类型----数组</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>数组指针<ul><li>本质是指针，<code>不必指向数组</code>，只是使用定义的数组的宽度</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//变量名px，数据类型 int[5]</span><br><span class="hljs-type">int</span>(*px)[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//例子</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>(*p)[<span class="hljs-number">2</span>];<br>p = (<span class="hljs-type">int</span>(*) [<span class="hljs-number">2</span>])arr;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, *(*(p+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>), *(p + <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], p[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><ol start="3"><li>结构体指针<ul><li>结构体</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Struct Arg<br>&#123;<br>   <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">int</span> b;<br>   <span class="hljs-type">int</span> c;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//创建结构体</span><br>    Student s;<br>    s.a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//声明结构体指针</span><br>    Student* ps;<br>    <span class="hljs-comment">//为结构体指针赋值</span><br>    ps = &amp;s;<br>    <span class="hljs-comment">//通过指针读取数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ps-&gt;a);<br>    <br>    <span class="hljs-comment">//还可以使用其他指针类型对结构体指针进行赋值，此时结构体指针可以利用自己的构造遍历未知空间数据</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>    Arg* px = (Arg*)&amp;x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,px-&gt;a,px-&gt;b,px-&gt;c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h1><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291126765.png" alt="202212222123177" /></p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_n = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">return</span> g_n+x+y;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0</li><li>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值</li><li>全局变量所占内存会一直存在，知道整个进程结束</li><li>全局变量的反汇编识别，通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度<ul><li><code>MOV REG,byte/word/dword ptr ds:[0x12345678]</code></li></ul></li><li><strong>全局变量就是所谓的基址</strong></li></ol><h3 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">return</span> g_n+x+y;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存</li><li>当局部变量所属的方法执行完毕后，局部变量所占用的内存将变成垃圾数据。局部变量消失</li><li>局部变量只能在方法内部使用，函数A无法使用函数B的局部变量</li><li>局部变量的反汇编识别<ul><li><code>[ebp-4]</code>，<code>[ebp-8]</code>，<code>[ebp-0xC]</code>等</li></ul></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>​这里需要注意，这是针对普通的函数所写出的地址对应，即<code>push edp……</code>等操作，如果是个裸函数，或自定义函数，则不再适配</p><ul><li><p>全局变量----一个固定的地址，类似<code>byte/word/dword ptr ds:[0x12345678]</code>类型</p></li><li><p>局部变量----<code>[ebp-x]</code>，类似<code>[ebp-4]</code>，<code>[ebp-8]</code>，<code>[ebp-0xC]</code>等</p></li><li><p>传入参数----<code>[ebp+x]</code>，类似<code>[ebp+8]</code>，<code>[ebp+0xC]</code>等(x≠4)</p></li><li><p>特殊----</p><ul><li><code>[ebp]</code>存储的是ebp在被push前的数值</li><li><code>[ebp+4]</code>存储是call返回时的EIP指向的地址</li></ul></li></ul><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//样例一</span><br><span class="hljs-type">char</span>* x = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">char</span> y[] = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//报错，其中&quot;china&quot;存储在常量区，不能对其进行修改，但是可以修改x的指向(地址)</span><br>*(x+<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-comment">//正常，y[]存储的字符串存储在全局变量区域(从常量区复制过来的)，可以进行修改</span><br>y[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//样例二</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span>* x = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">char</span> y[] = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-comment">//报错</span><br>*(x+<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-comment">//正常</span><br>y[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>&quot;china&quot;字符串存储在常量区内，不可以进行修改</li><li><code>*(x+1)</code>中的x指向的是&quot;china&quot;在常量区的地址，直接对x进行修改就是修改常量区的数据，报错</li><li><code>y[1]</code>中的数组在堆栈中开辟，常量区中的&quot;china&quot;被复制到了eax等寄存器中，成为了变量，修改y就是修改堆栈中的变量部分，所以正常运行。即y[1]不修改常量区内容，而是复制到变量区再进行修改</li></ul><h2 id="内存分配与释放"><a class="markdownIt-Anchor" href="#内存分配与释放"></a> 内存分配与释放</h2><ul><li>自动分配内存(c语言)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* ptr;<span class="hljs-comment">//声明指针</span><br><br><span class="hljs-comment">//在堆中申请内存,分配128个int</span><br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//无论申请的空间大小 一定要进行校验 判断是否申请成功</span><br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化分配的内存空间</span><br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//使用。。。</span><br>*(ptr) = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//使用完毕 释放申请的堆空间</span><br><span class="hljs-built_in">free</span>(ptr);<br><br><span class="hljs-comment">//将指针设置为NULL</span><br>ptr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li>注意事项：<ol><li>使用 sizeof(类型)*n 来定义申请内存的大小</li><li>malloc 返回类型为 void* 类型  需要强制转换</li><li>无论申请的内存有多小，一定要判断是否申请成功</li><li>申请完空间后要记得初始化</li><li>使用完一定要是否申请的空间</li><li>将指针的值设置为NULL</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week5</title>
    <link href="/posts/b169c66f.html"/>
    <url>/posts/b169c66f.html</url>
    
    <content type="html"><![CDATA[<ul><li>懒得写了，就这样放这里吧</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week4</title>
    <link href="/posts/c66ef6f9.html"/>
    <url>/posts/c66ef6f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>无壳，直接分析，发现是每3个字节进行sha1加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232130791.png" alt="image-20230423213033751" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232130663.png" alt="image-20230423213042625" /></p><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><p>直接进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> itertools<br><br>text=[<span class="hljs-string">&#x27;A2F17ED1C6A8BC31769CDF654DF4B8A937042CB6&#x27;</span>,<span class="hljs-string">&#x27;0CA8A2EDB0C1D34A432A5A4464E0D6ABD847C831&#x27;</span>,<span class="hljs-string">&#x27;C359D69F3F08BB920F2C3B51133205533462093E&#x27;</span>,<span class="hljs-string">&#x27;CC5C3FE6E7356A26A134CFF5633349F597C40A9D&#x27;</span>,<span class="hljs-string">&#x27;4AC4BB3F27F245BA9178651AA5CDEDCBB2862E2A&#x27;</span>,<span class="hljs-string">&#x27;A01E33F4DCDB6BA1AE9F34A97CF8F6DEEEDF1A8D&#x27;</span>,<span class="hljs-string">&#x27;D3AF70912A8C1B22CFDECE071BA36BC4662B58FA&#x27;</span>,<span class="hljs-string">&#x27;9395EAB195D25B676D7D07075D3838A9AC19DF21&#x27;</span>,<span class="hljs-string">&#x27;FDB43C5EF76ECDA0C1661D6D199B5BFAC1DB538A&#x27;</span>,<span class="hljs-string">&#x27;DA8E9997A010BE78B20108CE79FEC1FB9C63D8DC&#x27;</span>,<span class="hljs-string">&#x27;809DA627F1AD01D65864C376E3179B62D9D74261&#x27;</span>,<span class="hljs-string">&#x27;8F61EE21AC7579626934E0FFB6A62B3D4A82EEC4&#x27;</span>,<span class="hljs-string">&#x27;E2A954758FDB61F869998E9788B7B7E48480B832&#x27;</span>,<span class="hljs-string">&#x27;B8E3349B97532B27AA62B8718B68240179158144&#x27;</span>]<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(text[i]))<br><br>modle = <span class="hljs-built_in">list</span>(itertools.product(<br>    [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>,<br>     <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>,<br>     <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;@&#x27;</span>,<span class="hljs-string">&#x27;|&#x27;</span>], repeat=<span class="hljs-number">3</span>))<br><br>i = -<span class="hljs-number">1</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># print(modle[i])</span><br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span>.join(modle[i])<br><br>        <span class="hljs-keyword">if</span> hashlib.sha1(<span class="hljs-built_in">str</span>.encode()).hexdigest() <span class="hljs-keyword">in</span> text[k].lower():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;correct: &#x27;</span>, <span class="hljs-built_in">str</span>)<br>            <span class="hljs-comment"># input()</span><br>            flag+=<span class="hljs-built_in">str</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[-]:&#x27;</span>+<span class="hljs-built_in">str</span>)<br>    i=-<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><br><br>enc = [<span class="hljs-string">&#x27;a2f17ed1c6a8bc31769cdf654df4b8a937042cb6&#x27;</span>, <span class="hljs-string">&#x27;0ca8a2edb0c1d34a432a5a4464e0d6abd847c831&#x27;</span>, <span class="hljs-string">&#x27;c359d69f3f08bb920f2c3b51133205533462093e&#x27;</span>, <span class="hljs-string">&#x27;cc5c3fe6e7356a26a134cff5633349f597c40a9d&#x27;</span>, <span class="hljs-string">&#x27;4ac4bb3f27f245ba9178651aa5cdedcbb2862e2a&#x27;</span>, <span class="hljs-string">&#x27;a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d&#x27;</span>, <span class="hljs-string">&#x27;d3af70912a8c1b22cfdece071ba36bc4662b58fa&#x27;</span>,<br>       <span class="hljs-string">&#x27;9395eab195d25b676d7d07075d3838a9ac19df21&#x27;</span>, <span class="hljs-string">&#x27;fdb43c5ef76ecda0c1661d6d199b5bfac1db538a&#x27;</span>, <span class="hljs-string">&#x27;da8e9997a010be78b20108ce79fec1fb9c63d8dc&#x27;</span>, <span class="hljs-string">&#x27;809da627f1ad01d65864c376e3179b62d9d74261&#x27;</span>, <span class="hljs-string">&#x27;8f61ee21ac7579626934e0ffb6a62b3d4a82eec4&#x27;</span>, <span class="hljs-string">&#x27;e2a954758fdb61f869998e9788b7b7e48480b832&#x27;</span>, <span class="hljs-string">&#x27;b8e3349b97532b27aa62b8718b68240179158144&#x27;</span>]<br><br><span class="hljs-comment"># 爆破的字符表</span><br><span class="hljs-built_in">dict</span> = string.ascii_letters + string.punctuation + string.digits<br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(<span class="hljs-built_in">dict</span>, k=<span class="hljs-number">3</span>))  <span class="hljs-comment"># 随机生成三个字符，可以产生重复字符</span><br>        <span class="hljs-comment"># print(str)</span><br>        <span class="hljs-keyword">if</span> hashlib.sha1(<span class="hljs-built_in">str</span>.encode()).hexdigest() == enc[i]:<br>            flag += <span class="hljs-built_in">str</span><br>            <span class="hljs-built_in">print</span>(flag)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="exception"><a class="markdownIt-Anchor" href="#exception"></a> Exception</h1><ul><li>涉及一个SEH断点异常处理，可以大致看出逻辑。将 <code>try</code> patch掉之后不会报错，可以看出是一个魔改的TEA</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week3</title>
    <link href="/posts/580a635a.html"/>
    <url>/posts/580a635a.html</url>
    
    <content type="html"><![CDATA[<h1 id="zzzzzz3333"><a class="markdownIt-Anchor" href="#zzzzzz3333"></a> Zzzzzz3333</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>32位，无壳，直接IDA分析<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291150349.png" alt="202211102038340" /><br />由图，需要对 <code>Arglist</code> 的一系列方程进行解密，然后将 <code>Arglist</code> 放入加密过程中进行加密之后就可以得到flag<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291150598.png" alt="202211102050613" /><span class="label label-primary">byte_402168</span>中的数据此时可以使用z3求解器来解方程组来得到 <code>Arglist</code></li></ul><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><ul><li><p>z3下载</p><ol><li>打开文件管理器，在地址栏中输入 <code>%APPDATA%</code></li><li>搜索pip文件夹，在pip文件夹中打开pip.ini文件,将其修改为下面形式（这是阿里源）</li></ol>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url = http://mirrors.aliyun.com/pypi/simple/<br><span class="hljs-keyword">trusted</span>-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><ol start="3"><li>直接使用pip下载</li></ol>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> z3-solver<br></code></pre></td></tr></table></figure><p>之后就可以在pycharm中导入z3的包并且不报错了<br />若是直接可以pip下载，则直接下载即可,我是pip源出现了问题,所以写此来提醒自己应该怎么正确换源不报错</p></li><li><p>直接使用z3解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#创建容器</span><br>a=Solver()<br><br><span class="hljs-comment">#设置未知量</span><br>s=[Int(<span class="hljs-string">&#x27;s[%d]&#x27;</span> %i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-comment">#添加约束条件</span><br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">1</span>)==<span class="hljs-number">0x191a</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">45</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">11</span>)==<span class="hljs-number">0x2649</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">16</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x1785</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">28</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">67</span>)==<span class="hljs-number">0x386c</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">4</span>)==<span class="hljs-number">0x1c53</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">0</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">45</span>)==<span class="hljs-number">0x2746</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">34</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">17</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x29ef</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">43</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">15</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">21</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">30</span>)==<span class="hljs-number">0x2d7e</span>)<br><br><span class="hljs-comment">#判断是否有解(a.model()前必須先調用a.check())</span><br><span class="hljs-keyword">if</span> a.check()==sat:<br>    <span class="hljs-built_in">print</span>(a.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No resolve&quot;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">得到了s的数值</span><br><span class="hljs-string">s[7] = 100, s[3] = 108, s[5] = 49, s[0] = 102,</span><br><span class="hljs-string">s[2] = 108, s[6] = 110, s[1] = 97, s[4] = 119,</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>key = [<span class="hljs-number">0</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">11</span>,  <span class="hljs-number">12</span>, <span class="hljs-number">107</span>,  <span class="hljs-number">20</span>,  <span class="hljs-number">30</span>,  <span class="hljs-number">28</span>,  <span class="hljs-number">82</span>,<br> <span class="hljs-number">95</span>,  <span class="hljs-number">95</span>,  <span class="hljs-number">40</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">29</span>,  <span class="hljs-number">59</span>,  <span class="hljs-number">37</span>,  <span class="hljs-number">14</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">0</span>,<br> <span class="hljs-number">86</span>,  <span class="hljs-number">16</span>,  <span class="hljs-number">79</span>,  <span class="hljs-number">25</span>]<br>k = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    k += <span class="hljs-built_in">chr</span>((key[i] &amp; (s[i &amp; <span class="hljs-number">7</span>] ^ key[i]) | ~key[i] &amp; (~key[i] ^ ~s[i &amp; <span class="hljs-number">7</span>])))<br><br><span class="hljs-built_in">print</span>(k)<br></code></pre></td></tr></table></figure></li><li><p>使用矩阵方法求解（实质与使用z3一样）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入 numpy 模块</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#行交换</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">swap_row</span>(<span class="hljs-params">matrix, i, j</span>):<br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= m:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;错误! : 行交换超出范围 ...&#x27;</span>)<br>      <span class="hljs-keyword">else</span>:<br>          matrix[i],matrix[j] = matrix[j].copy(),matrix[i].copy()<br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#变成阶梯矩阵</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_change</span>(<span class="hljs-params">matrix</span>):<br>      m, n = matrix.shape<br>      main_factor = []<br>      main_col = main_row = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">while</span> main_row &lt; m <span class="hljs-keyword">and</span> main_col &lt; n:<br>          <span class="hljs-comment"># 选择进行下一次主元查找的列</span><br>          main_row = <span class="hljs-built_in">len</span>(main_factor)<br>          <span class="hljs-comment"># 寻找列中非零的元素</span><br>          not_zeros = np.where(<span class="hljs-built_in">abs</span>(matrix[main_row:,main_col]) &gt; <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br>          <span class="hljs-comment"># 如果该列向下全部数据为零，则直接跳过列</span><br>          <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(not_zeros) == <span class="hljs-number">0</span>:<br>              main_col += <span class="hljs-number">1</span><br>              <span class="hljs-keyword">continue</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># 将主元列号保存在列表中</span><br>              main_factor.append(main_col)<br>              <span class="hljs-comment"># 将第一个非零行交换至最前</span><br>              <span class="hljs-keyword">if</span> not_zeros[<span class="hljs-number">0</span>] != [<span class="hljs-number">0</span>]:<br>                  matrix = swap_row(matrix,main_row,main_row+not_zeros[<span class="hljs-number">0</span>])<br>              <span class="hljs-comment"># 将该列主元下方所有元素变为零</span><br>              <span class="hljs-keyword">if</span> main_row &lt; m-<span class="hljs-number">1</span>:<br>                  <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(main_row+<span class="hljs-number">1</span>,m):<br>                      a = <span class="hljs-built_in">float</span>(matrix[k, main_col] / matrix[main_row, main_col])<br>                      matrix[k] = matrix[k] - matrix[main_row] * matrix[k, main_col] / matrix[main_row, main_col]<br>              main_col += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> matrix,main_factor<br><br><br>  <span class="hljs-comment">#回代求解</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">back_solve</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-comment"># 判断是否有解</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(main_factor) == <span class="hljs-number">0</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主元错误,无主元！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> main_factor[-<span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无解！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      <span class="hljs-comment"># 把所有的主元元素上方的元素变成0</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(main_factor) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>          factor = matrix[i, main_factor[i]]<br>          matrix[i] = matrix[i] / <span class="hljs-built_in">float</span>(factor)<br>          <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>              times = matrix[j, main_factor[i]]<br>              matrix[j] = matrix[j] - <span class="hljs-built_in">float</span>(times) * matrix[i]<br>      <span class="hljs-comment"># 先看看结果对不对</span><br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#结果打印</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_result</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;阶梯矩阵为空！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span><br>      m, n = matrix.shape<br>      result = [<span class="hljs-string">&#x27;&#x27;</span>] * (n - <span class="hljs-number">1</span>)<br>      main_factor = <span class="hljs-built_in">list</span>(main_factor)<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-comment"># 如果不是主元列，则为自由变量</span><br>          <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> main_factor:<br>              result[i] = <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;(free var)&#x27;</span><br>          <span class="hljs-comment"># 否则是主元变量，从对应的行，将主元变量表示成非主元变量的线性组合</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># row_of_main表示该主元所在的行</span><br>              row_of_main = main_factor.index(i)<br>              result[i] = <span class="hljs-built_in">str</span>(matrix[row_of_main, -<span class="hljs-number">1</span>])<br>              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):<br>                  ratio = matrix[row_of_main, j]<br>                  <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-built_in">str</span>(ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>                  <span class="hljs-keyword">if</span> ratio &lt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;+&#x27;</span> + <span class="hljs-built_in">str</span>(-ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方程的通解是:&#x27;</span>, )<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;=&#x27;</span>, result[i])<br><br><br>  <span class="hljs-comment">#得到简化的阶梯矩阵和主元列</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">Handle</span>(<span class="hljs-params">matrix_a, matrix_b</span>):<br>      <span class="hljs-comment"># 拼接成增广矩阵</span><br>      matrix_01 = np.hstack([matrix_a, matrix_b])<br>      matrix_01, main_factor = matrix_change(matrix_01)<br>      matrix_01 = back_solve(matrix_01, main_factor)<br>      print_result(matrix_01, main_factor)<br>      <span class="hljs-keyword">return</span> matrix_01, main_factor<br><br><br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>      <span class="hljs-comment">#a = np.array([[0, 1, 1], [0, 1, 0], [1, 0, 0]])</span><br>      a = np.array([[<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">11</span>,<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>], [<span class="hljs-number">16</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">19</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">28</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">19</span>,<span class="hljs-number">0</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">34</span>,<span class="hljs-number">10</span>,<span class="hljs-number">17</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">1</span>,<span class="hljs-number">21</span>,<span class="hljs-number">1</span>,<span class="hljs-number">30</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      b = np.array([[<span class="hljs-number">6426</span>],[<span class="hljs-number">9801</span>],[<span class="hljs-number">6021</span>],[<span class="hljs-number">14444</span>],[<span class="hljs-number">7251</span>],[<span class="hljs-number">10054</span>],[<span class="hljs-number">10735</span>],[<span class="hljs-number">11646</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      Handle(a, b)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">20</span>)<br><br></code></pre></td></tr></table></figure><p>得到的x[1…8]就是解出来的Arglist，也是上文的s[0…8],使用上面的代码代入求解即可.<br />ps:解出来的为浮点数，记得需要进位操作</p></li></ul><h1 id="eztea"><a class="markdownIt-Anchor" href="#eztea"></a> EzTea</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><ul><li>查壳,放到IDA中查看,之后可以看出来是将输入进行加密,之后和原有之进行比较<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291151611.png" alt="202211121540089" /></li><li>然后根据查看tea中的内容，知道使用的就是xxtea加密，只不过将一些数据进行了修改<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291151464.png" alt="202211121555569" /><br />对比后发现修改的地方为:<span class="label label-primary">DELTA,z>>5变成z>>4,z<<4变成z<<5</span></li></ul><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><ul><li>xxtea的通用代码,根据题意进行了修改<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*原来</span><br><span class="hljs-comment">  DELTA 0x9e3779b9  </span><br><span class="hljs-comment">  MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//修改后 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 0x11451400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MX (((z^key[(p&amp;3)^e]) + (y^sum)) ^ ((z<span class="hljs-string">&lt;&lt;5^y&gt;</span>&gt;3) + (y<span class="hljs-string">&lt;&lt;2^z&gt;</span>&gt;4))) </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xxtea</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">int</span> n, <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> key[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> y, z, sum;<br>    <span class="hljs-type">unsigned</span> p, rounds, e;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)            <span class="hljs-comment">/* Coding Part */</span><br>    &#123;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = <span class="hljs-number">0</span>;<br>        z = v[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            sum += DELTA;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n - <span class="hljs-number">1</span>; p++)<br>            &#123;<br>                y = v[p + <span class="hljs-number">1</span>];<br>                z = v[p] += MX;<br>            &#125;<br>            y = v[<span class="hljs-number">0</span>];<br>            z = v[n - <span class="hljs-number">1</span>] += MX;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">-1</span>)      <span class="hljs-comment">/* Decoding Part */</span><br>    &#123;<br>        n = -n;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = rounds * DELTA;<br>        y = v[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = n - <span class="hljs-number">1</span>; p &gt; <span class="hljs-number">0</span>; p--)<br>            &#123;<br>                z = v[p - <span class="hljs-number">1</span>];<br>                y = v[p] -= MX;<br>            &#125;<br>            z = v[n - <span class="hljs-number">1</span>];<br>            y = v[<span class="hljs-number">0</span>] -= MX;<br>            sum -= DELTA;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> enc[] =<br>    &#123;<br>      <span class="hljs-number">0x82</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x96</span>,<br>      <span class="hljs-number">0x40</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x71</span>,<br>      <span class="hljs-number">0x3D</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x88</span>,<br>      <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span><br>    &#125;;<br>    <span class="hljs-type">uint32_t</span> key[] = &#123; <span class="hljs-number">0x19</span>,<span class="hljs-number">0x19</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x10</span> &#125;;<br>    <span class="hljs-comment">// 传入-9代表解密，9为v的长度，即n</span><br>    <span class="hljs-built_in">xxtea</span>((<span class="hljs-type">uint32_t</span>*)enc, <span class="hljs-number">-9</span>, (<span class="hljs-type">uint32_t</span>*)key);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,enc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="annnnnggrr"><a class="markdownIt-Anchor" href="#annnnnggrr"></a> Annnnnggrr</h1><ul><li>考察angr的知识点,直接一把梭</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>):<br>    bin_path = argv[<span class="hljs-number">1</span>]<br>    p = angr.Project(bin_path)<br><br>    start_addr = <span class="hljs-number">0x140001103</span> <span class="hljs-comment"># 跳过输入，从获取输入内存开始</span><br>    init_state = p.factory.blank_state(addr = start_addr)<br><br>    passwd = claripy.BVS(<span class="hljs-string">&quot;passwd&quot;</span>,<span class="hljs-number">32</span>*<span class="hljs-number">8</span>)<span class="hljs-comment"># 创建向量，32个char类型</span><br>    pass_addr = <span class="hljs-number">0x140005640</span> <span class="hljs-comment"># 存放输入数据的内存地址</span><br>    init_state.memory.store(pass_addr, passwd) <span class="hljs-comment"># 将创建的向量加载到内存地址中</span><br><br>    sm = p.factory.simgr(init_state)<br>    sm.explore(find = <span class="hljs-number">0x14000248A</span>) <span class="hljs-comment"># 找到开始对比的地址处</span><br><br>    <span class="hljs-comment"># 将运行数据和内置数据进行对比</span><br>    enc = [<span class="hljs-number">0x4F</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0xCA</span>]<br>    <br>    <span class="hljs-keyword">if</span> sm.found:<br>        check_state = sm.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>            <span class="hljs-comment"># 加载相应地址上的输入到 ch 中</span><br>            ch = check_state.memory.load(pass_addr + i, <span class="hljs-number">1</span>)<br>            check_state.solver.add(ch == enc[i]) <span class="hljs-comment">#add添加约束，不满足则重新找</span><br>        <span class="hljs-comment"># 得到最终的数据</span><br>        res = check_state.solver.<span class="hljs-built_in">eval</span>(passwd,cast_to = <span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;No&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br></code></pre></td></tr></table></figure><h1 id="the-sliders-labyrinth"><a class="markdownIt-Anchor" href="#the-sliders-labyrinth"></a> The Slider’s Labyrinth</h1><ul><li>无壳，直接看，发现有两处花指令，直接把 E8 <code>nop</code> 掉，然后生成函数</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232049500.png" alt="image-20230423204916419" /></p><ul><li>之后发现是一个 maze，这里知道遇见 <code>#</code> 才会停止</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232048777.png" alt="image-20230423204808646" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">################</span><br><span class="hljs-string">#*        #    #</span><br><span class="hljs-string">#              #</span><br><span class="hljs-string">#    #         #</span><br><span class="hljs-string">##             #</span><br><span class="hljs-string">#        #    ##</span><br><span class="hljs-string">#   #          #</span><br><span class="hljs-string">#              #</span><br><span class="hljs-string">#    #      # O#</span><br><span class="hljs-string">################</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>然后走最短路径为 <code>dsasdwds</code></li></ul><h1 id="funnyotl"><a class="markdownIt-Anchor" href="#funnyotl"></a> funnyOTL</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><ul><li>无壳，直接看，发现进行了伪随机数参与的加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232116152.png" alt="image-20230423211637028" /></p><ul><li>动调获得每一次的 <code>posLogMe</code> 和 最后的 <code>enc</code>，然后求解</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232118527.png" alt="image-20230423211844458" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232118923.png" alt="image-20230423211852840" /></p><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>enc = [<span class="hljs-number">0x4C</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x5F</span>,<br>       <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x61</span>,<br>       <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x5F</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag&#123;&#x27;</span>+<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">18</span>+<span class="hljs-string">&#x27;&#125;&#x27;</span>)  <span class="hljs-comment"># flag&#123;123456789012345678&#125;</span><br><br>order = [<span class="hljs-number">0x12</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0xa</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0xa</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xc</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>]  <span class="hljs-comment"># 动态调试获得</span><br><br>string_3 = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span><br>string_4 = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">22</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>):<br>    posCur=i<br>    posLogMe=order[i//<span class="hljs-number">2</span>]<br><br>    string_3[<span class="hljs-number">1</span>]= enc[posLogMe + <span class="hljs-number">1</span>]<br>    string_3[<span class="hljs-number">0</span>] =enc[posLogMe]<br><br>    string_4[<span class="hljs-number">0</span>] = enc[posCur]<br>    string_4[<span class="hljs-number">1</span>] = enc[posCur + <span class="hljs-number">1</span>]<br><br>    string_3[<span class="hljs-number">1</span>] = (~(string_3[<span class="hljs-number">1</span>])&amp;<span class="hljs-number">0xff</span>) ^ posLogMe <span class="hljs-comment"># 这里的处理需要注意</span><br>    string_3[<span class="hljs-number">0</span>] = string_3[<span class="hljs-number">0</span>]^posLogMe&amp;<span class="hljs-number">0xff</span><br><br>    enc[posLogMe] = string_4[<span class="hljs-number">0</span>]<br>    enc[posLogMe + <span class="hljs-number">1</span>] = string_4[<span class="hljs-number">1</span>]<br><br>    enc[posCur+<span class="hljs-number">1</span>] = string_3[<span class="hljs-number">1</span>]<br>    enc[posCur] = string_3[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(enc[i]), end=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># &#125;LTS_wonk_u_w0n_LTO&#123;galf</span><br><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#125;LTS_wonk_u_w0n_LTO&#123;galf&#x27;</span>[::-<span class="hljs-number">1</span>])<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week2</title>
    <link href="/posts/2f0d53cc.html"/>
    <url>/posts/2f0d53cc.html</url>
    
    <content type="html"><![CDATA[<h1 id="前人后者"><a class="markdownIt-Anchor" href="#前人后者"></a> 前…人，后…者</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>查壳之后是32位程序，IDA打开<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147000.png" alt="202211081105733" /></li><li>使用<span class="label label-primary">sub_4113DE</span>对输入进行加密<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147034.png" alt="202211081110311" /></li><li>观察特点，上面是凯撒加密，之后价格结果与0x22异或<br />查看<span class="label label-primary">byte_41A004</span><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147160.png" alt="202211081113384" /><br />得到经过凯撒加密，然后异或之后的结果</li></ul><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">81</span>, <span class="hljs-number">91</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">89</span>,  <span class="hljs-number">77</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">84</span>,  <span class="hljs-number">67</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">71</span>,  <span class="hljs-number">80</span>,<br>  <span class="hljs-number">125</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">78</span>,  <span class="hljs-number">64</span>,  <span class="hljs-number">74</span>,  <span class="hljs-number">95</span>]<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-built_in">str</span>+=<span class="hljs-built_in">chr</span>(a[i]^<span class="hljs-number">0x22</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[i], end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148316.png" alt="202211081130028" /></p><h1 id="findme"><a class="markdownIt-Anchor" href="#findme"></a> FindMe</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148685.png" alt="202211092056077" /><br />该程序经过<span class="label label-primary">sub_1BCD</span>使得dword_5040 == 1即可得到flag</p><p>怎经过调试，可以看到关键的函数<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148532.png" alt="202211092101605" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148972.png" alt="202211092101271" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148828.png" alt="202211092102474" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148741.png" alt="202211092103231" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148418.png" alt="202211092103704" /><br />大致的含义是首先对s进行赋0，然后经过位运算，异或之后进行得到dword_5020，求解就是逆推进行求解</p><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><ul><li>首先由dword_5020获得最后的数据<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148156.png" alt="202211092108307" /><br />则首先经过异或右移17，之后再右移0x2022</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><ul><li>之后经过位运算<br />|为按位或运算，只要对应两个二进制位有一个为1时，结果就为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br>flag = [<span class="hljs-string">&#x27;&#x27;</span>]*<span class="hljs-number">32</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>,<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">ascii</span> = s[i//<span class="hljs-number">4</span>] &gt;&gt; (<span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        还原或运算，每次左移在后面补零，又与之后的s[i]位运算将零替换成s[i]的值</span><br><span class="hljs-string">        即最后的s[i]由s[i]本身与s[i]左移之后的数相加而成(左移位数远远超过本身，按位或就成为了相加),则逆推需要减去</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        s[i//<span class="hljs-number">4</span>] = s[i//<span class="hljs-number">4</span>] - (<span class="hljs-built_in">ascii</span> &lt;&lt; <span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        flag[i+(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>)] = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ascii</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure><h1 id="petals"><a class="markdownIt-Anchor" href="#petals"></a> Petals</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149363.png" alt="202211172010055" /></p><p>找到main函数，观察<code>loc_1209</code>是指令，可能反编译有问题，点击进去看看</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149708.png" alt="202211172012817" /></p><p>在下面找到一个错误的提示，按D转换成原始数据形式</p><p>对E8使用Patcher直接nop掉，之后按c转换为代码，同时将此指令<code>loc_1209</code>按P转换为函数，之后就转换成函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149728.png" alt="202211172017531" /></p><p>而<code>sub_160C</code>是一个比较函数，若是输入的值与最后存储的值相同，那么就是输入对了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>* input, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+18h] [rbp-118h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+1Ch] [rbp-114h]</span><br>__int64 v5[<span class="hljs-number">33</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br><span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br><span class="hljs-built_in">memset</span>(v5, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">255</span>; ++i)<br>*((BYTE*)v5 + i) = ~(i ^ len);<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; len &gt; j; ++j)<br>input[j] = *((BYTE*)v5 + (<span class="hljs-type">unsigned</span> __int8)input[j]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> enc[] =<br>&#123;<br>  <span class="hljs-number">0xD0</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x89</span>,<br>  <span class="hljs-number">0x92</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0xD1</span>,<br>  <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x87</span>,<span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-type">char</span> flag[<span class="hljs-number">56</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) &#123;<br>flag[i] = j;<br><span class="hljs-built_in">func</span>(flag, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">if</span> (flag[i] == enc[i]) &#123;<br>cout &lt;&lt; (<span class="hljs-type">char</span>)j;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 66ccff#luotianyi#b074d58a</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="likemyasp"><a class="markdownIt-Anchor" href="#likemyasp"></a> Likemyasp</h1><h2 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h2><ul><li><p>有壳</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230926089.png" alt="image-20230423092643020" /></p></li><li><p>upx尝试了脱不了，试试手动脱壳</p></li></ul><p>​直接在 x64dbg中脱壳，首先加载后按 F9 来到了加壳之后的 OEP处 (这里的 EP 是加壳后的EP，我们需要找到加壳前的 EP)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230931775.png" alt="image-20230423093143699" /></p><p>​之后 <code>Ctrl + n</code> 在 <code>VirtualProtect</code> 处右键/F2下断点。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230944510.png" alt="image-20230423094446475" /></p><p>​然后 <code>F9</code> 执行，发现总共会命中两次，在第二次命中的时候按 <code>ALT + F9</code> 退出此函数体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230947235.png" alt="image-20230423094701172" /></p><p>​之后一直 <code>F8</code> 单步调试，直到走不动了，这个就是等待IO操作的时候，可以重新调试发现 <code>main</code> 函数的地方就是在这个函数中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230950356.png" alt="image-20230423095011293" /></p><p>​再次观察可以发现前面两个是传参的地方，之后<code>F7</code> 步进函数内，发现有显示的文字，那么大概可以判断这里就是脱壳后的程序了，然后用 <code>Scylla</code> dump 并修复</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230951176.png" alt="image-20230423095148133" /></p><ul><li>之后就可以看出来函数的逻辑了</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230954433.png" alt="image-20230423095435400" /></p><h2 id="动调"><a class="markdownIt-Anchor" href="#动调"></a> 动调</h2><ul><li>不脱壳，直接动调。在最多逻辑的函数(猜测这是加密过程)中对最后下断点进行动调</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231029385.png" alt="image-20230423102904343" /></p><ul><li><code>F8</code> 进行步过，然后一直走到卡住的地方(等待IO输入)，然后进入函数体就可以发现主函数逻辑了</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231027691.png" alt="image-20230423102747612" /></p><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">chipher = [<span class="hljs-number">0xD803C1FC098</span>, <span class="hljs-number">0xE20360BC097</span>, <span class="hljs-number">0xFE02A1C00A0</span>, <span class="hljs-number">0xFA0121040CB</span>, <span class="hljs-number">0xF2032104092</span>, <span class="hljs-number">0xD6015884082</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(chipher)):<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">37</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0xa</span>)<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">23</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0x14</span>)<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">14</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0x1e</span>)<br>    flag += <span class="hljs-built_in">chr</span>(~(chipher[i])&amp; <span class="hljs-number">0xff</span>)<br><span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure><h1 id="ur_so_native"><a class="markdownIt-Anchor" href="#ur_so_native"></a> ur_so_native</h1><h2 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h2><ul><li>一个apk文件，直接在jadx中分析，去到<code>com.new_star_ctf.u_navie/MainActivity</code>查看程序的逻辑<ul><li>之后发现加密函数 <code>encry</code> ,它的前面有个 <code>native</code> 的关键字，代表函数在 <code>native</code> 层实现。而native层实现的函数保存在 <code>.so</code> 文件中， <code>.so</code> 文件位于apk文件解压后<code>\lib</code> 层下</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231039751.png" alt="image-20230423103941691" /></p><ul><li>將 <code>libencry.so</code> 拉入IDA，找到 <code>encry</code> 函数，会发现一堆奇怪的东西。这是一种名为 <code>JNI</code> 的东西导致 IDA分析错误 <a href="https://zh.wikipedia.org/zh-cn/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3">什么是JNI</a></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231040054.png" alt="image-20230423104049001" /></p><ul><li>之后对应 <code>JNI</code> 函数原型，手动修改 <code>entry</code> 函数的参数类型(按<code>y</code>)</li><li><a href="https://blog.csdn.net/yb493071294/article/details/80378730">还原 JNI 函数名</a></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231111060.png" alt="image-20230423111118023" /></p><p>这里查看加密很奇怪，就附上别人的链接(懒得写了)</p><p><a href="https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html">NewStartCTF</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week1</title>
    <link href="/posts/b6040276.html"/>
    <url>/posts/b6040276.html</url>
    
    <content type="html"><![CDATA[<h1 id="hello_reversing"><a class="markdownIt-Anchor" href="#hello_reversing"></a> Hello_Reversing</h1><h2 id="查壳"><a class="markdownIt-Anchor" href="#查壳"></a> 查壳</h2><ul><li>首先使用exeinfope查一下壳<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142134.png" alt="202210282330917" /></li><li>由图所示，此程序是64位程序，没有壳（Not packed）</li></ul><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>使用ida打开程序，找到主函数（main）界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142425.png" alt="202210282333815" /></li><li>观察伪代码的信息，看到有&quot;3vers1ng_w0rld}&quot;，猜测此为flag的一半，另外一半可能也是这样的展示方式，则使用Shift+F12直接搜索程序中的字符串.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142526.png" alt="202210282337023" /></li><li>最后发现字符串的另一半在<a href="https://www.cnblogs.com/lsgxeva/p/8947829.html">.rdata</a>段中<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142422.png" alt="202210290824478" /></li><li>找到了flag的前半部分，点击进入汇编界面。在相应显示flag前半段的位置处，直接按Shift+e进行提取，那么就得到了flag.</li></ul><h1 id="pyre"><a class="markdownIt-Anchor" href="#pyre"></a> Pyre</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><ul><li><p>得到文件pyre.exe，由文件名字可以看出这个是由py文件编译成的exe文件，则使用<a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor.py</a>可以将pyre进行反编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> pyinstxtractor.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p>运行成功<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143942.png" alt="202210290851753" /></p></li><li><p>反编译后，会生成一个文件夹,其中的.pyc文件就是由.exe反编译得到的，现在需要将.pyc反编译成.py文件<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143490.png" alt="202210290854071" /></p></li></ul><h2 id="反编译"><a class="markdownIt-Anchor" href="#反编译"></a> 反编译</h2><ol><li><p>直接使用<a href="https://tool.lu/pyc/">在线网站</a>进行反编译</p></li><li><p>使用<a href="https://github.com/rocky/python-uncompyle6">uncompyle6</a>进行反编译</p></li></ol><ul><li>uncompyle6可将python字节码转换回等效的python源代码，它接受python 1.3版到3.8版的字节码</li><li>安装</li></ul>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> uncompyle6<br></code></pre></td></tr></table></figure><ul><li>使用示例</li></ul>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">uncompyle6 -<span class="hljs-keyword">o</span> fliename.<span class="hljs-keyword">py</span> <span class="hljs-keyword">file</span>.pyc #  对filename.pyc文件进行反编译，输出为<span class="hljs-keyword">file</span>.<span class="hljs-keyword">py</span>文件<br></code></pre></td></tr></table></figure><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><ul><li><p>查看反编译后的.py源代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">flag = <span class="hljs-string">&#x27;&#x27;</span><br>encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>    tmp = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">input</span>)):<br>        tmp += <span class="hljs-built_in">input</span>[table[i]]<br><br>    <span class="hljs-keyword">return</span> tmp<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please input your flag:&#x27;</span>)<br>    flag = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) != <span class="hljs-number">23</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Length Wrong!!&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        final = enc(flag)<br>        <span class="hljs-keyword">if</span> final == encode:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wow,you get the right flag!!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Sorry,Your input is Wrong&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>此加密为将flag打乱顺序，将table的值作为下标进行输出，则可以构造和encode等长的列表，进行逆操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br>flag = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode))]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode)):<br>    flag[table[i]] = encode[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure></li></ul><h1 id="baby_re"><a class="markdownIt-Anchor" href="#baby_re"></a> Baby_Re</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><ul><li><p>64位程序.使用ida打开程序，找到主函数（main）界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143901.png" alt="202210291704483" /></p><p>由main函数界面，可以看出此题是输入一个字符串，先进行与i异或，之后经过compare函数，正确返回为1</p></li><li><p>跟进compare函数，发现是用final与s进行比较<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143700.png" alt="202210291708684" /><br />可以知道flag（输入的字符串)为32位长，然后遍历输入的字符串，要求和final一样,跟进final，</p></li><li><p>按Shift+e提取数据<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143724.png" alt="202210291712101" /></p></li></ul><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">86</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">98</span>, <span class="hljs-number">98</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>, <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">121</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><ul><li>运行出来的flag为flag{Something_run_before_main?}</li><li>提交发现这个flag是一个假的，之后根据题意与线索，发现有4个bytes不一样<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143889.png" alt="202210291724280" /></li><li>跟进function进行查看<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143970.png" alt="202210291726414" /><br />发现对于这四个位置进行了修改，之后更改exp,修改这4个位置的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>, <span class="hljs-number">86</span>, <span class="hljs-number">54</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>, <br>  <span class="hljs-number">58</span>, <span class="hljs-number">98</span>, <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">38</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">63</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h1 id="easyre"><a class="markdownIt-Anchor" href="#easyre"></a> EasyRe</h1><h2 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h2><ul><li>题目为.exe文件和.dll文件.对.exe查壳,无壳,64位,在ida中查看.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143629.png" alt="202210291954295" /><br />首先exe会加载dll，调用dll里的函数，图中的红框.同时这里的57行将ProcAddress定义为enc.dll中的encode函数<br />之后就是将输入的字符串经过encode后与Str2进行比较，相等则得到flag</li><li>继续分析enc.dll<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291144593.png" alt="202210292004505" /><br />跟进return进行查看<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291145266.png" alt="202210292004268" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146960.png" alt="202210292005284" /><br />则enc.dll大致是将输入的字符串a1进行一个加密操作之后赋值给a2，之后a2与Str(Reverse)进行异或输出a2</li><li>enc.dll的加密操作复杂，使用Shift+F12查看有没有可以使用的信息<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146739.png" alt="202210292009641" /><br />看到一串字符，判定为base64编码，即加密就是base加密</li></ul><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><ul><li>这里final[14]题目中没有告知,先当0进行处理,成功获得flag;若是不能，可以爆破final[14],对其遍历所有ascii爆破最后的flag.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>final = [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">40</span>, <span class="hljs-number">64</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">60</span>, <span class="hljs-number">46</span>, <span class="hljs-number">43</span>, <span class="hljs-number">30</span>, <span class="hljs-number">61</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>,<br>        <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">60</span>, <span class="hljs-number">21</span>, <span class="hljs-number">40</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">63</span>, <span class="hljs-number">42</span>, <span class="hljs-number">57</span>, <span class="hljs-number">9</span>, <span class="hljs-number">49</span>, <span class="hljs-number">86</span>, <span class="hljs-number">36</span>, <span class="hljs-number">28</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;?$P&lt;,%#K&#x27;</span>:<br>    final.append(<span class="hljs-built_in">ord</span>(i))<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Reverse&#x27;</span><br><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag.append(<span class="hljs-built_in">chr</span>(final[i] ^ <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i % <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)])))<br><br>content = base64.b64decode(<span class="hljs-string">&#x27;&#x27;</span>.join(flag).encode())<br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><h1 id="艾克体悟题"><a class="markdownIt-Anchor" href="#艾克体悟题"></a> 艾克体悟题</h1><p>作者给了提示：<a href="https://note.youdao.com/ynoteshare/index.html?id=a006b246edc7fc65ed20abbc2d9c5351&amp;type=note&amp;%5C_time=1663716620460">点击这里</a></p><h2 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h2><ul><li>有题目可以得知，在模拟器中直接打开apk文件<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146756.png" alt="202211072352571" /></li><li>则使用<span class="label label-info">adb shell</span>启动指定的Activity</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span>   进入<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.droidlearn.activity_travel/.FlagActivity   按上述地址路径，打开指定控件<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146943.png" alt="202211072353036" /></p><h2 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h2><ol><li>使用python中的 pyautogui 库控制鼠标自动进行连点操作</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyautogui <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br>pd.FAILSAFE = <span class="hljs-literal">True</span><br><br>time.sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#3秒时间自己移动到要点击的位置</span><br>pd.click(clicks=<span class="hljs-number">100000</span>,interval=<span class="hljs-number">0.0001</span>)<br><span class="hljs-comment"># pyautogui.click()</span><br><span class="hljs-comment"># (100,100, clicks=2,interval=0.5,button=‘right’,duration=0.2)</span><br><span class="hljs-comment"># 位置，点击次数，间隔时间，右键(默认左键)，移动间隔</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_61774705/article/details/127165732">exp参考此篇文章</a></p><ol start="2"><li>使用apk反编译后重新打包，将1w的数值修改为1</li></ol><ul><li><p>下载<a href="https://ibotpeaches.github.io/Apktool/">下载apktool</a>,此工具作用就是将apk反编译和重新打包<br />输入`</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>apktool_2.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">jar </span>d &lt;filepath&gt; -o &lt;newfilename&gt;<br></code></pre></td></tr></table></figure><p>生成文件夹.<br />进入文件夹 <code>demo\smali\com\droidlearn\activity_travel</code> 路径找 <code>FlagActivity$1.smali</code> 文件，此文件可以直接用编辑器打开<br />在此文件中寻找到到0x2710（10000）十六进制，修改为0x1即为点击1次即可.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146717.png" alt="202211080956544" /></p></li><li><p>重新打包</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">java -jar apktool_2<span class="hljs-number">.6</span><span class="hljs-number">.1</span>.jar b &lt;<span class="hljs-keyword">new</span><span class="hljs-type">filename</span>&gt; -o &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146071.png" alt="202211081009495" /><br />打包成功即生成一个.apk，但此时的apk不可使用，还需安装签名.</p></li><li><p>测试<br />安装至夜神模拟器，用/nox/bin目录下的adb工具进行安装，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">adb install &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146818.png" alt="202211081012000" /><br />安装失败，这是没有签名导致的.</p></li><li><p>生成口令文件<br />使用JRE环境变量下的keytool生成口令文件,<a href="https://blog.csdn.net/w47_csdn/article/details/87564029">详细参考</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -genkey -alias testalias -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">36500</span> -keystore &lt;filename&gt;.keystore`<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147006.png" alt="202211081018301" /><br />输入回答，之后在当前目录下生成一个.keystore文件，使用<code>keytool -list -v -keystore &lt;filename&gt;.keystore</code>可以查看详细信息.</p></li><li><p>签名</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">jarsigner -<span class="hljs-keyword">verbose</span> -keystore <span class="hljs-symbol">&lt;filename&gt;</span>.keystore -storepass <span class="hljs-symbol">&lt;password&gt;</span> -signedjar <span class="hljs-symbol">&lt;newfile&gt;</span>.apk <span class="hljs-symbol">&lt;filename&gt;</span>.apk testalias<br></code></pre></td></tr></table></figure><p>其中<br />-<span class="label label-default">keystore + 签名文件</span><br><br />-<span class="label label-default">sotrepass + 签名口令密码</span> <br><br />-<span class="label label-default">signedjar后跟三个参数 分别是签名后的apk文件 需要签名的apk文件 签名的别名</span><br></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147430.png" alt="202211081027234" /></p><p>签名成功，之后下载此flag.apk,启动指定的<span class="label label-info">FlagActivity$1.smali</span>，则可以得到flag<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147214.png" alt="202211081044884" /><br /><a href="https://www.anyiblog.top/2022/09/25/20220925/#Re5-%E8%89%BE%E5%85%8B%E4%BD%93%E6%82%9F%E9%A2%98">exp参考此篇文章</a></p></li><li><p>补充<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147062.png" alt="202211081042328" /><br />下载时若是出现此报错，需要删除之前下载的那个apk，<a href="https://blog.csdn.net/qq_42351033/article/details/122450733">解决方案</a><br />进入adb shell之后可以通过<code>pm list package</code>列出模拟器中所有的包</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Crypto &amp; 算法</title>
    <link href="/posts/108720dc.html"/>
    <url>/posts/108720dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础操作"><a class="markdownIt-Anchor" href="#基础操作"></a> 基础操作</h1><h2 id="转化"><a class="markdownIt-Anchor" href="#转化"></a> 转化</h2><h3 id="-str"><a class="markdownIt-Anchor" href="#-str"></a> -&gt;Str</h3><ul><li><code>chr(a)</code><ul><li>将int类型的a根据其ascii码转化为str字符</li></ul></li><li><code>hex(a)</code><ul><li>将int类型的a转化为其十六进制str类型</li></ul></li><li><code>str(a)</code><ul><li>将所有类型的a按照其本身转化为str类型</li></ul></li><li><code>str = a.decode()</code><ul><li>将bytes类型的a转化为str类型</li></ul></li></ul><h3 id="-int"><a class="markdownIt-Anchor" href="#-int"></a> -&gt;Int</h3><ul><li><p><code>int(a,k)</code></p><ul><li>a为k进制数，使用 <code>int</code>将k进制数的a转化为十进制数</li><li><code>int(a)</code>直接将字符a转化为int类型，此时a必须为数字字符<ul><li>注意：不是转化为ascii码，而是转化为数字类型，即值不变，类型改变</li></ul></li></ul></li><li><p><code>eval(a)</code></p><ul><li>将str类型的十六进制数a转化为int类型(这里十六进制需要加上0x)</li></ul></li><li><p><code>ord(a)</code></p><ul><li>将字符类型的a按其ascii码转化为int类型</li></ul></li></ul><h3 id="-bytes"><a class="markdownIt-Anchor" href="#-bytes"></a> -&gt;Bytes</h3><ul><li><code>str.encode(encoding='utf-8')</code><ul><li>这里 <strong>utf-8是默认选项</strong>，也可以选择不填，即encode()<ul><li>str转换成 bytes 用 encode() 方法</li><li><code>bytes=b'\xe4\xba\xba\xe7\x94'</code>—bytes的形式</li></ul></li></ul></li></ul><h2 id="技巧"><a class="markdownIt-Anchor" href="#技巧"></a> 技巧</h2><ul><li><p><code>join()</code></p><ul><li><code>print(''.join(list))</code>直接输出将列表拼接成字符串的结果<ul><li>list存储的是字符，例如list = [‘a’,‘c’,‘r’]</li><li>本意为隔一个’‘输出list的一个值，由于’'中间没有间隔，则即直接将list进行拼接</li></ul></li></ul></li><li><p><code>flag = key.split(' ')</code></p><ul><li>将字符key切割为列表类型，分界线为 <code>' '</code></li></ul></li><li><p><code>key = [i for i in range(10)]</code></p><ul><li><code>key</code>初始化——遍历 <code>i</code>，同时将i赋值给key[i]</li></ul></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ul><li><code>pow(a,b,c)</code><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>c</mi></mrow><annotation encoding="application/x-tex">pow(a,b,c) == a^{b}\  \% \ c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.904668em;vertical-align:-0.05556em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathnormal">c</span></span></span></span></li></ul></li></ul><h1 id="crypto库"><a class="markdownIt-Anchor" href="#crypto库"></a> Crypto库</h1><h2 id="utilnumber"><a class="markdownIt-Anchor" href="#utilnumber"></a> Util.number</h2><ul><li><p><code>bytes_to_long</code>与 <code>long_to_bytes</code></p><ul><li><code>bytes_to_long</code>将字节流转换位long类型数字，即最后一位字符转为ASCii之后乘以2<code>&lt;sup&gt;</code>0<code>&lt;/sup&gt;</code>, 往前的字符乘以2<code>&lt;sup&gt;</code>1<code>&lt;/sup&gt;</code>, 2<code>&lt;sup&gt;</code>2<code>&lt;/sup&gt;</code>……</li><li><code>long_to_bytes</code>将long类型数字转换为bytes类型，是 <code>bytes_to_long</code>的逆运算</li></ul></li><li><p><code>getPrime(n_lebgth)</code></p><ul><li>反复使用素性检测算法验证以获素随机数,其长度为2<code>&lt;sup&gt;</code>n<code>&lt;/sup&gt;</code></li></ul></li><li><p><code>getStrongPrime(n_lebgth)</code></p><ul><li>获得满足RSA要求的大素数</li></ul></li><li><p><code>inverse(a,n)</code></p><ul><li>求a模n的逆元</li><li>对于正整数 a, n，如果有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax ≡ 1 \ (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，则称 x 的最小正整数解为 a 模 n的逆元</li></ul></li><li><p><code>getRandomNBitInteger(N)</code></p><ul><li>获得N比特的随机数（也就是保证最高位非0，且长度为2<code>&lt;sup&gt;</code>N<code>&lt;/sup&gt;</code>）</li></ul></li><li><p><code>gad(a,b)</code></p><ul><li>获得a与b的最大公约数</li></ul></li></ul><h1 id="算法原理"><a class="markdownIt-Anchor" href="#算法原理"></a> 算法原理</h1><h2 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> Base64</h2><h3 id="算法原理-2"><a class="markdownIt-Anchor" href="#算法原理-2"></a> 算法原理</h3><ul><li>原理：使用64个可打印字符表示二进制所有数据的方法。这里由于 $ 2^6 = 64$ ，则使用 6 个位元作为一个单元，对应一个可打印字符。那么可以使用 3 个字节来对应 4 个 Base64 的可打印字符来表示。</li><li>Base64的可打印字符包括 字母 <strong>A-Z</strong> 、<strong>a-z</strong>，数字 <strong>0-9</strong>、和 “ +/ ” 一共 64 个可打印字符</li><li>转换规则：</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304031958591.png" alt="image-20230403195843560" /></p><h3 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h3><h4 id="base32与base16"><a class="markdownIt-Anchor" href="#base32与base16"></a> base32与base16</h4><ul><li><code>b32encode(bytes)</code>与 <code>b32decode()</code><ul><li>bytes必须是由str类型经过str.encode()转换而得来</li></ul></li><li><code>b32hexencode(bytes)</code>与 <code>b32hexdecode()</code><ul><li>与上面的相同</li></ul></li><li><code>b16</code>与 <code>b32</code>相同</li></ul><h4 id="base64-2"><a class="markdownIt-Anchor" href="#base64-2"></a> base64</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>encrypt = base64.b64encode(<span class="hljs-string">&#x27;AlwaysBeta&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-comment"># Python3 中字符都是 unicode 编码，而 b64encode函数的参数为 byte 类型，所以必须先转码</span><br>decrypt = base64.b64decode(a)<br><br><span class="hljs-comment"># 换表解密</span><br>new_table = <span class="hljs-string">&quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>old_table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>cipher = <span class="hljs-string">&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;</span>.swapcase()<br><span class="hljs-comment">#swapcase是大小写转化，大写转小写等</span><br><span class="hljs-built_in">print</span>(base64.b64decode(cipher.translate(<span class="hljs-built_in">str</span>.maketrans(new_table, old_table))))<br></code></pre></td></tr></table></figure><h2 id="rc4"><a class="markdownIt-Anchor" href="#rc4"></a> RC4</h2><blockquote><pre><code class="hljs">RC4的最终实现还是使用构造出来的盒子和你的输入进行异或，那么可以直接动调找到那个盒子，记录盒子的值，直接和最后比对的数据进行异或就可以得到flag。</code></pre></blockquote><h3 id="算法原理-3"><a class="markdownIt-Anchor" href="#算法原理-3"></a> 算法原理</h3><ul><li><p>原理：<strong>对明文使用同一个密钥异或两次最后仍是得到原文</strong>。</p><ul><li>即生成密钥之后，由密钥与明文异或后生成密文(加密过程)，由同一密钥与密文异或后得到明文 (解密过程)</li></ul></li><li><p>过程：</p><ol><li>初始化状态向量S(256个字节)</li><li>初始化密钥得到向量T(256个字节)，初始化就是将密钥轮换填充到T中</li><li>对向量S进行置换操作</li><li>密钥流的生成和加密(最后依旧是S异或明文生成密文)</li></ol></li></ul><h3 id="算法实现-2"><a class="markdownIt-Anchor" href="#算法实现-2"></a> 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4 <span class="hljs-keyword">as</span> rc4cipher<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4</span>(<span class="hljs-params">pattern, data, key1</span>):<br>    <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">&quot;encrypt&quot;</span>:<br>        key = <span class="hljs-built_in">bytes</span>(key1, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        enc = rc4cipher.new(key)<br>        res = enc.encrypt(data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>        res=base64.b64encode(res)<br>        res = <span class="hljs-built_in">str</span>(res,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&quot;decrypt&quot;</span>:<br>        data = base64.b64decode(data)<br>        key = <span class="hljs-built_in">bytes</span>(key1, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        enc = rc4cipher.new(key)<br>        res = enc.decrypt(data)<br>        res = <span class="hljs-built_in">str</span>(res,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    data = <span class="hljs-string">&#x27;测试&#x27;</span><br>    key = <span class="hljs-string">&#x27;l2ru8181z&#x27;</span><br>  <br>    encrypt = rc4(<span class="hljs-string">&#x27;encrypt&#x27;</span>,data,key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;加密的结果：<span class="hljs-subst">&#123;encrypt&#125;</span>&quot;</span>)<br>    decrypt = rc4(<span class="hljs-string">&#x27;decrypt&#x27;</span>, encrypt, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解密的结果：<span class="hljs-subst">&#123;decrypt&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="tea"><a class="markdownIt-Anchor" href="#tea"></a> TEA</h2><h3 id="算法原理-4"><a class="markdownIt-Anchor" href="#算法原理-4"></a> 算法原理</h3><p><a href="https://taardisaa.github.io/2021/09/24/TEA/">TEA，XTEA，XXTEA加密算法概要</a></p><ul><li><p>关于TEA的一点心得</p><ol><li><p>解密时需要准确判断sum的状态(最后sum的数值是多少，要把它放在什么位置)</p></li><li><p>数据可以直接使用IDA伪代码里提供的数据，不需要再进行小端序转换(汇编需要用lazyida插件)。不过最后的时候需要每4个字节从后往前进行拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(ut32* m, ut32 n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%08x &quot;</span>, m[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; len;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">3</span>; k &gt;= <span class="hljs-number">0</span>; k --)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,((m[j]&gt;&gt;( <span class="hljs-number">8</span> * k )) &amp; <span class="hljs-number">0xff</span>));<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python实现也需要将每个 <code>int</code> 类型从而往前转化为字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">result = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>):<br>    result += <span class="hljs-built_in">chr</span>((res[i]) &amp; <span class="hljs-number">0xff</span>)<br>    result += <span class="hljs-built_in">chr</span>((res[i] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>)<br>    result += <span class="hljs-built_in">chr</span>((res[i] &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>)<br>    result += <span class="hljs-built_in">chr</span>((res[i] &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li><li><p>python还可以使用内置函数进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = decrypt(n, v, k)<span class="hljs-comment"># res为数组</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:<br>        <span class="hljs-built_in">print</span>(r.to_bytes(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;little&#x27;</span>).decode(), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># 参考 DASCTF &amp; CBCTF 2023 auuuu3的Exp</span><br><span class="hljs-comment"># 这里libnum.n2s()也可以转换，但是它是逆序输出，需要转换一下      </span><br></code></pre></td></tr></table></figure></li><li><p>python使用struct进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [<span class="hljs-number">1767863401</span>, <span class="hljs-number">1700945779</span>, <span class="hljs-number">1633644133</span>, <span class="hljs-number">1852795999</span>, <span class="hljs-number">1633967975</span>, <span class="hljs-number">1769430905</span>, <span class="hljs-number">1970235508</span>, <span class="hljs-number">1870225268</span>, <span class="hljs-number">2037210997</span>, <span class="hljs-number">1769104991</span>, <span class="hljs-number">6581861</span>, <span class="hljs-number">0</span>]<br>result = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):<br>        result += struct.pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, res[i]).decode(<span class="hljs-string">&#x27;ISO-8859-1&#x27;</span>) <span class="hljs-comment"># &lt;I为小端序，&gt;I为大端序。ISO-8859-1是转化字符为指定编码格式</span><br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li></ol></li></ul><h3 id="算法实现-3"><a class="markdownIt-Anchor" href="#算法实现-3"></a> 算法实现</h3><h4 id="tea-2"><a class="markdownIt-Anchor" href="#tea-2"></a> Tea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value += delta <br>        v0.value += ((v1.value&lt;&lt;<span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value&gt;&gt;<span class="hljs-number">5</span>) + k1)  <br>        v1.value += ((v0.value&lt;&lt;<span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value&gt;&gt;<span class="hljs-number">5</span>) + k3)<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br><br>    total = c_uint32(delta * <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):                     <br>        v1.value -= ((v0.value&lt;&lt;<span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value&gt;&gt;<span class="hljs-number">5</span>) + k3) <br>        v0.value -= ((v1.value&lt;&lt;<span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value&gt;&gt;<span class="hljs-number">5</span>) + k1)  <br>        total.value -= delta<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value   <br>  <br><span class="hljs-comment"># test</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">1</span>]))  <br>    res = encrypt(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(res, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0x9a65a69a 0x67ed00f6</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="xtea"><a class="markdownIt-Anchor" href="#xtea"></a> xTea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> * <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">v, key</span>):   <br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9E3779B9</span><br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):  <br>        v0.value += (((v1.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v1.value &gt;&gt; <span class="hljs-number">5</span>)) + v1.value) ^ (total.value + key[total.value &amp; <span class="hljs-number">3</span>])<br>        total.value += delta <br>        v1.value += (((v0.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v0.value &gt;&gt; <span class="hljs-number">5</span>)) + v0.value) ^ (total.value + key[(total.value&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>])<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">v, key</span>):<br>    v0, v1  = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9E3779B9</span><br>  <br>    total = c_uint32(delta * <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= (((v0.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v0.value &gt;&gt; <span class="hljs-number">5</span>)) + v0.value) ^ (total.value + key[(total.value&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>])<br>        total.value -= delta <br>        v0.value -= (((v1.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v1.value &gt;&gt; <span class="hljs-number">5</span>)) + v1.value) ^ (total.value + key[total.value &amp; <span class="hljs-number">3</span>])<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br>  <br><span class="hljs-comment"># test</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">1</span>]))<br>    res = encrypt(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(res, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0xae685ec7 0x59af4238</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="xxtea"><a class="markdownIt-Anchor" href="#xxtea"></a> xxTea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MX</span>(<span class="hljs-params">z, y, total, key, p, e</span>):<br>    temp1 = (z.value&gt;&gt;<span class="hljs-number">5</span> ^ y.value&lt;&lt;<span class="hljs-number">2</span>) + (y.value&gt;&gt;<span class="hljs-number">3</span> ^ z.value&lt;&lt;<span class="hljs-number">4</span>)<br>    temp2 = (total.value ^ y.value) + (key[(p&amp;<span class="hljs-number">3</span>) ^ e.value] ^ z.value)<br>  <br>    <span class="hljs-keyword">return</span> c_uint32(temp1 ^ temp2)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span>//n<br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    z = c_uint32(v[n-<span class="hljs-number">1</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br>  <br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        total.value += delta  <br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>            y = c_uint32(v[p+<span class="hljs-number">1</span>])<br>            v[p] = c_uint32(v[p] + MX(z,y,total,key,p,e).value).value<br>            z.value = v[p]<br>        y = c_uint32(v[<span class="hljs-number">0</span>])<br>        v[n-<span class="hljs-number">1</span>] = c_uint32(v[n-<span class="hljs-number">1</span>] + MX(z,y,total,key,n-<span class="hljs-number">1</span>,e).value).value<br>        z.value = v[n-<span class="hljs-number">1</span>]<br>        rounds -= <span class="hljs-number">1</span> <br><br>    <span class="hljs-keyword">return</span> v<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span>//n <br>  <br>    total = c_uint32(rounds * delta)<br>    y = c_uint32(v[<span class="hljs-number">0</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            z = c_uint32(v[p-<span class="hljs-number">1</span>])<br>            v[p] = c_uint32((v[p] - MX(z,y,total,key,p,e).value)).value<br>            y.value = v[p]<br>        z = c_uint32(v[n-<span class="hljs-number">1</span>])  <br>        v[<span class="hljs-number">0</span>] = c_uint32(v[<span class="hljs-number">0</span>] - MX(z,y,total,key,<span class="hljs-number">0</span>,e).value).value<br>        y.value = v[<span class="hljs-number">0</span>]  <br>        total.value -= delta<br>        rounds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> v <br><br><br><span class="hljs-comment">#  test  </span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment"># 该算法中每次可加密不只64bit的数据，并且加密的轮数由加密数据长度决定</span><br>    v = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    k = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br>    n = <span class="hljs-number">2</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(v[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(v[<span class="hljs-number">1</span>]))<br>    res = encrypt(n, v, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(n, res, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0xef86c2bb 0x25f31b5e</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="md5"><a class="markdownIt-Anchor" href="#md5"></a> MD5</h2><h3 id="算法原理-5"><a class="markdownIt-Anchor" href="#算法原理-5"></a> 算法原理</h3><p><a href="https://blog.csdn.net/hawinlolo/article/details/94464237">MD5 加密算法详解</a></p><h3 id="算法实现-4"><a class="markdownIt-Anchor" href="#算法实现-4"></a> 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>obj = hashlib.md5()<br><span class="hljs-comment"># 构造一个hashlib的对象(obj)，此处的 md5 可以替换为SHA1, SHA224, SHA256, SHA384, SHA512等加密算法</span><br>obj.update(<span class="hljs-string">&quot;使用md5加密&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-comment"># update对指定字符串进行加密，但加密前需要对数据进行转码为 byte 类型</span><br>result = obj.hexdigest()<br><span class="hljs-comment"># 这里hexdigest与digest相同，使用二进制表示(实际转化为十六进制形式表示)</span><br><span class="hljs-built_in">print</span>(result)<br> <br><span class="hljs-comment"># 也可以不创建对象，直接进行加密</span><br>obj = hashlib.sha1(<span class="hljs-string">&quot;1231231231&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="aes"><a class="markdownIt-Anchor" href="#aes"></a> AES</h2><p><a href="https://blog.csdn.net/chouzhou9701/article/details/122019967">python实现AES加密解密</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编基础</title>
    <link href="/posts/84aee333.html"/>
    <url>/posts/84aee333.html</url>
    
    <content type="html"><![CDATA[<h1 id="进制"><a class="markdownIt-Anchor" href="#进制"></a> 进制</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义：</h2><ul><li>N进制指逢N进1的一系列符号</li></ul><h2 id="进制之间的关系"><a class="markdownIt-Anchor" href="#进制之间的关系"></a> 进制之间的关系</h2><h3 id="0d-0x"><a class="markdownIt-Anchor" href="#0d-0x"></a> 0d -&gt; 0x</h3><table border="1">  <tr>    <td>二进制</td>    <td>0</td>    <td>1</td>    <td>10</td>    <td>11</td>    <td>100</td>    <td>101</td>    <td>110</td>    <td>111</td>  </tr>  <tr>    <td>十六进制</td>    <td>0</td>    <td>1</td>    <td>2</td>    <td>3</td>    <td>4</td>    <td>5</td>    <td>6</td>    <td>7</td>  </tr>  <tr>    <td>二进制</td>    <td>1000</td>    <td>1001</td>    <td>1010</td>    <td>1011</td>    <td>1100</td>    <td>1101</td>    <td>1110</td>    <td>1111</td>  </tr>  <tr>    <td>十六进制</td>    <td>8</td>    <td>9</td>    <td>A</td>    <td>B</td>    <td>C</td>    <td>D</td>    <td>E</td>    <td>F</td>  </tr></table><h3 id="八进制"><a class="markdownIt-Anchor" href="#八进制"></a> 八进制</h3><ul><li>八进制加法表</li></ul><table border="1">  <tr>    <td>1 + 1 = 2</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 2 = 3</td>    <td>2 + 2 = 4</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 3 = 4</td>    <td>2 + 3 = 5</td>    <td>3 + 3 = 6</td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 4 = 5</td>    <td>2 + 4 = 6</td>    <td>3 + 4 = 7</td>    <td>4 + 4 = 10</td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 5 = 6</td>    <td>2 + 5 = 7</td>    <td>3 + 5 = 10</td>    <td>4 + 5 = 11</td>    <td>5 + 5 = 12</td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 6 = 7</td>    <td>2 + 6 = 10</td>    <td>3 + 6 = 11</td>    <td>4 + 6 = 12</td>    <td>5 + 6 = 13</td>    <td>6 + 6 = 14</td>    <td></td>  </tr>  <tr>    <td>1 + 7 = 10</td>    <td>2 + 7 = 11</td>    <td>3 + 7 = 12</td>    <td>4 + 7 = 13</td>    <td>5 + 7 = 14</td>    <td>6 + 7 = 15</td>    <td>7 + 7 = 16</td>  </tr></table><ul><li>八进制乘法表</li></ul><table border="1">  <tr>    <td>1 * 1 = 1</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 2 = 2</td>    <td>2 * 2 = 4</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 3 = 3</td>    <td>2 * 3 = 6</td>    <td>3 * 3 = 11</td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 4 = 4</td>    <td>2 * 4 = 10</td>    <td>3 * 4 = 14</td>    <td>4 * 4 = 20</td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 5 = 5</td>    <td>2 * 5 = 12</td>    <td>3 * 5 = 17</td>    <td>4 * 5 = 24</td>    <td>5 * 5 = 31</td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 6 = 6</td>    <td>2 * 6 = 14</td>    <td>3 * 6 = 22</td>    <td>4 * 6 = 30</td>    <td>5 * 6 = 36</td>    <td>6 * 6 = 44</td>    <td></td>  </tr>  <tr>    <td>1 * 7 = 7</td>    <td>2 * 7 = 16</td>    <td>3 * 7 = 25</td>    <td>4 * 7 = 34</td>    <td>5 * 7 = 43</td>    <td>6 * 7 = 52</td>    <td>7 * 7 = 61</td>  </tr></table><hr /><h1 id="数据宽度与逻辑运算"><a class="markdownIt-Anchor" href="#数据宽度与逻辑运算"></a> 数据宽度与逻辑运算</h1><h2 id="数据宽度"><a class="markdownIt-Anchor" href="#数据宽度"></a> 数据宽度</h2><ul><li><p>字节/字（8bit）——可存储两个十六进制—8位二进制，例如FF</p><ul><li>十六进制占4位</li></ul></li><li><p>补：</p><ul><li>补码每一位取反加1为原码</li><li>原码每一位取反加1为补码</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291118937.png" alt="202210031849487" /></p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><ul><li>在最底层中计算<span class="label label-primary">2 + 3 = 5</span><ul><li><p>先转换为二进制，0010赋值为X，0011赋值为Y</p></li><li><p>之后将X与Y进行xor与and，若and之后的结果左移一位后有一位不为0，则把xor的结果赋值为X，and的结果赋值为Y，再进行计算</p></li><li><p>若最后and的结果左移一位之后每一位都为0，那么xor就是最后的结果</p><div class="note note-info">            <p>一个数进行了两次异或还是它本身</p>          </div></li></ul></li></ul><h1 id="寄存器与内存"><a class="markdownIt-Anchor" href="#寄存器与内存"></a> 寄存器与内存</h1><h2 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h2><ul><li><p>1、寄存器位于CPU内部,执行速度快，但比较贵</p></li><li><p>2、内存速度相对较慢,但成本较低，所以可以做的很大</p></li><li><p>3、寄存器和内存没有本质区别,都是用于存储数据的容器,都是定宽的</p></li><li><p>4、寄存器常用的共8个：EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI</p></li><li><p>5、计算机中的几个常用的计量单位：BYTE,WORD,DWORD</p><ul><li><p>BYTE——字节——8（BIT）</p></li><li><p>WORD——字——16（BIT）</p></li><li><p>DWORD——双字——32（BIT）</p></li></ul>   <div class="note note-info">            <p>1 KB  =  1024 BYTE,<br />1 MB  =  1024 KB,<br />1 GB  =  1024 MB</p>          </div></li><li><p>6、内存的数量特别庞大，无法对每个内存单位都起一个名字，所以用编号代替，我们称计算机CPU32位或者64位</p><ul><li>计算机内存的每一个字节会有一个编号（即内存编号的单位是字节）<ul><li>如：<span class="label label-primary">0x00000000，0x00000001…… 0xFFFFFFFF</span></li></ul></li><li>32位计算机的编号最大是32位,也就是32个1,换成16进制为FFFFFFFF,也就是说,32位计算机内存寻址的最大范围是32位.而内存的单位是字节,那内存中能存储的信息最多位FFFFFFFF + 1字节,即4G（可以打补丁等进行扩展）</li></ul></li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><ul><li><p>内存格式</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291118828.png" alt="202210032015464" /></p><ul><li>编号加<code>[]</code>表示这是内存编号，否则就是立即数</li><li>往往将多个字节连在一起命名为一个编号，这就导致一个编号（包含了4个字节的内存空间）可以存储32位</li></ul></li><li><p>从指定内存中写入/读取数据</p><ul><li><code>mov dword ptr ds:[0x0012FF34], 0x12345678</code>(mov是移动数据)<ul><li>遵循高位在后原则，即<code>[0x0012FF34]</code>对应的是78，而下一位<code>[0x0012FF35]</code>则是对应56（一个字节是8位，即两个十六进制数为一组），同时这个就是将4个字节组成了一个内存空间并命名</li></ul></li><li><code>mov eax, dword ptr ds:[0x0012FF34]</code><ul><li><code>dword</code>：要读\写多少  此时是4字节，byte = 1字节，word = 2字节</li><li><code>ptr</code>: Point代表后面是一个指针（存的不是值，而是地址）</li><li><code>ds</code>：段寄存器</li><li><code>[0x0012FF34]</code>：内存编号，必须是32位，前面的0可以省略，会自动补0<ul><li>这是一个地址编号，相当于指针</li></ul></li></ul></li><li>注意：<ul><li>地址编号不要随便写，因为内存是由保护的，并不是所有的内存都可以直接读写（需要特别处理），建议地址编号写成esp的值</li></ul></li></ul></li></ul><h2 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h2><h3 id="类别"><a class="markdownIt-Anchor" href="#类别"></a> 类别</h3><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH    AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH    BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH    CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH    DL</td></tr><tr><td>ESP</td><td>SP</td><td></td></tr><tr><td>EBP</td><td>BP</td><td></td></tr><tr><td>ESI</td><td>SI</td><td></td></tr><tr><td>EDI</td><td>DI</td><td></td></tr></tbody></table><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119557.png" alt="202210031849381" /></p><blockquote><p>AX为EAX的低位</p><p>AH为AX的高位，AL为AX的低位</p></blockquote><h3 id="32位寄存器"><a class="markdownIt-Anchor" href="#32位寄存器"></a> 32位寄存器</h3><table><thead><tr><th>寄存器</th><th>主要用途</th><th>存储数据的范围</th></tr></thead><tbody><tr><td>EAX</td><td>累加器</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ECX</td><td>计数</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EDX</td><td>I/O指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EBX</td><td>DS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ESP</td><td>堆栈指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EBP</td><td>SS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ESI</td><td>字符串操作的源指针；SS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EDI</td><td>字符串操作的目标指针；ES段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr></tbody></table><h2 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器"></a> 标志寄存器</h2><p>EFLAGS寄存器</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119091.png" alt="202210032027304" /></p><h3 id="进位标志cfcarry-flag"><a class="markdownIt-Anchor" href="#进位标志cfcarry-flag"></a> 进位标志CF(Carry Flag)</h3><ul><li>如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0（无符号运算，AL中看超没超过FF  ）<ul><li>最高位进位——CF=1<ul><li><code>MOV AL, 0xFE</code></li><li><code>ADD AL,2</code></li></ul></li><li>最高位不进位——CF=0<ul><li><code>MOV AL,0xEF</code></li><li><code>ADD AL,2</code></li></ul></li></ul></li></ul><h3 id="奇偶标志pfparity-flag"><a class="markdownIt-Anchor" href="#奇偶标志pfparity-flag"></a> 奇偶标志PF(Parity Flag)</h3><ul><li>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性，如果“1”的个数为偶数，则PF的值为1，否则其值为0——二进制中的1的个数</li><li>最低有效字节——**只看二进制中后8位 **<ul><li><code>MOV AL, 3</code>——PE不变</li><li><code>ADD AL, 3</code>——PE=1（6=110）</li><li><code>ADD AL, 2</code>——PE=0（8=1000）</li></ul></li></ul><h3 id="辅助进位标志afauxiliary-carry-flag"><a class="markdownIt-Anchor" href="#辅助进位标志afauxiliary-carry-flag"></a> 辅助进位标志AF(Auxiliary Carry Flag)</h3><ul><li>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<ul><li>(1)、在字操作时，发生低字节向高字节进位或借位时</li><li>(2)、在字节操作时，发生低4位向高4位进位或借位时</li></ul></li><li>例一：32位<ul><li><code>MOV EAX, 0x55EEFFFF</code></li><li><code>ADD EAX, 2</code></li></ul></li><li>例二：16位<ul><li><code>MOV AX, 5EFE</code></li><li><code>ADD AX, 2</code></li></ul></li><li>例三：8位<ul><li><code>MOV AL, 4E</code></li><li><code>ADD AL, 2</code></li></ul></li></ul><h3 id="零标志zfzero-flag"><a class="markdownIt-Anchor" href="#零标志zfzero-flag"></a> 零标志ZF(Zero Flag)</h3><ul><li>零标志ZF用来反映运算结果是否为0，如果运算结果（mov是赋值，不是运算结果）为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位<ul><li><code>XOR EAX, EAX</code>——ZF变成0</li><li><code>MOV EAX, 2</code>——ZF不变，与mov没有关系</li><li><code>SUB EAX, 2</code></li></ul></li></ul><h3 id="符号标志sfsign-flag"><a class="markdownIt-Anchor" href="#符号标志sfsign-flag"></a> 符号标志SF(Sign Flag)</h3><ul><li>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位（转换为2进制的最高位）相同<ul><li><code>MOV AL, 7F</code>——0111 1111</li><li><code>ADD AL, 2</code>—进位了</li></ul></li></ul><h3 id="溢出标志ofoverflow-flag"><a class="markdownIt-Anchor" href="#溢出标志ofoverflow-flag"></a> 溢出标志OF(Overflow Flag)</h3><ul><li>溢出标志OF用于反映有符号数加减运算所得结果是否溢出</li><li>如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0</li></ul><h4 id="溢出"><a class="markdownIt-Anchor" href="#溢出"></a> 溢出</h4><ul><li>进位标志<code>CF</code>表示无符号数运算结果是否超出范围</li><li>溢出标志<code>OF</code>表示有符号数运算结果是否超出范围</li><li>溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律：<ul><li>正 + 正 = 正 如果结果是负数，则说明有溢出</li><li>负 + 负 = 负 如果结果是正数，则说明有溢出</li><li>正 + 负 永远都不会有溢出</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210031849487.png" alt="" /></li></ul></li><li>例子<ul><li>1、无符号、有符号都不溢出<ul><li><code>MOV AL,8</code></li><li><code>ADD AL,8</code></li></ul></li><li>2、无符号溢出、有符号不溢出<ul><li><code>MOV AL,0FF</code></li><li><code>ADD AL,2</code></li></ul></li><li>3、无符号不溢出、有符号溢出<ul><li><code>MOV AL,7F</code></li><li><code>ADD AL,2</code></li></ul></li><li>4、无符号、有符号都溢出<ul><li><code>MOV AL,0FE</code></li><li><code>ADD AL,80</code></li></ul></li></ul></li></ul><h4 id="进位判断"><a class="markdownIt-Anchor" href="#进位判断"></a> 进位判断</h4><ul><li><p>比如80-40</p><ul><li><code>mov al,80</code></li><li><code>sub al,40</code></li></ul></li><li><p>相当于</p><ul><li><code>mov al, 80</code></li><li><code>add al,0c0</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119729.png" alt="202210032041035" /></p><ul><li>符号有效位指最左边的那一位</li><li>最高有效数值位指符号位后一位</li></ul></li></ul><h1 id="汇编指令"><a class="markdownIt-Anchor" href="#汇编指令"></a> 汇编指令</h1><div class="note note-blue">            <p>r—表示通用寄存器<br />m—表示内存<br />imm—表示立即数</p>          </div><h2 id="数据传递指令"><a class="markdownIt-Anchor" href="#数据传递指令"></a> 数据传递指令</h2><h3 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> <code>MOV</code></h3><ul><li>移动数据</li><li>MOV使用<ul><li><code>MOV 目标操作数 源操作数</code></li><li>作用：拷贝源操作数到目标操作数<ul><li>源操作数可以是立即数，通用寄存器，段寄存器，或者内存单元</li><li>目标操作数可以是通用寄存器，段寄存器或内存单元</li><li>操作数的宽度必须一样</li><li>源操作数和目标操作数不能同时为内存单元</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MOV r/m8, r8     <br>MOV r/m16, r16<br>MOV r/m32, r32<br><br>MOV r8, r/m8<br>MOV r16, r/m16<br>MOV r32, r/m32<br><br>MOV r8, imm8<br>MOV r16, imm16<br>MOV r32, imm32<br></code></pre></td></tr></table></figure><h3 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> <code>XCHG</code></h3><ul><li>交换数据</li><li>格式：<code>XCHG  R/M,R/M</code>  两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XCHG AL, CL<br>XCHG DWORD PTR DS:[12FFC4], EAX<br>XCHG BYTE PTR DS:[12FFC4], AL<br></code></pre></td></tr></table></figure><h2 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h2><h3 id="andorxor"><a class="markdownIt-Anchor" href="#andorxor"></a> <code>AND,OR,XOR</code></h3><ul><li>和,或,异或运算</li><li>对每一<strong>位</strong>进行比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;AND/OR/XOR用法相同<br>AND AL, imm8<br>AND AX, imm16<br>AND EAX, imm32<br><br>AND r/m8, imm8     <br>AND r/m16, imm16<br>AND r/m32, imm32<br>  <br>AND r/m16, imm8<br>AND r/m32, imm8<br><br>AND r/m8, r8     <br>AND r/m16, r16<br>AND r/m32, r32<br><br>AND r8, r/m8<br>AND r16, r/m16<br>AND r32, r/m32<br></code></pre></td></tr></table></figure><h3 id="not"><a class="markdownIt-Anchor" href="#not"></a> <code>NOT</code></h3><ul><li>非运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NOT r/m8<br>NOT r/m16<br>NOT r/m32<br></code></pre></td></tr></table></figure><h2 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h2><h3 id="运算指令"><a class="markdownIt-Anchor" href="#运算指令"></a> 运算指令</h3><h4 id="add与sub"><a class="markdownIt-Anchor" href="#add与sub"></a> <code>ADD与SUB</code></h4><ul><li>加减运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">ADD/SUB AL, imm8<br>ADD/SUB AX, imm16<br>ADD/SUB EAX, imm32<br><br>ADD/SUB r/m8, imm8     <br>ADD/SUB r/m16, imm16<br>ADD/SUB r/m32, imm32<br>  <br>ADD/SUB r/m16, imm8<br>ADD/SUB r/m32, imm8<br><br>ADD/SUB r/m8, r8     <br>ADD/SUB r/m16, r16<br>ADD/SUB r/m32, r32<br><br>ADD/SUB r8, r/m8<br>ADD/SUB r16, r/m16<br>ADD/SUB r32, r/m32<br></code></pre></td></tr></table></figure><h4 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> <code>ADC</code></h4><ul><li>带进位加法：加法之后再加1</li><li>格式：<code>ADC  R/M,R/M/IMM</code>两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADC AL,CL<br>ADC BYTE PTR DS:[12FFC4],2<br>ADC BYTE PTR DS:[12FFC4],AL<br></code></pre></td></tr></table></figure><h4 id="sbb"><a class="markdownIt-Anchor" href="#sbb"></a> <code>SBB</code></h4><ul><li>带借位减法：减法之后再减1</li><li>格式：<code>SBB  R/M,R/M/IMM</code>两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SBB AL, CL<br>SBB BYTE PTR DS:[12FFC4], 2<br>SBB BYTE PTR DS:[12FFC4], AL<br></code></pre></td></tr></table></figure><h4 id="inc与dec"><a class="markdownIt-Anchor" href="#inc与dec"></a> <code>INC与DEC</code></h4><ul><li><strong>INC</strong>加一指令，对于目的操作数进行加一操作</li><li><strong>DEC</strong>减一指令，对于目的操作数进行减一操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INC REG/MEM<br>DEC REG/MEM<br></code></pre></td></tr></table></figure><h3 id="移位指令"><a class="markdownIt-Anchor" href="#移位指令"></a> 移位指令</h3><h4 id="算术移位指令"><a class="markdownIt-Anchor" href="#算术移位指令"></a> 算术移位指令</h4><ul><li><p>指令格式：SAL/SAR Reg/Mem, CL/Imm</p></li><li><p>SAL(Shift Arithmetic Left): 算术左移----末尾补0</p><p>SAR(Shift Arithmetic Right): 算术右移----考虑符号，最高位符号为1，则补1；反之补0</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SAL Reg/Mem, CL/Imm<br>SAR Reg/Mem, CL/Imm<br></code></pre></td></tr></table></figure><h4 id="逻辑移位指令"><a class="markdownIt-Anchor" href="#逻辑移位指令"></a> 逻辑移位指令</h4><ul><li><p>指令格式：SHL/SHR Reg/Mem, CL/Imm</p></li><li><p>SHL(Shift Left): 逻辑左移----末尾补0</p><p>SHR(Shift Right): 逻辑右移----最高位补1</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHL Reg/Mem, CL/Imm<br>SHR Reg/Mem, CL/Imm<br></code></pre></td></tr></table></figure><h4 id="循环移位指令"><a class="markdownIt-Anchor" href="#循环移位指令"></a> 循环移位指令</h4><ul><li><p>指令格式：ROL r/m, i8 ；ROR r/m, CL</p></li><li><p>ROL(Rotate Left): 循环左移</p><p>ROR(Rotate Right): 循环右移</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ROL r/m, i8<br>ROR r/m, CL<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291120603.png" alt="202301052011851" /></p><h4 id="带进位的循环移位指令"><a class="markdownIt-Anchor" href="#带进位的循环移位指令"></a> 带进位的循环移位指令</h4><ul><li><p>指令格式：RCL r/m, i8 ； RCR r/m, CL</p></li><li><p>RCL(Rotate through Carry Left): 带进位循环左移</p><p>RCR(Rotate through Carry Right): 带进位循环右移</p></li><li><p><code>将CF看成数据的一部分进行循环移位操作</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">RCL r/m, i8 <br>RCR r/m, CL<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291121306.png" alt="202301052016625" /></p><h2 id="堆栈操作指令"><a class="markdownIt-Anchor" href="#堆栈操作指令"></a> 堆栈操作指令</h2><ul><li><strong>堆栈的内存分配是由高地址向低地址延申的</strong></li></ul><h3 id="堆栈数据操作指令"><a class="markdownIt-Anchor" href="#堆栈数据操作指令"></a> 堆栈数据操作指令</h3><h4 id="push与pop"><a class="markdownIt-Anchor" href="#push与pop"></a> <code>PUSH与POP</code></h4><ul><li><strong>PUSH</strong>将数据入栈，ESP寄存器指向的地址减4，将数据存入栈中</li><li><strong>POP</strong>将数据出栈，ESP寄存器指向的地址会先将数据取出，ESP寄存器指向的地址加4</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH REG/MEM/IMM<br>POP  REG/MEM<br></code></pre></td></tr></table></figure><h3 id="保存恢复通用寄存器"><a class="markdownIt-Anchor" href="#保存恢复通用寄存器"></a> 保存/恢复通用寄存器</h3><h4 id="pushad与popad"><a class="markdownIt-Anchor" href="#pushad与popad"></a> <code>PUSHAD与POPAD</code></h4><ul><li><strong>PUSHAD</strong>指令再堆栈上按顺序压入所有的32位通用寄存器，顺序依次是EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI</li><li><strong>POPAD</strong>指令以相反的顺序从堆栈中弹出这些通用寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSHAD<br>POPAD<br></code></pre></td></tr></table></figure><h3 id="保存恢复标志寄存器"><a class="markdownIt-Anchor" href="#保存恢复标志寄存器"></a> 保存/恢复标志寄存器</h3><h4 id="pushfd与popfd"><a class="markdownIt-Anchor" href="#pushfd与popfd"></a> <code>PUSHFD与POPFD</code></h4><ul><li><strong>PUSHFD</strong>压入32位的EFLAGS标志寄存器的值</li><li><strong>POPFD</strong>将堆栈顶部的值弹出并送至EFLAGS标志寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSHFD<br>POPFD<br></code></pre></td></tr></table></figure><h2 id="转移指令"><a class="markdownIt-Anchor" href="#转移指令"></a> 转移指令</h2><h3 id="无条件转移指令"><a class="markdownIt-Anchor" href="#无条件转移指令"></a> 无条件转移指令</h3><h4 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> <code>JMP</code></h4><ul><li>修改EIP的值，不影响寄存器和堆栈<ul><li><code>JMP 寄存器/立即数/内存</code>——相当于<code>MOV EIP， 寄存器/立即数/内存</code></li></ul></li><li>EIP决定CPU的指向，执行完一条语句后，其根据内存地址，再加上内存地址存储的数值大小，推测出下一条语句的内存地址编号，进而确定了要执行的语句</li></ul><h3 id="条件转移指令"><a class="markdownIt-Anchor" href="#条件转移指令"></a> 条件转移指令</h3><ul><li>条件转移指令又称为JCC指令集，根据EFLAGS标志寄存器中不同的标志位决定如何进行跳转</li></ul><h4 id="gcc"><a class="markdownIt-Anchor" href="#gcc"></a> <code>GCC</code></h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">指令</th><th style="text-align:center">含义</th><th style="text-align:center">测试条件</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><code>JE,JZ</code></td><td style="text-align:center">结果为零则跳转(相等时跳转)</td><td style="text-align:center">ZF=1才跳转，否则直接步进到下一条指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>JNE,JNZ</code></td><td style="text-align:center">结果不为零则跳转(不相等时跳转)</td><td style="text-align:center">ZF=0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><code>JS</code></td><td style="text-align:center">结果为负则跳转</td><td style="text-align:center">SF=1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><code>JNS</code></td><td style="text-align:center">结果为非负则跳转</td><td style="text-align:center">SF=0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><code>JP,JPE</code></td><td style="text-align:center">结果中1的个数为偶数则跳转</td><td style="text-align:center">PF=1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><code>JNP,JPE</code></td><td style="text-align:center">结果中1的个数为偶数则跳转</td><td style="text-align:center">PF=0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><code>JO</code></td><td style="text-align:center">结果溢出了则跳转</td><td style="text-align:center">OF=1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"><code>JNO</code></td><td style="text-align:center">结果没有溢出则跳转</td><td style="text-align:center">OF=0</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"><code>JB,JNAE</code></td><td style="text-align:center">小于则跳转 (无符号数)</td><td style="text-align:center">CF=1</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"><code>JNB,JAE</code></td><td style="text-align:center">大于等于则跳转 (无符号数)</td><td style="text-align:center">CF=0</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"><code>JBE,JNA</code></td><td style="text-align:center">小于等于则跳转 (无符号数)</td><td style="text-align:center">CF=1 or ZF=1</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"><code>JNBE,JA</code></td><td style="text-align:center">大于则跳转(无符号数)</td><td style="text-align:center">CF=0 and ZF=0</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"><code>JL,JNGE</code></td><td style="text-align:center">小于则跳转 (有符号数)</td><td style="text-align:center">SF≠OF</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"><code>JNL,JGE</code></td><td style="text-align:center">大于等于则跳转 (有符号数)</td><td style="text-align:center">SF=OF</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><code>JLE,JNG</code></td><td style="text-align:center">小于等于则跳转 (有符号数)</td><td style="text-align:center">ZF=1 or SF≠ OF</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center"><code>JNLE,JG</code></td><td style="text-align:center">大于则跳转(有符号数)</td><td style="text-align:center">ZF=0 and SF=OF</td></tr></tbody></table><ul><li>经常和GCC指令搭配</li><li>补充:<ul><li><code>Z</code>–ZF，<code>S</code>–SF，<code>P</code>–PF，<code>O</code>–OF</li><li><code>E</code>----Equit(相等的)</li><li><code>L</code>----Low(低的)，<code>B</code>----Below(下面)</li><li><code>N</code>----Not(非)</li></ul></li></ul><h4 id="test"><a class="markdownIt-Anchor" href="#test"></a> <code>TEST</code></h4><ul><li><strong>TEST</strong>用于对两个操作数进行逻辑与运算，结果不送入目的操作数但影响标志位 OF、SF、ZF、PF 和 CF</li><li>通常用于测试一些条件是否满足。常见用法：用这个指令,可以确定某寄存器是否等于0<ul><li><code>TEST EAX,EAX</code>——观察Z位</li><li>如果EAX的二进制某些位为1的话,那么运算的结果就不为零</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Test reg, imm/reg/mem<br>Test mem, imm/reg<br></code></pre></td></tr></table></figure><h4 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> <code>CMP</code></h4><ul><li><strong>CMP</strong>对两个操作数进行比较，比较的方式相当于用目的操作数减源操作数的减法操作，但是 cmp 只影响相应的标志寄存器，不会将减法的结果送入目的操作数中。影响的标志位有 OF、SF、ZF、AF、PF 和 CF</li><li>该指令是比较两个操作数,实际上,它相当于SUB指令,但是相减的结构并不保存到第一个操作数中，只是根据相减的结果 来改变零标志位（ZF）的,当两个操作数相等的时候,零标志位为1</li><li>例一：观察Z位<ul><li><code>MOV EAX, 100</code></li><li><code>MOV ECX, 100</code></li><li><code>CMP EAX,ECX</code>——Z位变成1</li></ul></li><li>例二：观察S位<ul><li><code>MOV EAX, 100</code></li><li><code>MOV ECX, 200</code></li><li><code>CMP EAX,ECX</code>——S位改变，则前一个数比后一个小</li></ul></li><li>例三：<ul><li><code>CMP AX,WORD PTR DS:[405000]</code></li><li><code>CMP AL,BYTE PTR DS:[405000]</code></li><li><code>CMP EAX,DWORD PTR DS:[405000]</code>——注意数据宽度</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Cmp reg, imm/reg/mem<br>Cmp mem, imm/reg<br></code></pre></td></tr></table></figure><h2 id="循环指令"><a class="markdownIt-Anchor" href="#循环指令"></a> 循环指令</h2><h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> <code>LOOP</code></h3><ul><li><strong>LOOP</strong>是循环控制指令，需要使用 ecx 寄存器来进行循环计数，当执行到 loop 指令时，先将 ecx 寄存器中的值减 1，如果 ecx 寄存器中的值大于 0，则转移到 loop 指令后的地址处，如果 ecx 寄存器中的值等于 0，则执行 loop 指令的下一条指令</li><li>在使用汇编语言编写代码的时候，loop 后面跟随一个标号，而在反汇编代码中 loop 指令后跟随一个地址值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LOOP s<br>LOOP 00403020<br></code></pre></td></tr></table></figure><h2 id="调用和返回指令"><a class="markdownIt-Anchor" href="#调用和返回指令"></a> 调用和返回指令</h2><h3 id="call"><a class="markdownIt-Anchor" href="#call"></a> <code>CALL</code></h3><ul><li><p><strong>CALL</strong>与JMP相似，但是在修改 EIP 寄存器的值之前，会将 call 指令的下一条指令的地址保存至堆栈，以便在调用过程(函数)后再继续从 call 指令处执行</p></li><li><p>按F7可以进行跳转，之后若是jmp指令，可以按回车进行跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291121868.png" alt="202210032042660" /></p><ul><li>由<code>4183DC</code>得到<code>4183E1</code>是由<code>4183DC</code>加上此段的字节数<code>E8 26000000</code>共5个字节</li><li>之后ESP-4，ESP存储的是<code>004183E1</code>，EIP = <code>00418407</code></li></ul></li><li><p><code>CALL 地址A/寄存器</code>——相当于<code>MOV EIP,地址A/寄存器   Push 下一行地址</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call reg/mem/imm<br></code></pre></td></tr></table></figure><h3 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> <code>RET</code></h3><ul><li><strong>RET</strong>用于过程(函数)的返回，该指令从堆栈的栈顶中弹出 4 个字节(这里的 4 个字节特指 32 位系统)送入 EIP 寄存器中。一般该指令在过程(函数)需要返回的位置或者是过程(函数)的结尾处</li><li>与CALL相结合，call 指令调用过程(函数)时会将 call 指令的下一条指令压入栈顶，当过程(函数)执<br />行中遇到 ret 指令时，会将 call 指令压入的指令弹出送入 EIP 寄存器中，这样代码的流程就会接着 call 指令的下一条指令继续执行</li><li>返回到call指令所处节点的下一个节点（上图中的<code>004183E1</code>），即产生了回溯，同时退栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Ret<br>Retn imm<br></code></pre></td></tr></table></figure><h3 id="retn"><a class="markdownIt-Anchor" href="#retn"></a> <code>RETN</code></h3><ul><li>相当于<code>POP EIP</code></li><li>将<code>ESP</code>指向内存地址的值弹出到<code>EIP</code>指令指针寄存器中</li><li>同时ESP+4</li></ul><div class="note note-info">            <p>RET指令不需要修正堆栈栈顶的位置直接返回，RETN指令则需要修正堆栈栈顶的位置后再进行返回</p>          </div> <h2 id="串操作指令"><a class="markdownIt-Anchor" href="#串操作指令"></a> 串操作指令</h2><h3 id="串传送指令"><a class="markdownIt-Anchor" href="#串传送指令"></a> 串传送指令</h3><h4 id="movs"><a class="markdownIt-Anchor" href="#movs"></a> <code>MOVS</code></h4><ul><li><p><strong>MOVS</strong>是借助 ESI 寄存器和 EDI 寄存器，把内存中源地址(ESI指向源地址)的数据送入内存的目的地址(EDI指向目的地址)中，MOVS 指令有 MOVSB、MOVSW 和 MOVSD 三种宽度。</p></li><li><p>在执行了 MOVS 指令后，ESI 寄存器和 EDI 寄存器指向的地址会自动增加或减少 1 个单位(与数据宽度对应)。增加与减少依赖 EFLAGS 标志寄存器的 DF 标志位进行控制。DF = 0，增加；反之减少。</p></li><li><p><a href="https://blog.csdn.net/longintchar/article/details/50949923">movsb,movsw,movsd指令</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;BYTE/WORD/DWORD<br>  MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]  ;简写为：MOVSB<br>  MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]  ;简写为：MOVSW<br>  MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] ;简写为：MOVSD<br>;例子<br> ;例一：<br>  MOV EDI,12FFD8<br>  MOV ESI,12FFD0<br>  MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  ;观察EDI的值<br> ;例二：修改标志寄存器中D位的值，然后在执行下面的指令：<br>  MOV EDI,12FFD8<br>  MOV ESI,12FFD0<br>  MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  ;观察EDI的值<br></code></pre></td></tr></table></figure><h3 id="串存储指令"><a class="markdownIt-Anchor" href="#串存储指令"></a> 串存储指令</h3><h4 id="stos"><a class="markdownIt-Anchor" href="#stos"></a> <code>STOS</code></h4><ul><li><strong>STOS</strong>是将 <code>AL/AX/EAX</code> 的值存储到 EDI 寄存器指向的内存单元。STOS 指令有 STOSB、STOSW 和 STOSD 三种宽度</li></ul><ol><li>[EDI]指向的内存单元——EDI存储的地址编号指向的地址内存</li><li>使用后EDI<code>+4/-4</code>，看EFLAGS寄存器<ol><li>DF = 0, EDI + 4</li><li>DF = 1, EDI - 4</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">STOS BYTE PTR ES:[EDI]  ;简写为STOSB，会自动补全<br>STOS WORD PTR ES:[EDI]  ;简写为STOSW<br>STOS DWORD PTR ES:[EDI] ;简写为STOSD<br>;例子：<br>  ;例一：<br>  MOV EAX,12345678<br>  MOV EDI,12FFC4<br>  STOS BYTE/WORD/DWORD PTR ES:[EDI]<br>  ;例二：修改标志寄存器中D位的值，然后再执行下面的指令：<br>  MOV EAX,12345678<br>  MOV EDI,12FFC4<br>  STOS BYTE/WORD/DWORD PTR ES:[EDI]<br></code></pre></td></tr></table></figure><h3 id="重复前缀指令"><a class="markdownIt-Anchor" href="#重复前缀指令"></a> 重复前缀指令</h3><h4 id="rep"><a class="markdownIt-Anchor" href="#rep"></a> <code>REP</code></h4><ul><li><p><strong>REP</strong>通过配合 ECX 寄存器即可实现重复执行的操作，当执行一次 REP 指令时，ECX寄存器的值都会自动减 1，如果 ECX 寄存器的值不为 0 则重复执行，如果 ECX 寄存器的值为 0 则重复执行结束</p></li><li><p>ECX后面的数字为十六进制，需转化为十进制，再重复执行</p></li><li><p><code>注意</code>：其余寄存器后面的数字也是十六进制</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ECX,10<br>REP MOVSD<br>REP STOSD<br></code></pre></td></tr></table></figure><hr /><h2 id="内存寻址公式"><a class="markdownIt-Anchor" href="#内存寻址公式"></a> 内存寻址公式</h2><h3 id="立即数"><a class="markdownIt-Anchor" href="#立即数"></a> [立即数]</h3><ul><li>读取内存中的值：<ul><li><code>MOV EAX, DWORD PTR DS:[0x13FFC4]</code><ul><li>读取了C4,C5,C6,C7四个字节（因为是dword，从C4开始读取存进eax中）</li></ul></li><li><code>MOV EAX, DWORD PTR DS:[0x13FFC8]</code></li></ul></li><li>向内存中写入数据<ul><li><code>MOV DWORD PTR DS:[0x13FFC4], EAX</code></li><li><code>MOV DWORD PTR DS:[0x13FFC4], EBX</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[0x13FFC4]</code></li><li><code>LEA EAX, DWORD PTR DS:[ESP+8]</code><ul><li>lea可以获取此时的内存地址编号，并赋值给eax</li></ul></li></ul></li></ul><h3 id="reg"><a class="markdownIt-Anchor" href="#reg"></a> [reg]</h3><ul><li>reg表示寄存器，可以是8个通用寄存器中的任意一个</li><li>读取内存的值<ul><li><code>MOV ECX, 0x13FFD0</code></li><li><code>MOV EAX, DWORD PTR DS:[ECX]</code><ul><li>此时<code>[ECX]</code>指将ecx的内容当作指针，指向对应的内存编号，取此内存的值赋值给eax,相当于<code>[ECX]</code>存取的是指针，取指针指向地址的值</li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EDX, 0x13FFD8</code></li><li><code>MOV DWORD PTR DS:[ECX], 0X87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EDX]</code><ul><li>获取的是内存的编号，即<code>[EDX]</code>存储的值</li></ul></li><li><code>MOV EAX, DWORD PTR DS:[EDX]</code></li></ul></li></ul><h3 id="reg-立即数"><a class="markdownIt-Anchor" href="#reg-立即数"></a> [reg + 立即数]</h3><ul><li>读取内存的值<ul><li><code>MOV ECX, 0x13FFD0</code></li><li><code>MOV EAX, DWORD PTR DS:[ECX+4]</code></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EDX, 0x13FFD8</code></li><li><code>MOV DWORD PTR DS:[ECX+0xC], 0x87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PYR DS:[EDX+4]</code></li><li><code>MOV EAX, DWORD PTY DS:[EDX+4]</code></li></ul></li></ul><h3 id="regreg1248"><a class="markdownIt-Anchor" href="#regreg1248"></a> [reg+reg*{1,2,4,8}]</h3><ul><li>读取内存的值<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV EDX, DWORD PTR DS:[EAX+ECX*4]</code><ul><li>最大的上限就是<code>FFFFFFFF</code></li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV DWORD PTR DS:[EAX+ECX*4], 87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EAX+ECX*4]</code></li></ul></li></ul><h3 id="regreg1248立即数"><a class="markdownIt-Anchor" href="#regreg1248立即数"></a> [reg+reg*{1,2,4,8}+立即数]</h3><ul><li>读取内存的值<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV EDX, DWORD PTR DS:[EAX+ECX*4+4]</code><ul><li>最大的上限就是<code>FFFFFFFF</code></li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV DWORD PTR DS:[EAX+ECX*4+4], 87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EAX+ECX*4+4]</code></li></ul></li></ul><hr /><h1 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h1><h2 id="堆栈引入"><a class="markdownIt-Anchor" href="#堆栈引入"></a> 堆栈引入</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291122016.png" alt="202210032020851" /></p><ul><li>1、BASE（栈底），TOP（栈顶）是2个32位的通用寄存器，里面存储的是内存单元编号（内存地址）</li><li>2、BASE里面存储了一个地址，记录起始地址</li><li>3、TOP里面存储了一个地址，记录结束地址</li><li>4、存入数据的时候，TOP的值减4（这里每次存取的是4个字节）；释放数据的时候，TOP的值加4（这里每次存取的是4个字节）</li><li>5、因为WIndows分配是高地址向低地址分配，所以TOP加4才能进行释放数据</li><li>6、如果要读取中间的某个数据，可以通过TOP与BASE加上偏移的方式去读取</li><li>7、此方法为堆栈，优点就是临时存储大量的数据，便于查找</li></ul><h2 id="堆栈操作"><a class="markdownIt-Anchor" href="#堆栈操作"></a> 堆栈操作</h2><ul><li><code>MOV EBX, 13FFDC</code>——BASE</li><li><code>MOV EDX, 13FFDC</code>——TOP</li></ul><h3 id="压入数据"><a class="markdownIt-Anchor" href="#压入数据"></a> 压入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;方法一<br>MOV DWORD PTR DS:[EDX-4], 0xBBBBBBBB<br>SUB EDX, 4<br>;方法二<br>LEA EDX, DWORD PTR DS:[EDX-4]<br>MOV DWORD PTR DS:[EDX], 0xDDDDDDDD<br></code></pre></td></tr></table></figure><blockquote><p><code>sub</code>与<code>lea</code>的两条语句等价，可以互换</p></blockquote><h3 id="读取第n个数"><a class="markdownIt-Anchor" href="#读取第n个数"></a> 读取第N个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;读第四个压入的数据<br>MOV ESI, DWORD PTR DS:[EBX-0X10] ;0x10指4*4<br><br>MOV ESI, DWORD PTR DS:[EDX+0X10] ;0x10指4*4<br></code></pre></td></tr></table></figure><h3 id="弹出数据"><a class="markdownIt-Anchor" href="#弹出数据"></a> 弹出数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ECX, DWORD PTR DS:[EDX]<br>LAN EDX, DWORD PTR DS:[EDX+4] / ADD EDX, 4<br><br>LEA EDX, DWORD PTR DS:[EDX+4]<br>MOV EDI, DWORD PTR DS:[EDX-4]<br></code></pre></td></tr></table></figure><h2 id="默认堆栈"><a class="markdownIt-Anchor" href="#默认堆栈"></a> 默认堆栈</h2><ul><li><code>ESP</code>用于存储栈顶的值，<code>EBP</code>用于存储栈底的值</li><li><code>push 0x12345678/reg</code>将数据压入栈，同时偏移<code>ESP</code></li><li><code>pop reg</code>将数据弹出栈，赋值给寄存器<code>reg</code>，同时偏移<code>ESP</code></li><li><a href="https://blog.csdn.net/qq_44288506/article/details/104767511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=push%E4%B8%8Epop%E6%8C%87%E4%BB%A4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-104767511.142%5Ev47%5Epc_rank_34_1,201%5Ev3%5Econtrol_2&amp;spm=1018.2226.3001.4187">push与pop指令讲解</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH r32/m32<br>PUSH r16/m16<br>PUSH imm8/imm16/imm32<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">POP r32/m32<br>POP r16/m16<br>POP imm8/imm16/imm32<br>POP EBP #指EBP出栈，即将此时的内存编号赋值给EBP，同时ESP+4<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushad ;保存当前通用寄存器到堆栈中<br>popad  ;将堆栈中的数据还原到通用寄存器中<br>;在此过程中堆栈的值不能发生变化，否则不能还原<br></code></pre></td></tr></table></figure><hr />]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
