<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>逆向分析实战</title>
    <link href="/posts/6e5d5d10.html"/>
    <url>/posts/6e5d5d10.html</url>
    
    <content type="html"><![CDATA[<h1>数据相关</h1><h2 id="数据存储">数据存储</h2><h3 id="数据宽度">数据宽度</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212102310024.png" alt="image-20221210231053930"></p><center><strong>图 1  常用存储单位所在字节数与位数</strong></center><h3 id="字节序">字节序</h3><ul><li><p>数据在内存中存储的方式分为<strong>大端存储</strong>和<strong>小端存储</strong></p></li><li><p>例如：0x12345678，其中<strong>12为高位字节数据，78为低位字节数据</strong></p></li></ul><h4 id="大端存储">大端存储</h4><ul><li>内存<strong>高</strong>位地址存放<strong>低</strong>位字节数据，内存<strong>低</strong>位地址存放数据<strong>高</strong>位字节数据</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212110040864.png" alt="image-20221211004020838"></li></ul><center><strong>图 2  大端存储</strong></center><h4 id="小端存储">小端存储</h4><ul><li>内存<strong>高</strong>位地址存放<strong>高</strong>位字节数据，内存<strong>低</strong>位地址存放数据<strong>低</strong>位字节数据</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212110042944.png" alt="image-20221211004205917"></li></ul><center><strong>图 3  小端存储</strong></center><h4 id="使用">使用</h4><p>通常情况下</p><ul><li>Windows操作系统兼容的CPU采用小端存储</li><li>UNIX操作系统兼容的CPU多采用大端存储</li><li>网络中传递数据时采用大端存储</li></ul><h4 id="注意">注意</h4><ul><li>对于数据0x01020304,左边为<strong>高位字节</strong></li><li>对于内存存储顺序,一般默认为<strong>低地址到高地址</strong></li></ul><h1>汇编</h1><h2 id="寄存器">寄存器</h2><h3 id="概述">概述</h3><p>与逆向相关的寄存器</p><ul><li>基本寄存器<ul><li>8个通用寄存器,6个段寄存器,1个指令指针寄存器,1个标志寄存器</li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212111532648.png" alt="image-20221211153203542"></p><center><strong>图 4  x86 CPU中的基本寄存器</strong></center><ul><li>调试寄存器</li><li>控制寄存器</li></ul><h3 id="通用寄存器">通用寄存器</h3><p>通用寄存器主要用于各种运算和数据的传输,又分为<strong>数据寄存器</strong>和<strong>指针变址寄存器</strong></p><table style="border:none;text-align:center;width:auto;margin: 0 auto;"><tbody><tr><td style="padding: 6px"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212111535516.png" ></td><td><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212111536898.png" ></td></tr>        <tr><td><strong>图 5  数据寄存器</strong></td><td><strong>图 6  指针变址寄存器</strong></td></tr></tbody></table><h4 id="数据寄存器">数据寄存器</h4><p>主要用在算数运算与逻辑运算指令中，常用来保存各种需要计算的值</p><ul><li><strong>EAX</strong>：累加器，在乘法和除法指令中被自动使用；在 Win32 中，一般用在函数的返回值中</li><li><strong>EBX</strong>：基址寄存器，DS 段中的数据指针</li><li><strong>ECX</strong>：计数器，CPU 自动使用 ECX 作为循环计数器，在字符串和循环操作中常用，在循环指令（LOOP）或串操作中，ECX 用来进行循环计数，每执行一次循环，ECX 都会被 CPU 自动减一</li><li><strong>EDX</strong>：数据寄存器</li></ul><h4 id="指针变址寄存器">指针变址寄存器</h4><p>主要用作保存内存地址的指针</p><ul><li><strong>EBP</strong>：扩展基址指针寄存器，SS 段中堆栈内数据指针。EBP 由高级语言用来引用参数和局部变量，通常称为堆栈基址指针寄存器。</li><li><strong>ESP</strong>：堆栈指针寄存器，SS 段中堆栈指针。ESP 用来寻址堆栈上的数据，ESP 寄存器一般不参与算数运算，通常称为堆栈指针寄存器。</li><li><strong>ESI</strong>：源变址寄存器，字符串操作源指针。</li><li><strong>EDI</strong>：目的变址寄存器，字符串操作目标指针。</li></ul><h3 id="段寄存器">段寄存器</h3><p>段寄存器用于存放段的基地址，段是一块预分配的内存区域。有些段存放有程序的指令，有些则存放有程序的变量，另外还有其他的段，如堆栈段存放着函数变量和函数参数等</p><ul><li>16位 CPU 中，段寄存器只有4个，分别是 CS（代码段）、DS（数据段）、SS（堆栈段）和ES（附加数据段）</li><li>32 位的 CPU 中，段寄存器从 4 个扩展为 6 个，分别是 CS、DS、SS、ES、FS 和 GS。FS 和 GS 段寄存器也属于附加的段寄存器</li></ul><h3 id="指令指针寄存器">指令指针寄存器</h3><ul><li><p>指令指针寄存器 <strong>EIP</strong> 是一个 32 位的寄存器，在 16 位的环境中，它的名称是 IP。EIP 寄存器保存着下一条要执行的指令的地址</p></li><li><p>EIP 寄存器的值在程序中是无法直接修改的，只能通过影响 EIP 的指令间接地进行修改，如 JMP、CALL、RET 等指令。此外，通过中断或异常也可以影响 EIP 的值</p></li></ul><h3 id="标志寄存器">标志寄存器</h3><p>在 16 位 CPU 中，标志寄存器称为 <strong>FLAGS</strong>（有的书上是 <strong>PSW</strong>，即程序状态字寄存器）。在 32 位 CPU 中，标志寄存器也扩展为 32 位，被称为 <strong>EFLAGS</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212111545235.png" alt="image-20221211154550208"></p><center><strong>图 7  16位的标志寄存器</strong></center><h4 id="条件标志">条件标志</h4><ol><li><strong>OF(OverFlow Flag)</strong>:溢出标志位，用来反映有符号数加减法运算所得结果是否溢出。如果运算超过当前运算位数所能表示的范围，则称为溢出，该标志位被置为 1，否则为 0</li><li><strong>SF(Sign Flag)</strong>:符号标志位，用来反映运算结果的符号位。运算结果为负时为 1，否则为 0</li><li><strong>ZF(Zero Flag)</strong>:零标志位，用来反映运算结果是否为 0。运算结果为 0 时该标志位被置为 1，否则为 0</li><li><strong>AF(Auxiliary carry Flag)</strong>:辅助进位标志位。在字操作时，发生低字节向高字节进位或借位时该标志位被置为 1，否则为 0（注意：在字节操作时，发生低 4 位向高 4 位进位或借位时该标志位被置为 1，否则为 0）</li><li><strong>PF(Parity Flag)</strong>:奇偶标志位，用于反映结果中“1”的个数的奇偶性。如果“1”的个数为偶数，该标志位被置为 1，否则为 0</li><li><strong>CF(Carry Flag)</strong>:进位标志位,运算结果的最高位产生了一个进位或借位，则该标志位被置为 1，否则为 0</li></ol><h4 id="控制标志">控制标志</h4><ol><li><strong>DF(Direction Flag)</strong>:方向标志位，用于串操作指令中，控制地址的变化方向。当 DF 为 0 时，存储器地址自动增加；当 DF 为 1 时，存储器地址自动减少。操作 DF 标志寄存器可以使用指令 CLD 和 STD 进行复位和置位</li><li><strong>IF(Interrupt Flag)</strong>:中断标志位，用于控制外部可屏蔽中断是否可以被处理器响应。当 IF 为 1 时，允许中断；当 IF 为 0 时，则不允许中断。操作 IF 标志寄存器可以使用 CLI 和 STI 进行复位和置位</li><li><strong>TF(Trap Flag)</strong>:陷阱标志位，用于控制处理器是否进入单步操作方式。当 TF 为 0 时，处理器在正常模式下运行；当 TF 为 1 时，处理器单步执行指令，调试器可以逐条指令进行执行就是使用了该标志位</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言</title>
    <link href="/posts/8e41db39.html"/>
    <url>/posts/8e41db39.html</url>
    
    <content type="html"><![CDATA[<ul><li>参考自：</li></ul><p>​汇编语言(第四版)————王爽</p><h1>关于8086CPU</h1><p>本书以 <code>8086CPU</code> 为例，这里描述下简单的性质</p><p><a href="https://blog.csdn.net/qq_50918834/article/details/123476647?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-123476647-blog-103859037.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-123476647-blog-103859037.pc_relevant_vip_default&amp;utm_relevant_index=1">win10(64位)安装汇编环境(masm)及使用</a></p><h2 id="16位结构的CPU">16位结构的CPU</h2><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><h2 id="物理地址的方法">物理地址的方法</h2><ul><li>8086CPU 有20条地址总线，但是其为16位结构，则其采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211302137983.png" alt="image-20221130213721942"></p><center><strong>图 1  8086CPU 相关部件的逻辑结构</strong></center><ul><li>地址加法器采用 <strong>物理地址 = 段地址(SA) X 16 + 偏移地址(EA)</strong>(段地址与偏移地址都是16位)<ul><li>本质含义为<strong>基础地址 + 偏移地址 = 物理地址</strong></li><li>其中16为在二进制下左移4位，16进制下左移1位，与偏移量结合相当于增加了4条地址总线</li><li>一个X进制的数据左移1位，相当于乘以X</li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211302151831.png" alt="image-20221130215138787"></p><center><strong>图 2  地址加法器的工作过程</strong></center><h1>Debug使用</h1><ul><li><strong>R</strong> 命令查看，改变CPU寄存器的内容</li><li><strong>D</strong> 查看内存中的内容----<strong>d 段地址:偏移地址</strong></li><li><strong>E</strong> 改写内存中的内容</li><li><strong>U</strong> 将内存中的机器指令翻译成汇编指令</li><li><strong>T</strong> 执行一条机器指令</li><li><strong>G</strong> 修改IP的值,即跳转.例如:g 0012</li><li><strong>A</strong> 以汇编指令的格式在内存中写入一条机器指令</li><li><strong>P</strong> 使Debug自动重复执行&quot;loop&quot;相关指令至cx==0.也可以执行程序返回(int 21)</li><li><strong>Q</strong> 退出Debug模式，返回命令行</li></ul><h1>寄存器</h1><h2 id="通用寄存器">通用寄存器</h2><p>数据寄存器</p><h3 id="AX">AX</h3><ul><li>累加器</li></ul><h3 id="BX">BX</h3><ul><li><p><code>mov ax,[bx]</code></p><ul><li><p>bx中存放的数据作为一个偏移地址EA,<strong>段地址SA默认在ds中</strong>,将SA:EA处的数据送入ax中.即:</p><p>(ax) = ( ( ds ) * 16 + ( bx ) )</p></li></ul></li><li><p><code>mov ax,[0]</code></p><ul><li><p>debug和汇编编译器masm对此指令有不用的处理</p><ul><li>debug中[0]表示ds:0处的数据</li><li>masm中[0]表示数字0</li></ul></li><li><p><strong>解决冲突</strong>: 在&quot;[ ]&quot;的前面显式地给出段地址所在的段寄存器</p><ol><li><p>在汇编源程序中,如果用指令访问一个内存单元,则在指令中必须用&quot;[…]“来表示内存单元,如果在”[]“里用一个常量idata直接给出内存单元的拍内衣地址,就要在”[]&quot;的前面显式地给出段地址所在的段寄存器,比如:</p><p>mov ax,ds:[0]</p></li><li><p>如果在&quot;[]&quot;里用寄存器,比如bx,简介给出内存单元地偏移地址,则段地址默认在ds中.当然,也可以显式地给出段地址所在地段寄存器,比如: mov ax,ds:[bx]</p></li></ol></li></ul></li><li><p><code>mov ax,[bx+idata]</code></p><ul><li>idata表示常量</li><li>偏移地址位(bx)+idata,也可以写成<code>mov ax,idata[bx]</code>或者<code>mov ax,[bx].idata</code></li><li>可以简化代码长度</li></ul></li><li><p><code>mov ax,[bx+si+idata]</code></p><ul><li>与上面含义相同,展示不同的寻址方式</li></ul></li><li><p><strong>只有bx,si,di,bp四个寄存器可以在&quot;[…]&quot;中进行内存单元的寻址</strong></p><ul><li>例如:<code>mov ax,[bp+si]</code>,其余寄存器都不可以</li></ul></li></ul><h3 id="CX">CX</h3><ul><li>计数器，CPU 自动使用 CX 作为循环计数器，在字符串和循环操作中常用，在循环指令（LOOP）或串操作中，CX 用来进行循环计数，每执行一次循环，ECX 都会被 CPU 自动减一</li></ul><p>指针变址寄存器</p><h3 id="SI与DI">SI与DI</h3><ul><li>与bx功能相近,si和di不能够分成两个8位寄存器</li></ul><h2 id="标志寄存器">标志寄存器</h2><ul><li><p>8086CPU的标志寄存器(flag)有16位,其中存储的信息通常被称为程序状态字(PSW)</p><ul><li><p>作用:</p><ol><li><p>用来存储相关指令的某些执行结果</p></li><li><p>用来为CPU执行相关指令提供行为依据</p></li><li><p>用来控制CPU的相关工作方式</p></li></ol></li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212152021020.png" alt="image-20221215202131982"></p><center><strong>8086CPU的标志寄存器结构</strong></center><ul><li>flag按位起作用,其中1,3,5,12,13,14,14没有作用,不具有任何含义.而<strong>0,2,4,6,7,8,9,10,11</strong>位具有特殊的含义.</li></ul><h3 id="CF标志">CF标志</h3><p><strong>Carry Flag</strong></p><ul><li>flag的第0位是CF,进位标志位.一般情况下,在进行无符号数运算的时候,它记录了运算结果的最高有效位向更高位的进位值,或从更高位的借位值.</li></ul><h3 id="PF标志">PF标志</h3><p><strong>Parity Even Flag</strong></p><ul><li>flag的第2位是PF,奇偶标志位.它记录相关指令执行后,其结果的所有bit位中1的个数是否位偶数.如果1的个数为偶数,pf = 1;如果为奇数,那么pf = 0.</li></ul><h3 id="ZF标志">ZF标志</h3><p><strong>Zero Flag</strong></p><ul><li>flag的第6位是ZF,零标志位.它记录相关指令执行后,其结果是否为0.如果结果为0,那么zf = 1;如果结果不为0,zf = 0.</li><li>一般add,sub,mul,div,inc,or,and等进行逻辑或算术运算指令会对ZF产生影响.</li></ul><h3 id="SF标志">SF标志</h3><p><strong>Sign Flag</strong></p><ul><li>flag的第7位是SF,符号标志位.它记录相关指令执行后,其结果是否为负.如果结果为负,sf = 1;如果非负,sf = 0.</li><li>它是CPU对有符号数运算结果的一种记录,记录数据的正负,只在有符号数计算中起作用.</li></ul><h3 id="DF标志">DF标志</h3><p><strong>Direction Flag</strong></p><ul><li>flag的第10位是DF,方向标志位.在<strong>串处理指令</strong>中,控制每次操作后si,di的增减<ul><li>df = 0,每次操作后si,di递增</li><li>df = 1,每次操作后si,di递减</li></ul></li></ul><h3 id="OF标志">OF标志</h3><p><strong>Overflow Flag</strong></p><ul><li>flag的第11位是OF,溢出标志位.一般情况下,OF记录了<strong>有符号数</strong>运算的结果是否发生了溢出.如果发生溢出,of = 1;如果没有,of = 0.</li><li><strong>注意CF和OF的区别</strong>:CF是对无符号数运算有意义,而OF是对有符号数运算有意义</li></ul><h2 id="段寄存器">段寄存器</h2><h3 id="CS和IP">CS和IP</h3><ul><li>CS为代码段寄存器，IP为指令指针寄存器<ul><li>若设CS中内容为M，IP中内容为N，则8086CPU将从内存 <code>M X 16 + N</code> 单元开始，读取一条指令并执行</li></ul></li><li>8086CPU工作过程<ol><li>从<strong>CS:IP</strong>指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP = IP + 所读取指令的长度，从而指向下一条指令</li><li>执行指令。转到步骤1，重复这个过程</li></ol></li></ul><h4 id="修改CS、IP的指令">修改CS、IP的指令</h4><ul><li>转移指令:能够改变CS，IP的内容的指令,例如：<strong>jmp指令</strong><ul><li><strong>jmp 段地址:偏移地址</strong><ul><li>用指令中给出的段地址修改CS,偏移地址修改IP</li><li>jmp 2AE3:3  执行后,CS=2AE3H,IP=0003H,CPU将从2AE33H处读取指令</li></ul></li><li><strong>jmp 某一合法寄存器</strong>,功能为：用寄存器中的值修改IP----类似mov IP,ax<ul><li>jmp ax<ul><li>执行前:ax=1000H,CS=2000H,IP=0003H</li><li>执行后:ax=1000H,CS=2000H,<code>IP=1000H</code></li></ul></li></ul></li></ul></li></ul><h3 id="DS">DS</h3><ul><li><p><strong>DS</strong>用来存放要访问数据的段地址</p></li><li><p><code>mov al,[0]</code> […]表示一个内存单元，[0]中的0表示内存单元的偏移地址，这个时候的<strong>段地址</strong>默认是在ds中( <strong>物理地址 = 段地址 X 16 + 偏移地址</strong>)</p></li></ul><h2 id="栈">栈</h2><p>8086CPU的入栈和出栈都是以**字(两个字节)**为单位进行的，高地址单元存放高8位(<strong>前面的两字节</strong>)，低地址单元存放低8位(<strong>小端存储</strong>)</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212021508126.png" alt="image-20221202150812086"></p><center><strong>图 3  8086CPU的栈操作</strong></center><h3 id="SS和SP">SS和SP</h3><ul><li><p>段寄存器SS和寄存器SP</p></li><li><p>栈顶的段地址存放在SS中，偏移地址存放在SP中</p></li><li><p><strong>任何时刻，SS:SP 指向栈顶元素</strong></p></li><li><p>入栈时，栈顶从高地址向低地址方向增长</p></li><li><p>栈为空时，以<code>10000H~1000FH</code>为栈空间</p><ul><li>SS:SP指向栈空间最高地址单元的下一个单元<ul><li>例如：SS=1000H,SP=0010H ----10H-FH == 1H(字节)</li></ul></li><li>该单元的地址为栈最底部的<code>字</code>单元的地址+2。<ul><li>例如：栈最底部<code>字</code>单元的地址为1000:000E,所以栈空时，SP = 0010H</li></ul></li></ul></li><li><p><code>push</code> 先将记录栈顶偏移地址的SP寄存器中的内容减2，使得SS:SP指向新的栈顶单元，然后再将寄存器中的数据送入SS：SP指向的新的栈顶单元</p></li><li><p>注意栈顶超界问题</p></li></ul><h3 id="BP">BP</h3><ul><li><strong>基数指针寄存器BP(base pointer)</strong> 是一个寄存器，它的用途有点特殊，是和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到,例如:堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址</li><li>只要在[…]中使用寄存器bp,而指令中没有显性地给出段地址,<strong>段地址就默认在ss中</strong></li></ul><h2 id="段的综述">段的综述</h2><ul><li>用段存放数据,定义为:“<strong>数据段</strong>” ----DS + []</li><li>用段存放代码,定义为:“<strong>代码段</strong>” ----CS + IP</li><li>用段充当栈,  定义为:“<strong>栈段</strong>”   ----SS + SP</li></ul><h1>程序</h1><h2 id="源程序">源程序</h2><ul><li><p>汇编指令与伪指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;assume为假设，假设某一段寄存器和程序中的某一个用segment…ends定义的段相联系<br>;此代码将用作代码段的段codesg和CPU中的段寄存器cs联系起来<br>assume cs:codesg<br><br>;定义一个段，段的名称为“codesg”，这个段从此开始<br>;&quot;codesg&quot;为标号，指代了一个地址<br>codesg segment<br><br>mov ax,0123H<br>mov bx,0456H<br>add ax,bx<br>add ax,ax<br><br>;这两条指令实现程序返回<br>mov ax,4c00H<br>int 21H<br><br>;名称为“codesg”的段到此结束<br>codesg ends<br><br>;汇编程序结束<br>end<br><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212021629583.png" alt="image-20221202162931534"></p><center><strong>图 4  与结束相关的概念</strong></center><h2 id="编译与连接">编译与连接</h2><ul><li><strong>编译</strong>:使用编译器对源程序文件(.asm)中的<strong>源程序</strong>进行编译,产生<strong>目标文件</strong>(.obj)</li><li>连接:使用连接程序对<strong>目标文件</strong>进行连接,生成可在操作系统中直接运行的<strong>可执行文件</strong>(.exe)</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212042046362.png" alt="image-20221204204616313"></p><center><strong>图 5  汇编程序从写出到执行的过程</strong></center><h2 id="执行">执行</h2><ul><li>DOS系统的shell(<strong>command</strong>.com,也称为命令解释器)将可执行文件的程序加载入内存,设置CS:IP指向程序入口,此后command停止,CPU运行程序</li><li>DOS系统中.EXE文件中程序的加载过程<ul><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212121618376.png" alt="image-20221212161826290"></li></ul></li></ul><center><strong>图 6  EXE文件中程序加载过程</strong></center><ol><li><p>程序加载后,ds中存放着程序所在内存区的段地址,这个内存区的偏移地址为0,则程序所在的内存区的地址为ds:0</p></li><li><p>这个内存区的前256个字节中存放的是PSP,DOS用来和程序及进行通信.从256字节处向后的空间存放的是程序</p><p>(即 <strong>( CS ) = ( DS ) + 10H</strong> )</p></li></ol><h2 id="寻址方式">寻址方式</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212130940356.png" alt="image-20221213094011306"></p><center><strong>图 7  寻址方式小结</strong></center><h1>指令</h1><h2 id="loop">loop</h2><ul><li>格式: <code>loop 标号</code></li><li>循环指令,所有的循环指令都是短转移,在对应的机器码中<strong>包含转移的位移,而不是目的地址</strong>(即包含到目的地址的位移)</li><li>CPU执行loop指令的时候,要进行两部操作<ul><li>(1) ( cx ) = ( cx ) - 1</li><li>(2) 判断 cx 中的值,不为零则转至标号处执行程序,如果为零则向下执行</li></ul></li></ul><h2 id="and">and</h2><ul><li>逻辑与指令,<strong>按位进行与运算</strong></li><li>可将操作对象的相应位设为0,其他位不变</li><li>例如:将al的第六位设为0:and al,10111111B,可适用于大小写转化</li></ul><h2 id="or">or</h2><ul><li>逻辑或指令,<strong>按位进行或运算</strong></li><li>可将操作对象的相应位设为1,其他位不变</li></ul><h2 id="inc和dec">inc和dec</h2><ul><li><code>inc dx</code>----dx中的数据加1</li><li><code>dec dx</code>----dx中的数据减1</li></ul><h2 id="div">div</h2><ul><li><p>除法指令</p><ol><li>除数:有8位和16位两种,在一个reg或内存单元中</li><li>被除数:默认放在AX或DX和AX中,如果除数为8位,被除数则为16位,默认在AX中存放;如果除数为16位,被除数则为32位,在DX和AX中存放,DX存放高16位,AX存放低16位</li><li>结果:如果除数为8位,则AL存储除法操作的商,AH存储除法操作的余数;如果除数为16位,则AX存储除法操作的商,DX存储除法操作的余数</li></ol></li><li><p>例如:<code>div byte ptr ds:[0]</code></p><ul><li>(al) = (ax) /  ( (ds) * 16 + 0) )的商</li><li>(ah) = (ax) /  ( (ds) * 16 + 0) )的余数</li></ul></li></ul><h2 id="mul">mul</h2><ul><li><p>乘法指令</p><ol><li>两个相乘的数:两个数要么都是8位,要么都是16位.如果是8位,一个默认放在AL中,另一个放在8位reg或内存字节单元中;如果是16位,一个默认在AX中,另一个放在16位reg或内存单元中.</li><li>结果:如果8位乘法,结果默认放在AX中;如果16位乘法,结果高位默认在DX中存放,低位在AX中放.</li></ol></li><li><p>格式</p><ul><li><code>mul reg</code></li><li><code>mul 内存单元</code>(内存单元可以用不同寻址方式给出)</li></ul></li></ul><h2 id="jmp">jmp</h2><ul><li><p>无条件转义指令,可以只修改IP,也可以同时修改CS和IP</p></li><li><p>需要:</p><ol><li>转移的目的地址</li><li>转移的距离(段间转移,段内短转移,段内近转移)</li></ol></li><li><p>面向地址</p><ul><li><p>段内转移(只修改IP的值)</p><ul><li><p><code>jmp short 标号</code>的功能为:(IP) = (IP) + 8位位移,机器码为<code>EB XX</code>(XX指位移)</p><ul><li><strong>8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</strong></li><li>short指明此处的位移为8位位移,进行<strong>段内短转移</strong></li><li>8位位移的范围为-128~127,用补码表示</li><li>8位位移有编译程序在编译时算出</li></ul></li><li><p><code>jmp near ptr 标号</code></p><ul><li>与jmp short 标号相同,不过是16位位移,进行<strong>段内近转移</strong></li></ul></li></ul></li><li><p>段间转移(修改CS:IP的值)</p><ul><li>(CS) = 标号所在段的段地址,(IP) = 标号在段中的偏移地址</li><li><code>jmp far ptr 标号</code></li></ul></li></ul></li><li><p>面向寄存器</p><ul><li><code>jmp 16位reg</code></li><li>功能:( IP ) = ( 16位reg )</li></ul></li><li><p>面向内存</p><ul><li><p><code>jmp word ptr 内存单元地址(段内转移)</code></p><ul><li>功能:从内存单元地址处开始存放着一个字,是转移的目的偏移地址</li></ul></li><li><p><code>jmp dword ptr 内存单元地址(段间转移)</code></p><ul><li>功能:从内存单元地址处开始存放着两个字,高地址处的字是转移的目的段地址,低地址处是转移的目的偏移地址</li></ul></li></ul></li></ul><h2 id="jcxz">jcxz</h2><ul><li>有条件转移指令,所有的有条件转移转移指令都是短转移,在对应的机器码中包含转移的位移,而不是目的地址.</li><li><code>jcxz 标号</code>(如果 (cx) = 0, 转移到标号处执行),<strong>使用格式参考jmp</strong><ul><li>当 (cx) = 0 时,(IP) = (IP) + 8 位位移(8位参考jmp中的8位)</li><li>当 (cx) ≠ 0 时,程序向下执行,不跳转</li></ul></li></ul><h2 id="CALL与RET">CALL与RET</h2><h3 id="ret和retf">ret和retf</h3><ul><li><p><code>ret</code>指令用栈中的数据,修改IP的内容,从而实现近转移</p><ul><li>CPU操作<ol><li>(IP) = ((ss) * 16 + (sp))</li><li>(sp) = (sp) + 2</li></ol></li><li>汇编语法解释<ul><li>pop IP</li></ul></li></ul></li><li><p><code>retf</code>指令用栈中的数据,修改CS和IP的内容,从而实现远转移</p><ul><li>CPU操作<ol><li>(IP) = ((ss) * 16 + (sp))</li><li>(sp) = (sp) + 2</li><li>(CS) = ((ss) * 16 + (sp))</li><li>(sp) = (sp) + 2</li></ol></li><li>汇编语法解释<ul><li>pop IP</li><li>pop CS</li></ul></li></ul></li></ul><h3 id="CALL">CALL</h3><ul><li>CPU操作<ol><li>将当前的IP或CS和IP压入栈中__(执行CALL时,IP已经指向下一条语句,即将下一条语句的IP地址压入栈中)__</li><li>转移</li></ol></li><li>依据位移转移<ul><li><code>call 标号</code>(将当前的IP压栈后,转到标号处执行指令)<ol><li>(sp) = (sp) - 2</li><li>((ss) * 16 + (sp)) = (IP)<strong>(此处的IP为CALL指令的下一条IP地址)</strong></li><li>(IP) = (IP) + 16位位移</li></ol></li><li>16位位移 = 标号处的地址 - call指令后的第一个字节的地址</li><li>16位位移的范围为 - 32768~32767,用补码表示</li><li>16位位移由编译程序在编译时算出</li><li>汇编语法表示<ul><li>push IP</li><li>jmp near ptr 标号</li></ul></li></ul></li><li>转移的目的地址在指令中<ul><li><code>call far ptr 标号</code>实现段间转移<ol><li>(sp) = (sp) - 2</li><li>((ss) * 16 + (sp)) = (CS)</li><li>(sp) = (sp) - 2</li><li>((ss) * 16 + (sp)) = (IP)<strong>(此处的IP为CALL指令的下一条IP地址)</strong></li><li>(CS) = 标号所在段的段地址</li><li>(IP) = 标号所在段中的偏移地址</li></ol></li><li>汇编语法<ul><li>push CS</li><li>push IP</li><li>jmp far ptr 标号</li></ul></li></ul></li><li>转移地址在寄存器中<ul><li><code>call 16位reg</code><ol><li>(sp) = (sp) - 2</li><li>((ss) * 16 + (sp)) = (IP)<strong>(此处的IP为CALL指令的下一条IP地址)</strong></li><li>(IP) = (16位reg)</li></ol></li><li>汇编语法<ul><li>push IP</li><li>jmp 16位reg</li></ul></li></ul></li><li>转移地址在内存中<ul><li><code>call word/dword ptr 内存单元地址</code><ul><li>dword 注意转移的内存高地址为段地址,低地址为偏移地址</li></ul></li></ul></li></ul><h3 id="CALL和RET配合使用">CALL和RET配合使用</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202212151734080.png" alt="image-20221215173449989"></p><center><strong>图 8  具有子程序的源程序的框架</strong></center><ul><li>具体程序实现时需要避免寄存器冲突----寄存器入栈和出栈操作</li></ul><h2 id="adc">adc</h2><ul><li>带进位加法指令,利用了CF位上记录的进位值</li><li>格式: <code>adc 操作对象1 操作对象2</code></li><li>功能: 操作对象1 = 操作对象1 + 操作对象2 + CF</li></ul><h2 id="sbb">sbb</h2><ul><li>带借位减法指令,利用了CF位上记录的进位值</li><li>格式: <code>adc 操作对象1 操作对象2</code></li><li>功能: 操作对象1 = 操作对象1 - 操作对象2 - CF</li></ul><h2 id="cmp">cmp</h2><ul><li>比较指令,功能相当于减法指令,知识不保存结果.cmp执行后,将对标志寄存器产生影响</li><li>格式: <code>cmp 操作对象1 操作对象2</code></li><li>功能: 计算操作对象1 - 操作对象2</li></ul><h2 id="串传送指令">串传送指令</h2><ul><li><p><code>movsb</code></p><ul><li>功能:以字节为单位传送</li><li>操作<ol><li>((ex) * 16 + (di)) = ((ds) * 16 + (si))</li><li>如果df = 0,(si) = (si) + 1,(di) = (di) + 1</li><li>如果df = 1,(si) = (si) - 1,(di) = (di) - 1</li></ol></li></ul></li><li><p><code>movsw</code></p><ul><li><p>功能:以字为单位传送</p></li><li><p>操作</p><ol><li>((ex) * 16 + (di)) = ((ds) * 16 + (si))</li><li>如果df = 0,(si) = (si) + 2,(di) = (di) + 2</li><li>如果df = 1,(si) = (si) - 2,(di) = (di) - 2</li></ol></li></ul></li><li><p><code>cld</code></p><ul><li>将标志寄存器的DF位设为0(clear)</li></ul></li><li><p><code>std</code></p><ul><li>将标志寄存器的DF位设为1(setup)</li></ul></li></ul><h2 id="rep">rep</h2><ul><li><p>常和串传送指令搭配使用</p></li><li><p>功能:根据cx的值,重复执行后面的指令</p></li><li><p>用法:</p><ul><li><p><code>rep movsb</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">s:movsb<br>  loop s<br></code></pre></td></tr></table></figure></li><li><p><code>rep movsw</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">s:movsw<br>  loop s<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="pushf和popf">pushf和popf</h2><ul><li>功能是将标志寄存器的值压栈,而popf是从栈中弹出数据,送入标志寄存器中</li><li>为直接访问标志寄存器提供一种方法</li></ul><h2 id="定义数据类型">定义数据类型</h2><h3 id="db-dw-dd">db,dw,dd</h3><ul><li>db定义**字节型(word)<strong>数据,dw定义</strong>字型(byte)<strong>数据,dd定义</strong>双字节型(dword)**数据</li></ul><h3 id="dup">dup</h3><ul><li>操作符,在汇编语言中同db,dw,dd等一样,也是由编译器识别处理的符号.它是和db,dw,dd等数据定义伪指令配合使用的,用来进行数据的重复</li><li>例如:<ul><li><code>db 3 dup (0)</code>,定义了3个字节,它们的值都是0,相当于db 0,0,0</li><li><code>db 3 dup (0,1,2)</code>定义了9个字节,相当于db 0,1,2,0,1,2,0,1,2</li></ul></li></ul><h2 id="操作符offset">操作符offset</h2><ul><li>再汇编语言中是由编译器处理的符号,功能是取得标号的偏移地址</li><li>例如:<code>mov ax,offset s</code> 取得标号s的偏移地址(相对于此时地址CS:IP的偏移量)</li></ul><h2 id="ptr">ptr</h2><ul><li>功能:临时指定类型的<ul><li>指明数据的尺寸<ul><li>通过寄存器名指明要处理的数据的尺寸.(即有寄存器，可以不用ptr来限制了，系统会自动分析的)</li><li>在没有寄存器名存在的情况下，即都是在内存，得用操作符 X ptr 指明内存单元的长度，X在汇编指令中可以为byte，word或者DWORD。</li></ul></li><li>临时的类型转换<ul><li>例如:jmp far ptr 标号(far ptr说明转移的类型)</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week3</title>
    <link href="/posts/580a635a.html"/>
    <url>/posts/580a635a.html</url>
    
    <content type="html"><![CDATA[<h1>Zzzzzz3333</h1><h2 id="分析">分析</h2><ul><li>32位，无壳，直接IDA分析<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211102038340.png" alt=""><br>由图，需要对<span class="label label-primary">Arglist</span>的一系列方程进行解密，然后将<span class="label label-primary">Arglist</span>放入加密过程中进行加密之后就可以得到flag<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211102050613.png" alt=""><span class="label label-primary">byte_402168</span>中的数据此时可以使用z3求解器来解方程组来得到<span class="label label-primary">Arglist</span></li></ul><h2 id="exp">exp</h2><ul><li><p>z3下载</p><ol><li>打开文件管理器，在地址栏中输入 <span class="label label-warning">%APPDATA%</span></li><li>搜索pip文件夹，在pip文件夹中打开pip.ini文件,将其修改为下面形式（这是阿里源）</li></ol>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url = http://mirrors.aliyun.com/pypi/simple/<br><span class="hljs-keyword">trusted</span>-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><ol start="3"><li>直接使用pip下载</li></ol>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> z3-solver<br></code></pre></td></tr></table></figure><p>之后就可以在pycharm中导入z3的包并且不报错了<br>若是直接可以pip下载，则直接下载即可,我是pip源出现了问题,所以写此来提醒自己应该怎么正确换源不报错</p></li><li><p>直接使用z3解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#创建容器</span><br>a=Solver()<br><br><span class="hljs-comment">#设置未知量</span><br>s=[Int(<span class="hljs-string">&#x27;s[%d]&#x27;</span> %i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-comment">#添加约束条件</span><br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">1</span>)==<span class="hljs-number">0x191a</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">45</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">11</span>)==<span class="hljs-number">0x2649</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">16</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x1785</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">28</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">67</span>)==<span class="hljs-number">0x386c</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">4</span>)==<span class="hljs-number">0x1c53</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">0</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">45</span>)==<span class="hljs-number">0x2746</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">34</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">17</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x29ef</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">43</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">15</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">21</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">30</span>)==<span class="hljs-number">0x2d7e</span>)<br><br><span class="hljs-comment">#判断是否有解(a.model()前必須先調用a.check())</span><br><span class="hljs-keyword">if</span> a.check()==sat:<br>    <span class="hljs-built_in">print</span>(a.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No resolve&quot;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">得到了s的数值</span><br><span class="hljs-string">s[7] = 100, s[3] = 108, s[5] = 49, s[0] = 102,</span><br><span class="hljs-string">s[2] = 108, s[6] = 110, s[1] = 97, s[4] = 119,</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>key = [<span class="hljs-number">0</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">11</span>,  <span class="hljs-number">12</span>, <span class="hljs-number">107</span>,  <span class="hljs-number">20</span>,  <span class="hljs-number">30</span>,  <span class="hljs-number">28</span>,  <span class="hljs-number">82</span>,<br> <span class="hljs-number">95</span>,  <span class="hljs-number">95</span>,  <span class="hljs-number">40</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">29</span>,  <span class="hljs-number">59</span>,  <span class="hljs-number">37</span>,  <span class="hljs-number">14</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">0</span>,<br> <span class="hljs-number">86</span>,  <span class="hljs-number">16</span>,  <span class="hljs-number">79</span>,  <span class="hljs-number">25</span>]<br>k = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    k += <span class="hljs-built_in">chr</span>((key[i] &amp; (s[i &amp; <span class="hljs-number">7</span>] ^ key[i]) | ~key[i] &amp; (~key[i] ^ ~s[i &amp; <span class="hljs-number">7</span>])))<br><br><span class="hljs-built_in">print</span>(k)<br></code></pre></td></tr></table></figure></li><li><p>使用矩阵方法求解（实质与使用z3一样）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入 numpy 模块</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#行交换</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">swap_row</span>(<span class="hljs-params">matrix, i, j</span>):<br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= m:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;错误! : 行交换超出范围 ...&#x27;</span>)<br>      <span class="hljs-keyword">else</span>:<br>          matrix[i],matrix[j] = matrix[j].copy(),matrix[i].copy()<br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#变成阶梯矩阵</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_change</span>(<span class="hljs-params">matrix</span>):<br>      m, n = matrix.shape<br>      main_factor = []<br>      main_col = main_row = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">while</span> main_row &lt; m <span class="hljs-keyword">and</span> main_col &lt; n:<br>          <span class="hljs-comment"># 选择进行下一次主元查找的列</span><br>          main_row = <span class="hljs-built_in">len</span>(main_factor)<br>          <span class="hljs-comment"># 寻找列中非零的元素</span><br>          not_zeros = np.where(<span class="hljs-built_in">abs</span>(matrix[main_row:,main_col]) &gt; <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br>          <span class="hljs-comment"># 如果该列向下全部数据为零，则直接跳过列</span><br>          <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(not_zeros) == <span class="hljs-number">0</span>:<br>              main_col += <span class="hljs-number">1</span><br>              <span class="hljs-keyword">continue</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># 将主元列号保存在列表中</span><br>              main_factor.append(main_col)<br>              <span class="hljs-comment"># 将第一个非零行交换至最前</span><br>              <span class="hljs-keyword">if</span> not_zeros[<span class="hljs-number">0</span>] != [<span class="hljs-number">0</span>]:<br>                  matrix = swap_row(matrix,main_row,main_row+not_zeros[<span class="hljs-number">0</span>])<br>              <span class="hljs-comment"># 将该列主元下方所有元素变为零</span><br>              <span class="hljs-keyword">if</span> main_row &lt; m-<span class="hljs-number">1</span>:<br>                  <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(main_row+<span class="hljs-number">1</span>,m):<br>                      a = <span class="hljs-built_in">float</span>(matrix[k, main_col] / matrix[main_row, main_col])<br>                      matrix[k] = matrix[k] - matrix[main_row] * matrix[k, main_col] / matrix[main_row, main_col]<br>              main_col += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> matrix,main_factor<br><br><br>  <span class="hljs-comment">#回代求解</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">back_solve</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-comment"># 判断是否有解</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(main_factor) == <span class="hljs-number">0</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主元错误,无主元！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> main_factor[-<span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无解！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      <span class="hljs-comment"># 把所有的主元元素上方的元素变成0</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(main_factor) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>          factor = matrix[i, main_factor[i]]<br>          matrix[i] = matrix[i] / <span class="hljs-built_in">float</span>(factor)<br>          <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>              times = matrix[j, main_factor[i]]<br>              matrix[j] = matrix[j] - <span class="hljs-built_in">float</span>(times) * matrix[i]<br>      <span class="hljs-comment"># 先看看结果对不对</span><br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#结果打印</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_result</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;阶梯矩阵为空！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span><br>      m, n = matrix.shape<br>      result = [<span class="hljs-string">&#x27;&#x27;</span>] * (n - <span class="hljs-number">1</span>)<br>      main_factor = <span class="hljs-built_in">list</span>(main_factor)<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-comment"># 如果不是主元列，则为自由变量</span><br>          <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> main_factor:<br>              result[i] = <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;(free var)&#x27;</span><br>          <span class="hljs-comment"># 否则是主元变量，从对应的行，将主元变量表示成非主元变量的线性组合</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># row_of_main表示该主元所在的行</span><br>              row_of_main = main_factor.index(i)<br>              result[i] = <span class="hljs-built_in">str</span>(matrix[row_of_main, -<span class="hljs-number">1</span>])<br>              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):<br>                  ratio = matrix[row_of_main, j]<br>                  <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-built_in">str</span>(ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>                  <span class="hljs-keyword">if</span> ratio &lt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;+&#x27;</span> + <span class="hljs-built_in">str</span>(-ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方程的通解是:&#x27;</span>, )<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;=&#x27;</span>, result[i])<br><br><br>  <span class="hljs-comment">#得到简化的阶梯矩阵和主元列</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">Handle</span>(<span class="hljs-params">matrix_a, matrix_b</span>):<br>      <span class="hljs-comment"># 拼接成增广矩阵</span><br>      matrix_01 = np.hstack([matrix_a, matrix_b])<br>      matrix_01, main_factor = matrix_change(matrix_01)<br>      matrix_01 = back_solve(matrix_01, main_factor)<br>      print_result(matrix_01, main_factor)<br>      <span class="hljs-keyword">return</span> matrix_01, main_factor<br><br><br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>      <span class="hljs-comment">#a = np.array([[0, 1, 1], [0, 1, 0], [1, 0, 0]])</span><br>      a = np.array([[<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">11</span>,<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>], [<span class="hljs-number">16</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">19</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">28</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">19</span>,<span class="hljs-number">0</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">34</span>,<span class="hljs-number">10</span>,<span class="hljs-number">17</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">1</span>,<span class="hljs-number">21</span>,<span class="hljs-number">1</span>,<span class="hljs-number">30</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      b = np.array([[<span class="hljs-number">6426</span>],[<span class="hljs-number">9801</span>],[<span class="hljs-number">6021</span>],[<span class="hljs-number">14444</span>],[<span class="hljs-number">7251</span>],[<span class="hljs-number">10054</span>],[<span class="hljs-number">10735</span>],[<span class="hljs-number">11646</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      Handle(a, b)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">20</span>)<br><br></code></pre></td></tr></table></figure><p>得到的x[1…8]就是解出来的Arglist，也是上文的s[0…8],使用上面的代码代入求解即可.<br>ps:解出来的为浮点数，记得需要进位操作</p></li></ul><h1>EzTea</h1><h2 id="分析-2">分析</h2><ul><li>查壳,放到IDA中查看,之后可以看出来是将输入进行加密,之后和原有之进行比较<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211121540089.png" alt=""></li><li>然后根据查看tea中的内容，知道使用的就是xxtea加密，只不过将一些数据进行了修改<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211121555569.png" alt=""><br>对比后发现修改的地方为:<span class="label label-primary">DELTA,z>>5变成z>>4,z<<4变成z<<5</span></li></ul><h2 id="exp-2">exp</h2><ul><li>xxtea的通用代码,根据题意进行了修改<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*原来</span><br><span class="hljs-comment">  DELTA 0x9e3779b9  </span><br><span class="hljs-comment">  MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//修改后 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 0x11451400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MX (((z^key[(p&amp;3)^e]) + (y^sum)) ^ ((z<span class="hljs-string">&lt;&lt;5^y&gt;</span>&gt;3) + (y<span class="hljs-string">&lt;&lt;2^z&gt;</span>&gt;4))) </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xxtea</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">int</span> n, <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> key[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> y, z, sum;<br>    <span class="hljs-type">unsigned</span> p, rounds, e;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)            <span class="hljs-comment">/* Coding Part */</span><br>    &#123;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = <span class="hljs-number">0</span>;<br>        z = v[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            sum += DELTA;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n - <span class="hljs-number">1</span>; p++)<br>            &#123;<br>                y = v[p + <span class="hljs-number">1</span>];<br>                z = v[p] += MX;<br>            &#125;<br>            y = v[<span class="hljs-number">0</span>];<br>            z = v[n - <span class="hljs-number">1</span>] += MX;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">-1</span>)      <span class="hljs-comment">/* Decoding Part */</span><br>    &#123;<br>        n = -n;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = rounds * DELTA;<br>        y = v[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = n - <span class="hljs-number">1</span>; p &gt; <span class="hljs-number">0</span>; p--)<br>            &#123;<br>                z = v[p - <span class="hljs-number">1</span>];<br>                y = v[p] -= MX;<br>            &#125;<br>            z = v[n - <span class="hljs-number">1</span>];<br>            y = v[<span class="hljs-number">0</span>] -= MX;<br>            sum -= DELTA;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> enc[] =<br>    &#123;<br>      <span class="hljs-number">0x82</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x96</span>,<br>      <span class="hljs-number">0x40</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x71</span>,<br>      <span class="hljs-number">0x3D</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x88</span>,<br>      <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span><br>    &#125;;<br>    <span class="hljs-type">uint32_t</span> key[] = &#123; <span class="hljs-number">0x19</span>,<span class="hljs-number">0x19</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x10</span> &#125;;<br>    <span class="hljs-comment">// 传入-9代表解密，9为v的长度，即n</span><br>    <span class="hljs-built_in">xxtea</span>((<span class="hljs-type">uint32_t</span>*)enc, <span class="hljs-number">-9</span>, (<span class="hljs-type">uint32_t</span>*)key);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,enc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week2</title>
    <link href="/posts/2f0d53cc.html"/>
    <url>/posts/2f0d53cc.html</url>
    
    <content type="html"><![CDATA[<h1>前…人，后…者</h1><h2 id="分析">分析</h2><ul><li>查壳之后是32位程序，IDA打开<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081105733.png" alt=""></li><li>使用<span class="label label-primary">sub_4113DE</span>对输入进行加密<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081110311.png" alt=""></li><li>观察特点，上面是凯撒加密，之后价格结果与0x22异或<br>查看<span class="label label-primary">byte_41A004</span><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081113384.png" alt=""><br>得到经过凯撒加密，然后异或之后的结果</li></ul><h2 id="exp">exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">81</span>, <span class="hljs-number">91</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">89</span>,  <span class="hljs-number">77</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">84</span>,  <span class="hljs-number">67</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">71</span>,  <span class="hljs-number">80</span>,<br>  <span class="hljs-number">125</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">78</span>,  <span class="hljs-number">64</span>,  <span class="hljs-number">74</span>,  <span class="hljs-number">95</span>]<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-built_in">str</span>+=<span class="hljs-built_in">chr</span>(a[i]^<span class="hljs-number">0x22</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[i], end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081130028.png" alt=""></p><h1>FindMe</h1><h2 id="分析-2">分析</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092056077.png" alt=""><br>该程序经过<span class="label label-primary">sub_1BCD</span>使得dword_5040 == 1即可得到flag</p><p>怎经过调试，可以看到关键的函数<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092101605.png" alt=""><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092101271.png" alt=""><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092102474.png" alt=""><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092103231.png" alt=""><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092103704.png" alt=""><br>大致的含义是首先对s进行赋0，然后经过位运算，异或之后进行得到dword_5020，求解就是逆推进行求解</p><h2 id="exp-2">exp</h2><ul><li>首先由dword_5020获得最后的数据<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211092108307.png" alt=""><br>则首先经过异或右移17，之后再右移0x2022</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><ul><li>之后经过位运算<br>|为按位或运算，只要对应两个二进制位有一个为1时，结果就为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br>flag = [<span class="hljs-string">&#x27;&#x27;</span>]*<span class="hljs-number">32</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>,<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">ascii</span> = s[i//<span class="hljs-number">4</span>] &gt;&gt; (<span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        还原或运算，每次左移在后面补零，又与之后的s[i]位运算将零替换成s[i]的值</span><br><span class="hljs-string">        即最后的s[i]由s[i]本身与s[i]左移之后的数相加而成(左移位数远远超过本身，按位或就成为了相加),则逆推需要减去</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        s[i//<span class="hljs-number">4</span>] = s[i//<span class="hljs-number">4</span>] - (<span class="hljs-built_in">ascii</span> &lt;&lt; <span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        flag[i+(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>)] = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ascii</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure><h1>Petals</h1><h2 id="分析-3">分析</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211172010055.png" alt="image-20221117201025285"></p><p>找到main函数，观察<code>loc_1209</code>是指令，可能反编译有问题，点击进去看看</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211172012817.png" alt="image-20221117201207882"></p><p>在下面找到一个错误的提示，按D转换成原始数据形式</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211172013376.png" alt="image-20221117201340361"></p><p>对E8使用Patcher直接nop掉，之后按c转换为代码，同时将此指令<code>loc_1209</code>按P转换为函数，之后就转换成函数</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211172017531.png" alt="image-20221117201740510"></p><p>而<code>sub_160C</code>是一个比较函数，若是输入的值与最后存储的值相同，那么就是输入对了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>* input, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+18h] [rbp-118h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+1Ch] [rbp-114h]</span><br>__int64 v5[<span class="hljs-number">33</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br><span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br><span class="hljs-built_in">memset</span>(v5, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">255</span>; ++i)<br>*((BYTE*)v5 + i) = ~(i ^ len);<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; len &gt; j; ++j)<br>input[j] = *((BYTE*)v5 + (<span class="hljs-type">unsigned</span> __int8)input[j]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> enc[] =<br>&#123;<br>  <span class="hljs-number">0xD0</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x89</span>,<br>  <span class="hljs-number">0x92</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0xD1</span>,<br>  <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x87</span>,<span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-type">char</span> flag[<span class="hljs-number">56</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) &#123;<br>flag[i] = j;<br><span class="hljs-built_in">func</span>(flag, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">if</span> (flag[i] == enc[i]) &#123;<br>cout &lt;&lt; (<span class="hljs-type">char</span>)j;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 66ccff#luotianyi#b074d58a</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week1</title>
    <link href="/posts/b6040276.html"/>
    <url>/posts/b6040276.html</url>
    
    <content type="html"><![CDATA[<h1>Hello_Reversing</h1><h2 id="查壳">查壳</h2><ul><li>首先使用exeinfope查一下壳<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210282330917.png" alt=""></li><li>由图所示，此程序是64位程序，没有壳（Not packed）</li></ul><h2 id="分析">分析</h2><ul><li>使用ida打开程序，找到主函数（main）界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210282333815.png" alt=""></li><li>观察伪代码的信息，看到有&quot;3vers1ng_w0rld}&quot;，猜测此为flag的一半，另外一半可能也是这样的展示方式，则使用Shift+F12直接搜索程序中的字符串.<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210282337023.png" alt=""></li><li>最后发现字符串的另一半在<a href="https://www.cnblogs.com/lsgxeva/p/8947829.html">.rdata</a>段中<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210290824478.png" alt=""></li><li>找到了flag的前半部分，点击进入汇编界面。在相应显示flag前半段的位置处，直接按Shift+e进行提取，那么就得到了flag.</li></ul><h1>Pyre</h1><h2 id="分析-2">分析</h2><ul><li><p>得到文件pyre.exe，由文件名字可以看出这个是由py文件编译成的exe文件，则使用<a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor.py</a>可以将pyre进行反编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> pyinstxtractor.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p>运行成功<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210290851753.png" alt="运行成功"></p></li><li><p>反编译后，会生成一个文件夹,其中的.pyc文件就是由.exe反编译得到的，现在需要将.pyc反编译成.py文件<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210290854071.png" alt=""></p></li></ul><h2 id="反编译">反编译</h2><ol><li><p>直接使用<a href="https://tool.lu/pyc/">在线网站</a>进行反编译</p></li><li><p>使用<a href="https://github.com/rocky/python-uncompyle6">uncompyle6</a>进行反编译</p></li></ol><ul><li>uncompyle6可将python字节码转换回等效的python源代码，它接受python 1.3版到3.8版的字节码</li><li>安装</li></ul>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> uncompyle6<br></code></pre></td></tr></table></figure><ul><li>使用示例</li></ul>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">uncompyle6 -<span class="hljs-keyword">o</span> fliename.<span class="hljs-keyword">py</span> <span class="hljs-keyword">file</span>.pyc #  对filename.pyc文件进行反编译，输出为<span class="hljs-keyword">file</span>.<span class="hljs-keyword">py</span>文件<br></code></pre></td></tr></table></figure><h2 id="exp">exp</h2><ul><li><p>查看反编译后的.py源代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">flag = <span class="hljs-string">&#x27;&#x27;</span><br>encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>    tmp = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">input</span>)):<br>        tmp += <span class="hljs-built_in">input</span>[table[i]]<br><br>    <span class="hljs-keyword">return</span> tmp<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please input your flag:&#x27;</span>)<br>    flag = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) != <span class="hljs-number">23</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Length Wrong!!&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        final = enc(flag)<br>        <span class="hljs-keyword">if</span> final == encode:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wow,you get the right flag!!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Sorry,Your input is Wrong&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>此加密为将flag打乱顺序，将table的值作为下标进行输出，则可以构造和encode等长的列表，进行逆操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br>flag = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode))]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode)):<br>    flag[table[i]] = encode[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure></li></ul><h1>Baby_Re</h1><h2 id="分析-3">分析</h2><ul><li><p>64位程序.使用ida打开程序，找到主函数（main）界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291704483.png" alt=""></p><p>由main函数界面，可以看出此题是输入一个字符串，先进行与i异或，之后经过compare函数，正确返回为1</p></li><li><p>跟进compare函数，发现是用final与s进行比较<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291708684.png" alt=""><br>可以知道flag（输入的字符串）为32位长，然后遍历输入的字符串，要求和final一样,跟进final，</p></li><li><p>按Shift+e提取数据<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291712101.png" alt=""></p></li></ul><h2 id="exp-2">exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">86</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">98</span>, <span class="hljs-number">98</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>, <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">121</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><ul><li>运行出来的flag为flag{Something_run_before_main?}</li><li>提交发现这个flag是一个假的，之后根据题意与线索，发现有4个bytes不一样<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291724280.png" alt=""></li><li>跟进function进行查看<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291726414.png" alt=""><br>发现对于这四个位置进行了修改，之后更改exp,修改这4个位置的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>, <span class="hljs-number">86</span>, <span class="hljs-number">54</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>, <br>  <span class="hljs-number">58</span>, <span class="hljs-number">98</span>, <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">38</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">63</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h1>EasyRe</h1><h2 id="分析-4">分析</h2><ul><li>题目为.exe文件和.dll文件.对.exe查壳,无壳,64位,在ida中查看.<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210291954295.png" alt=""><br>首先exe会加载dll，调用dll里的函数，图中的红框.同时这里的57行将ProcAddress定义为enc.dll中的encode函数<br>之后就是将输入的字符串经过encode后与Str2进行比较，相等则得到flag</li><li>继续分析enc.dll<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210292004505.png" alt=""><br>跟进return进行查看<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210292004268.png" alt=""><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210292005284.png" alt=""><br>则enc.dll大致是将输入的字符串a1进行一个加密操作之后赋值给a2，之后a2与Str(Reverse)进行异或输出a2</li><li>enc.dll的加密操作复杂，使用Shift+F12查看有没有可以使用的信息<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210292009641.png" alt=""><br>看到一串字符，判定为base64编码，即加密就是base加密</li></ul><h2 id="exp-3">exp</h2><ul><li>这里final[14]题目中没有告知,先当0进行处理,成功获得flag;若是不能，可以爆破final[14],对其遍历所有ascii爆破最后的flag.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>final = [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">40</span>, <span class="hljs-number">64</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">60</span>, <span class="hljs-number">46</span>, <span class="hljs-number">43</span>, <span class="hljs-number">30</span>, <span class="hljs-number">61</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>,<br>        <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">60</span>, <span class="hljs-number">21</span>, <span class="hljs-number">40</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">63</span>, <span class="hljs-number">42</span>, <span class="hljs-number">57</span>, <span class="hljs-number">9</span>, <span class="hljs-number">49</span>, <span class="hljs-number">86</span>, <span class="hljs-number">36</span>, <span class="hljs-number">28</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;?$P&lt;,%#K&#x27;</span>:<br>    final.append(<span class="hljs-built_in">ord</span>(i))<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Reverse&#x27;</span><br><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag.append(<span class="hljs-built_in">chr</span>(final[i] ^ <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i % <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)])))<br><br>content = base64.b64decode(<span class="hljs-string">&#x27;&#x27;</span>.join(flag).encode())<br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><h1>艾克体悟题</h1><p>作者给了提示：<a href="https://note.youdao.com/ynoteshare/index.html?id=a006b246edc7fc65ed20abbc2d9c5351&amp;type=note&amp;%5C_time=1663716620460">点击这里</a></p><h2 id="分析-5">分析</h2><ul><li>有题目可以得知，在模拟器中直接打开apk文件<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211072352571.png" alt=""></li><li>则使用<span class="label label-info">adb shell</span>启动指定的Activity</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span>   进入<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.droidlearn.activity_travel/.FlagActivity   按上述地址路径，打开指定控件<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211072353036.png" alt=""></p><h2 id="exp-4">exp</h2><ol><li>使用python中的 pyautogui 库控制鼠标自动进行连点操作</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyautogui <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br>pd.FAILSAFE = <span class="hljs-literal">True</span><br><br>time.sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#3秒时间自己移动到要点击的位置</span><br>pd.click(clicks=<span class="hljs-number">100000</span>,interval=<span class="hljs-number">0.0001</span>)<br><span class="hljs-comment"># pyautogui.click()</span><br><span class="hljs-comment"># (100,100, clicks=2,interval=0.5,button=‘right’,duration=0.2)</span><br><span class="hljs-comment"># 位置，点击次数，间隔时间，右键(默认左键)，移动间隔</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_61774705/article/details/127165732">exp参考此篇文章</a></p><ol start="2"><li>使用apk反编译后重新打包，将1w的数值修改为1</li></ol><ul><li><p>下载<a href="https://ibotpeaches.github.io/Apktool/">下载apktool</a>,此工具作用就是将apk反编译和重新打包<br>输入`</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>apktool_2.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">jar </span>d &lt;filepath&gt; -o &lt;newfilename&gt;<br></code></pre></td></tr></table></figure><p>生成文件夹.<br>进入文件夹 demo\smali\com\droidlearn\activity_travel 路径找 FlagActivity$1.smali 文件，此文件可以直接用编辑器打开<br>在此文件中寻找到到0x2710（10000）十六进制，修改为0x1即为点击1次即可.<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211080956544.png" alt=""></p></li><li><p>重新打包</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">java -jar apktool_2<span class="hljs-number">.6</span><span class="hljs-number">.1</span>.jar b &lt;<span class="hljs-keyword">new</span><span class="hljs-type">filename</span>&gt; -o &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081009495.png" alt=""><br>打包成功即生成一个.apk，但此时的apk不可使用，还需安装签名.</p></li><li><p>测试<br>安装至夜神模拟器，用/nox/bin目录下的adb工具进行安装，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">adb install &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081012000.png" alt=""><br>安装失败，这是没有签名导致的.</p></li><li><p>生成口令文件<br>使用JRE环境变量下的keytool生成口令文件,<a href="https://blog.csdn.net/w47_csdn/article/details/87564029">详细参考</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -genkey -alias testalias -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">36500</span> -keystore &lt;filename&gt;.keystore`<br></code></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081018301.png" alt=""><br>输入回答，之后在当前目录下生成一个.keystore文件，使用<code>keytool -list -v -keystore &lt;filename&gt;.keystore</code>可以查看详细信息.</p></li><li><p>签名</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">jarsigner -<span class="hljs-keyword">verbose</span> -keystore <span class="hljs-symbol">&lt;filename&gt;</span>.keystore -storepass <span class="hljs-symbol">&lt;password&gt;</span> -signedjar <span class="hljs-symbol">&lt;newfile&gt;</span>.apk <span class="hljs-symbol">&lt;filename&gt;</span>.apk testalias<br></code></pre></td></tr></table></figure><p>其中<br>-<span class="label label-default">keystore + 签名文件</span><br><br>-<span class="label label-default">sotrepass + 签名口令密码</span> <br><br>-<span class="label label-default">signedjar后跟三个参数 分别是签名后的apk文件 需要签名的apk文件 签名的别名</span><br><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081027234.png" alt=""><br>签名成功，之后下载此flag.apk,启动指定的<span class="label label-info">FlagActivity$1.smali</span>，则可以得到flag<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081044884.png" alt=""><br><a href="https://www.anyiblog.top/2022/09/25/20220925/#Re5-%E8%89%BE%E5%85%8B%E4%BD%93%E6%82%9F%E9%A2%98">exp参考此篇文章</a></p></li><li><p>补充<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211081042328.png" alt=""><br>下载时若是出现此报错，需要删除之前下载的那个apk，<a href="https://blog.csdn.net/qq_42351033/article/details/122450733">解决方案</a><br>进入adb shell之后可以通过<code>pm list package</code>列出模拟器中所有的包</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Crypto &amp; Python</title>
    <link href="/posts/108720dc.html"/>
    <url>/posts/108720dc.html</url>
    
    <content type="html"><![CDATA[<h1>基础操作</h1><h2 id="转化">转化</h2><ul><li><code>int(a,k)</code><ul><li>a为k进制数，使用<code>int</code>将k进制数转化为十进制数</li><li><code>int(a)</code>直接将字符a转化为int类型，此时a必须为数字字符，<ul><li>注意：不是转化为ascii码，而是转化为数字类型，即值不变，类型改变</li></ul></li></ul></li><li><code>str(a)</code><ul><li>与<code>int(a)</code>是相反的操作，但是范围扩大</li></ul></li><li><code>ord(a)</code><ul><li>将字符a按其ascii码转化为int类型</li></ul></li><li><code>chr(a)</code><ul><li>将int类型的a根据其ascii码转化为字符</li></ul></li><li><code>str.encode(encoding='utf-8', errors='strict')</code><ul><li>以指定的编码格式编码字符串，默认编码为 ‘utf-8’</li></ul></li><li><code>bytes</code>与<code>str</code><ul><li><code>bytes = str.encode()</code><ul><li>str 转换成 bytes 用 encode() 方法</li><li><code>bytes=b'\xe4\xba\xba\xe7\x94'</code>bytes的形式</li></ul></li><li><code>str = bytes.decode()</code><ul><li>反转换</li></ul></li></ul></li><li><code>hex()</code><ul><li><code>a.hex()</code>将bytes类型（即a）转化为十六进制</li><li><code>bytes.fromhex(a.hex())</code>可以将十六进制数转化为bytes类型</li></ul></li><li><code>join()</code><ul><li><code>print(''.join(list))</code>直接输出将列表拼接成字符串的结果<ul><li>list存储的是字符，例如list = [‘a’,‘c’,‘r’]</li><li>本意为隔一个’‘输出list的一个值，由于’'中间没有间隔，则即直接将list进行拼接</li></ul></li></ul></li></ul><h2 id="切割">切割</h2><ul><li><code>flag = key.split(' ')</code><ul><li>将字符key切割为列表类型，分界线为<code>' '</code></li></ul></li></ul><h2 id="赋值">赋值</h2><ul><li><code>key = [i for i in range(10)]</code><ul><li><code>key</code>初始化——遍历<code>i</code>，同时将i赋值给key[i]</li></ul></li></ul><h2 id="函数">函数</h2><ul><li><code>pow(a,b,c)</code><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>c</mi></mrow><annotation encoding="application/x-tex">pow(a,b,c) == a^{b}\  \% \ c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9047em;vertical-align:-0.0556em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathnormal">c</span></span></span></span></li></ul></li></ul><h1>Crypto库</h1><h2 id="Util-number">Util.number</h2><ul><li><p><code>bytes_to_long</code>与<code>long_to_bytes</code></p><ul><li><code>bytes_to_long</code>将字节流转换位long类型数字，即最后一位字符转为ASCii之后乘以2<sup>0</sup>, 往前的字符乘以2<sup>1</sup>, 2<sup>2</sup>……</li><li><code>long_to_bytes</code>将long类型数字转换为bytes类型，是<code>bytes_to_long</code>的逆运算</li></ul></li><li><p><code>getPrime(n_lebgth)</code></p><ul><li>反复使用素性检测算法验证以获素随机数,其长度为2<sup>n</sup></li></ul></li><li><p><code>getStrongPrime(n_lebgth)</code></p><ul><li>获得满足RSA要求的大素数</li></ul></li><li><p><code>inverse(a,n)</code></p><ul><li>求a模n的逆元</li><li>对于正整数 a, n，如果有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax ≡ 1 \ (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，则称 x 的最小正整数解为 a 模 n的逆元</li></ul></li><li><p><code>getRandomNBitInteger(N)</code></p><ul><li>获得N比特的随机数（也就是保证最高位非0，且长度为2<sup>N</sup>）</li></ul></li><li><p><code>gad(a,b)</code></p><ul><li>获得a与b的最大公约数</li></ul></li></ul><h1>base64库</h1><h2 id="base32与base16">base32与base16</h2><ul><li><code>b32encode(bytes)</code>与<code>b32decode()</code><ul><li>bytes必须是由str类型经过str.encode()转换而得来</li></ul></li><li><code>b32hexencode(bytes)</code>与<code>b32hexdecode()</code><ul><li>与上面的相同</li></ul></li><li><code>b16</code>与<code>b32</code>相同</li></ul><h2 id="base64">base64</h2><ul><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
