<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="/posts/87126416.html"/>
    <url>/posts/87126416.html</url>
    
    <content type="html"><![CDATA[<h1 id="first__page"><a class="markdownIt-Anchor" href="#first__page"></a> First__Page</h1><h2 id="2019红帽杯easyre"><a class="markdownIt-Anchor" href="#2019红帽杯easyre"></a> [2019红帽杯]easyRE</h2><h3 id="具体流程"><a class="markdownIt-Anchor" href="#具体流程"></a> 具体流程</h3><ul><li><p>首先<code>Shift + F12</code>查看字符串，找到了base64编码的东西</p><ul><li><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052153730.png" alt="image-20230305215330684" /></li><li>base64解了十次，得到了<a href="https://bbs.kanxue.com/thread-254172.htm">看雪CTF从入门到存活（六）主动防御</a>这个网站，然后没有一点信息，应该是被耍了。</li></ul></li><li><p>接着从主函数出发，找到关键函数<code>sub_4009C6</code></p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052215011.png" alt="image-20230305221551966" /></p></li><li><p>分析前半段(如注释)，代码解出v18的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">v15 = <span class="hljs-string">&#x27;Iodl&gt;Qnb(ocy\x7F&#x27;</span><br>v16 = <span class="hljs-string">&#x27;y.i\x7F&#x27;</span><br>v17 = <span class="hljs-string">&#x27;d`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span><br>v = v15 + v16 + v17<br>enc =[]<br>key = <span class="hljs-built_in">list</span>(v14)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>    enc.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key[i]) ^ i))<br>tmp = <span class="hljs-string">&#x27;&#x27;</span>.join(enc)<br><span class="hljs-built_in">print</span>(tmp)<br><span class="hljs-comment"># tmp = Info:The first four chars are `flag`</span><br></code></pre></td></tr></table></figure></li><li><p>由得出的结果，知道这里没有flag，继续往下看</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052254462.png" alt="image-20230305225421428" /></p></li><li><p>这里进行了十次base64加密，对应了上文中的base解密出来为网站的事情</p></li><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052255104.png" alt="image-20230305225555059" /></p></li></ul></li><li><p>查看0ff_6CC090时(也就是base64加密数据的存放地址)，看到了新的数据off_6CC0A0，直接查看其引用，找到<code>sub_400D35</code>函数</p><ul><li><p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202303052259863.png" alt="image-20230305225937825" /></p></li><li><p>观察函数，猜测v1为数组，其的值应该是<code>flag</code>。这里由于 <strong>HIBYTE</strong> 函数的作用是获取高字节也就是数组的最后一位，在由上面的Info信息得到结果，而与 <strong>HIBYTE</strong> 相对应的还有 <strong>BYTE()</strong>、<strong>BYTE1()</strong>、**BYTE2()**第一个是获取数组的第一位，第二个就是获取第二位，依次类推。由此编写脚本得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">key = [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x18</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x2F</span>,<br>  <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x27</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x6E</span>,<br>  <span class="hljs-number">0x72</span>, <span class="hljs-number">0x3C</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x5B</span>]<br>key2 = <span class="hljs-string">&#x27;flag&#x27;</span><br>key3 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key2)):<br>    key3.append(<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(key2[i]) ^ key[i]))<br><span class="hljs-built_in">print</span>(key3)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    key3.append(<span class="hljs-built_in">chr</span>(key[i]^<span class="hljs-built_in">ord</span>(key3[i%<span class="hljs-number">4</span>])))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(key3))<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3><ul><li>判断IDA给出定义的真实含义，如上述的v1指代一个数组，确切而言指示这v1[0]</li><li>根据上下文判断伪代码对于语句的操作，如上述的字符串相加</li></ul><h2 id="youngter-drive"><a class="markdownIt-Anchor" href="#youngter-drive"></a> Youngter-drive</h2><blockquote><p>知识点：多线程处理</p></blockquote><p>参考：<a href="https://tokameine.top/2021/04/30/buuctf-youngter-drive/">BUUCTF Youngter-drive笔记与思考 (线程) – TokameinE</a></p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><h4 id="识别"><a class="markdownIt-Anchor" href="#识别"></a> 识别</h4><ul><li>查壳，UPX壳，直接脱</li><li>拖到IDA中，发现调用Windows的API<ul><li><img src="https://gitee.com/Nuthecz/img/raw/master/202303040947552.png" alt="image-20230304094722528" /></li><li>这里<code>CreateThread</code>是创建一个线程，属于新知识点。具体讲解在最后</li></ul></li></ul><h4 id="具体流程-2"><a class="markdownIt-Anchor" href="#具体流程-2"></a> 具体流程</h4><ul><li>结合给出的IDA分析与注释，这里分别追踪 <code>StartAddress</code> 和 <code>sub_41119F</code> 两个线程。</li><li><code>StartAddress</code><ul><li><img src="https://gitee.com/Nuthecz/img/raw/master/202303040949069.png" alt="image-20230304094927047" /></li><li>这里执行<strong>sub_41112C</strong>操作，其中<strong>dword_418008</strong>的值为29—综合下文sub_411940可以判断出此值为flag的长度。继续追踪，找到sub_411940函数。</li><li><img src="https://gitee.com/Nuthecz/img/raw/master/202303040956524.png" alt="image-20230304095634491" /></li><li>由分析，此时对于flag数组进行了替换操作，其操作从后往前(a2一开始为29，之后递减)。此操作含义就是在 <strong>off_418000中查询下标为flag[i]-38对应的值，赋值给flag[i]</strong>。</li></ul></li><li><code>sub_41119F</code></li></ul><h3 id="知识点多线程"><a class="markdownIt-Anchor" href="#知识点多线程"></a> 知识点：多线程</h3><ul><li><p>多线程：指一个程序中有多个顺序流在执行。其中 <code>CreateThread</code> 是创造一个线程，创造的线程要用句柄 <code>HANDLE</code> 来储存， <code>CloseHandle</code> 是关闭该线程。</p></li><li><p>API函数：</p><ul><li><pre class="highlight"><code class="cmake">CreateThread(lpThreadAttributesdwStackSize    lpStartAddresslpParameterdwCreationFlagslpThreadId)</code></pre><ul><li><code>lpThreadAttributes</code>：NULL</li><li><code>dwStackSize</code>：栈空间大小，0表示1MB</li><li><code>lpStartAddress</code>：执行的线程函数地址</li><li><code>lpParameter</code>：传给线程函数的参数</li><li><code>dwCreationFlags</code>：控制线程的创建，0表示可以立即调用；如果为 <code>CREATE_SUSPENDED</code> ，则创建后无法调用，直到调用 <code>ResumeThread()</code></li><li><code>lpThreadId</code>：NULL</li><li><code>CreateMutexW</code>：实现进程互斥，IDA中实际作用</li></ul></li></ul></li><li><p>一个程序在运行时占用整个进程，一个进程可以建立多个线程。这些线程能够并行 (同时进行代码处理)以加快程序的运行速度。其中线程分为 “对等线程”，“分离线程”，“主线程”。而当一个处理器在处理一个线程时遇到 <strong>慢速系统调用(sleep、read等)</strong> 等需要消耗较多时间的处理需求时，控制器便通过上下文切换传送到下一个对等进程，以加快程序的运行。</p></li></ul><h2 id="crackrtf"><a class="markdownIt-Anchor" href="#crackrtf"></a> CrackRTF</h2><h2 id="actf新生赛2020usualcrypt"><a class="markdownIt-Anchor" href="#actf新生赛2020usualcrypt"></a> [ACTF新生赛2020]usualCrypt</h2><h2 id="mrctf2020transform"><a class="markdownIt-Anchor" href="#mrctf2020transform"></a> [MRCTF2020]Transform</h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理与应用</title>
    <link href="/posts/1b8dd184.html"/>
    <url>/posts/1b8dd184.html</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a class="markdownIt-Anchor" href="#绪论"></a> 绪论</h1><h2 id="区分数据库相关含义"><a class="markdownIt-Anchor" href="#区分数据库相关含义"></a> 区分数据库相关含义</h2><h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3><p>​<strong>数据库(DB)</strong>：指在计算机的存储设备上合理存放相关联，有结构的数据集合。<code>数据库在硬件存放</code></p><ul><li><strong>有结构</strong>：数据库与文件系统相比最大的特点之一</li></ul><h3 id="数据库管理系统"><a class="markdownIt-Anchor" href="#数据库管理系统"></a> 数据库管理系统</h3><p>​<strong>数据库管理系统(DBMS)</strong>：是一个操作和管理数据库的大型软件(是一组软件)，它由一组计算机程序构成，位于用户于操作系统之间的一层数据管理系统(属于系统软件)。</p><h3 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h3><p>​<strong>数据库系统(DBS)</strong>：用于实现有组织、动态地存储大量相关地结构化数据，便于用户使用数据库地计算机软件和硬件资源组成的系统。即数据库系统是指在<strong>计算机系统</strong>中引进<strong>数据库</strong>和<strong>数据库管理系统</strong>后地系统。</p><ul><li>数据库系统一般由<strong>硬件、软件、数据库和用户</strong>4部分组成。<ul><li>硬件、软件—计算机系统</li><li>用户(包括管理、开发和终端用户)—数据库管理系统<ul><li><strong>数据库管理员(DBA)</strong>：负责整个数据库系统的建设、管理、维护和协调工作。主要职责：<ol><li>参与数据库系统的设计于建设</li><li>对系统的运行实行监控</li><li>定义数据的安全性要求和完整性约束条件</li><li>负责数据库性能的改进和数据库的重组及重构工作</li></ol></li></ul></li></ul></li></ul><h3 id="数据库应用系统"><a class="markdownIt-Anchor" href="#数据库应用系统"></a> 数据库应用系统</h3><p>​<strong>数据库应用系统(DBAS)</strong>：指数据库系统及应用程序的组成。</p><h2 id="数据库系统的产生与发展"><a class="markdownIt-Anchor" href="#数据库系统的产生与发展"></a> 数据库系统的产生与发展</h2><h3 id="区分概念"><a class="markdownIt-Anchor" href="#区分概念"></a> 区分概念</h3><p>​<strong>数据管理</strong>：数据处理中心环节</p><h3 id="数据管理技术的产生与发展"><a class="markdownIt-Anchor" href="#数据管理技术的产生与发展"></a> 数据管理技术的产生与发展</h3><h4 id="人工管理阶段"><a class="markdownIt-Anchor" href="#人工管理阶段"></a> 人工管理阶段</h4><ul><li>程序和数据密不可分</li><li>数据不能共享</li><li>数据不具有独立性(<code>缺乏数据独立性</code>)</li></ul><h4 id="文件系统阶段"><a class="markdownIt-Anchor" href="#文件系统阶段"></a> 文件系统阶段</h4><ul><li>优点：<ul><li>程序与数据可以分别独立存放，数据可以组成数据文件，并且可以独立命名</li></ul></li><li>问题：<ul><li>数据冗余度大、共享性差、易产生数据不一致性</li><li>数据独立性差</li><li>用户负担重</li><li><code>数据无结构</code></li></ul></li></ul><h4 id="数据库系统阶段"><a class="markdownIt-Anchor" href="#数据库系统阶段"></a> 数据库系统阶段</h4><ul><li><code>数据结构化</code>：文件系统与数据库系统的根本区别之一</li><li><code>类别</code>：层次型数据库，网状数据库和关系型数据库</li></ul><h3 id="数据库系统的特点"><a class="markdownIt-Anchor" href="#数据库系统的特点"></a> 数据库系统的特点</h3><ol><li>数据结构化：文件系统与数据库系统的根本区别之一</li><li>数据冗余度小、共享性高、避免了数据的不一致性</li><li>具有较高的数据独立性</li><li>数据由DBMS统一管理和控制</li></ol><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><h3 id="相关解释"><a class="markdownIt-Anchor" href="#相关解释"></a> 相关解释</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>​现有数据库系统均是基于某种数据模型的，<code>数据模型是数据库系统的核心和基础</code></p><h4 id="数据模型的分类"><a class="markdownIt-Anchor" href="#数据模型的分类"></a> 数据模型的分类</h4><ol><li>概念数据模型(概念模型)：是独立于计算机系统的数据模型，完全不涉及信息在计算机中的表示，是<strong>面向数据库用户的现实世界模型</strong>，主要用来描述现实世界的概念化结构。</li><li>逻辑数据模型(数据模型)：<strong>用户所看到的模型</strong>，是具体的DBMS所支持的数据模型，如<strong>层次数据模型，网状数据模型，关系模型和面向对象模型</strong>。</li><li>物理数据模型(物理模型)：对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方式，是<strong>面向计算机系统的</strong>。</li></ol><h4 id="数据模型的组成要素"><a class="markdownIt-Anchor" href="#数据模型的组成要素"></a> 数据模型的组成要素</h4><ol><li>数据结构：支队实体模型和实体间联系的表达和实现。<code>它是数据模型最基本的组成部分，规定了数据模型的静态特性</code>—描述一个模型性质的最重要的方面。</li><li>数据操作：数据操作是指一组用于指定数据结构的任何有效实例执行的操作或推导规则。<code>数据操作规定了数据模型的动态特性</code></li><li>数据完整性约束：数据完整性给出数据及其联系应具有的制约和依赖规则。</li></ol><h3 id="实体联系数据模型"><a class="markdownIt-Anchor" href="#实体联系数据模型"></a> 实体——联系数据模型</h3><ul><li>信息，实体集联系和E-R图</li></ul><h3 id="常用结构数据模型"><a class="markdownIt-Anchor" href="#常用结构数据模型"></a> 常用(结构)数据模型</h3><h4 id="层次模型"><a class="markdownIt-Anchor" href="#层次模型"></a> 层次模型</h4><ul><li>满足条件：有且只有一个节点没有双亲节点(称为根节点)；根节点以外的其他节点有且只有一个双亲节点。</li><li>特点：<ul><li>记录之间得到联系通过指针来实现，常用的物理实现方法由邻接法和链接法。</li><li>由于采用指针实现记录间的联系，所以，<code>层次模型具有查询效率较高的优点</code></li></ul></li><li>缺点：<ul><li>层次数据模型缺乏直接表达现实世界中非层次型结构的复杂联系，如多对多的联系</li><li>层次顺序严格限制</li></ul></li><li>IMS是IBM公司推出的最有影响的一种典型的层次模型数据管理系统</li></ul><h4 id="网状模型"><a class="markdownIt-Anchor" href="#网状模型"></a> 网状模型</h4><ul><li>取消了层次模型的限制，不但允许一个以上的节点无双亲，而且一个节点允许有一个以上的双亲</li><li>比层次数据模型更具<code>普遍性</code>的结构，反映了实体集间普遍存在的更为复杂的联系，<code>层次结构实际上是网状结构的一个特例</code></li></ul><h4 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h4><h5 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释：</h5><ul><li>二维表(数据结构)称为关系，对二维框架的描述称为关系模型</li><li>表中的列称为<strong>属性或者字段</strong>，列中的<strong>值</strong>取自相应的域，<strong>域</strong>是属性所有可能取值的集合</li><li>表中的一行称为一个元组(Tuple)，元组用关键字(Key Word)标识</li></ul><h5 id="关系性质"><a class="markdownIt-Anchor" href="#关系性质"></a> 关系性质：</h5><ul><li>关系中的每一个属性是不可分解的，即所有域都应是原子数据的集合；没有完全相同的行和列，行、列的排列顺序是无关紧要的。</li></ul><h5 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h5><ul><li><p>关系模式是关系中信息内容结构的描述。它包括关系名，属性名，每个属性列的取值集合，数据完整性约束条件以及各属性间固有的数据依赖关系等。</p></li><li><p>关系模式的表示：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>I</mi><mo separator="true">,</mo><mo>∑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,I,\sum)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mclose">)</span></span></span></span></span></p><ul><li>R：关系名</li><li>U：组成关系R的全部属性的集合</li><li>DOM：属性列到域的映射，即DOM；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">U \rightarrow D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，且每个属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所有可能的取值集合构成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D_i(i = 1,2,\ldots ,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，并允许<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>=</mo><msub><mi>D</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">D_i = D_j,i\neq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></li><li>I：一组完整性约束条件</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>：属性集间的一组数据依赖</li><li>通常，在不涉及完整性约束及数据依赖的情况下，为了简化，可用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>表示关系模式，例如，学生关系模式可以表示为：S(学号，姓名，性别，年龄，学院)</li></ul></li></ul><h5 id="数据约束"><a class="markdownIt-Anchor" href="#数据约束"></a> 数据约束</h5><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><ol><li><p>什么是数据独立性？ 数据库的体系结构如何保证数据独立性？</p><ul><li>数据独立性是指数据库中数据与应用程序的无关性，也指应用程序和数据结构之间相互独立，不受影响。在三层模式体系结构中数据独立性可定义为：数据库系统在某一层次模式上的改变不会使它的上一层模式也发生改变的能力。其包括数据逻辑独立性和数据物理独立性。其中逻辑独立性是指数据的全局逻辑结构与局部逻辑结构之间的相互独立性，表示一旦模式发生变化，无须改变外模式或应用程序的能力；物理独立性是指数据的存储结构与全局逻辑结构之间的相互独立性，表示不会因为内模式发生改变而导致概念模式发生改变的能力。</li><li>数据独立性是由DBMS在三级模式间提供的两层映像来保证的。两层映像分为外模式/模式映像和模式/内模式映像，实现了三个抽象级别的来实现和转换.当整个系统需要改变模式时，DBMS对于外模式/模式映像做出相应的改变，保证了数据逻辑独立性，而数据的存储结构发生改变时，DBMS对于模式/内模式映像做出相应改变，从而保证了物理独立性</li></ul></li><li><p>什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级结构的优点是什么？</p><ul><li>外部模式又称为子模式，介于模式与应用之间，是用户与数据库之间的接口，是数据库用户能够看见和使用的局部数据和特征的描述。</li><li>概念模式简称模式，是由数据库设计者综合所有用户数据，按照统一的观点构造的对数据库全局逻辑结构的描述。</li><li>内部模式称为存储模式，是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</li><li>一个数据库结构从逻辑上可以划分为三个层次：外部模式，概念模式，内部模式，称为数据库的三级模式结构。</li><li>数据库系统的三级模式是对数据进行三个级别的抽象。它把数据的具体组织留给DBMS去做，用户只要抽象地处理数据，而不必关心数据在机器中地具体表示方式和存储方式。数据库的三级结构是依靠映像来联系和相互转化的，正是这两层映像保证了数据库系统中数据具有较高的数据独立性。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/posts/8d4b7ae1.html"/>
    <url>/posts/8d4b7ae1.html</url>
    
    <content type="html"><![CDATA[<ul><li>参考自：</li></ul><p>​计算机组成原理(第三版)————唐朔飞</p><p>​计算机组成原理(第六版)————白中英 戴志涛</p><p>​计算机组成原理考研复习指导————王道论坛</p><h1 id="计算机系统概论"><a class="markdownIt-Anchor" href="#计算机系统概论"></a> 计算机系统概论</h1><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211221638632.png" alt="image-20221122163857577" /></p><h2 id="计算机系统简介"><a class="markdownIt-Anchor" href="#计算机系统简介"></a> 计算机系统简介</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211192249834.png" alt="image-20221119224908771" /></p><center><strong>图 1  多级层次结构的计算机系统</strong></center><ul><li>虚拟机M4将高级语言程序翻译成机器语言程序.其中翻译程序为<code>编译程序</code>和<code>解释程序</code>.<ul><li>编译程序将高级语言程序一次性全部翻译成机器语言程序,而后再执行机器语言程序.源程序不变,则之后不必翻译.</li><li>翻译程序一条条语句进行翻译，每一条翻译完后立即执行,之后执行程序需重新翻译.</li></ul></li></ul><h2 id="计算机的基本组成"><a class="markdownIt-Anchor" href="#计算机的基本组成"></a> 计算机的基本组成</h2><ol><li>冯•诺依曼计算机特点<ul><li>由运算器、存储器、控制器、输入设备和输出设备五大部件组成</li><li>指令和数据以同等低位存放于存储器内，并可按地址寻访</li><li>机器以<code>运算器</code>为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211192325306.png" alt="image-20221119232514277" /></p><center><strong>图 2  典型的冯•诺依曼计算机结构框图</strong></center><ol start="2"><li>计算机的硬件框图</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211192326551.png" alt="image-20221119232615526" /></p><center><strong>图 3  以存储器为中心的计算机结构框图</strong></center><ul><li><code>CPU</code>:运算器和控制器<ul><li><code>ALU</code>(算术逻辑单元):完成算数逻辑运算</li><li><code>CU</code>(控制单元):解释存储器中的指令，并发出各种操作命令来执行指令</li></ul></li><li><code>I/O 设备</code>(外部设备):输入设备与输出设备</li><li><code>主机</code>:CPU与主存储器</li></ul><ol start="3"><li>计算机组成</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211221225086.png" alt="image-20221122122544036" /></p><center><strong>图 4  细化的计算机组成框图</strong></center><ul><li><strong>主存储器(主存)</strong><ul><li><p>存储体由许多<code>存储单元</code>组成，每个存储单元又包含若干个存储元件(或称存储基元、存储元)，每个存储元件能寄存一位二进制代码 “0” 或 “1”</p></li><li><p>主存的工作方式就是按存储单元的地址号来实现对存储字各位的存(写入)、取(读出)</p></li><li><p>为了实现按地址访问的方式，主存中配置<code>MAR</code>(存储器地址寄存器),<code>MDR</code>(存储器数据寄存器),这两个寄存器后来都集成在CPU芯片中</p><ul><li>MAR——用来存放欲访问的存储单元的地址，其位数对应存储单元的个数</li><li>MDR——用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，其位数与存储字长相等</li></ul></li></ul></li><li><strong>运算器</strong><ul><li>至少3个寄存器(ACC,MQ,X)和一个算数逻辑运算单元(ALU)<ul><li><code>ACC</code>——累加器</li><li><code>MQ</code>——乘商寄存器</li><li><code>X</code>——操作寄存器</li></ul></li></ul></li><li><strong>控制器</strong><ul><li>由程序计数器(PC),指令寄存器(IR),控制单元(CU)<ul><li><code>PC</code>——存放当前欲执行指令的地址,可自动加1</li><li><code>IR</code>——存放当前指令，来自主存的<code>MDR</code><ul><li>IR中的<code>操作码(OP (IR) )</code> 送至CU,记作 OP(IR)-&gt;CU,用来分析指令;其<code>地址码(Ad (IR) )</code> 作为操作数的地址送至存储器的MAR,记作 Ad(IR)—&gt;MAR</li></ul></li><li><code>CU</code>——分析当前指令所需完成的操作,并发出各种微操作命令序列,用以控制所有被控对象。</li></ul></li><li>完成一条指令操作的取指、分析和执行3个阶段</li></ul></li><li><strong>I/O</strong><ul><li>接收 CU 发出的各种控制命令，并完成相应的操作</li></ul></li></ul><h2 id="计算机硬件的计数指标"><a class="markdownIt-Anchor" href="#计算机硬件的计数指标"></a> 计算机硬件的计数指标</h2><ol><li><p><strong>机器字长</strong></p><ul><li>CPU一次能处理数据的位数，通常与 CPU 的寄存器位数有关</li></ul></li><li><p><strong>存储容量</strong></p><ul><li>存储器的容量包含主存容量域辅存容量</li><li>主存容量是指主存中存放二进制代码的总位数，即存储容量 = 存储单元个数 X 存储字长</li></ul></li></ol><h1 id="系统总线"><a class="markdownIt-Anchor" href="#系统总线"></a> 系统总线</h1><h2 id="总线的基本概念"><a class="markdownIt-Anchor" href="#总线的基本概念"></a> 总线的基本概念</h2><ul><li><p>计算机系统的五大部件之间的互连方式有两种，一种是各部件之间使用单独的连线，称为分连接(如图2，图3)；另一种是将各部件连到一组公共信息传输线上，称为总线连接.</p></li><li><p>总线是连接多个部件的信息传输线，是各部件共享的传输介质.实际上是由许多传输线或通路组成，每条线可一位一位地传输二进制代码，一串二进制代码可在一段时间内逐一传输完成，若干条传输线可以同时传输若干位二进制代码.</p></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282229862.png" alt="image-20221128222935838" /></p><center><strong>图 5  面向CPU的双总线结构框图</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282229223.png" alt="image-20221128222950198" /></p><center><strong>图 6  单总线结构框图</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282230107.png" alt="image-20221128223002082" /></p><center><strong>图 7  以存储器为中心的双总线结构框图</strong></center><h2 id="总线分类"><a class="markdownIt-Anchor" href="#总线分类"></a> 总线分类</h2><p>按<code>数据传送方式</code>分为传输总线和串行传输总线.</p><p>下面按<code>连接部件</code>的不同，分为三类总线：</p><ol><li><p><strong>片内总线</strong></p><ul><li>片内总线是指芯片内部的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算逻单元 ALU 之间都由片内总线连接</li></ul></li><li><p><strong>系统总线</strong></p><ul><li><p>系统总线是指 CPU、主存、 I/0设备(通过 I/0 接口)各大部件之间的信息传输线</p></li><li><p>按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线:</p><ul><li><p>数据总线</p><p>数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关，一般为8位、16位或32位，其位数称为<code>数据总线宽度</code></p></li><li><p>地址总线</p><p>地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址或 I/0 设备的地址.其位数与存储单元的个数相一致.</p></li><li><p>控制总线</p><p>控制总线是用来发出各种控制信号的传输线，同时起到监视各部件状态的作用</p></li></ul></li></ul></li></ol><h2 id="总线特性及性能指标"><a class="markdownIt-Anchor" href="#总线特性及性能指标"></a> 总线特性及性能指标</h2><p>总线的性能指标</p><ol><li><strong>总线宽度</strong>：数据总线的根数，用 bit(位) 表示</li><li><strong>总线带宽</strong>：总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用 MBps(兆字节每秒) 表示</li></ol><h2 id="总线结构"><a class="markdownIt-Anchor" href="#总线结构"></a> 总线结构</h2><h3 id="单总线结构"><a class="markdownIt-Anchor" href="#单总线结构"></a> 单总线结构</h3><p>单总线结构将 CPU、主存、I/0 设备(通过 I/0 接口)都挂在一组总线上，允许 I/0 设备之间、 I/0 设备与 CPU 之间或 I/0 设备与主存之间直接交换信息(如图6).这种结构简单，也便于扩充，但所有的传送都通过这组共享总线，因此极易形成计算机系统的瓶颈。它也不允许两个以上的部件在同一时刻向总线传输信息，这就必然会影响系统工作效率的提高</p><h3 id="多总线结构"><a class="markdownIt-Anchor" href="#多总线结构"></a> 多总线结构</h3><ul><li>双总线结构的特点是将速度较低的 I/0 设备从单总线上分离出来，形成主存总线与 I/0 总线分开的结构(如图8)</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282251251.png" alt="image-20221128225144220" /></p><center><strong>图 8  双总线结构</strong></center><p>如果将速率不同的 I/0 设备进行分类，然后将它们连接在不同的通道上，那么计算机系统的工作效率将会更高，由此发展成多总线结构。</p><ul><li>主存总线用于 CPU 与主存之间的传输；I/0 总线供 CPU 与各类 I/0 设备之间传递<br />信息；DMA 总线用于高速 I/0 设备（磁盘、磁带等）与主存之间直接交换信息。在三总线结构中，<code>任一时刻只能使用一种总线</code>。主存总线与 DMA 总线不能同时对主存进行存取， I/0 总线只有在CPU 执行 I/0 指令时才能用到(如图9)</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282254288.png" alt="image-20221128225449256" /></p><center><strong>图 9  三总线结构</strong></center><ul><li>处理器与 Cache 之间有一条局部总线，它将 CPU 与 Cache 或与更多的局部设备连接。Cache 的控制机构不仅将 Cache 连到局部总线上，而且还直接连到系统总线上，这样 Cache 就可通过系统总线与主存传输信息，而且 I/0 设备与主存之间的传输也不必通过CPU(如图10).</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282256078.png" alt="image-20221128225631045" /></p><center><strong>图 10  另一种三总线结构</strong></center><ul><li>四总线结构增加了一条与计算机系统紧密相连的高速总线</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282257523.png" alt="image-20221128225757492" /></p><center><strong>图 11  四总线结构</strong></center><h1 id="存储器"><a class="markdownIt-Anchor" href="#存储器"></a> 存储器</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><h3 id="存储器的分类"><a class="markdownIt-Anchor" href="#存储器的分类"></a> 存储器的分类</h3><p>按<code>存取方式</code>可以把存储器分为随机存储器,只读存储器,顺序存储器和直接存取存储器.</p><ol><li><strong>随机存储器</strong>( <code>RAM</code> , Random Access Memory)<ul><li>RAM 是一种可读／写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关</li></ul></li><li><strong>只读存储器</strong>( <code>ROM</code> , Read Only Memol)<ul><li>只读存储器是能对其存储的内容读出，而不能对其重新写入的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息</li></ul></li><li><strong>串行访问存储器</strong><ul><li>如果对存储单元进行读／写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器</li></ul></li></ol><p>按在<code>计算机系统中的作用</code>不同，存储器主要分为主存储器、辅助存储器、缓冲存储器.</p><ol><li><strong>主存储器</strong>(简称主存,内存)的主要特点是它可以和 CPU 直接交换信息</li><li><strong>辅助存储器</strong>(简称辅存)是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，它不能与 CPU 直接交换信息</li><li><strong>高速缓冲存储器</strong>(简称缓存_Cache)位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们.</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211282320611.png" alt="image-20221128232018576" /></p><center><strong>图 12  存储器分类</strong></center><h3 id="存储器的性能指标"><a class="markdownIt-Anchor" href="#存储器的性能指标"></a> 存储器的性能指标</h3><ol><li><strong>存储容量</strong>：存储字数 X 字长(如 1M X 8 位)<ul><li>存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量</li></ul></li><li><strong>存储速度</strong>：数据传输率 = 数据的宽度 / 存储周期<ul><li>存取时间(T<sub>a</sub>)：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读入时间和写入时间</li><li>存取周期(T<sub>m</sub>)：存取周期又称为读写周期或访问周期.它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔</li><li>主存带宽(B<sub>m</sub>)：主存带宽又称数据传输率，表示从主存进出信息的最大数量，单位为字/秒，字节/秒(B/s)，位/秒(b/s)</li></ul></li></ol><h3 id="存储器的层次化结构"><a class="markdownIt-Anchor" href="#存储器的层次化结构"></a> 存储器的层次化结构</h3><h2 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h2><h3 id="随机存储器"><a class="markdownIt-Anchor" href="#随机存储器"></a> 随机存储器</h3><ol><li><strong>SRAM</strong><ul><li>静态随机存储器(SRAM)的存储元使用双稳态触发器(六晶体管MOS)来记忆信息，非破坏性读出</li><li>存取速度快，但集成度低，功耗较大，一般用来组成高速缓冲存储器</li></ul></li><li><strong>DRAM</strong></li></ol><ul><li>动态随机存储器(DRAM)是利用存储元电路中栅极电容上的电荷来存储信息，采用地址复用技术</li><li>更容易继承，但存取速度相较SRAM慢，一般用来组成大容量主存系统</li><li>DRAM电容上的电荷一般只能维持1~2ms,因此即使电源不断电，信息也会自动消失.所以需要每隔一定时间刷新，通常取2ms,称为刷新时间.<ul><li>刷新方式分为：集中刷新,分散刷新,异步刷新</li></ul></li></ul><h3 id="只读存储器"><a class="markdownIt-Anchor" href="#只读存储器"></a> 只读存储器</h3><ul><li>ROM期间的显著优点：<ul><li>结构简单，所以位密度比可读可写存储器的高</li><li>具有非易失性，所以可靠性高</li></ul></li><li>ROM的类型<ul><li>掩模式只读存储器(MROM)</li><li>一次可编程只读存储器(PROM)</li><li>可擦除可编程只读存储器(EPROM)</li><li>闪存存储器(Flash Memory)</li><li>固态硬盘(Solid State Drives, SSD)</li></ul></li></ul><h3 id="多模块存储器"><a class="markdownIt-Anchor" href="#多模块存储器"></a> 多模块存储器</h3><ol><li><p><strong>单体多字存储器</strong></p><ul><li>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。一次并行读出 m 个字，地址必须顺序排列并处千同一存储单元。</li></ul></li><li><p><strong>多体并行存储器</strong></p><ul><li><p>多体并行存储器由多体模块组成。每个模块都有相同的容扯和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p></li><li><p>分为高位交叉编址和低位交叉编址</p></li></ul></li></ol><ul><li>高位交叉编址(顺序方式)<ul><li>高位地址表示体号，低位地址为体内地址</li><li>高位交叉方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，各模块不能被并行访问，因而不能提高存储器的吞吐率。</li></ul></li></ul><img  src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211291106304.png"><center><strong>图 13  高位交叉编址的多体存储器</strong></center><ul><li>低位交叉编址(交叉方式)<ul><li>低位地址为体号，高位地址为体内地址</li><li>低位交叉方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。</li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211291203333.png" alt="image-20221129120341299" /></p><center><strong>图 14  低位交叉编址的多体存储器</strong></center><h2 id="主存储器与cpu的连接"><a class="markdownIt-Anchor" href="#主存储器与cpu的连接"></a> 主存储器与CPU的连接</h2><h3 id="连接原理"><a class="markdownIt-Anchor" href="#连接原理"></a> 连接原理</h3><ol><li>主存储器通过数据总线、地址总线和控制总线与 CPU 连接</li></ol><ol start="2"><li>数据总线的位数与工作频率的乘积正比千数据传输率</li><li>地址总线的位数决定了可寻址的最大内存空间</li><li>控制总线（读／写）指出总线周期的类型和本次输入／输出操作完成的时刻</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211291211638.png" alt="image-20221129121112611" /></p><center><strong>图 15  主存储器与CPU的连接 </strong></center><h3 id="主存容量的扩展"><a class="markdownIt-Anchor" href="#主存容量的扩展"></a> 主存容量的扩展</h3><ol><li><strong>位扩展</strong><ul><li>CPU 的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位（即进行位扩展，用多个存储器件对字长进行扩充，增加<code>存储字长</code>），使其数据位数与 CPU 的数据线数相等。位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211291220286.png" alt="image-20221129122040257" /></p><center><strong>图 16  位扩展连接示意图</strong></center><ol start="2"><li><strong>字扩展</strong><ul><li>字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211291221696.png" alt="image-20221129122147667" /></p><center><strong>图 17  字扩展连接示意图</strong></center><ol start="3"><li><strong>字位同时扩展法</strong><ul><li>字位同时扩展是指既增加存储字的数量，又增加存储字长</li></ul></li></ol><h2 id="高速缓冲存储器"><a class="markdownIt-Anchor" href="#高速缓冲存储器"></a> 高速缓冲存储器</h2><h3 id="cache的基本工作原理"><a class="markdownIt-Anchor" href="#cache的基本工作原理"></a> Cache的基本工作原理</h3><p>Cache 位千存储器层次结构的顶层，通常由 SRAM 构成</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301438455.png" alt="image-20221130143802417" /></p><center><strong>图 18  高速缓冲存储器的工作原理</strong></center><h3 id="cache和主存的映射方式"><a class="markdownIt-Anchor" href="#cache和主存的映射方式"></a> Cache和主存的映射方式</h3><p>Cache 行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，即把存放在主存中的信息按照某种规则装入 Cache</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112021003.png" alt="image-20230211202132953" /></p><ol><li><strong>直接映射</strong><ul><li><code>Cache行号＝主存块号 mod Cache总行数</code></li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301447371.png" alt="image-20221130144707339" /></p><center><strong>图 19  Cache和主存之间的直接映射方式</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112029523.png" alt="image-20230211202954500" /></p><ol start="2"><li><strong>全相联映射方式</strong><ul><li>主存中的每一块可以装入Cache 中的任何位狸，每行的标记用于指出该行取自主存的哪一<br />块，所以CPU 访存时需要与所有Cache 行的标记进行比较</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301449108.png" alt="image-20221130144914080" /></p><center><strong>图 20  Cache和主存之间的全相联映射方式</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112029748.png" alt="image-20230211202932723" /></p><ol start="3"><li><strong>组相联映射方式</strong><ul><li>将 Cache 分成 Q 个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301453758.png" alt="image-20221130145321726" /></p><center><strong>图 21  Cache和主存之间的组相联映射方式</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112030127.png" alt="image-20230211203015104" /></p><h3 id="cache的替换策略"><a class="markdownIt-Anchor" href="#cache的替换策略"></a> Cache的替换策略</h3><p>在采用<strong>全相联映射或组相联映射</strong>方式时，从主存向 Cache 传送一个新块，当 Cache 或 Cache组中的空间已被占满时，就需要使用替换算法置换Cache行,而直接映射会直接替换，无需考虑替换策略</p><ol><li><p><strong>随机算法</strong>：随机地确定替换的 Cache 块。它的实现比较简单，但未依据程序访问的局部性原理，因此可能命中率较低</p></li><li><p><strong>先进先出算法</strong>：选择最早调入的行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的</p></li><li><p>**近期最少使用算法LRU：**将近期内长久未被访问过的行换出</p><p>**策略：**每行设置一个计数器，每命中一次，命中行计数器清零，其它各行计数器增1；替换时，将计数值最大的行换出。保护了刚拷贝到cache的新数据行</p></li><li><p>**近期最少使用算法(LRU)：**依据程序访问的局部性原理，选择近期内长久未访问过的Cache 行作为替换的行，平均命中率要比 FIFO 的高，是堆栈类算法----<strong>最常用</strong></p><p>**策略：**每行设置一个计数器，新行从0开始计数，每访问一次，计数器增1；替换时，把计数值最小的行换出，同时将这些特定行的计数器清零</p></li></ol><h3 id="cache-的写策略"><a class="markdownIt-Anchor" href="#cache-的写策略"></a> Cache 的写策略</h3><p>由于 cache 的内容只是主存部分内容的副本，它应当与主存内容保持一致。而 CPU 对cache 的写入更改了 cache 的内容，则可采取写操作策略使 cache 与主存内容保持一致</p><ol><li><p><strong>写回法</strong>:</p><ul><li>当 CPU 写 cache 命中时，只修改 cache 的内容，而不立即写入主存；只有当此行被换出时才写回主存</li></ul></li><li><p><strong>全写法</strong>:</p><ul><li>当写 cache 命中时，cache 与主存同时发生写修改，因而较好地维护了 cache 与主存的内容的一致性</li></ul></li><li><p><strong>写一次法</strong>:</p><ul><li>写一次法是基于写回法并结合全写法的写策略：写命中与写未命中的处理方法和写回法基本相同，只是第一次写命中时要同时写入主存</li></ul></li></ol><h1 id="指令系统"><a class="markdownIt-Anchor" href="#指令系统"></a> 指令系统</h1><h2 id="指令系统的发展"><a class="markdownIt-Anchor" href="#指令系统的发展"></a> 指令系统的发展</h2><ol><li><strong>指令系统</strong>(指令集)：一台计算机中所有机器指令的集合，称为这台计算机的指令系统</li><li><strong>指令系统体系结构</strong>(ISC)<ul><li>复杂指令系统计算机(<code>CISC</code>)：</li><li>精简指令系统计算机(<code>SISC</code>)：</li></ul></li></ol><h2 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h2><ol><li><p><strong>指令字</strong>：表示一条指令的机器字，通常简称指令</p></li><li><p><strong>指令格式</strong>：指令字用二进制代码表示的结构形式，通常由操作码字段和地址码字段组成</p></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301513956.png" alt="image-20221130151323928" /></p><ul><li><p>指令的操作码 OP 表示该指令应进行什么性质的操作以及具有何种功能</p></li><li><p>地址码 A 给出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。</p></li></ul><p>根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式</p><ol><li><p>零地址指令</p><ul><li>零地址指令的指令字中只有操作码，而没有地址码</li></ul></li><li><p>一地址指令</p><ul><li>一地址指令只有一个地址码，它指定一个操作数，另一个操作数地址是隐含的</li></ul></li><li><p>二地址指令</p><ul><li>适用于常用的算术和逻辑运算，包含目的操作数地址和源操作数地址(源寄存器和目的寄存器可以指定32个寄存器)</li><li><strong>SS型</strong>指：存储器-存储器型；<strong>RS型</strong>指：寄存器-存储器型；<strong>RR型</strong>指：寄存器-寄存器型</li></ul></li><li><p>三地址指令</p><ul><li>A3←(A1)OP(A2)</li><li>A1 为被操作数地址，也称源操作数地址；A2 为操作数地址，也称终点操作数地址；A3 为存放操作结果的地址</li><li>三地址指令中 A1，A2，A3 通常指定为运算器中通用寄存器的地址，这是为了加快指令执行速度</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301521447.png" alt="image-20221130152142418" /></p><center><strong>图 22  不同指令格式</strong></center><h2 id="指令和数据的寻址"><a class="markdownIt-Anchor" href="#指令和数据的寻址"></a> 指令和数据的寻址</h2><h3 id="指令寻址"><a class="markdownIt-Anchor" href="#指令寻址"></a> 指令寻址</h3><ol><li><p>顺序寻址</p><ul><li>通过程序计数器 PC 加 1 (1 个指令字长)，自动形成下一条指令的地址</li></ul></li><li><p>跳跃寻址</p><ul><li>通过转移类指令实现.</li><li>受到状态寄存器和操作数的控制，跳跃的地址分为绝对地址(由标记符直接得到)和相对地址(相对千当前指令地址的偏移量)，跳跃的结果是当前指令修改 PC 值</li></ul></li></ol><h3 id="数据寻址"><a class="markdownIt-Anchor" href="#数据寻址"></a> 数据寻址</h3><ol><li><p>隐含寻址</p><ul><li>不明显地给出操作数的地址，而在指令中隐含操作数的地址</li></ul></li><li><p>立即数寻址</p><ul><li>指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数，采用补码表示</li></ul></li><li><p>直接寻址</p><ul><li>在指令格式的地址字段中直接指出操作数在内存的地址 A</li><li>如果用 D 表示操作数，那么直接寻址的表达式为 EA = D----EA为有效地址</li></ul></li><li><p>间接寻址</p><ul><li>指令地址字段中的形式地址 A 不是操作数 D 的真正地址，而是操作数地址的指示器</li><li>EA = ( A )</li></ul></li><li><p>寄存器寻址</p><ul><li>当操作数不在内存中，而是放在 CPU 的通用寄存器中时，可采用寄存器寻址方式</li><li>此时指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号，EA = R</li></ul></li><li><p>寄存器间接寻址</p><ul><li>指令格式中的寄存器内容不是操作数，而是操作数的地址，该地址指明的操作数在内存中</li><li>EA = ( R)</li></ul></li><li><p>偏移寻址</p><ul><li>EA = A + ( R)</li><li>一个地址字段中的形式地址 A 直接被使用；另一个地址字段，或基于操作码的一个隐含用，指的是某个专用寄存器</li><li>相对寻址<ul><li>隐含引用的专用寄存器是程序计数器(PC)，即 EA = A + ( PC)，它是当前 PC的内容加上指令地址字段中 A 的值</li></ul></li><li>基址寻址<ul><li>被引用的专用寄存器含有一个存储器地址，地址字段含有一个相对于该地址的偏移量(通常是无符号整数)</li></ul></li><li>变址寻址<ul><li>地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，与基址寻址刚好相反</li></ul></li></ul></li><li><p>段寻址</p></li><li><p>堆栈寻址</p></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301550644.png" alt="image-20221130155034604" /></p><center><strong>图 23  基本寻址方式示意图</strong></center><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202211301551586.png" alt="image-20221130155105554" /></p><center><strong>图 24  基本寻址方式</strong></center><h1 id="中央处理器"><a class="markdownIt-Anchor" href="#中央处理器"></a> 中央处理器</h1><h2 id="cpu的组成和功能"><a class="markdownIt-Anchor" href="#cpu的组成和功能"></a> CPU的组成和功能</h2><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><ol><li><strong>指令控制</strong>：程序的顺序控制。</li><li><strong>操作控制</strong>：管理并产生每条指令的操作信号，并把它们送到相应部件，控制这些部件按要求进行动作。</li><li><strong>时间控制</strong>:对各种操作实施时间上的定时。</li><li><strong>数据加工</strong>：对数据进行算术和逻辑运算处理</li></ol><h2 id="微程序控制器"><a class="markdownIt-Anchor" href="#微程序控制器"></a> 微程序控制器</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302120947440.png" alt="image-20230212094713385" /></p><h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3><p><strong>微程序控制器的组成</strong>：控制存储器CM、地址转移逻辑、微指令寄存器（微地址寄存器和微命令寄存器）</p><ol><li>控制存储器(μCM)：存放实现全部指令系统的微程序，是一个只读存储器。μCM的字长就是微指令字长，其容量取决于微程序的数量，即取决于指令系统的规模。读出并执行一条微指令的时间为一个微指令周期。在串行方式的微程序控制器中，微指周期就是只读存储器的工作周期。</li><li>微指令寄存器(μIR)：存放由μCM读出的一条微指令。由微地址寄存器和微命令寄存器组成。前者决定下一条微指令的地址，后者存放一条微指令的操作控制字段和判别测试字段。</li><li>地址转移逻辑：承担自动完成修改微地址的任务。如果微程序不出现分支，那么下 一条微指令的地址就直接由微地址寄存器给出。当微程序出现分支时，则通过判别测试字段P和执行部件的“状态条件”反馈ؑ信息，修改微地址寄存器的内容，以形成下一条微指令的地址。</li><li>微地址寄存器(μMAR)：它接受微地址形成部件送来的微地址，为下一步从μCM读取微指令作准备。</li></ol><h3 id="工作过程实质"><a class="markdownIt-Anchor" href="#工作过程实质"></a> 工作过程实质</h3><p><strong>微程序控制器的工作过程实质</strong>：在微程序控制器的控制下， 执行机器指令的过程</p><p><strong>具体过程</strong>：</p><ol><li>执行取指令的公操作：机器开始运行时，自动地将取指微程序的入口微地址送入µAR，并从µCM中读出微指令，送往µIR，当取指微程序执行完以后，从主存中取出的机器指令就已经存入IR中了。</li><li>由机器指令的操作码字段OP通过 “地址转移逻辑” 产生出䈕机器指令所对应的微程序的入口微地址，并送入µAR。</li><li>从µCM中逐条取出相应的微指令并执行之。</li><li>执行完对应于一条机器指令的一段微程序之后，又回到取指微程序的入口地址，继续第1步，以完成取下一条机器指令的公操作。</li></ol><h1 id="问题汇总"><a class="markdownIt-Anchor" href="#问题汇总"></a> 问题汇总</h1><p>(@)<strong>第二章</strong>：定点数与浮点数的表示方法，定点数与浮点数的加减乘除法，浮点数的规格化</p><p><strong>第三章：</strong>(@)存储器容量扩充与和CPU的连接，DRAM的刷新，多模块交叉存储器带宽，cache的命中率，cache的替换策略，cache的写回策略，(@)cache与CPU的映射</p><p>**第四章：**指令格式相关，(@)指令寻址方式</p><p>**第五章：**CPU结构和流程，(@)微程序控制器相关，流水线CPU</p><p>**第六章：**总线带宽，总线的仲裁</p><p>**第七章：**磁盘存储器的技术指标相关</p><p><strong>第八章</strong>：程序中断</p><h2 id="第二章-运算方法和运算器"><a class="markdownIt-Anchor" href="#第二章-运算方法和运算器"></a> 第二章 运算方法和运算器</h2><p>**题型：**定点数与浮点数的表示方法，定点数与浮点数的加减乘除法，浮点数的规格化</p><p><a href="https://www.bilibili.com/video/BV1P3411v7gd?p=4&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">相关题目参考视频</a></p><h2 id="第三章-存储系统"><a class="markdownIt-Anchor" href="#第三章-存储系统"></a> 第三章 存储系统</h2><p>**题型：**存储器容量的扩展，DRAM的刷新，多模块交叉存储器带宽，cache的命中率，cache的替换策略，cache的写回策略，cache与CPU的映射</p><h3 id="存储器与cpu的连接"><a class="markdownIt-Anchor" href="#存储器与cpu的连接"></a> 存储器与CPU的连接</h3><p>PPT—55</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112034669.png" alt="image-20230211170110780" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162008915.png" alt="image-20230216200841880" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162008649.png" alt="image-20230216200854596" /></p><p><strong>重点</strong>：</p><ol><li>知道字扩展和位扩展的含义，和它在存储器和CPU中的连接中是怎么体现的</li><li>着重关注题目要求的主存地址空间分配情况 <a href="https://www.bilibili.com/video/BV1P3411v7gd?p=1&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">参照视频</a></li><li>关注最后2k地址的分配情况(与2重点相同，但是要学会怎么使用片选逻辑)</li></ol><h3 id="dram刷新"><a class="markdownIt-Anchor" href="#dram刷新"></a> DRAM刷新</h3><p>PPT—48</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302111700128.png" alt="image-20230211170050067" /></p><h3 id="多模块交叉存储器"><a class="markdownIt-Anchor" href="#多模块交叉存储器"></a> 多模块交叉存储器</h3><p>总复习pdf—89</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302111727242.png" alt="image-20230211172721150" /></p><h3 id="cache"><a class="markdownIt-Anchor" href="#cache"></a> cache</h3><h4 id="命中率"><a class="markdownIt-Anchor" href="#命中率"></a> 命中率</h4><p>PPT—95</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302111745908.png" alt="image-20230211174528868" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302111826191.png" alt="image-20230211182604134" /></p><h4 id="映射"><a class="markdownIt-Anchor" href="#映射"></a> 映射</h4><p><a href="https://www.bilibili.com/video/BV1h3411h7kV/?spm_id_from=333.337.search-card.all.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">主存和cache的映射相关问题解决</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302112116386.png" alt="image-20230211202132953" /></p><h2 id="第四章-指令系统"><a class="markdownIt-Anchor" href="#第四章-指令系统"></a> 第四章 指令系统</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162007035.png" alt="image-20230216200745896" /></p><p>一个类似的题型，可以参照进行复习。<strong>重点在于对于指令格式和寻址方式的理解</strong>。</p><h2 id="第五章-中央处理器"><a class="markdownIt-Anchor" href="#第五章-中央处理器"></a> 第五章 中央处理器</h2><h3 id="cpu执行相关"><a class="markdownIt-Anchor" href="#cpu执行相关"></a> CPU执行相关</h3><ul><li>主要就是背图(cpu结构和流程中的)，然后根据图片进行CPU操作流程的分析</li><li>分析要与具体指令的指令周期联系起来，明白CPU是怎么执行指令的(指令周期中的)</li></ul><h4 id="cpu结构和流程"><a class="markdownIt-Anchor" href="#cpu结构和流程"></a> CPU结构和流程</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162015694.png" alt="image-20230216201502658" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162014275.png" alt="image-20230216201447237" /></p><h5 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302190725106.png" alt="image-20230219072528065" /></p><p><strong>(1)</strong></p><p><strong>CPU</strong>的组成：由算术逻辑运算单元、操作控制器组成。</p><ol><li><p>ALU：算术逻辑运算单元。执行算术运算、逻辑运算并测试</p></li><li><p>操作控制器：协调和指挥整个系统的操作，取指令并执行。</p></li><li><p>A和B—运算器前端的数据暂存器，也称运算寄存器。用来暂存参加运算的操作数</p></li><li><p>R0～R3----CPU的通用寄存器组。存放操作数。</p></li><li><p>IR-指令寄存器器：保存当前正在执行的指令的指令码</p></li><li><p>PC-程序计数器：其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。</p></li><li><p>AR—地址寄存器：用来保存当前CPU所访问的内存单元的地址（指令地址或操作数地址）</p></li><li><p>DR—数据（缓冲）寄存器：用来暂存写入内存单元的数据及从内存单元读出的数据</p></li></ol><p><strong>(2)</strong></p><p>取指微指令2分，间接寻址3分，SUB指令3分，微操作标注2分</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302190727964.png" alt="image-20230219072731944" /></p><p><strong>(3)</strong></p><p>如微程序</p><h4 id="指令周期"><a class="markdownIt-Anchor" href="#指令周期"></a> 指令周期</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162017854.png" alt="image-20230216201718800" /></p><ul><li>方框语言表示指令周期</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162018751.png" alt="image-20230216201820709" /></p><ul><li><p>例题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162020824.png" alt="image-20230216202012784" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162020218.png" alt="image-20230216202024182" /></p></li></ul><h3 id="微程序"><a class="markdownIt-Anchor" href="#微程序"></a> 微程序</h3><h4 id="微程序组成重点"><a class="markdownIt-Anchor" href="#微程序组成重点"></a> 微程序组成(重点)</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302121603944.png" alt="image-20230212160355843" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302121604815.png" alt="image-20230212160413767" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302121604066.png" alt="image-20230212160435967" /></p><h4 id="微程序设计"><a class="markdownIt-Anchor" href="#微程序设计"></a> 微程序设计</h4><p>微命令编码和微命令地址形成方式(考题一般不涉及)</p><h3 id="流水线cpu"><a class="markdownIt-Anchor" href="#流水线cpu"></a> 流水线CPU</h3><p>了解什么是流水线CPU</p><h4 id="流水线中的主要问题"><a class="markdownIt-Anchor" href="#流水线中的主要问题"></a> 流水线中的主要问题</h4><p>资源冲突，数据冲突和控制冲突----知道是什么和解决方法</p><ul><li><p>数据冲突引发的问题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162026951.png" alt="image-20230216202616892" /></p></li></ul><h2 id="第六章-总线系统"><a class="markdownIt-Anchor" href="#第六章-总线系统"></a> 第六章 总线系统</h2><p>主要是总线的相关指标和仲裁</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162028654.png" alt="image-20230216202806590" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162028153.png" alt="image-20230216202821119" /></p><h2 id="第七章-外围设备"><a class="markdownIt-Anchor" href="#第七章-外围设备"></a> 第七章 外围设备</h2><p>主要就是磁盘存储器的技术指标</p><p>掌握PPT16之后的指标和例题</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162038774.png" alt="image-20230216203831719" /></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4991/202302162038664.png" alt="image-20230216203847575" /></p><h2 id="第八章-输入输出系统"><a class="markdownIt-Anchor" href="#第八章-输入输出系统"></a> 第八章 输入/输出系统</h2><p>主要是程序中断</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Crypto &amp; Python</title>
    <link href="/posts/108720dc.html"/>
    <url>/posts/108720dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础操作"><a class="markdownIt-Anchor" href="#基础操作"></a> 基础操作</h1><h2 id="转化"><a class="markdownIt-Anchor" href="#转化"></a> 转化</h2><ul><li><code>int(a,k)</code><ul><li>a为k进制数，使用<code>int</code>将k进制数转化为十进制数</li><li><code>int(a)</code>直接将字符a转化为int类型，此时a必须为数字字符，<ul><li>注意：不是转化为ascii码，而是转化为数字类型，即值不变，类型改变</li></ul></li></ul></li><li><code>str(a)</code><ul><li>与<code>int(a)</code>是相反的操作，但是范围扩大</li></ul></li><li><code>ord(a)</code><ul><li>将字符a按其ascii码转化为int类型</li></ul></li><li><code>chr(a)</code><ul><li>将int类型的a根据其ascii码转化为字符</li></ul></li><li><code>bytes</code>与<code>str</code><ul><li><code>bytes = str.encode(encoding='utf-8')</code>，这里<strong>utf-8是默认选项</strong>，也可以选择不填，即encode()<ul><li>str 转换成 bytes 用 encode() 方法</li><li><code>bytes=b'\xe4\xba\xba\xe7\x94'</code>—bytes的形式</li></ul></li><li><code>str = bytes.decode()</code><ul><li>反转换</li></ul></li></ul></li><li><code>hex()</code><ul><li><code>a.hex()</code>将bytes类型（即a）转化为十六进制</li><li><code>bytes.fromhex(a.hex())</code>可以将十六进制数转化为bytes类型</li></ul></li><li><code>join()</code><ul><li><code>print(''.join(list))</code>直接输出将列表拼接成字符串的结果<ul><li>list存储的是字符，例如list = [‘a’,‘c’,‘r’]</li><li>本意为隔一个’‘输出list的一个值，由于’'中间没有间隔，则即直接将list进行拼接</li></ul></li></ul></li></ul><h2 id="切割"><a class="markdownIt-Anchor" href="#切割"></a> 切割</h2><ul><li><code>flag = key.split(' ')</code><ul><li>将字符key切割为列表类型，分界线为<code>' '</code></li></ul></li></ul><h2 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h2><ul><li><code>key = [i for i in range(10)]</code><ul><li><code>key</code>初始化——遍历<code>i</code>，同时将i赋值给key[i]</li></ul></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ul><li><code>pow(a,b,c)</code><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>c</mi></mrow><annotation encoding="application/x-tex">pow(a,b,c) == a^{b}\  \% \ c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.904668em;vertical-align:-0.05556em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathnormal">c</span></span></span></span></li></ul></li></ul><h1 id="crypto库"><a class="markdownIt-Anchor" href="#crypto库"></a> Crypto库</h1><h2 id="utilnumber"><a class="markdownIt-Anchor" href="#utilnumber"></a> Util.number</h2><ul><li><p><code>bytes_to_long</code>与<code>long_to_bytes</code></p><ul><li><code>bytes_to_long</code>将字节流转换位long类型数字，即最后一位字符转为ASCii之后乘以2<sup>0</sup>, 往前的字符乘以2<sup>1</sup>, 2<sup>2</sup>……</li><li><code>long_to_bytes</code>将long类型数字转换为bytes类型，是<code>bytes_to_long</code>的逆运算</li></ul></li><li><p><code>getPrime(n_lebgth)</code></p><ul><li>反复使用素性检测算法验证以获素随机数,其长度为2<sup>n</sup></li></ul></li><li><p><code>getStrongPrime(n_lebgth)</code></p><ul><li>获得满足RSA要求的大素数</li></ul></li><li><p><code>inverse(a,n)</code></p><ul><li>求a模n的逆元</li><li>对于正整数 a, n，如果有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax ≡ 1 \ (mod \ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，则称 x 的最小正整数解为 a 模 n的逆元</li></ul></li><li><p><code>getRandomNBitInteger(N)</code></p><ul><li>获得N比特的随机数（也就是保证最高位非0，且长度为2<sup>N</sup>）</li></ul></li><li><p><code>gad(a,b)</code></p><ul><li>获得a与b的最大公约数</li></ul></li></ul><h1 id="base64库"><a class="markdownIt-Anchor" href="#base64库"></a> base64库</h1><h2 id="base32与base16"><a class="markdownIt-Anchor" href="#base32与base16"></a> base32与base16</h2><ul><li><code>b32encode(bytes)</code>与<code>b32decode()</code><ul><li>bytes必须是由str类型经过str.encode()转换而得来</li></ul></li><li><code>b32hexencode(bytes)</code>与<code>b32hexdecode()</code><ul><li>与上面的相同</li></ul></li><li><code>b16</code>与<code>b32</code>相同</li></ul><h2 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> base64</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>encrypt = base64.b64encode(<span class="hljs-string">&#x27;AlwaysBeta&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-comment"># Python3 中字符都是 unicode 编码，而 b64encode函数的参数为 byte 类型，所以必须先转码</span><br>decrypt = base64.b64decode(a)<br><br><span class="hljs-comment"># 换表解密</span><br>new_table = <span class="hljs-string">&quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>old_table = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br>cipher = <span class="hljs-string">&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;</span>.swapcase()<br><span class="hljs-comment">#swapcase是大小写转化，大写转小写等</span><br><span class="hljs-built_in">print</span>(base64.b64decode(cipher.translate(<span class="hljs-built_in">str</span>.maketrans(new_table, old_table))))<br></code></pre></td></tr></table></figure><h1 id="hashlib库"><a class="markdownIt-Anchor" href="#hashlib库"></a> hashlib库</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>obj = hashlib.md5()<br><span class="hljs-comment"># 构造一个hashlib的对象(obj)，此处的 md5 可以替换为SHA1, SHA224, SHA256, SHA384, SHA512等加密算法</span><br>obj.update(<span class="hljs-string">&quot;使用md5加密&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-comment"># update对指定字符串进行加密，但加密前需要对数据进行转码为 byte 类型</span><br>result = obj.hexdigest()<br><span class="hljs-comment"># 这里hexdigest与digest相同，使用二进制表示(实际转化为十六进制形式表示)</span><br><span class="hljs-built_in">print</span>(result)<br> <br><span class="hljs-comment"># 也可以不创建对象，直接进行加密</span><br>obj = hashlib.sha1(<span class="hljs-string">&quot;1231231231&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
